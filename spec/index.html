<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8" />
    <title>SPARQL 1.2 Query Language</title>

    <script src="https://www.w3.org/Tools/respec/respec-w3c" class="remove"></script>
    <script src="./common/local-biblio.js" class="remove"></script>
    <script src="./common/fixup.js" class="remove"></script>

    <script class="remove">
      // All config options at https://respec.org/docs/
      var respecConfig = {
        group:                "rdf-star" ,
        localBiblio:          localBibliography,
        specStatus:           "ED",
        edDraftURI:           "https://w3c.github.io/sparql-query/spec/",
        testSuiteURI:         "https://w3c.github.io/rdf-tests/",
        shortName:            "sparql12-query",
        copyrightStart:       "2008",
         
        github:               "https://github.com/w3c/sparql-query",
        wgPublicList:         "public-rdf-star-wg",

//        implementationReportURI: "https://w3c.github.io/sparql12-query/reports/",
//        errata:               "https://w3c.github.io/sparql12-query/errata/",

        previousPublishDate:  "2013-03-21",
        prevRecURI:           "https://www.w3.org/TR/2013/REC-sparql11-query-20130321",
        prevRecShortname:     "sparql11-query",
        previousPublishDate:  "2013-03-21",
        previousMaturity:     "REC",
        
         editors: [
           { name: "Olaf Hartig", w3cid: "112469"},
           { name: "Andy Seaborne", w3cid: "29909" },
           { name: "Ruben Taelman", w3cid: "84199"},
           { name: "Gregory Williams", w3cid: "38870"},
         ],
        formerEditors: [
          { name: "Steve Harris" },
          { name: "Andy Seaborne" },
          { name: "Eric Prud'hommeaux" },
        ],

        //doJsonLd:     true,
        
        lint: { "no-unused-dfns": false }
      };
    </script>

    <style>
      /* @import url("local.css"); */
      /* Inlined to make preview work */

/* CSS For SPARQL Query */

/* In-progress working draft artifacts - to be removed eventually */
  .issue	{ background-color: #fdd;
                  font-size: 88% ; }
  .add		{ background-color: #7fff7f }
  .remove	{ background-color: #ff7f7f }
ul.issue	{}
  .issueBlock	{ margin: 1em 4em 1em 2.5em ; /* Top Right Bottom Left */
                  padding: 1ex;
	          /*overflow: auto;*/
                  page-break-inside: avoid ; }
  .issueTopic	{ font-weight: bold ; }

 .todo		{ font-size: 80% ; color: #444 ; }
p.todo		{}

.wgNote	{ border: 0.2em solid red;
      padding: 0.5em ;
      margin: 1em 4em 1em 2em ; }

.box     { border: thin solid #888888;
           page-break-inside: avoid ;
           background-color: #F8F8F8 ; padding:1em ;
           margin-left:0 ; margin-right: 2ex; 
           margin-top: 0.1ex ; margin-bottom: 0.1ex ;
         }

/* Misc WD stuff */
span.cvs-id     {color: gray; font-size:80%; display: block; }

/* == General Tag Treatment == */
pre		 { margin: 1em 4em 1em 2.5em ; /* Top Right Bottom Left */
                   padding: 1ex;
	           /*overflow: auto;*/
                   page-break-inside: avoid ; }

/* Tables */
table, td	{ text-align: left; }
td, th   { border-style: solid;
                  border-width: 1px;
                  border-color: black;
                  border-bottom-color: gray;
                  border-right-color: gray; }
td.annotation, th.annotation { border-style: none; border-bottom-style: dotted; }
table.plain	{ border-spacing: 0px; padding: 0px ; border-collapse: collapse ; }
                  /* cellpadding="0" cellspacing="1" style="border-collapse: collapse */


th.major	{ background-color: #005a9c;
                  color: white; }
.subHeading	{ text-align: left;
                  background-color: #CCCCCC; }
th, td		{ padding: 3px; }
td		{ font-size: 85%; }
th a:link	{ text-decoration: none; }
th a:hover	{ background-color:#FFFF99;
                  text-decoration: underline; }

/* == Prototypes == */
pre.prototype	{ background-color:#f7f8ff;
                  border:thin solid #8888aa;
                  margin: 1em 4em 1em 0em ; }
.return, .type	{ color: #177 }

/* == Notes ==  */
.note		{ margin-left: 2.5em; margin-right: 4ex ; font-size: 85% ; font-style: italic ; }

/* Definitions */
.defn		{ margin-left:0 ; margin-right: 2ex; 
                  margin-top: 0.1ex ; margin-bottom: 0.1ex ;
                  /*border: double 1px #888888; *//* Buggy */
                  border: thin solid #888888;
                  padding: 1ex 2ex 0.5ex 2ex ; /* top, right, bottom, left */
                  page-break-inside: avoid ;
                  background-color: #F0F8F8 ; }
div.defn p	{ margin-top: 1ex ; margin-bottom: 1.5ex ;}
div.defn ul	{ margin-top: 1ex ; margin-bottom: 1.5ex ; }
@media print	{ .defn { margin: 1em 1em 1em 1em ; } }
span.definedTerm	{font-weight: bold;}

div.grammarExtract
                { border: thin solid #888888;
                  padding: 1ex 2ex 1ex 2ex ; /* top, right, bottom, left */
                  margin: 1em 6em 1em 2em ; 
                  page-break-inside: avoid ;
                  background-color: #F8F8F8 ; }

pre.codeBlock  { font-family:monospace ; page-break-inside: avoid ; 
                 margin: 0 ;
	         margin-right: 2ex ;
                 border: thin solid #888888; }




/* Examples */
pre.data	{ border: thin solid #88AA88;
                  background-color: #E8F0E8;
                  margin: 1em 4em 1em 0em ; }

pre.dataExcerpt	{ border: thin solid #88AA88;
                  background-color: #E8F0E8;
                  margin: 1em 4em 1em 0em ; }
/* Example Queries */
.query          { background-color:#f7f8ff; }
.queryExcerpt   { background-color:#f7f8ff; }
pre.query	{ border:thin solid #8888aa;
                  margin: 1em 4em 1em 0em ; }
/* Example Results */
.result		{ border: thin solid  #888888 ;
                  background-color: #F0F0F0 ; }
pre.resultGraph	{  margin: 0em 0em 0em 0em ; /* Top Right Bottom Left */
                   padding: 0ex;
                   font-size: 100% ;
                   page-break-inside: avoid ; }
pre.resultSet	{  margin: 0em 0em 0em 0em ; /* Top Right Bottom Left */
                   padding: 0ex;
                   font-size: 100% ;
                   page-break-inside: avoid ; }
pre.resultAsk	{  margin: 0em 0em 0em 0em ; /* Top Right Bottom Left */
                   padding: 0ex;
                   font-size: 100% ;
                   page-break-inside: avoid ; }
pre.resultTurtle{  margin: 0em 0em 0em 0em ; /* Top Right Bottom Left */
                   padding: 0ex;
                   font-size: 100% ;
                   page-break-inside: avoid ; }

pre.result	{ margin: 1em 4em 1em 0em ; }

div.result	{ font-family: monospace;
                  margin:  1em 4em 1em 0em ;
                  padding: 1ex ; }

.result table	{ border-collapse: collapse; }
.result table td{ border-width: 1px ;
                  border-color : black ; 
                  font-family: monospace ;
                  empty-cells: show;
                  padding-left: 1ex ; padding-right: 1ex ;
                  vertical-align:top;
                  text-align: left ; } 
/*  spacing: 0 ;*/
.result table th{ border-width: 1px ;
                  font-family: monospace ;
                  border-color: black ;
                  empty-cells: show;
                  padding-left: 1ex ; padding-right: 1ex ;
                  vertical-align:top;
                  text-align:center; } 

/* Examples : Algebra */
div.algExample {  border: thin solid #888888;
                  page-break-inside: avoid ;
                  padding:0.5em ; margin:0.5em ;
                  margin-left: 2em ; margin-right: 2em ;
                  font-family:monospace ; }

div.algExample1 { padding:0.5em ; background-color: #F0F0FF ; }
div.algExample2 { padding:0.5em ; margin-top: 0.5em ; background-color: #F0FFF0 ; }

/* Grammar Mark-up */
.operator	{ color: #3f3f5f; }
.function	{ color: #3f3f5f; }

/* Tuned to cope with different browsers behaviours */
div.grammarTable table	{ border-style: solid ;
			  border-width: 1px ;
			  border-color: #AAA ;
			  border-spacing: 0px ; 
			  border-collapse: collapse ; }

div.grammarTable table * { border-left-width: 0px ;
			   border-right-width: 0px ;
			   border-color: #AAA ; } 

div.grammarTable table * tr   { border-top-style: solid ;
			  border-top-width: 1px ;
			  border-top-color: #AAA ; } 

.grammar	{ text-align: left ;
                  vertical-align: top ; }
.token		{ color: #3f3f5f; }
table.FAndOTable .token		{ color: #00c; }
table.FAndOTable .token:visited		{ color: #a0c; }
.gRuleHead	{ font-style: italic ;
                  font-family: monospace ; }
.gRuleBody	{ font-family: monospace ; }
.gRuleLabel	{ font-family: monospace ; }

.code		{ font-family: monospace; font-size: 100%; }
pre.code	{ font-family: monospace; font-size: 100%; margin: 0 ; }

/* Table of Contents */
.toc		{ text-indent: 0; }

/* References to the Rdf Data Model */
span.rdfDM	{ color: #11d; }


/* Truth Table */
  .truth	{ font-family: monospace; }
  .error	{ color: #ff1f1f; }
  table.truthTable td	{ text-align: center; font-family: monospace; }
  table.truthTable th	{ background-color: #dfdfdf; }
  table.truthTable tbody th	{ font-weight: normal; font-family: monospace; }

/* Casting table */
table.casting	{ font-size: x-small; }

.castY	{ background-color: #7FFF7F;
                  color: black; }

.castN	{ background-color: #FF7F7F;
                  color: black; }

.castM	{ background-color: white;
                  color: black; }

span.cancast:hover { background-color: #ffa;
                     color: black; }

.SPARQLoperator	{ background-color: #FFFFbf; /* yellow */
          }

.owlnonterminal {
    font-weight: bold;
    font-family: sans-serif;
    font-size: 95%;
}
.owlgrammar {
    margin-top: 1ex;
    margin-bottom: 1ex;
    padding-left: 1ex;
    padding-right: 1ex;
    padding-top: 1ex;
    padding-bottom: 0.6ex;
    border: 1px dashed #2f6fab;
    font-family: monospace;
}



      /* ReSpec */
      dfn { font-style: normal ; }
      /* ReSpec */

      code           { font-family: monospace; }

      div.constraint,
      div.issue,
      div.notice     { margin-left: 2em; }

      ol.enumar      { list-style-type: decimal; }
      ol.enumla      { list-style-type: lower-alpha; }
      ol.enumlr      { list-style-type: lower-roman; }
      ol.enumua      { list-style-type: upper-alpha; }
      ol.enumur      { list-style-type: upper-roman; }


      div.exampleInner pre { margin-left: 1em;
                             margin-top: 0em; margin-bottom: 0em}
      div.exampleOuter {border: 4px double gray;
                        margin: 0em; padding: 0em}
      div.exampleInner { background-color: #d5dee3;
                         border-top-width: 4px;
                         border-top-style: double;
                         border-top-color: #d3d3d3;
                         border-bottom-width: 4px;
                         border-bottom-style: double;
                         border-bottom-color: #d3d3d3;
                         padding: 4px; margin: 0em }
      div.exampleWrapper { margin: 4px }
      div.exampleHeader { font-weight: bold;
                          margin: 4px}

      em.rfc2119 { text-transform: lowercase;
                   font-variant: small-caps;
                   font-style: normal; }
      @media (max-width: 767px) {
        table { word-break: break-all; max-width: 80vw; }
      }
    </style>
  </head>
  <body>
    <section id="abstract">
      <h2>Abstract</h2>
      <p>
        RDF is a directed, labeled graph data format for representing information in the
        Web. This specification defines the syntax and semantics of the SPARQL query language for
        RDF. SPARQL can be used to express queries across diverse data sources, whether the data is
        stored natively as RDF or viewed as RDF via middleware. SPARQL contains capabilities for
        querying required and optional graph patterns along with their conjunctions and
        disjunctions. SPARQL also supports aggregation, subqueries, negation, creating values by
        expressions, extensible value testing, and constraining queries by source RDF graph. The results
        of SPARQL queries can be result sets or RDF graphs.
      </p>
    </section>

    <section id="sotd" class="introductory">
      <p>
        This specification is published by the
        <a href="https://www.w3.org/groups/wg/rdf-star">RDF Star Working Group</a> as part of the
        update of specifications for format and errata.
      </p>

      <section id="related" data-include="common/sparql-related.html"></section>
    </section>

    <!-- BODY -->
    <section id="introduction">
      <h2>Introduction</h2>
      <p>
        RDF is a directed, labeled graph data format for representing information in the Web. RDF is
        often used to represent, among other things, personal information, social networks, metadata
        about digital artifacts, as well as to provide a means of integration over disparate sources of
        information. This specification defines the syntax and semantics of the SPARQL query language
        for RDF.
      </p>
      <p>
        The SPARQL query language for RDF is designed to meet the use cases and
        requirements identified by the RDF Data Access Working Group in [[rdf-dawg-uc]],
        the SPARQL 1.1 Working Group in [[sparql-features]], and the RDF-star Working Group.
      </p>
      <section id="docOutline">
        <h3>Document Outline</h3>
        <p>
          Unless otherwise noted in the section heading, all sections and appendices in this
          document are normative.
        </p>
        <p>
          This section of the document, <a href="#introduction">section 1</a>, introduces the SPARQL
          query language specification. It presents the organization of this specification document and
          the conventions used throughout the specification.
        </p>
        <p>
          <a href="#basicpatterns">Section 2</a> of the specification introduces the SPARQL query
          language itself via a series of example queries and query results. 
          <a href="#termConstraint">Section 3</a> continues the introduction of the SPARQL query language with
          more examples that demonstrate SPARQL's ability to express constraints on the RDF terms that
          appear in a query's results.
        </p>
        <p>
          <a href="#sparqlSyntax">Section 4</a> presents details of the SPARQL query language's
          syntax. It is a companion to the full grammar of the language and defines how grammatical
          constructs represent IRIs, blank nodes, literals, and variables. Section 4 also defines the
          meaning of several grammatical constructs that serve as syntactic sugar for more verbose
          expressions.
        </p>
        <p>
          <a href="#GraphPattern">Section 5</a> introduces basic graph patterns and group graph
          patterns, the building blocks from which more complex SPARQL query patterns are constructed.
          Sections 6, 7, and 8 present constructs that combine SPARQL graph patterns into larger graph
          patterns. In particular, <a href="#optionals">Section 6</a> introduces the ability to make
          portions of a query optional; <a href="#alternatives">Section 7</a> introduces the ability to
          express the disjunction of alternative graph patterns; and <a href="#negation">Section 8</a>
          introduces patterns to test for the absense of information.
        </p>
        <p>
          <a href="#propertypaths">Section 9</a> adds property paths to graph pattern matching,
          giving a compact representation of queries and also the ability to match arbitrary length
          paths in the graph.
        </p>
        <p>
          <a href="#assignment">Section 10</a> describes the forms of assignment possible
          in SPARQL.
        </p>
        <p>
          <a href="#aggregates">Sections 11</a> introduces the mechanism to group and
          aggregate results, which can be incorporated as subqueries as described
          in <a href="#subqueries">Section 12</a>.
        </p>
        <p>
          <a href="#rdfDataset">Section 13</a> introduces the ability to constrain
          portions of a query to particular source graphs. Section 13 also presents
          SPARQL's mechanism for defining the source graphs for a query.
        </p>
        <p>
          <a href="#basic-federated-query">Section 14</a> refers to the separate document
          [[[SPARQL11-FEDERATED-QUERY]]].
        </p>
        <p>
          <a href="#solutionModifiers">Section 15</a> defines the constructs that affect
          the solutions of a query by ordering, slicing, projecting, limiting, and
          removing duplicates from a sequence of solutions.
        </p>
        <p>
          <a href="#QueryForms">Section 16</a> defines the four types of SPARQL queries
          that produce results in different forms.
        </p>
        <p>
          <a href="#expressions">Section 17</a> defines SPARQL's extensible value testing
          and expression framework. It presents the functions and operators that can be
          used to constrain the values that appear in a query's results and also calculate
          new values to be returned by a query.
        </p>
        <p>
          <a href="#sparqlDefinition">Section 18</a> is a formal definition of the
          evaluation of SPARQL graph patterns and solution modifiers.
        </p>
        <p>
          <a href="#grammar">Section 19</a> contains the normative definition of the syntax for the
          SPARQL query and [[[SPARQL11-UPDATE]]] languages, as given by a grammar expressed in EBNF
          notation.
        </p>
      </section>
    
      <section id="docConventions">
        <h3>Document Conventions</h3>
        <section id="docNamespaces">
          <h4>Namespaces</h4>
          <p>In this document, examples assume the following namespace prefix bindings unless
            otherwise stated:</p>
          <div style="text-align: center;">
            <table style="border-collapse: collapse; border-color: #000000; border-spacing: 5px; border-width: 1px">
              <tbody>
                <tr>
                  <th>Prefix</th>
                  <th>IRI</th>
                </tr>
                <tr>
                  <td><code>rdf:</code></td>
                  <td><code>http://www.w3.org/1999/02/22-rdf-syntax-ns#</code></td>
                </tr>
                <tr>
                  <td><code>rdfs:</code></td>
                  <td><code>http://www.w3.org/2000/01/rdf-schema#</code></td>
                </tr>
                <tr>
                  <td><code>xsd:</code></td>
                  <td><code>http://www.w3.org/2001/XMLSchema#</code></td>
                </tr>
                <tr>
                  <td><code>fn:</code></td>
                  <td><code>http://www.w3.org/2005/xpath-functions#</code></td>
                </tr>
                <tr>
                  <td><code>sfn:</code></td>
                  <td><code>http://www.w3.org/ns/sparql#</code></td>
                </tr>
              </tbody>
            </table>
          </div>
        </section>
        <section id="docDataDesc">
          <h4>Data Descriptions</h4>
          <p>This document uses the [[[TURTLE]]] [[TURTLE]] data format to show each triple
            explicitly. Turtle allows IRIs to be abbreviated with prefixes:</p>
          <pre class="data nohighlight">
            PREFIX dc:   &lt;http://purl.org/dc/elements/1.1/&gt;
            PREFIX :     &lt;http://example.org/book/&gt;

            :book1  dc:title  "SPARQL Tutorial" .
          </pre>
        </section>
        <section id="docResultDesc">
          <h4>Result Descriptions</h4>
          <p>Result sets are illustrated in tabular form.</p>
          <div class="result">
            <div id="table39"></div>
            <table class="resultTable">
              <tbody>
                <tr>
                  <th>x</th>
                  <th>y</th>
                  <th>z</th>
                </tr>
                <tr>
                  <td>"Alice"</td>
                  <td><code>&lt;http://example/a&gt;</code></td>
                  <td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>A 'binding' is a pair (<a href="#defn_QueryVariable">variable</a>,
            <a data-cite="RDF12-CONCEPTS#dfn-rdf-term">RDF term</a>). 
            In this result set, there are three variables:
            <code>x</code>, <code>y</code> and <code>z</code> (shown as column headers). Each solution
            is shown as one row in the body of the table.&nbsp; Here, there is a single solution, in
            which variable <code>x</code> is bound to <code>"Alice"</code>, variable <code>y</code> is
            bound to <code>&lt;http://example/a&gt;</code>, and variable <code>z</code> is not bound to
            an RDF term. Variables are not required to be bound in a solution.</p>
        </section>
        <section id="docTerminology">
          <h4>Terminology</h4>
          <p>The SPARQL language includes IRIs.
            Note that all IRIs in SPARQL queries are absolute; they may or may not include a fragment
            identifier [[RFC3987], section 3.1. IRIs include URIs [[RFC3986]] and URLs. The abbreviated
            forms (<a href="#QSynIRI">relative IRIs and prefixed names</a>) in the SPARQL syntax are
            resolved to produce absolute IRIs.</p>
          <p>The following terms are defined in [[[RDF12-CONCEPTS]]] [[RDF12-CONCEPTS]] and used in
            SPARQL:</p>

          <ul>
            <li>
              <a data-cite="RDF12-CONCEPTS#dfn-iri">IRI</a>
            </li>
            <li>
              <a data-cite="RDF12-CONCEPTS#dfn-literal">literal</a>
            </li>
            <li>
              <a data-cite="RDF12-CONCEPTS#dfn-lexical-form">lexical form</a>
            </li>
            <li>
              <a data-cite="RDF12-CONCEPTS#dfn-language-tag">language tag</a>
            </li>
            <li>
              <a data-cite="RDF12-CONCEPTS#dfn-datatype-iri">datatype IRI</a>
            </li>
            <li>
              <a data-cite="RDF12-CONCEPTS#dfn-blank-node">blank node</a>
            </li>
            <li>
              <a data-cite="RDF12-CONCEPTS#dfn-rdf-term">RDF term</a>
            </li>
          </ul>
        </section>
      </section>
    </section>
    <section id="basicpatterns">
      <h2>Making Simple Queries (Informative)</h2>
      <p>Most forms of SPARQL query contain a set of triple patterns called a <em>basic graph
          pattern</em>. Triple patterns are like RDF triples except that each of the subject, predicate
        and object may be a variable. A basic graph pattern <em>matches</em> a subgraph of the RDF data
        when an <a data-cite="RDF12-CONCEPTS#dfn-rdf-term">RDF term</a> from that subgraph may be substituted for the
        variables and the result is RDF graph equivalent to the subgraph.</p>
      <section id="WritingSimpleQueries">
        <h3>Writing a Simple Query</h3>
        <p>The example below shows a SPARQL query to find the title of a book from the given data
          graph. The query consists of two parts: the <code>SELECT</code> clause identifies the
          variables to appear in the query results, and the <code>WHERE</code> clause provides the
          basic graph pattern to match against the data graph. The basic graph pattern in this example
          consists of a single triple pattern with a single variable (<code>?title</code>) in the
          object position.</p>
        <div class="exampleGroup">
          <p>Data:</p>
          <pre class="data nohighlight">
            &lt;http://example.org/book/book1&gt; &lt;http://purl.org/dc/elements/1.1/title&gt; "SPARQL Tutorial" .</pre>
          <div class="queryGroup">
            <p>Query:</p>
            <pre class="query nohighlight">
SELECT ?title
WHERE
{
    &lt;http://example.org/book/book1&gt; &lt;http://purl.org/dc/elements/1.1/title&gt; ?title .
}
</pre>
            <p>This query, on the data above, has one solution:</p>
            <p>Query Result:</p>
            <div class="result">
              <div id="table109"></div>
              <table class="resultTable">
                <tbody>
                  <tr>
                    <th>title</th>
                  </tr>
                  <tr>
                    <td>"SPARQL Tutorial"</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>
      </section>
      <section id="MultipleMatches">
        <h3>Multiple Matches</h3>
        <p>The result of a query is a <a href="#defn_sparqlSolutionSequence">solution sequence</a>,
          corresponding to the ways in which the query's graph pattern matches the data. There may be
          zero, one or multiple solutions to a query.</p>
        <p>Data:</p>
        <div class="exampleGroup">
<pre class="data nohighlight">PREFIX foaf:  &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a  foaf:name   "Johnny Lee Outlaw" .
_:a  foaf:mbox   &lt;mailto:jlow@example.com&gt; .
_:b  foaf:name   "Peter Goodguy" .
_:b  foaf:mbox   &lt;mailto:peter@example.org&gt; .
_:c  foaf:mbox   &lt;mailto:carol@example.org&gt; .
</pre>
          <p>Query:</p>
          <div class="queryGroup">
            <pre class="query nohighlight">
PREFIX foaf:   &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name ?mbox
WHERE
{ ?x foaf:name ?name .
  ?x foaf:mbox ?mbox }
</pre>
            <p>Query Result:</p>
            <div class="result">
              <table class="resultTable">
                <tbody>
                  <tr>
                    <th>name</th>
                    <th>mbox</th>
                  </tr>
                  <tr>
                    <td>"Johnny Lee Outlaw"</td>
                    <td>&lt;mailto:jlow@example.com&gt;</td>
                  </tr>
                  <tr>
                    <td>"Peter Goodguy"</td>
                    <td>&lt;mailto:peter@example.org&gt;</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>
        <p>Each solution gives one way in which the selected variables can be bound to RDF terms so
          that the query pattern matches the data. The result set gives all the possible solutions. In
          the above example, the following two subsets of the data provided the two matches.</p>
        <pre class="data nohighlightExcerpt"> 
_:a foaf:name  "Johnny Lee Outlaw" .
_:a foaf:box   &lt;mailto:jlow@example.com&gt; .
</pre>
        <pre class="data nohighlightExcerpt"> 
_:b foaf:name  "Peter Goodguy" .
_:b foaf:box   &lt;mailto:peter@example.org&gt; .
</pre>
        <p>This is a <a href="#BGPsparql">basic graph pattern match</a>; all the variables used in
          the query pattern must be bound in every solution.</p>
      </section>
      <section id="matchingRDFLiterals">
        <h3>Matching RDF Literals</h3>
        <p>The data below contains three RDF literals:</p>
        <div class="exampleGroup">
          <pre class="data nohighlight">
@prefix dt:   &lt;http://example.org/datatype#&gt; .
@prefix ns:   &lt;http://example.org/ns#&gt; .
@prefix :     &lt;http://example.org/ns#&gt; .
@prefix xsd:  &lt;http://www.w3.org/2001/XMLSchema#&gt; .

:x   ns:p     "cat"@en .
:y   ns:p     "42"^^xsd:integer .
:z   ns:p     "abc"^^dt:specialDatatype .
</pre>
          <p>Note that, in Turtle, <code>"cat"@en</code> is an RDF literal with a lexical form "cat"
            and a language tag "en"; <code>"42"^^xsd:integer</code> is a literal with the
            datatype <code>http://www.w3.org/2001/XMLSchema#integer</code>; and
            <code>"abc"^^dt:specialDatatype</code> is a literal with the datatype
            <code>http://example.org/datatype#specialDatatype</code>.</p>
        </div>
        <p>This RDF data is the data graph for the query examples in sections 2.3.1–2.3.3.</p>
        <section id="matchLangTags">
          <h4>Matching Literals with Language Tags</h4>
          <p>Language tags in SPARQL are expressed using <code>@</code> and the language tag, as
            defined in [[[BCP47]]] [[BCP47]].</p>
          <p>This following query has no solution because <code>"cat"</code> is not the same RDF
            literal as <code>"cat"@en</code>:</p>
          <div class="queryGroup">
            <pre class="query nohighlight">SELECT ?v WHERE { ?v ?p "cat" }</pre>
            <div class="result">
              <table class="resultTable">
                <tbody>
                  <tr>
                    <th>&nbsp;&nbsp; v&nbsp;&nbsp;&nbsp;&nbsp;</th>
                  </tr>
                </tbody>
              </table>
            </div>
            <p>but the query below will find a solution where variable <code>v</code> is bound to
              <code>:x</code> because the language tag is specified and matches the given data:</p>
            <pre class="query nohighlight">SELECT ?v WHERE { ?v ?p "cat"@en }
            </pre>
            <div class="result">
              <table class="resultTable">
                <tbody>
                  <tr>
                    <th>v</th>
                  </tr>
                  <tr>
                    <td>&lt;http://example.org/ns#x&gt;</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </section>
        <section id="matchNumber">
          <h4>Matching Literals with Numeric Types</h4>
          <p>Integers in a SPARQL query indicate an RDF literal with the datatype
            <code>xsd:integer</code>. For example: <code>42</code> is a shortened form of&nbsp;
            <code>"42"^^&lt;http://www.w3.org/2001/XMLSchema#integer&gt;</code>.</p>
          <p>The pattern in the following query has a solution with variable <code>v</code> bound to
            <code>:y</code>.</p>
          <div class="queryGroup">
            <pre class="query nohighlight">SELECT ?v WHERE { ?v ?p 42 }
            </pre>
            <div class="result">
              <div id="table60"></div>
              <table class="resultTable">
                <tbody>
                  <tr>
                    <th>v</th>
                  </tr>
                  <tr>
                    <td>&lt;http://example.org/ns#y&gt;</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
          <p><a href="#QSynLiterals">Section 4.1.2</a> defines SPARQL shortened forms for
            <code>xsd:float</code> and <code>xsd:double</code>.</p>
        </section>
        <section id="matchArbDT">
          <h4>Matching Literals with Arbitrary Datatypes</h4>
          <p>The following query has a solution with variable <code>v</code> bound to
            <code>:z</code>. The query processor does not have to have any understanding of the values
            in the space of the datatype. Because the lexical form and datatype IRI both match, the
            literal matches.</p>
          <div class="queryGroup">
            <pre class="query nohighlight">
              SELECT ?v WHERE { ?v ?p "abc"^^&lt;http://example.org/datatype#specialDatatype&gt; }
            </pre>
            <div class="result">
              <div id="table61"></div>
              <table class="resultTable">
                <tbody>
                  <tr>
                    <th>v</th>
                  </tr>
                  <tr>
                    <td>&lt;http://example.org/ns#z&gt;</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </section>
      </section>
      <section id="BlankNodesInResults">
        <h3>Blank Node Labels in Query Results</h3>
        <p>Query results can contain blank nodes. Blank nodes in the example result sets in this
          document are written in the form "_:" followed by a blank node label.</p>
        <p>Blank node labels are scoped to a result set (see "[[[RDF-SPARQL-XMLRES]]]" and
          "[[[SPARQL11-RESULTS-JSON]]]") or, for the <code>CONSTRUCT</code> query form, the result
          graph. Use of the same label within a result set indicates the same blank node.</p>
        <div class="exampleGroup">
          Data:
<pre class="data nohighlight">
@prefix foaf:  &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a  foaf:name   "Alice" .
_:b  foaf:name   "Bob" .
</pre>
          <div class="queryGroup">
            Query:
<pre class="query nohighlight">
PREFIX foaf:   &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?x ?name
WHERE  { ?x foaf:name ?name }
</pre>
            <div class="result">
              <div id="table56"></div>
              <table class="resultTable">
                <tbody>
                  <tr>
                    <th>x</th>
                    <th>name</th>
                  </tr>
                  <tr>
                    <td>_:c</td>
                    <td>"Alice"</td>
                  </tr>
                  <tr>
                    <td>_:d</td>
                    <td>"Bob"</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
          <p>The results above could equally be given with different blank node labels because the
            labels in the results only indicate whether RDF terms in the solutions are the same or
            different.</p>
          <div class="result">
            <div id="table57"></div>
            <table class="resultTable">
              <tbody>
                <tr>
                  <th>x</th>
                  <th>name</th>
                </tr>
                <tr>
                  <td>_:r</td>
                  <td>"Alice"</td>
                </tr>
                <tr>
                  <td>_:s</td>
                  <td>"Bob"</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
        <p>These two results have the same information: the blank nodes used to match the query are
          different in the two solutions. There need not be any relation between a label
          <code>_:a</code> in the result set and a blank node in the data graph with the same
          label.</p>
        <p>An application writer should not expect blank node labels in a query to refer to a
          particular blank node in the data.</p>
      </section>
      <section id="CreatingValuesWithExpressions">
        <h3>Creating Values with Expressions</h3>
        <p>SPARQL 1.2 allows values to be created from complex expressions. The queries below show how
          the <a href="#func-concat">CONCAT</a> function can be used to concatenate first names and
          last names from foaf data, then assign the value using an 
          <a href="#selectExpressions">expression in the <code>SELECT</code> clause</a> and also assign the
          value by using the <a href="#bind">BIND</a> form.</p>
        <div class="exampleGroup">
          Data:
          <pre class="data nohighlight">
@prefix foaf:  &lt;http://xmlns.com/foaf/0.1/&gt; .
            
_:a  foaf:givenName   "John" .
_:a  foaf:surname  "Doe" .
</pre>
          <div class="queryGroup">
            Query:
            <pre class="query nohighlight">
PREFIX foaf:   &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ( CONCAT(?G, " ", ?S) AS ?name )
WHERE  { ?P foaf:givenName ?G ; foaf:surname ?S }
</pre>
            Query:
<pre class="query nohighlight">
PREFIX foaf:   &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name
WHERE  { 
    ?P foaf:givenName ?G ; 
       foaf:surname ?S 
    BIND(CONCAT(?G, " ", ?S) AS ?name)
}
</pre>
            <div class="result">
              <div id="table59"></div>
              <table class="resultTable">
                <tbody>
                  <tr>
                    <th>name</th>
                  </tr>
                  <tr>
                    <td>"John Doe"</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>
      </section>
      <section id="constructGraph">
        <h3>Building RDF Graphs</h3>
        <p>SPARQL has several <a href="#QueryForms">query forms</a>. The <code>SELECT</code> query
          form returns variable bindings. The <code>CONSTRUCT</code> query form returns an RDF graph.
          The graph is built based on a template which is used to generate RDF triples based on the
          results of matching the graph pattern of the query.</p>
        <div class="exampleGroup">
          <p>Data:</p>
          <pre class="data nohighlight">
@prefix org:    &lt;http://example.com/ns#&gt; .

_:a  org:employeeName   "Alice" .
_:a  org:employeeId     12345 .

_:b  org:employeeName   "Bob" .
_:b  org:employeeId     67890 .
</pre>
          <div class="queryGroup">
            <p>Query:</p>
            <pre class="query nohighlight">
PREFIX foaf:   &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX org:    &lt;http://example.com/ns#&gt;

CONSTRUCT { ?x foaf:name ?name }
WHERE  { ?x org:employeeName ?name }
</pre>
            <p>Results:</p>
            <div class="result">
              <pre class="resultGraph">
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .
                
_:x foaf:name "Alice" .
_:y foaf:name "Bob" .
</pre>
            </div>
          </div>
          <p>which can be serialized in <a data-cite="RDF12-XML#">RDF/XML</a> as:</p>
          <div class="result">
            <pre class="resultGraph" style="text-align: left;">
&lt;rdf:RDF
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:foaf="http://xmlns.com/foaf/0.1/" &gt;

  &lt;rdf:Description&gt;
    &lt;foaf:name&gt;Alice&lt;/foaf:name&gt;
  &lt;/rdf:Description&gt;
  &lt;rdf:Description&gt;
    &lt;foaf:name&gt;Bob&lt;/foaf:name&gt;
  &lt;/rdf:Description&gt;
&lt;/rdf:RDF&gt;
</pre>
          </div>
        </div>
      </section>
    </section>
    <section id="termConstraint">
      <h2>RDF Term Constraints (Informative)</h2>
      <p>Graph pattern matching produces a solution sequence, where each solution has a set of
        bindings of variables to RDF terms. SPARQL <code>FILTER</code>s restrict solutions to those for
        which the filter expression evaluates to <code>TRUE</code>.</p>
      <p>This section provides an informal introduction to SPARQL <code>FILTER</code>s; their
        semantics are defined in section '<a href="#expressions">Expressions and Testing Values</a>'
        where there is a <a href="#SparqlOps">comprehensive function library</a>. The examples in this
        section share one input graph:</p>
      <div class="exampleGroup">
        Data:
        <pre class="data nohighlight">
@prefix dc:   &lt;http://purl.org/dc/elements/1.1/&gt; .
@prefix :     &lt;http://example.org/book/&gt; .
@prefix ns:   &lt;http://example.org/ns#&gt; .

:book1  dc:title  "SPARQL Tutorial" .
:book1  ns:price  42 .
:book2  dc:title  "The Semantic Web" .
:book2  ns:price  23 .
        </pre>
      </div>
      <section id="restrictString">
        <h3>Restricting the Value of Strings</h3>
        <p>SPARQL <code>FILTER</code> functions like <code><a href="#func-regex">regex</a></code> can
          test RDF literals. <code>regex</code> matches only <a href="#func-string">string
            literals</a>. <code>regex</code> can be used to match the lexical forms of other literals by
          using the <a href="#func-str">str</a> function.</p>
        <p>Query:</p>
        <div class="queryGroup">
          <pre class="query nohighlight">
PREFIX  dc:  &lt;http://purl.org/dc/elements/1.1/&gt;
SELECT  ?title
WHERE   { 
    ?x dc:title ?title
    FILTER regex(?title, "^SPARQL") 
}
</pre>
          <p>Query Result:</p>
          <div class="result">
            <div id="table63"></div>
            <table class="resultTable">
              <tbody>
                <tr>
                  <th>title</th>
                </tr>
                <tr>
                  <td>"SPARQL Tutorial"</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
        <p>Regular expression matches may be made case-insensitive with the "<code>i</code>"
          flag.</p>
        <p>Query:</p>
        <div class="queryGroup">
          <pre class="query nohighlight">
PREFIX  dc:  &lt;http://purl.org/dc/elements/1.1/&gt;
SELECT  ?title
WHERE   { 
    ?x dc:title ?title
    FILTER regex(?title, "web", "i" ) 
}
</pre>
          <p>Query Result:</p>
          <div class="result">
            <div id="table64"></div>
            <table class="resultTable">
              <tbody>
                <tr>
                  <th>title</th>
                </tr>
                <tr>
                  <td>"The Semantic Web"</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
        <p>The regular expression language is <a data-cite="XPATH-FUNCTIONS#regex-syntax">defined by XQuery
            and XPath Functions and Operators</a> and is based on
          <a data-cite="XMLSCHEMA-2#regexs">XML Schema Regular Expressions</a>.</p>
      </section>
      <section id="restrictNumber">
        <h3>Restricting Numeric Values</h3>
        <p>SPARQL <code>FILTER</code>s can restrict on arithmetic expressions.</p>
        <p>Query:</p>
        <div class="queryGroup">
          <pre class="query nohighlight">
PREFIX  dc:  &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX  ns:  &lt;http://example.org/ns#&gt;

SELECT  ?title ?price
WHERE   {
    ?x ns:price ?price .
    FILTER (?price &lt; 30.5)
    ?x dc:title ?title . 
}
</pre>
          <p>Query Result:</p>
          <div class="result">
            <div id="table58"></div>
            <table class="resultTable">
              <tbody>
                <tr>
                  <th>title</th>
                  <th>price</th>
                </tr>
                <tr>
                  <td>"The Semantic Web"</td>
                  <td>23</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
      </section>
      <p>By constraining the <code>price</code> variable, only <code>:book2</code> matches the query
        because only <code>:book2</code> has a price less than <code>30.5</code>, as the filter
        condition requires.</p>
      <section id="otherTermConstraints">
        <h3>Other Term Constraints</h3>
        <p>In addition to <span class="type numeric">numeric</span> types, SPARQL supports types
          <code>xsd:string</code>, <code>xsd:boolean</code> and <code>xsd:dateTime</code>
          (see <a href="#operandDataTypes">Operand Data Types</a>). Section <a href="#OperatorMapping">Operator
            Mapping</a> describes the operators and section <a href="#SparqlOps">Function Definitions</a>
          the functions that can be that can be applied to RDF terms.</p>
      </section>
    </section>
    <section id="sparqlSyntax">
      <h2>SPARQL Syntax</h2>
      <p>
        This section covers the syntax used by SPARQL for 
        <a data-cite="RDF12-CONCEPTS#dfn-rdf-term">RDF terms</a>
        and <a href="#sparqlTriplePatterns">triple patterns</a>. 
        The full grammar is given in <a href="#grammar">section 19</a>.
      </p>
      <section id="syntaxTerms">
        <h3>RDF Term Syntax</h3>
        <section id="QSynIRI">
          <h4>Syntax for IRIs</h4>
          <p>The <a href="#riri">iri</a> production designates the set of IRIs [[RFC3987]]; IRIs are
            a generalization of URIs [[RFC3986]] and are fully compatible with URIs and URLs. The
            <a href="#rPrefixedName">PrefixedName</a> production designates a prefixed name. The
            mapping from a prefixed name to an IRI is described below. IRI references (relative or
            absolute IRIs) are designated by the <a href="#rIRIREF">IRIREF</a> production, where the
            '&lt;' and '&gt;' delimiters do not form part of the IRI reference. Relative IRIs match the
            <code>irelative-ref</code> reference in section 2.2 ABNF for IRI References and IRIs in
            [[RFC3987]] and are resolved to IRIs as described below.</p>
          <section id="prefNames">
            <h5>Prefixed Names</h5>
            <p>The <code>PREFIX</code> keyword associates a prefix label with an IRI. A prefixed name
              is a prefix label and a local part, separated by a colon "<code>:</code>". A prefixed
              name is mapped to an IRI by concatenating the IRI associated with the prefix and the
              local part. The prefix label or the local part may be empty. 
              Note that <a href="#rPN_LOCAL">SPARQL local names</a> allow leading digits while 
              <a data-cite="XML-NAMES11#NT-LocalPart">XML local names</a> do not. 
              <a href="#rPN_LOCAL">SPARQL local names</a> also allow the non-alphanumeric
              characters allowed in IRIs via backslash
              character escapes (e.g. <code>ns:id\=123</code>). <a href="#rPN_LOCAL">SPARQL local
                names</a> have more syntactic restrictions than 
              <a data-cite="CURIE#">CURIE</a>s.</p>
          </section>
          <section id="relIRIs">
            <h5>Relative IRIs</h5>
            <p>Relative IRIs are combined with base IRIs as per [[[RFC3986]]] [[RFC3986]] using only
              the basic algorithm in section 5.2. Neither Syntax-Based Normalization nor Scheme-Based
              Normalization (described in sections 6.2.2 and 6.2.3 of [[RFC3986]]) are performed.
              Characters additionally allowed in IRI references are treated in the same way that
              unreserved characters are treated in URI references, per section 6.5 of [[[RFC3987]]]
              [[RFC3987]].</p>
            <p>The <code>BASE</code> keyword defines the Base IRI used to resolve relative IRIs per
              [[RFC3986]] section 5.1.1, "Base URI Embedded in Content". Section 5.1.2, "Base URI from
              the Encapsulating Entity" defines how the Base IRI may come from an encapsulating
              document, such as a SOAP envelope with an xml:base directive or a mime multipart document
              with a Content-Location header. The "Retrieval URI" identified in 5.1.3, Base "URI from
              the Retrieval URI", is the URL from which a particular SPARQL query was retrieved. If
              none of the above specifies the Base URI, the default Base URI (section 5.1.4, "Default
              Base URI") is used.</p>
            <p>The following fragments are some of the different ways to write the same IRI:</p>
            <pre class="data nohighlight">&lt;http://example.org/book/book1&gt;</pre>
            <pre class="data nohighlight">BASE &lt;http://example.org/book/&gt;
&lt;book1&gt;</pre>
            <pre class="data nohighlight">PREFIX book: &lt;http://example.org/book/&gt;
book:book1</pre>
          </section>
        </section>
        <section id="QSynLiterals">
          <h4>Syntax for Literals</h4>
          <p>The general syntax for literals is a string (enclosed in either double quotes,
            <code>"..."</code>, or single quotes, <code>'...'</code>), with either an optional language
            tag (introduced by <code>@</code>) or an optional datatype IRI or prefixed name (introduced
            by <code>^^</code>).</p>
          <p>As a convenience, integers can be written directly (without quotation marks and an
            explicit datatype IRI) and are interpreted as literals with datatype
            <code>xsd:integer</code>; decimal numbers for which there is '.' in the number but no
            exponent are interpreted as <code>xsd:decimal</code>; and numbers with exponents are
            interpreted as <code>xsd:double</code>. Values of type <code>xsd:boolean</code> can also be
            written as <code>true</code> or <code>false</code>.</p>
          <p>To facilitate writing literal values which themselves contain quotation marks or which
            are long and contain newline characters, SPARQL provides an additional quoting construct in
            which literals are enclosed in three single- or double-quotation marks.</p>
          <p>Examples of literal syntax in SPARQL include:</p>
          <ul>
            <li><code>"chat"</code></li>
            <li><code>'chat'@fr</code> with language tag "fr"</li>
            <li><code>"xyz"^^&lt;http://example.org/ns/userDatatype&gt;</code></li>
            <li><code>"abc"^^appNS:appDataType</code></li>
            <li><code>'''The librarian said, "Perhaps you would enjoy 'War and
                Peace'."'''</code></li>
            <li><code>1</code>, which is the same as <code>"1"^^xsd:integer</code></li>
            <li><code>1.3</code>, which is the same as <code>"1.3"^^xsd:decimal</code></li>
            <li><code>1.300</code>, which is the same as <code>"1.300"^^xsd:decimal</code></li>
            <li><code>1.0e6</code>, which is the same as <code>"1.0e6"^^xsd:double</code></li>
            <li><code>true</code>, which is the same as <code>"true"^^xsd:boolean</code></li>
            <li><code>false</code>, which is the same as <code>"false"^^xsd:boolean</code></li>
          </ul>
          <p>Tokens matching the productions 
            <a href="#rINTEGER">INTEGER</a>,
            <a href="#rDECIMAL">DECIMAL</a>, 
            <a href="#rDOUBLE">DOUBLE</a> or 
            <a href="#rBooleanLiteral">BooleanLiteral</a> are equivalent to a typed literal with the lexical
            value of the token and the corresponding datatype (<code>xsd:integer</code>,
            <code>xsd:decimal</code>, <code>xsd:double</code>, <code>xsd:boolean</code>).</p>
        </section>
        <section id="QSynVariables">
          <h4>Syntax for Query Variables</h4>
          <p>A query variable is marked by the use of either "?" or "$"; the "?" or "$" is not part
            of the variable name. In a query, <code>$abc</code> and <code>?abc</code> identify the same
            variable. The <a href="#rVARNAME">possible names</a> for variables are given in the
            <a href="#grammar">SPARQL grammar</a>.</p>
        </section>
        <section id="QSynBlankNodes">
          <h4>Syntax for Blank Nodes</h4>
          <p><a data-cite="RDF12-CONCEPTS#dfn-blank-node">Blank nodes</a>
            in graph patterns act as variables, not as references to specific
            blank nodes in the data being queried.</p>
          <p>Blank nodes are indicated by either the label form, such as "<code>_:abc</code>", or the
            abbreviated form "<code>[]</code>". A blank node that is used in only one place in the
            query syntax can be indicated with <code>[]</code>. A unique blank node will be used to
            form the triple pattern. Blank node labels are written as "<code>_:abc</code>" for a blank
            node with label "<code>abc</code>". The same blank node label cannot be used in two
            different basic graph patterns in the same query.</p>
          <p>The <code>[:p :v]</code> construct can be used in triple patterns. It creates a blank
            node label which is used as the subject of all contained predicate-object pairs. The
            created blank node can also be used in further triple patterns in the subject and object
            positions.</p>
          <p>The following two forms</p>
          <pre class="query nohighlight">
[ :p "v" ] .
          </pre>
          <pre class="query nohighlight">
[] :p "v" .
          </pre>
          <p>allocate a unique blank node label (here "<code>b57</code>") and are equivalent to
            writing:</p>
          <pre class="query nohighlight">
_:b57 :p "v" .
          </pre>
          <p>This allocated blank node label can be used as the subject or object of further triple
            patterns. For example, as a subject:</p>
          <pre class="query nohighlight">[ :p "v" ] :q "w" .
          </pre>
          <p>which is equivalent to the two triples:</p>
          <pre class="query nohighlight">
_:b57 :p "v" .
_:b57 :q "w" .
          </pre>
          <p>and as an object:</p>
          <pre class="query nohighlight">
:x :q [ :p "v" ] .
          </pre>
          <p>which is equivalent to the two triples:</p>
          <pre class="query nohighlight">
:x  :q _:b57 .
_:b57 :p "v" .
          </pre>
          <p>Abbreviated blank node syntax can be combined with other abbreviations
            for <a href="#predObjLists">common subjects</a> and <a href="#objLists">common predicates</a>.</p>
          <pre class="query nohighlight">
[ foaf:name  ?name ;
  foaf:mbox  &lt;mailto:alice@example.org&gt; ]
          </pre>
          <p>This is the same as writing the following basic graph pattern for some uniquely
            allocated blank node label, "<code>b18</code>":</p>
          <pre class="query nohighlight">  
_:b18  foaf:name  ?name .
_:b18  foaf:mbox  &lt;mailto:alice@example.org&gt; .
          </pre>
        </section>
      </section>
      <section id="QSynTriples">
        <h3>Syntax for Triple Patterns</h3>
        <p><a href="#defn_TriplePattern">Triple Patterns</a> are written as subject, predicate and
          object; there are abbreviated ways of writing some common triple pattern constructs.</p>
        <p>The following examples express the same query:</p>
        <pre class="query nohighlight">
PREFIX  dc: &lt;http://purl.org/dc/elements/1.1/&gt;
SELECT  ?title
WHERE   { &lt;http://example.org/book/book1&gt; dc:title ?title }  
</pre>
        <pre class="query nohighlight">
PREFIX  dc: &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX  : &lt;http://example.org/book/&gt;

SELECT  $title
WHERE   { :book1  dc:title  $title }
</pre>
        <pre class="query nohighlight">
BASE    &lt;http://example.org/book/&gt;
PREFIX  dc: &lt;http://purl.org/dc/elements/1.1/&gt;

SELECT  $title
WHERE   { &lt;book1&gt;  dc:title  ?title }
</pre>
        <section id="predObjLists">
          <h4>Predicate-Object Lists</h4>
          <p>Triple patterns with a common subject can be written so that the subject is only written
            once and is used for more than one triple pattern by employing the "<code>;</code>"
            notation.</p>
          <pre class="query nohighlight">
?x  foaf:name  ?name ;
foaf:mbox  ?mbox .
          </pre>
          <p>This is the same as writing the triple patterns:</p>
          <pre class="query nohighlight"> 
?x  foaf:name  ?name .
?x  foaf:mbox  ?mbox .
          </pre>
        </section>
        <section id="objLists">
          <h4>Object Lists</h4>
          <p>If triple patterns share both subject and predicate, the objects may be separated by
            "<code>,</code>".</p>
          <pre class="query nohighlight">
?x foaf:nick  "Alice" , "Alice_" .
          </pre>
          <p>is the same as writing the triple patterns:</p>
          <pre class="query nohighlight">
?x  foaf:nick  "Alice" .
?x  foaf:nick  "Alice_" .
          </pre>
          <p>Object lists can be combined with predicate-object lists:</p>
          <pre class="query nohighlight">
?x  foaf:name ?name ; foaf:nick  "Alice" , "Alice_" .
          </pre>
          <p>is equivalent to:</p>
          <pre class="query nohighlight">
?x  foaf:name  ?name .
?x  foaf:nick  "Alice" .
?x  foaf:nick  "Alice_" .
          </pre>
        </section>
        <section id="collections">
          <h4>RDF Collections</h4>
          <p><a data-cite="RDF12-SEMANTICS#collections">RDF collections</a> can be written in triple
            patterns using the syntax "(element1 element2 ...)". The form "<code>()</code>" is an
            alternative for the IRI 
            <code><a href="http://www.w3.org/1999/02/22-rdf-syntax-ns#nil">http://www.w3.org/1999/02/22-rdf-syntax-ns#nil</a></code>.
            When used with collection elements, such as <code>(1 ?x 3 4)</code>, triple patterns with
            blank nodes are allocated for the collection. The blank node at the head of the collection
            can be used as a subject or object in other triple patterns. The blank nodes allocated by
            the collection syntax do not occur elsewhere in the query.</p>
          <pre class="query nohighlight">
(1 ?x 3 4) :p "w" .
          </pre>
          <p>is syntactic sugar for (noting that <code>b0</code>, <code>b1</code>, <code>b2</code>
            and <code>b3</code> do not occur anywhere else in the query):</p>
          <pre class="query nohighlight">
_:b0  rdf:first  1 ;
      rdf:rest   _:b1 .
_:b1  rdf:first  ?x ;
      rdf:rest   _:b2 .
_:b2  rdf:first  3 ;
      rdf:rest   _:b3 .
_:b3  rdf:first  4 ;
      rdf:rest   rdf:nil .
_:b0  :p         "w" . 
          </pre>
          <p>RDF collections can be nested and can involve other syntactic forms:</p>
          <pre class="query nohighlight">(1 [:p :q] ( 2 ) ) .
          </pre>
          <p>is syntactic sugar for:</p>
          <pre class="query nohighlight">
_:b0  rdf:first  1 ;
      rdf:rest   _:b1 .
_:b1  rdf:first  _:b2 .
_:b2  :p         :q .
_:b1  rdf:rest   _:b3 .
_:b3  rdf:first  _:b4 .
_:b4  rdf:first  2 ;
      rdf:rest   rdf:nil .
_:b3  rdf:rest   rdf:nil .
          </pre>
        </section>
        <section id="abbrevRdfType">
          <h4>rdf:type</h4>
          <p>The keyword "<code>a</code>" can be used as a predicate in a triple pattern and is an
            alternative for the IRI&nbsp; 
            <code><a href="http://www.w3.org/1999/02/22-rdf-syntax-ns#type">http://www.w3.org/1999/02/22-rdf-syntax-ns#type</a></code>.
            This keyword is case-sensitive.</p>
          <pre class="query nohighlight">  
?x  a  :Class1 .
[ a :appClass ] :p "v" .
          </pre>
          <p>is syntactic sugar for:</p>
          <pre class="query nohighlight">
?x    rdf:type  :Class1 .
_:b0  rdf:type  :appClass .
_:b0  :p        "v" .
          </pre>
        </section>
      </section>
    </section>
    <section id="GraphPattern">
      <h2>Graph Patterns</h2>
      <p>SPARQL is based around graph pattern matching. More complex graph patterns can be formed by
        combining smaller patterns in various ways:</p>
      <ul>
        <li>
          <a href="#BasicGraphPatterns">Basic Graph Patterns</a>, where a set of triple patterns must
          match
        </li>
        <li>
          <a href="#GroupPatterns">Group Graph Pattern</a>, where a set of graph patterns must all
          match
        </li>
        <li>
          <a href="#optionals">Optional Graph patterns</a>, where additional patterns may extend the
          solution
        </li>
        <li>
          <a href="#alternatives">Alternative Graph Pattern</a>, where two or more possible patterns
          are tried
        </li>
        <li>
          <a href="#queryDataset">Patterns on Named Graphs</a>, where patterns are matched against
          named graphs
        </li>
      </ul>
      <p>In this section we describe the two forms that combine patterns by conjunction: basic graph
        patterns, which combine triples patterns, and group graph patterns, which combine all other
        graph patterns.</p>
      <p>The outer-most graph pattern in a query is called the query pattern. It is grammatically
        identified by <code>GroupGraphPattern</code> in</p>
      <div class="grammarExtract">
        <div class="grammarTable">
          <table>
            <tbody>
              <tr style="vertical-align: baseline">
                <td><code>[17]&nbsp;&nbsp;</code></td>
                <td><code><a href="#rWhereClause">WhereClause</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'WHERE'</span>? <a href="#rGroupGraphPattern">GroupGraphPattern</a></code></td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
      <section id="BasicGraphPatterns">
        <h3>Basic Graph Patterns</h3>
        <p>Basic graph patterns are sets of triple patterns. SPARQL graph pattern matching is defined
          in terms of combining the results from matching basic graph patterns.</p>
        <p>A sequence of triple patterns, with optional filters, comprises a single basic graph
          pattern. Any other graph pattern terminates a basic graph pattern.</p>
        <section id="bgpBNodeLabels">
          <h4>Blank Node Labels</h4>
          <p>When using blank nodes of the form <code>_:abc</code>,&nbsp; labels for blank nodes are
            scoped to the basic graph pattern.&nbsp; A label can be used in only a single basic graph
            pattern in any query.</p>
        </section>
        <section id="bgpExtend">
          <h4>Extending Basic Graph Pattern Matching</h4>
          <p>SPARQL evaluates basic graph patterns using subgraph matching, which is defined for
            simple entailment. SPARQL can be extended to other forms of entailment given
            <a href="#sparqlBGPExtend">certain conditions</a> as described below. The document
            [[[SPARQL11-ENTAILMENT]]] describes several specific entailment regimes.</p>
        </section>
      </section>
      <section id="GroupPatterns">
        <h3>Group Graph Patterns</h3>
        <p>In a SPARQL query string, a group graph pattern is delimited with braces: <code>{}</code>.
          For example, this query's query pattern is a group graph pattern of one basic graph
          pattern.</p>
        <div class="exampleGroup">
          <div class="queryGroup">
            <pre class="query nohighlight">
PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name ?mbox
WHERE  {
    ?x foaf:name ?name .
    ?x foaf:mbox ?mbox .
}
            </pre>
          </div>
        </div>
        <div class="exampleGroup">
          <div class="queryGroup">
            The same solutions would be obtained from a query that grouped the triple patterns into
            two basic graph patterns. For example, the query below has a different structure but
            would yield the same solutions as the previous query:
            <pre class="query nohighlight">
PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name ?mbox
WHERE  { 
   { ?x foaf:name ?name . }
   { ?x foaf:mbox ?mbox . }
}
</pre>
          </div>
        </div>
        <section id="emptyGroupPattern">
          <h4>Empty Group Pattern</h4>
          <p>The group pattern:</p>
          <pre class="query nohighlight">{ }</pre>
          <p>matches any graph (including the empty graph) with one solution that does not bind any
            variables. For example:</p>
          <pre class="query nohighlight">
SELECT ?x
WHERE {}
          </pre>
          <p>matches with one solution in which variable <code>x</code> is not bound.</p>
        </section>
        <section id="scopeFilters">
          <h4>Scope of Filters</h4>
          <p>A constraint, expressed by the keyword <code>FILTER</code>, is a restriction on
            solutions over the whole group in which the filter appears. The following patterns all have
            the same solutions:</p>
          <div class="exampleGroup">
            <div class="queryGroup">
              <pre class="query nohighlight">
{  ?x foaf:name ?name .
   ?x foaf:mbox ?mbox .
   FILTER regex(?name, "Smith")
}
              </pre>
            </div>
          </div>
          <div class="exampleGroup">
            <div class="queryGroup">
              <pre class="query nohighlight">
{  FILTER regex(?name, "Smith")
   ?x foaf:name ?name .
   ?x foaf:mbox ?mbox .
}
              </pre>
            </div>
          </div>
          <div class="exampleGroup">
            <div class="queryGroup">
              <pre class="query nohighlight">
{  ?x foaf:name ?name .
   FILTER regex(?name, "Smith")
   ?x foaf:mbox ?mbox .
}
              </pre>
            </div>
          </div>
        </section>
        <section id="groupExamples">
          <h4>Group Graph Pattern Examples</h4>
          <div class="exampleGroup">
            <div class="queryGroup">
              <pre class="query nohighlight">
{ ?x foaf:name ?name .
  ?x foaf:mbox ?mbox .
}
</pre>
            </div>
          </div>
          <p>is a group of one basic graph pattern and that basic graph pattern consists of two
            triple patterns.</p>
          <div class="exampleGroup">
            <div class="queryGroup">
              <pre class="query nohighlight">
{
  ?x foaf:name ?name . FILTER regex(?name, "Smith")
  ?x foaf:mbox ?mbox .
}
</pre>
            </div>
          </div>
          <p>is a group of one basic graph pattern and a filter, and that basic graph pattern
            consists of two triple patterns; the filter does not break the basic graph pattern into two
            basic graph patterns.</p>
          <div class="exampleGroup">
            <div class="queryGroup">
              <pre class="query nohighlight">
{
  ?x foaf:name ?name .
  {}
  ?x foaf:mbox ?mbox .
}
</pre>
            </div>
          </div>
          <p>is a group of three elements, a basic graph pattern of one triple pattern, an empty
            group, and another basic graph pattern of one triple pattern.</p>
        </section>
      </section>
    </section>
    <section id="optionals">
      <h2>Including Optional Values</h2>
      <p>Basic graph patterns allow applications to make queries where the entire query pattern must
        match for there to be a solution. For every solution of a query containing only group graph
        patterns with at least one basic graph pattern, every variable is bound to an RDF Term in a
        solution. However, regular, complete structures cannot be assumed in all RDF graphs. It is
        useful to be able to have queries that allow information to be added to the solution where the
        information is available, but do not reject the solution because some part of the query pattern
        does not match. Optional matching provides this facility: if the optional part does not match,
        it creates no bindings but does not eliminate the solution.</p>
      <section id="OptionalMatching">
        <h3>Optional Pattern Matching</h3>
        <p>Optional parts of the graph pattern may be specified syntactically with the OPTIONAL
          keyword applied to a graph pattern:</p>
        <pre class="query nohighlight">
<i>pattern</i> OPTIONAL { <i>pattern</i> }
        </pre>
        <div class="exampleGroup">
          <p>The syntactic form:</p>
          <pre class="query nohighlight">
{ OPTIONAL { <i>pattern</i> } }
          </pre>
          <p>is equivalent to:</p>
          <pre class="query nohighlight">
{ { } OPTIONAL { <i>pattern</i> } }
          </pre>
          <p>The <code>OPTIONAL</code> keyword is left-associative :</p>
          <pre class="query nohighlight">
<i>pattern</i> OPTIONAL { <i>pattern</i> } OPTIONAL { pattern }
          </pre>
          <p>is the same as:</p>
          <pre class="query nohighlight">
{ <i>pattern</i> OPTIONAL { <i>pattern</i> } } OPTIONAL { pattern }
          </pre>
          <p>In an optional match, either the optional graph pattern matches a graph, thereby
            defining and adding bindings to one or more solutions, or it leaves a solution unchanged
            without adding any additional bindings.</p>
          <p>Data:</p>
          <pre class="data nohighlight">
@prefix foaf:       &lt;http://xmlns.com/foaf/0.1/&gt; .
@prefix rdf:        &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .

_:a  rdf:type        foaf:Person .
_:a  foaf:name       "Alice" .
_:a  foaf:mbox       &lt;mailto:alice@example.com&gt; .
_:a  foaf:mbox       &lt;mailto:alice@work.example&gt; .

_:b  rdf:type        foaf:Person .
_:b  foaf:name       "Bob" .
</pre>
          <div class="queryGroup">
            Query:
            <pre class="query nohighlight">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name ?mbox
WHERE  {
    ?x foaf:name  ?name .
    OPTIONAL { ?x  foaf:mbox  ?mbox }
}
            </pre>
            <p>With the data above, the query result is:</p>
            <div class="result">
              <div id="table92"></div>
              <table class="resultTable">
                <tbody>
                  <tr>
                    <th>name</th>
                    <th>mbox</th>
                  </tr>
                  <tr>
                    <td>"Alice"</td>
                    <td>&lt;mailto:alice@example.com&gt;</td>
                  </tr>
                  <tr>
                    <td>"Alice"</td>
                    <td>&lt;mailto:alice@work.example&gt;</td>
                  </tr>
                  <tr>
                    <td>"Bob"</td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>
        <p>There is no value of <code>mbox</code> in the solution where the name is
          <code>"Bob"</code>.</p>
        <p>This query finds the names of people in the data. If there is a triple with predicate
          <code>mbox</code> and the same subject, a solution will contain the object of that triple as
          well. In this example, only a single triple pattern is given in the optional match part of
          the query but, in general, the optional part may be any graph pattern. The entire optional
          graph pattern must match for the optional graph pattern to affect the query solution.</p>
      </section>
      <section id="OptionalAndConstraints">
        <h3>Constraints in Optional Pattern Matching</h3>
        <p>Constraints can be given in an optional graph pattern. For example:</p>
        <div class="exampleGroup">
          <pre class="data nohighlight">
@prefix dc:   &lt;http://purl.org/dc/elements/1.1/&gt; .
@prefix :     &lt;http://example.org/book/&gt; .
@prefix ns:   &lt;http://example.org/ns#&gt; .

:book1  dc:title  "SPARQL Tutorial" .
:book1  ns:price  42 .
:book2  dc:title  "The Semantic Web" .
:book2  ns:price  23 .
          </pre>
          <div class="queryGroup">
            <pre class="query nohighlight">
PREFIX  dc:  &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX  ns:  &lt;http://example.org/ns#&gt;
SELECT  ?title ?price
WHERE   { 
    ?x dc:title ?title .
    OPTIONAL { ?x ns:price ?price . FILTER (?price &lt; 30) }
}
            </pre>
            <div class="result">
              <div id="table93"></div>
              <table class="resultTable">
                <tbody>
                  <tr>
                    <th>title</th>
                    <th>price</th>
                  </tr>
                  <tr>
                    <td>"SPARQL Tutorial"</td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>"The Semantic Web"</td>
                    <td>23</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>
        <p>No price appears for the book with title "SPARQL Tutorial" because the optional graph
          pattern did not lead to a solution involving the variable "<code>price</code>".</p>
      </section>
      <section id="MultipleOptionals">
        <h3>Multiple Optional Graph Patterns</h3>
        <p>Graph patterns are defined recursively. A graph pattern may have zero or more optional
          graph patterns, and any part of a query pattern may have an optional part. In this example,
          there are two optional graph patterns.</p>
        <div class="exampleGroup">
          Data:
          <pre class="data nohighlight">
@prefix foaf:       &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a  foaf:name       "Alice" .
_:a  foaf:homepage   &lt;http://work.example.org/alice/&gt; .

_:b  foaf:name       "Bob" .
_:b  foaf:mbox       &lt;mailto:bob@work.example&gt; .
          </pre>
          <div class="queryGroup">
            Query:
            <pre class="query nohighlight">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name ?mbox ?hpage
WHERE  {
    ?x foaf:name  ?name .
    OPTIONAL { ?x foaf:mbox ?mbox } .
    OPTIONAL { ?x foaf:homepage ?hpage }
}
</pre>
            <p>Query result:</p>
            <div class="result">
              <div id="table94"></div>
              <table class="resultTable">
                <tbody>
                  <tr>
                    <th>name</th>
                    <th>mbox</th>
                    <th>hpage</th>
                  </tr>
                  <tr>
                    <td>"Alice"</td>
                    <td></td>
                    <td>&lt;http://work.example.org/alice/&gt;</td>
                  </tr>
                  <tr>
                    <td>"Bob"</td>
                    <td>&lt;mailto:bob@work.example&gt;</td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>
      </section>
    </section>
    <section id="alternatives">
      <h2>Matching Alternatives</h2>
      <p>SPARQL provides a means of combining graph patterns so that one of several alternative graph
        patterns may match. If more than one of the alternatives matches, all the possible pattern
        solutions are found.</p>
      <p>Pattern alternatives are syntactically specified with the <code>UNION</code> keyword.</p>
      <div class="exampleGroup">
        Data:
        <pre class="data nohighlight">
@prefix dc10:  &lt;http://purl.org/dc/elements/1.0/&gt; .
@prefix dc11:  &lt;http://purl.org/dc/elements/1.1/&gt; .

_:a  dc10:title     "SPARQL Query Language Tutorial" .
_:a  dc10:creator   "Alice" .

_:b  dc11:title     "SPARQL Protocol Tutorial" .
_:b  dc11:creator   "Bob" .

_:c  dc10:title     "SPARQL" .
_:c  dc11:title     "SPARQL (updated)" .
        </pre>
        <div class="queryGroup">
          Query:
          <pre class="query nohighlight">
PREFIX dc10:  &lt;http://purl.org/dc/elements/1.0/&gt;
PREFIX dc11:  &lt;http://purl.org/dc/elements/1.1/&gt;

SELECT ?title
WHERE  { { ?book dc10:title  ?title } UNION { ?book dc11:title  ?title } }
          </pre>
          <p>Query result:</p>
          <div class="result">
            <div id="table97"></div>
            <table class="resultTable">
              <tbody>
                <tr>
                  <th>title</th>
                </tr>
                <tr>
                  <td>"SPARQL Protocol Tutorial"</td>
                </tr>
                <tr>
                  <td>"SPARQL"</td>
                </tr>
                <tr>
                  <td>"SPARQL (updated)"</td>
                </tr>
                <tr>
                  <td>"SPARQL Query Language Tutorial"</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
        <p>This query finds titles of the books in the data, whether the title is recorded using
          <a class="inform" href="http://dublincore.org/">Dublin Core</a> properties from version 1.0
          or version 1.1. To determine exactly how the information was recorded, a query could use
          different variables for the two alternatives:</p>
        <div class="queryGroup">
          <pre class="query nohighlight">
PREFIX dc10:  &lt;http://purl.org/dc/elements/1.0/&gt;
PREFIX dc11:  &lt;http://purl.org/dc/elements/1.1/&gt;

SELECT ?x ?y
WHERE  { { ?book dc10:title ?x } UNION { ?book dc11:title  ?y } }
          </pre>
          <div class="result">
            <div id="table98"></div>
            <table class="resultTable">
              <tbody>
                <tr>
                  <th>x</th>
                  <th>y</th>
                </tr>
                <tr>
                  <td></td>
                  <td>"SPARQL (updated)"</td>
                </tr>
                <tr>
                  <td></td>
                  <td>"SPARQL Protocol Tutorial"</td>
                </tr>
                <tr>
                  <td>"SPARQL"</td>
                  <td></td>
                </tr>
                <tr>
                  <td>"SPARQL Query Language Tutorial"</td>
                  <td></td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
        <p>This will return results with the variable <code>x</code> bound for solutions from the
          left branch of the <code>UNION</code>, and <code>y</code> bound for the solutions from the
          right branch. If neither part of the <code>UNION</code> pattern matched, then the graph
          pattern would not match.</p>
        <p>The <code>UNION</code> pattern combines graph patterns; each alternative possibility can
          contain more than one triple pattern:</p>
        <div class="queryGroup">
          <pre class="query nohighlight">
PREFIX dc10:  &lt;http://purl.org/dc/elements/1.0/&gt;
PREFIX dc11:  &lt;http://purl.org/dc/elements/1.1/&gt;

SELECT ?title ?author
WHERE {
    { ?book dc10:title ?title .  ?book dc10:creator ?author }
      UNION
    { ?book dc11:title ?title .  ?book dc11:creator ?author }
}
          </pre>
          <div class="result">
            <div id="table99"></div>
            <table class="resultTable">
              <tbody>
                <tr>
                  <th>title</th>
                  <th>author</th>
                </tr>
                <tr>
                  <td>"SPARQL Query Language Tutorial"</td>
                  <td>"Alice"</td>
                </tr>
                <tr>
                  <td>"SPARQL Protocol Tutorial"</td>
                  <td>"Bob"</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
      </div>
      <p>This query will only match a book if it has both a title and creator predicate from the same
        version of Dublin Core.</p>
    </section>
    <section id="negation">
      <h2>Negation</h2>
      <p>The SPARQL query language incorporates two styles of negation, one based on filtering
        results depending on whether a graph pattern does or does not match in the context of the query
        solution being filtered, and one based on removing solutions related to another pattern.</p>
      <section id="neg-pattern">
        <h3>Filtering Using Graph Patterns</h3>
        <p>Filtering of query solutions is done within a <code>FILTER</code> expression using
          <code>NOT EXISTS</code> and <code>EXISTS</code>. Note that the filter scope rules
          <a href="#scopeFilters">apply to the whole group in which the filter appears</a>.</p>
        <section id="neg-notexists">
          <h4>Testing For the Absence of a Pattern</h4>
          <p>The <code>NOT EXISTS</code> filter expression tests whether a graph pattern does not
            match the dataset, given the values of variables in the group graph pattern in which the
            filter occurs. It does not generate any additional bindings.</p>
          <div class="exampleGroup">
            <p>Data:</p>
            <pre class="data nohighlight">
@prefix  :       &lt;http://example/&gt; .
@prefix  rdf:    &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .
@prefix  foaf:   &lt;http://xmlns.com/foaf/0.1/&gt; .

:alice  rdf:type   foaf:Person .
:alice  foaf:name  "Alice" .
:bob    rdf:type   foaf:Person .
     </pre>
            <p>Query:</p>
            <div class="queryGroup">
              <pre class="query nohighlight">
PREFIX  rdf:    &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; 
PREFIX  foaf:   &lt;http://xmlns.com/foaf/0.1/&gt; 

SELECT ?person
WHERE 
{
    ?person rdf:type  foaf:Person .
    FILTER NOT EXISTS { ?person foaf:name ?name }
}
</pre>
              <p>Query Result:</p>
              <div class="result">
                <table class="resultTable">
                  <tbody>
                    <tr>
                      <th>person</th>
                    </tr>
                    <tr>
                      <td>&lt;http://example/bob&gt;</td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
          </div>
        </section>
        <section id="neg-exists">
          <h4>Testing For the Presence of a Pattern</h4>
          <p>The filter expression <code>EXISTS</code> is also provided. It tests whether the pattern
            can be found in the data; it does not generate any additional bindings.</p>
          <div class="exampleGroup">
            <p>Query:</p>
            <div class="queryGroup">
              <pre class="query nohighlight">
PREFIX  rdf:    &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; 
PREFIX  foaf:   &lt;http://xmlns.com/foaf/0.1/&gt; 

SELECT ?person
WHERE {
    ?person rdf:type  foaf:Person .
    FILTER EXISTS { ?person foaf:name ?name }
}
</pre>
              <p>Query Result:</p>
              <div class="result">
                <table class="resultTable">
                  <tbody>
                    <tr>
                      <th>person</th>
                    </tr>
                    <tr>
                      <td>&lt;http://example/alice&gt;</td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
          </div>
        </section>
      </section>
      <section id="neg-minus">
        <h3>Removing Possible Solutions</h3>
        <p>The other style of negation provided in SPARQL is <code>MINUS</code> which evaluates both
          its arguments, then calculates solutions in the left-hand side that are not compatible with
          the solutions on the right-hand side.</p>
        <div class="exampleGroup">
          Data:
          <pre class="data nohighlight">
@prefix :       &lt;http://example/&gt; .
@prefix foaf:   &lt;http://xmlns.com/foaf/0.1/&gt; .

:alice  foaf:givenName "Alice" ;
        foaf:familyName "Smith" .

:bob    foaf:givenName "Bob" ;
        foaf:familyName "Jones" .

:carol  foaf:givenName "Carol" ;
        foaf:familyName "Smith" .
</pre>
          <div class="queryGroup">
            Query:
            <pre class="query nohighlight">
PREFIX :       &lt;http://example/&gt;
PREFIX foaf:   &lt;http://xmlns.com/foaf/0.1/&gt;

SELECT DISTINCT ?s
WHERE {
    ?s ?p ?o .
    MINUS {
        ?s foaf:givenName "Bob" .
    }
}</pre>
            <p>Results:</p>
            <div class="result">
              <table class="resultTable">
                <tbody>
                  <tr>
                    <th>s</th>
                  </tr>
                  <tr>
                    <td>&lt;http://example/carol&gt;</td>
                  </tr>
                  <tr>
                    <td>&lt;http://example/alice&gt;</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>
      </section>
      <section id="neg-notexists-minus">
        <h3>Relationship and differences between NOT EXISTS and MINUS</h3>
        <p><code>NOT EXISTS</code> and <code>MINUS</code> represent two ways of thinking about
          negation, one based on testing whether a pattern exists in the data, given the bindings
          already determined by the query pattern, and one based on removing matches based on the
          evaluation of two patterns. In some cases they can produce different answers.</p>
        <section id="neg-example-1">
          <h4>Example: Sharing of variables</h4>
          <pre class="data nohighlight">
@prefix : &lt;http://example/&gt; .
:a :b :c .
</pre>
          <pre class="query nohighlight">
SELECT * { 
    ?s ?p ?o
    FILTER NOT EXISTS { ?x ?y ?z }
}</pre>
          <p>evaluates to a result set with no solutions because <code>{ ?x ?y ?z }</code> matches
            given any <code>?s ?p ?o</code>, so <code>NOT EXISTS { ?x ?y ?z }</code> eliminates any
            solutions.</p>
          <div class="result">
            <table class="resultTable">
              <tbody>
                <tr>
                  <th>s</th>
                  <th>p</th>
                  <th>o</th>
                </tr>
              </tbody>
            </table>
          </div>
          <p>whereas with <code>MINUS</code>, there is no shared variable between the first part
            (<code>?s ?p ?o</code>) and the second (<code>?x ?y ?z</code>) so no bindings are
            eliminated.</p>
          <pre class="query nohighlight">
SELECT * { 
    ?s ?p ?o 
    MINUS 
    { ?x ?y ?z }
}</pre>
          <p>Results:</p>
          <div class="result">
            <table class="resultTable">
              <tbody>
                <tr>
                  <th>s</th>
                  <th>p</th>
                  <th>o</th>
                </tr>
                <tr>
                  <td>&lt;http://example/a&gt;</td>
                  <td>&lt;http://example/b&gt;</td>
                  <td>&lt;http://example/c&gt;</td>
                </tr>
              </tbody>
            </table>
          </div>
        </section>
        <section id="neg-example-2">
          <h4>Example: Fixed pattern</h4>
          <p>Another case is where there is a concrete pattern (no variables) in the example:</p>
          <pre class="query nohighlight">
PREFIX : &lt;http://example/&gt;
SELECT * {  
    ?s ?p ?o 
    FILTER NOT EXISTS { :a :b :c }
}
</pre>
          <p>evaluates to a result set with no query solutions:</p>Results:
          <div class="result">
            <table class="resultTable">
              <tbody>
                <tr>
                  <th>s</th>
                  <th>p</th>
                  <th>o</th>
                </tr>
              </tbody>
            </table>
          </div>
          <p>whereas</p>
          <pre class="query nohighlight">
PREFIX : &lt;http://example/&gt;
SELECT * 
{ 
    ?s ?p ?o 
    MINUS { :a :b :c }
}
</pre>
          <p>evaluates to result set with one query solution:</p>
          <p>Results:</p>
          <div class="result">
            <table class="resultTable">
              <tbody>
                <tr>
                  <th>s</th>
                  <th>p</th>
                  <th>o</th>
                </tr>
                <tr>
                  <td>&lt;http://example/a&gt;</td>
                  <td>&lt;http://example/b&gt;</td>
                  <td>&lt;http://example/c&gt;</td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>because there is no match of bindings and so no solutions are eliminated.</p>
        </section>
        <section id="idp899488">
          <h4>Example: Inner FILTERs</h4>
          <p>Differences also arise because in a filter, variables from the group
            are <a href="#scopeFilters">in scope</a>. 
            In this example, the <code>FILTER</code> inside the 
            <code>NOT EXISTS</code> has access to the value of <code>?n</code> for the solution being considered.</p>
          <pre class="data nohighlight">
@prefix : &lt;http://example.com/&gt; .
:a :p 1 .
:a :q 1 .
:a :q 2 .

:b :p 3.0 .
:b :q 4.0 .
:b :q 5.0 .
</pre>
          <p>When using <code>FILTER NOT EXISTS</code>, the test is on each possible solution to
            <code>?x :p ?n</code>:</p>
          <pre class="query nohighlight">
PREFIX : &lt;http://example.com/&gt;
SELECT * WHERE {
    ?x :p ?n
    FILTER NOT EXISTS {
        ?x :q ?m .
        FILTER(?n = ?m)
    }
}</pre>
          <div class="result">
            <table class="resultTable">
              <tbody>
                <tr>
                  <th>x</th>
                  <th>n</th>
                </tr>
                <tr>
                  <td>&lt;http://example.com/b&gt;</td>
                  <td>3.0</td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>whereas with <code>MINUS</code>, the <code>FILTER</code> inside the pattern does not
            have a value for ?n and it is always unbound:</p>
          <pre class="query nohighlight">
PREFIX : &lt;http://example/&gt;
SELECT * WHERE {
    ?x :p ?n
    MINUS {
        ?x :q ?m .
        FILTER(?n = ?m)
    }
}</pre>
          <div class="result">
            <table class="resultTable">
              <tbody>
                <tr>
                  <th>x</th>
                  <th>n</th>
                </tr>
                <tr>
                  <td>&lt;http://example.com/b&gt;</td>
                  <td>3.0</td>
                </tr>
                <tr>
                  <td>&lt;http://example.com/a&gt;</td>
                  <td>1</td>
                </tr>
              </tbody>
            </table>
          </div>
        </section>
      </section>
    </section>
    <section id="propertypaths">
      <h2>Property Paths</h2>
      <p>A property path is a possible route through a graph between two graph nodes. A trivial case
        is a property path of length exactly 1, which is a triple pattern. The ends of the path may be
        RDF terms or variables. Variables can not be used as part of the path itself, only the
        ends.</p>
      <p>Property paths allow for more concise expressions for some SPARQL basic graph patterns and
        they also add the ability to match connectivity of two resources by an arbitrary length
        path.</p>
      <section id="pp-language">
        <h3>Property Path Syntax</h3>
        <p>In the description below, <i><code>iri</code></i> is either <a href="#QSynIRI">an IRI written
            in full or abbreviated by a prefixed name</a>, or the keyword <code>a</code>. <i><code>elt</code></i>
          is a path element, which may itself be composed of path constructs.</p>
        <table style="border-spacing: 0; border-width: 1px">
          <tbody>
            <tr>
              <th>Syntax Form</th>
              <th>Property Path Expression Name</th>
              <th>Matches</th>
            </tr>
            <tr>
              <td><code><i>iri</i></code></td>
              <td>PredicatePath</td>
              <td>An IRI. A path of length one.</td>
            </tr>
            <tr>
              <td><code>^<i>elt</i></code></td>
              <td>InversePath</td>
              <td>Inverse path (object to subject).</td>
            </tr>
            <tr>
              <td><code><i>elt1</i> / <i>elt2</i></code></td>
              <td>SequencePath</td>
              <td>A sequence path of <code><i>elt1</i></code> followed by <code><i>elt2</i></code>.</td>
            </tr>
            <tr>
              <td><code><i>elt1</i> | <i>elt2</i></code></td>
              <td>AlternativePath</td>
              <td>A alternative path of <code><i>elt1</i></code> or <code><i>elt2</i></code> (all
                possibilities are tried).</td>
            </tr>
            <tr>
              <td><code><i>elt</i>*</code></td>
              <td>ZeroOrMorePath</td>
              <td>A path that connects the subject and object of the path by zero or more matches of
                <code><i>elt</i></code>.</td>
            </tr>
            <tr>
              <td><code><i>elt</i>+</code></td>
              <td>OneOrMorePath</td>
              <td>A path that connects the subject and object of the path by one or more matches of
                <code><i>elt</i></code>.</td>
            </tr>
            <tr>
              <td><code><i>elt</i>?</code></td>
              <td>ZeroOrOnePath</td>
              <td>A path that connects the subject and object of the path by zero or one matches of
                <code><i>elt</i></code>.</td>
            </tr>
            <tr>
              <td><code>!<i>iri</i></code> or <code>!(<i>iri<sub>1</sub></i>|
                  ...|<i>iri<sub>n</sub></i>)</code></td>
              <td>NegatedPropertySet</td>
              <td>Negated property set. An IRI which is not one of <code><i>iri<sub>i</sub></i></code>.
                <code>!<i>iri</i></code> is short for <code>!<i>(iri)</i></code>.</td>
            </tr>
            <tr>
              <td><code>!^<i>iri</i></code> or <code>!(^<i>iri<sub>1</sub></i>|
                  ...|^<i>iri<sub>n</sub></i>)</code></td>
              <td>NegatedPropertySet</td>
              <td>Negated property set where the excluded matches are based on reversed path.<br>
                That is, not one of <i>iri<sub>1</sub></i>...<i>iri<sub>n</sub></i> as reverse paths.
                <code>!^<i>iri</i></code> is short for <code>!(^<i>iri</i>)</code>.</td>
            </tr>
            <tr>
              <td><code>!(<i>iri<sub>1</sub></i>| ...|<i>iri<sub>j</sub></i>|^<i>iri<sub>j+1</sub></i>|
                  ...|^<i>iri<sub>n</sub></i>)</code></td>
              <td>NegatedPropertySet</td>
              <td>A combination of forward and reverse properties in a negated property set.</td>
            </tr>
            <tr>
              <td><code>(<i>elt</i>)</code></td>
              <td>&nbsp;</td>
              <td>A group path <code><i>elt</i></code>, brackets control precedence.</td>
            </tr>
          </tbody>
        </table>
        <p>The order of IRIs, and reverse IRIs, in a negated property set is not significant and they
          can occur in a mixed order.</p>
        <p>The precedence of the syntax forms is, from highest to lowest:</p>
        <ul>
          <li>IRI, prefixed names</li>
          <li>Negated property sets</li>
          <li>Groups</li>
          <li>Unary operators <code>*</code>, <code>?</code> and <code>+</code></li>
          <li>Unary ^ inverse links</li>
          <li>Binary operator <code>/</code></li>
          <li>Binary operator <code>|</code></li>
        </ul>
        <p>Precedence is left-to-right within groups.</p>
      </section>
      <section id="propertypath-examples">
        <h3>Examples</h3>
        <p><i>Alternatives</i>: Match one or both possibilities</p>
        <pre class="query nohighlight">  
{ :book1 dc:title|rdfs:label ?displayString }
</pre>
        <p>which could have written:</p>
        <pre class="query nohighlight">
{ 
   :book1 &lt;http://purl.org/dc/elements/1.1/title&gt; | &lt;http://www.w3.org/2000/01/rdf-schema#label&gt; ?displayString
}
        </pre>
        <p><i>Sequence</i>: Find the name of any people that Alice knows.</p>
        <pre class="query nohighlight">
{
    ?x foaf:mbox &lt;mailto:alice@example&gt; .
    ?x foaf:knows/foaf:name ?name .
}</pre>
        <p><i>Sequence</i>: Find the names of people 2 "<code>foaf:knows</code>" links away.</p>
        <pre class="query nohighlight">
{ 
    ?x foaf:mbox &lt;mailto:alice@example&gt; .
    ?x foaf:knows/foaf:knows/foaf:name ?name .
}</pre>
        <p>This is the same as the SPARQL query:</p>
        <pre class="query nohighlight">  
SELECT ?x ?name {
    ?x  foaf:mbox &lt;mailto:alice@example&gt; .
    ?x  foaf:knows [ foaf:knows [ foaf:name ?name ]]. 
}
</pre>
        <p>or, with explicit variables:</p>
        <pre class="query nohighlight">
SELECT ?x ?name {
    ?x  foaf:mbox &lt;mailto:alice@example&gt; .
    ?x  foaf:knows ?a1 .
    ?a1 foaf:knows ?a2 .
    ?a2 foaf:name ?name .
}
</pre>
        <p><i>Filtering duplicates</i>: Because someone Alice knows may well know Alice, the example
          above may include Alice herself. This could be avoided with:</p>
        <pre class="query nohighlight"> 
 { ?x foaf:mbox &lt;mailto:alice@example&gt; .
   ?x foaf:knows/foaf:knows ?y .
   FILTER ( ?x != ?y )
   ?y foaf:name ?name 
 }</pre>
        <p><i>Inverse Property Paths</i>: These two are the same query: the second is just reversing
          the property direction which swaps the roles of subject and object.</p>
        <pre class="query nohighlight">
{ ?x foaf:mbox &lt;mailto:alice@example&gt; }
        </pre>
        <pre class="query nohighlight">
{ &lt;mailto:alice@example&gt; ^foaf:mbox ?x }
        </pre>
        <p><i>Inverse Path Sequence</i>: Find all the people who know someone <code>?x</code> knows.</p>
        <pre class="query nohighlight">
{
  ?x foaf:knows/^foaf:knows ?y .  
  FILTER(?x != ?y)
}
</pre>
        <p>which is equivalent to (<code>?gen1</code> is a system generated variable):</p>
        <pre class="query nohighlight"> 
{
  ?x foaf:knows ?gen1 .
  ?y foaf:knows ?gen1 .  
  FILTER(?x != ?y)
}
</pre>
        <p><i>Arbitrary length match</i>: Find the names of all the people that can be reached from
          Alice by <code>foaf:knows</code>:</p>
        <pre class="query nohighlight">
{
  ?x foaf:mbox &lt;mailto:alice@example&gt; .
  ?x foaf:knows+/foaf:name ?name .
}
</pre>
        <p><i>Alternatives in an arbitrary length path</i>:</p>
        <pre class="query nohighlight">
{ ?ancestor (ex:motherOf|ex:fatherOf)+ &lt;#me&gt; }
</pre>
        <p><i>Arbitrary length path match</i>: Some forms of limited inference are possible as well.
          For example, for RDFS, all types and supertypes of a resource:</p>
        <pre class="query nohighlight">
{ &lt;http://example/thing&gt; rdf:type/rdfs:subClassOf* ?type }
        </pre>
        <p>All resources and all their inferred types:</p>
        <pre class="query nohighlight">
{ ?x rdf:type/rdfs:subClassOf* ?type }
        </pre>
        <p><i>Subproperty</i>:</p>
        <pre class="query nohighlight">
{ ?x ?p ?v . ?p rdfs:subPropertyOf* :property }
        </pre>
        <p><i>Negated Property Paths</i>: Find nodes connected but not by rdf:type (either way
          round):</p>
        <pre class="query nohighlight"> 
{ ?x !(rdf:type|^rdf:type) ?y }
</pre>
        <p><i>Elements in an RDF collection</i>:</p>
        <pre class="query nohighlight">
{ :list rdf:rest*/rdf:first ?element }
</pre>
        <p><i>Note: This path expression does not guarantee the order of the results.</i></p>
      </section>
      <section id="propertypath-syntaxforms">
        <h3>Property Paths and Equivalent Patterns</h3>
        <p>SPARQL property paths treat the RDF triples as a directed, possibly cyclic, graph with
          named edges. Evaluation of a property path expression can lead to duplicates because any
          variables introduced in the equivalent pattern are not part of the results and are not
          already used elsewhere. They are hidden by implicit projection of the results to just the
          variables given in the query.</p>
        <p>For example, on the data:</p>
        <pre class="data nohighlight">
@prefix :       &lt;http://example/&gt; .

:order  :item :z1 .
:order  :item :z2 .

:z1 :name "Small" .
:z1 :price 5 .

:z2 :name "Large" .
:z2 :price 5 .
        </pre>
        <p>Query:</p>
        <pre class="query nohighlight">
PREFIX :   &lt;http://example/&gt;
SELECT * 
{  ?s :item/:price ?x . }
</pre>
        <p>Results:</p>
        <div class="result">
          <table class="resultTable">
            <tbody>
              <tr>
                <th>s</th>
                <th>x</th>
              </tr>
              <tr>
                <td>&lt;http://example/order&gt;</td>
                <td>5</td>
              </tr>
              <tr>
                <td>&lt;http://example/order&gt;</td>
                <td>5</td>
              </tr>
            </tbody>
          </table>
        </div>
        <p>whereas if the query were written out to include the intermediate variable
          (<code>?_a</code>), no rows in the results are duplicates:</p>
        <pre class="query nohighlight">
PREFIX :   &lt;http://example/&gt;
SELECT * 
{  ?s :item ?_a .
   ?_a :price ?x .
}</pre>
        <p>Results:</p>
        <div class="result">
          <table class="resultTable">
            <tbody>
              <tr>
                <th>s</th>
                <th>_a</th>
                <th>x</th>
              </tr>
              <tr>
                <td>&lt;http://example/order&gt;</td>
                <td>&lt;http://example/z1&gt;</td>
                <td>5</td>
              </tr>
              <tr>
                <td>&lt;http://example/order&gt;</td>
                <td>&lt;http://example/z2&gt;</td>
                <td>5</td>
              </tr>
            </tbody>
          </table>
        </div>
        <p>The equivalence to graphs patterns is particularly significant when query also involves an
          aggregation operation. The total cost of the order can be found with</p>
        <pre class="query nohighlight">
PREFIX :   &lt;http://example/&gt;
SELECT (sum(?x) AS ?total) { 
    :order :item/:price ?x
}
        </pre>
        <div class="result">
          <table class="resultTable">
            <tbody>
              <tr>
                <th>total</th>
              </tr>
              <tr>
                <td>10</td>
              </tr>
            </tbody>
          </table>
        </div>
      </section>
      <section id="propertypath-arbitrary-length">
        <h3>Arbitrary Length Path Matching</h3>
        <p>Connectivity between the subject and object by a property path of arbitrary length can be
          found using the "zero or more" property path operator, <code>*</code>, and the "one or more"
          property path operator, <code>+</code>. There is also a "zero or one" connectivity property
          path operator, <code>?</code>.</p>
        <p>Each of these operators uses the property path expression to try to find a connection
          between subject and object, using the path step a number of times, as restricted by the
          operator.</p>
        <p>For example, finding all the the possible types of a resource, including supertypes of
          resources, can be achieved with:</p>
        <pre class="query nohighlight">
PREFIX  rdfs:   &lt;http://www.w3.org/2000/01/rdf-schema#&gt; . 
PREFIX  rdf:    &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;
SELECT ?x ?type
{ 
    ?x rdf:type/rdfs:subClassOf* ?type
}</pre>
        <p>Similarly, finding all the people <code>:x</code> connects to via the
          <code>foaf:knows</code> relationship,</p>
        <pre class="query nohighlight">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX :     &lt;http://example/&gt;
SELECT ?person
{ 
    :x foaf:knows+ ?person
}
        </pre>
        <p>Such connectivity matching does not introduce duplicates (it does not incorporate any
          count of the number of ways the connection can be made) even if the repeated path itself
          would otherwise result in duplicates.</p>
        <p>The graph matched may include cycles. Connectivity matching is defined so that matching
          cycles does not lead to undefined or infinite results.</p>
      </section>
    </section>
    <section id="assignment">
      <h2>Assignment</h2>
      <p>The value of an expression can be added to a solution mapping by binding a new variable to
        the value of the expression, which is an RDF term. The variable can then be used in the query
        and also can be returned in results.</p>
      <p>Three syntax forms allow this: the <a href="#assignment"><code>BIND</code> keyword</a>,
        <a href="#selectExpressions">expressions in the <code>SELECT</code> clause</a> and
        <a href="#groupby">expressions in the <code>GROUP BY</code> clause</a>. The assignment form is
        <code>(<i>expression</i> AS ?var)</code>.</p>
      <p>If the evaluation of the expression produces an error, the variable remains unbound for that
        solution but the query evaluation continues.</p>
      <p>Data can also be directly included in a query using
        <a href="#inline-data"><code>VALUES</code></a> for inline data.</p>
      <section id="bind">
        <h3>BIND: Assigning to Variables</h3>
        <p>The <code>BIND</code> form allows a value to be assigned to a variable from a basic graph
          pattern or property path expression. Use of <code>BIND</code> ends the preceding basic graph
          pattern. The variable introduced by the <code>BIND</code> clause must not have been used in
          the group graph pattern up to the point of use in <code>BIND</code>.</p>
        <p>Example:</p>
        <div class="exampleGroup">
          <p>Data:</p>
          <pre class="data nohighlight">
@prefix dc:   &lt;http://purl.org/dc/elements/1.1/&gt; .
@prefix :     &lt;http://example.org/book/&gt; .
@prefix ns:   &lt;http://example.org/ns#&gt; .

:book1  dc:title     "SPARQL Tutorial" .
:book1  ns:price     42 .
:book1  ns:discount  0.2 .

:book2  dc:title     "The Semantic Web" .
:book2  ns:price     23 .
:book2  ns:discount  0.25 .
</pre>
          <p>Query:</p>
          <pre class="query nohighlight">
PREFIX  dc:  &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX  ns:  &lt;http://example.org/ns#&gt;

SELECT  ?title ?price
{   
    ?x ns:price ?p .
    ?x ns:discount ?discount
    BIND (?p*(1-?discount) AS ?price)
    FILTER(?price &lt; 20)
    ?x dc:title ?title . 
}
</pre>
          <p>Equivalent query (<code>BIND</code> ends the basic graph pattern; the
            <code>FILTER</code> applies to the whole group graph pattern):</p>
          <pre class="query nohighlight">
PREFIX  dc:  &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX  ns:  &lt;http://example.org/ns#&gt;

SELECT  ?title ?price
{  { ?x ns:price ?p .
     ?x ns:discount ?discount
     BIND (?p*(1-?discount) AS ?price)
    }
    {?x dc:title ?title . }
    FILTER(?price &lt; 20)
}</pre>
          <p>Results:</p>
          <div class="result">
            <table class="resultTable">
              <tbody>
                <tr>
                  <th>title</th>
                  <th>price</th>
                </tr>
                <tr>
                  <td>&nbsp;"The Semantic Web"</td>
                  <td>17.25</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
      </section>
      <section id="inline-data">
        <h3>VALUES: Providing inline data</h3>
        <p>Data can be directly written in a graph pattern or added to a query using
          <code>VALUES</code>. <code>VALUES</code> provides inline data as a 
          <a href="#defn_sparqlSolutionSequence">solution sequence</a> which are combined with the results of
          query evaluation by a <a href="#defn_algJoin">join</a> operation. It can be used by an
          application to provide specific requirements on query results and also by SPARQL query engine
          implementations that provide <a href="#basic-federated-query">federated query</a> through the
          <code>SERVICE</code> keyword to send a more constrained query to a remote query service.</p>
        <section id="inline-data-syntax">
          <h4>VALUES syntax</h4>
          <p><code>VALUES</code> allows multiple variables to be specified in the data block; there
            is a special syntax for the common case of specifying just one variable and some
            values.</p>
          <p>In the following example, there is a table of two variables, <code>?x</code> and
            <code>?y</code>. The second row has no value for <code>?y</code>.</p>
          <pre class="data nohighlight">
VALUES (?x ?y) {
    (:uri1 1)
    (:uri2 UNDEF)
}
          </pre>
          <p>Optionally, when there is a single variable and some values:</p>
          <pre class="data nohighlight">
VALUES ?z { "abc" "def" }
          </pre>
          <p>which is the same as using the general form:</p>
          <pre class="data nohighlight">
            VALUES (?z) { ("abc") ("def") }
          </pre>
        </section>
        <section id="inline-data-examples">
          <h4>VALUES Examples</h4>
          <p>A <code>VALUES</code> block of data can appear in a query pattern or at the end of a
            <code>SELECT</code> query, including a <a href="#subqueries">subquery</a>.</p>
          <div class="exampleGroup">
            <p>Data:</p>
            <pre class="data nohighlight">
@prefix dc:   &lt;http://purl.org/dc/elements/1.1/&gt; .
@prefix :     &lt;http://example.org/book/&gt; .
@prefix ns:   &lt;http://example.org/ns#&gt; .

:book1  dc:title  "SPARQL Tutorial" .
:book1  ns:price  42 .
:book2  dc:title  "The Semantic Web" .
:book2  ns:price  23 .
            </pre>
            <p>Query:</p>
            <pre class="query nohighlight">
PREFIX dc:   &lt;http://purl.org/dc/elements/1.1/&gt; 
PREFIX :     &lt;http://example.org/book/&gt; 
PREFIX ns:   &lt;http://example.org/ns#&gt; 

SELECT ?book ?title ?price
{
    VALUES ?book { :book1 :book3 }
    ?book dc:title ?title ;
          ns:price ?price .
}
            </pre>
            <p>Result:</p>
            <div class="result">
              <div id="table110"></div>
              <table class="resultTable">
                <tbody>
                  <tr>
                    <th>book</th>
                    <th>title</th>
                    <th>price</th>
                  </tr>
                  <tr>
                    <td>&lt;http://example.org/book/book1&gt;</td>
                    <td>"SPARQL Tutorial"</td>
                    <td>42</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
          <p>If a variable has no value for a particular solution in the <code>VALUES</code> clause,
            the keyword <code>UNDEF</code> is used instead of an RDF term.</p>
          <pre class="query nohighlight">
PREFIX dc:   &lt;http://purl.org/dc/elements/1.1/&gt; 
PREFIX :     &lt;http://example.org/book/&gt; 
PREFIX ns:   &lt;http://example.org/ns#&gt; 

SELECT ?book ?title ?price
{
    ?book dc:title ?title ;
          ns:price ?price .
    VALUES (?book ?title) {
        (UNDEF "SPARQL Tutorial")
        (:book2 UNDEF)
    }
}
          </pre>
          <div class="result">
            <div id="table111"></div>
            <table class="resultTable">
              <tbody>
                <tr>
                  <th>book</th>
                  <th>title</th>
                  <th>price</th>
                </tr>
                <tr>
                  <td>&lt;http://example.org/book/book1&gt;</td>
                  <td>"SPARQL Tutorial"</td>
                  <td>42</td>
                </tr>
                <tr>
                  <td>&lt;http://example.org/book/book2&gt;</td>
                  <td>"The Semantic Web"</td>
                  <td>23</td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>In this example, the <code>VALUES</code> might have been specified to execute over the
            results of the <code>SELECT</code> query:</p>
          <pre class="query nohighlight">
PREFIX dc:   &lt;http://purl.org/dc/elements/1.1/&gt; 
PREFIX :     &lt;http://example.org/book/&gt; 
PREFIX ns:   &lt;http://example.org/ns#&gt; 

SELECT ?book ?title ?price {
    ?book dc:title ?title ;
          ns:price ?price .
}
VALUES (?book ?title) {
    (UNDEF "SPARQL Tutorial")
    (:book2 UNDEF)
}
          </pre>
          <p>This is a different query but, in the example situation, has the same results.</p>
        </section>
      </section>
    </section>
    <section id="aggregates">
      <h2>Aggregates</h2>
      <p>Aggregates apply expressions over groups of solutions. By default a solution set consists of
        a single group, containing all solutions.</p>
      <p>Grouping may be specified using the <code>GROUP BY</code> syntax.</p>
      <p>Aggregates defined in version 1.1 of SPARQL are <code>COUNT</code>, <code>SUM</code>,
        <code>MIN</code>, <code>MAX</code>, <code>AVG</code>, <code>GROUP_CONCAT</code>, and
        <code>SAMPLE</code>.</p>
      <p>Aggregates are used where the querier wishes to see a result which is computed over a group
        of solutions, rather than a single solution. For example the maximum value that a particular
        variable takes, rather than each value individually.</p>
      <section id="aggregateExample">
        <h3>Aggregate Example</h3>
        <div class="exampleGroup">
          <p>Data:</p>
          <pre class="data nohighlight">
@prefix : &lt;http://books.example/&gt; .

:org1 :affiliates :auth1, :auth2 .
:auth1 :writesBook :book1, :book2 .
:book1 :price 9 .
:book2 :price 5 .
:auth2 :writesBook :book3 .
:book3 :price 7 .
:org2 :affiliates :auth3 .
:auth3 :writesBook :book4 .
:book4 :price 7 .
</pre>
          <p>Query:</p>
          <pre class="query nohighlight">
PREFIX : &lt;http://books.example/&gt;
SELECT (SUM(?lprice) AS ?totalPrice)
WHERE {
    ?org :affiliates ?auth .
    ?auth :writesBook ?book .
    ?book :price ?lprice .
}
GROUP BY ?org
HAVING (SUM(?lprice) &gt; 10)
          </pre>
          <p>Results:</p>
          <div class="result">
            <table class="resultTable">
              <tbody>
                <tr>
                  <th>totalPrice</th>
                </tr>
                <tr>
                  <td>21</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
        <p>This example demonstrates two features of aggregates: <code>GROUP BY</code>, which groups
          query solutions according to one or more expressions (in this case <code>?org</code>), and
          <code>HAVING</code>, which is analogous to a <code>FILTER</code> expression, but operates
          over groups, rather than individual solutions.</p>
        <p>The example is produced by grouping solutions according to the <code>GROUP BY</code>
          expression (i.e. all solutions where <code>?org</code> takes a particular value appear within
          the same group), and evaluating the Set Function <code>SUM</code> over that group. The groups
          are then filtered by the <code>HAVING</code> expression, which removes all groups where
          <code>SUM(?lprice)</code> is not greater than 10.</p>
        <p>In aggregate queries and sub-queries, variables that appear in the query pattern, but are
          not in the <code>GROUP BY</code> clause, can only be projected or used in select expressions
          if they are aggregated. The <code>SAMPLE</code> aggregate may be used for this purpose. For
          details see the section on <a href="#aggregateRestrictions">Projection Restrictions</a>.</p>
        <p>It should be noted that <a href="#selectExpressions">as per functions</a>, aggregate
          expressions are required to be aliased (again, similar to the <code>BIND</code> clause, using
          the keyword <code>AS</code>) in order to project them from queries or subqueries. In the
          example above this is done using the variable <code>?totalPrice</code>. It is an error for
          aggregates to project variables with a name already used in other aggregate projections, or
          in the <code>WHERE</code> clause.</p>
      </section>
      <section id="groupby">
        <h3>GROUP BY</h3>
        <p>In order to calculate aggregate values for a solution, the solution is first divided into
          one or more groups, and the aggregate value is calculated for each group.</p>
        <p>If aggregates are used in the query level in <code>SELECT</code>, <code>HAVING</code> or
          <code>ORDER BY</code> but the <code>GROUP BY</code> term is not used, then this is taken to
          be a single implicit group, to which all solutions belong.</p>
        <p>Within <code>GROUP BY</code> clauses the binding keyword, <code>AS</code>, may be used,
          such as <code>GROUP BY (?x + ?y AS ?z)</code>. This is equivalent to 
          <code>{ ... BIND (?x + ?y AS ?z) } GROUP BY ?z</code>.</p>
        <p>For example, given a solution sequence <code>S</code>, <code>( {?x→2, ?y→3}, {?x→2, ?y→5}, {?x→6, ?y→7} )</code>, we
          might wish to group the solutions according to the value of <code>?x</code>, and calculate the average of
          the values of <code>?y</code> for each group.</p>
        <p>This could be written as:</p>
        <pre class="query nohighlight">
SELECT (AVG(?y) AS ?avg)
WHERE {
    ?a :x ?x ;
    :y ?y .
}
GROUP BY ?x
        </pre>
      </section>
      <section id="having">
        <h3>HAVING</h3>
        <p><code>HAVING</code> operates over grouped solution sets, in the same way that
          <code>FILTER</code> operates over un-grouped ones.</p>
        <p><code>HAVING</code> expressions have the same evaluation rules as projections from grouped
          queries, as described in the following section.</p>
        <p>An example of the use of <code>HAVING</code> is given below.</p>
        <pre class="query nohighlight">
PREFIX : &lt;http://data.example/&gt;
SELECT (AVG(?size) AS ?asize)
WHERE {
    ?x :size ?size
}
GROUP BY ?x
HAVING(AVG(?size) &gt; 10)
        </pre>
        <p>This will return average sizes, grouped by the subject, but only where the mean size is
          greater than 10.</p>
      </section>
      <section id="aggregateRestrictions">
        <h3>Aggregate Projection Restrictions</h3>
        <p>In a query level which uses aggregates, only expressions consisting of aggregates and
          constants may be projected, with one exception. When <code>GROUP BY</code> is given with one
          or more simple expressions consisting of just a variable, those variables may be projected
          from the level.</p>
        <p>For example, the following query is legal as ?x is given as a <code>GROUP BY</code>
          term.</p>
        <pre class="query nohighlight">
PREFIX : &lt;http://example.com/data/#&gt;
SELECT ?x (MIN(?y) * 2 AS ?min)
WHERE {
    ?x :p ?y .
    ?x :q ?z .
} GROUP BY ?x (STR(?z))
        </pre>
        <p>Note that it would not be legal to project <code>STR(?z)</code> as this is not a simple
          variable expression. However, with <code>GROUP BY (STR(?z) AS ?strZ)</code> it would be
          possible to project <code>?strZ</code>.</p>
        <p>Other expressions, not using <code>GROUP BY</code> variables, or aggregates may have
          non-deterministic values projected from their groups using the <code>SAMPLE</code>
          aggregate.</p>
      </section>
      <section id="aggregateExample2">
        <h3>Aggregate Example (with errors)</h3>
        <p>This section shows an example query using aggregation, which demonstrates how errors are
          handled in results, in the presence of aggregates.</p>
        <p>Data:</p>
        <pre class="data nohighlight">
@prefix : &lt;http://example.com/data/#&gt; .

:x :p 1, 2, 3, 4 .
:y :p 1, _:b2, 3, 4 .
:z :p 1.0, 2.0, 3.0, 4 .
        </pre>
        <p>Query:</p>
        <pre class="query nohighlight">
PREFIX : &lt;http://example.com/data/#&gt;
SELECT ?g (AVG(?p) AS ?avg) ((MIN(?p) + MAX(?p)) / 2 AS ?c)
WHERE {
    ?g :p ?p .
}
GROUP BY ?g</pre>
        <p>Result:</p>
        <div class="result">
          <table class="resultTable">
            <tbody>
              <tr>
                <th>g</th>
                <th>avg</th>
                <th>c</th>
              </tr>
              <tr>
                <td>&lt;http://example.com/data/#x&gt;</td>
                <td>2.5</td>
                <td>2.5</td>
              </tr>
              <tr>
                <td>&lt;http://example.com/data/#y&gt;</td>
                <td></td>
                <td></td>
              </tr>
              <tr>
                <td>&lt;http://example.com/data/#z&gt;</td>
                <td>2.5</td>
                <td>2.5</td>
              </tr>
            </tbody>
          </table>
        </div>
        <p>Note that the bindings for the :y group is not included in the results as the evaluation
          of Avg({1, _:b2, 3, 4}), and (_:b2 + 4) / 2 is an error, removing the bindings from the
          solution.</p>
      </section>
    </section>
    <section id="subqueries">
      <h2>Subqueries</h2>
      <p>Subqueries are a way to embed SPARQL queries within other queries, normally to achieve
        results which cannot otherwise be achieved, such as limiting the number of results from some
        sub-expression within the query.</p>
      <p>Due to the bottom-up nature of SPARQL query evaluation, the subqueries are evaluated
        logically first, and the results are projected up to the outer query.</p>
      <p>Note that only variables projected out of the subquery will be visible, or
        <a href="#variableScope">in scope</a>, to the outer query.</p>
      <h3 id="subquery-example">Example</h3>
      <p>Data:</p>
      <div class="exampleGroup">
        <pre class="data nohighlight">
@prefix : &lt;http://people.example/&gt; .

:alice :name "Alice", "Alice Foo", "A. Foo" .
:alice :knows :bob, :carol .
:bob :name "Bob", "Bob Bar", "B. Bar" .
:carol :name "Carol", "Carol Baz", "C. Baz" .
        </pre>
        <p>Return a name (the one with the lowest sort order) for all the people that know Alice and
          have a name.</p>
        <p>Query:</p>
        <pre class="query nohighlight">
PREFIX : &lt;http://people.example/&gt;
PREFIX : &lt;http://people.example/&gt;

SELECT ?y ?minName
WHERE {
    :alice :knows ?y .
    {
      SELECT ?y (MIN(?name) AS ?minName)
      WHERE {
          ?y :name ?name .
      } GROUP BY ?y
    }
}
        </pre>
      </div>
      <p>Results:</p>
      <div class="result">
        <table class="resultTable">
          <tbody>
            <tr>
              <th>y</th>
              <th>minName</th>
            </tr>
            <tr>
              <td>:bob</td>
              <td>"B. Bar"</td>
            </tr>
            <tr>
              <td>:carol</td>
              <td>"C. Baz"</td>
            </tr>
          </tbody>
        </table>
      </div>
      <p>This result is achieved by first evaluating the inner query:</p>
      <pre class="query nohighlight">
SELECT ?y (MIN(?name) AS ?minName)
WHERE {
    ?y :name ?name .
} GROUP BY ?y
</pre>
      <p>This produces the following solution sequence:</p>
      <div class="result">
        <table class="resultTable">
          <tbody>
            <tr>
              <th>y</th>
              <th>minName</th>
            </tr>
            <tr>
              <td>:alice</td>
              <td>"A. Foo"</td>
            </tr>
            <tr>
              <td>:bob</td>
              <td>"B. Bar"</td>
            </tr>
            <tr>
              <td>:carol</td>
              <td>"C. Baz"</td>
            </tr>
          </tbody>
        </table>
      </div>
      <p>Which is joined with the results of the outer query:</p>
      <div class="result">
        <table class="resultTable">
          <tbody>
            <tr>
              <th>y</th>
            </tr>
            <tr>
              <td>:bob</td>
            </tr>
            <tr>
              <td>:carol</td>
            </tr>
          </tbody>
        </table>
      </div>
    </section>
    <section id="rdfDataset">
      <h2>RDF Dataset</h2>
      <p>The RDF data model expresses information as graphs consisting of triples with subject,
        predicate and object. Many RDF data stores hold multiple RDF graphs and record information
        about each graph, allowing an application to make queries that involve information from more
        than one graph.</p>
      <p>A SPARQL query is executed against an <em>RDF Dataset</em> which represents a collection of
        graphs. An RDF Dataset comprises one graph, the default graph, which does not have a name, and
        zero or more named graphs, where each named graph is identified by an IRI. A SPARQL query can
        match different parts of the query pattern against different graphs as described in section
        <a href="#queryDataset">13.3 Querying the Dataset</a>.</p>
      <p>An RDF Dataset may contain zero named graphs; an RDF Dataset always contains one default
        graph. A query does not need to involve matching the default graph; the query can just involve
        matching named graphs.</p>
      <p>The graph that is used for matching a basic graph pattern is the <i>active graph</i>. In the
        previous sections, all queries have been shown executed against a single graph, the default
        graph of an RDF dataset as the active graph. The <code>GRAPH</code> keyword is used to make the
        active graph one of all of the named graphs in the dataset for part of the query.</p>
      <section id="exampleDatasets">
        <h3>Examples of RDF Datasets</h3>
        <p>The definition of RDF Dataset does not restrict the relationships of named and default
          graphs. Information can be repeated in different graphs; relationships between graphs can be
          exposed. Two useful arrangements are:</p>
        <ul>
          <li>to have information in the default graph that includes provenance information about the
            named graphs</li>
          <li>to include the information in the named graphs in the default graph as well.</li>
        </ul>
        <div class="exampleGroup">
          <b>Example 1:</b>
          <pre class="data nohighlight">
# <b>Default graph</b>
@prefix dc: &lt;http://purl.org/dc/elements/1.1/&gt; .

&lt;http://example.org/bob&gt;    dc:publisher  "Bob" .
&lt;http://example.org/alice&gt;  dc:publisher  "Alice" .
          </pre>
          <pre class="data nohighlight">
# <b>Named graph: http://example.org/bob</b>
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a foaf:name "Bob" .
_:a foaf:mbox &lt;mailto:bob@oldcorp.example.org&gt; .
          </pre>
          <pre class="data nohighlight">
# <b>Named graph: http://example.org/alice</b>
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a foaf:name "Alice" .
_:a foaf:mbox &lt;mailto:alice@work.example.org&gt; .
          </pre>
        </div>
        <p>In this example, the default graph contains the names of the publishers of two named
          graphs. The triples in the named graphs are not visible in the default graph in this
          example.</p>
        <p id="ex_2"><b>Example 2:</b></p>
        <p>RDF data can be combined by the <a data-cite="RDF12-SEMANTICS#dfn-merge">RDF merge</a>
          [[RDF12-SEMANTICS]] of graphs. One possible arrangement of graphs in an RDF Dataset is to have the
          default graph be the RDF merge of some or all of the information in the named graphs.</p>
        <p>In this next example, the named graphs contain the same triples as before. The RDF dataset
          includes an RDF merge of the named graphs in the default graph, re-labeling blank nodes to
          keep them distinct.</p>
        <div class="exampleGroup">
          <pre class="data nohighlight">
# <b>Default graph</b>
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

_:x foaf:name "Bob" .
_:x foaf:mbox &lt;mailto:bob@oldcorp.example.org&gt; .

_:y foaf:name "Alice" .
_:y foaf:mbox &lt;mailto:alice@work.example.org&gt; .
          </pre>
          <pre class="data nohighlight">
# <b>Named graph: http://example.org/bob</b>
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a foaf:name "Bob" .
_:a foaf:mbox &lt;mailto:bob@oldcorp.example.org&gt; .
          </pre>
          <pre class="data nohighlight">
# <b>Named graph: http://example.org/alice</b>
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a foaf:name "Alice" .
_:a foaf:mbox &lt;<a href="mailto:alice@work.example">mailto:alice@work.example</a>&gt; .
          </pre>
          <p>In an RDF merge, blank nodes in the merged graph are not shared with blank nodes from
            the graphs being merged.</p>
        </div>
      </section>
      <section id="specifyingDataset">
        <h3>Specifying RDF Datasets</h3>
        <p>A SPARQL query may specify the dataset to be used for matching by using the
          <code>FROM</code> clause and the <code>FROM NAMED</code> clause to describe the RDF dataset.
          If a query provides such a dataset description, then it is used in place of any dataset that
          the query service would use if no dataset description is provided in a query. The RDF dataset
          may also be <a data-cite="SPARQL11-PROTOCOL#">specified in a SPARQL protocol request</a>, in
          which case the protocol description overrides any description in the query itself. A query
          service may refuse a query request if the dataset description is not acceptable to the
          service.</p>
        <p>The <code>FROM</code> and <code>FROM NAMED</code> keywords allow a query to specify an RDF
          dataset by reference; they indicate that the dataset should include graphs that are obtained
          from representations of the resources identified by the given IRIs (i.e. the absolute form of
          the given IRI references). The dataset resulting from a number of <code>FROM</code> and
          <code>FROM NAMED</code> clauses is:</p>
        <ul>
          <li>a default graph consisting of the RDF merge of the graphs referred to in the
            <code>FROM</code> clauses, and</li>
          <li>a set of (IRI, graph) pairs, one from each <code>FROM NAMED</code> clause.</li>
        </ul>
        <p>If there is no <code>FROM</code> clause, but there is one or more <code>FROM NAMED</code>
          clauses, then the dataset includes an empty graph for the default graph.</p>
        <section id="unnamedGraph">
          <h4>Specifying the Default Graph</h4>
          <p>Each <code>FROM</code> clause contains an IRI that indicates a graph to be used to form
            the default graph. This does not put the graph in as a named graph.</p>
          <p>In this example, the RDF Dataset contains a single default graph and no named
            graphs:</p>
          <div class="exampleGroup">
            <pre class="data nohighlight">
<b># Default graph (located at http://example.org/foaf/aliceFoaf)</b>
@prefix  foaf:  &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a  foaf:name     "Alice" .
_:a  foaf:mbox     &lt;mailto:alice@work.example&gt; .
            </pre>
            <div class="queryGroup">
              <pre class="query nohighlight">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT  ?name
FROM    &lt;http://example.org/foaf/aliceFoaf&gt;
WHERE   { ?x foaf:name ?name }
              </pre>
              <div class="result">
                <div id="table102"></div>
                <table class="resultTable">
                  <tbody>
                    <tr>
                      <th>name</th>
                    </tr>
                    <tr>
                      <td>"Alice"</td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
          </div>
          <p>If a query provides more than one <code>FROM</code> clause, providing more than one IRI
            to indicate the default graph, then the default graph is the 
            <a data-cite="RDF12-SEMANTICS#dfn-merge">RDF merge</a> of the graphs obtained from representations of the
            resources identified by the given IRIs.</p>
        </section>
        <section id="namedGraphs">
          <h4>Specifying Named Graphs</h4>
          <p>A query can supply IRIs for the named graphs in the RDF Dataset using the <code>FROM
              NAMED</code> clause. Each IRI is used to provide one named graph in the RDF Dataset. Using
            the same IRI in two or more <code>FROM NAMED</code> clauses results in one named graph with
            that IRI appearing in the dataset.</p>
          <pre class="data nohighlight">
<b># Graph: http://example.org/bob</b>
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a foaf:name "Bob" .
_:a foaf:mbox &lt;mailto:bob@oldcorp.example.org&gt; .
          </pre>
          <pre class="data nohighlight">
<b># Graph: http://example.org/alice</b>
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a foaf:name "Alice" .
_:a foaf:mbox &lt;mailto:alice@work.example&gt; .
          </pre>
          <div class="queryGroup">
            <pre class="query nohighlight">
...
FROM NAMED &lt;http://example.org/alice&gt;
FROM NAMED &lt;http://example.org/bob&gt;
...
            </pre>
          </div>
          <p>
            The <code>FROM NAMED</code> syntax suggests that the IRI identifies the corresponding
            graph, but the relationship between an IRI and a graph in an RDF dataset is indirect. The
            IRI identifies a resource, and the resource is represented by a graph (or, more precisely:
            by a document that serializes a graph). For 
            <a data-cite="?WEBARCH#intro">further details</a> see [[WEBARCH]].
          </p>
        </section>
        <section id="specDataset">
          <h4>Combining FROM and FROM NAMED</h4>
          <p>The <code>FROM</code> clause and <code>FROM NAMED</code> clause can be used in the same
            query.</p>
          <div class="exampleGroup">
            <pre class="data nohighlight">
# <b>Default graph (located at http://example.org/dft.ttl)
</b>@prefix dc: &lt;http://purl.org/dc/elements/1.1/&gt; .

&lt;http://example.org/bob&gt;    dc:publisher  "Bob Hacker" .
&lt;http://example.org/alice&gt;  dc:publisher  "Alice Hacker" .
            </pre>
            <pre class="data nohighlight">
# <b>Named graph: http://example.org/bob</b>
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a foaf:name "Bob" .
_:a foaf:mbox &lt;mailto:bob@oldcorp.example.org&gt; .
            </pre>
            <pre class="data nohighlight">
# <b>Named graph: http://example.org/alice</b>
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a foaf:name "Alice" .
_:a foaf:mbox &lt;mailto:alice@work.example.org&gt; .
            </pre>
            <pre class="query nohighlight">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX dc: &lt;http://purl.org/dc/elements/1.1/&gt;

SELECT ?who ?g ?mbox
FROM &lt;http://example.org/dft.ttl&gt;
FROM NAMED &lt;http://example.org/alice&gt;
FROM NAMED &lt;http://example.org/bob&gt;
WHERE
{
    ?g dc:publisher ?who .
    GRAPH ?g { ?x foaf:mbox ?mbox }
}
            </pre>
          </div>
          <p>The RDF Dataset for this query contains a default graph and two named graphs. The
            <code>GRAPH</code> keyword is described below.</p>
          <p>The actions required to construct the dataset are not determined by the dataset
            description alone. If an IRI is given twice in a dataset description, either by using two
            <code>FROM</code> clauses, or a <code>FROM</code> clause and a <code>FROM NAMED</code>
            clause, then it does not assume that exactly one or exactly two attempts are made to obtain
            an RDF graph associated with the IRI. Therefore, no assumptions can be made about blank
            node identity in triples obtained from the two occurrences in the dataset description. In
            general, no assumptions can be made about the equivalence of the graphs.</p>
        </section>
      </section>
      <section id="queryDataset">
        <h3>Querying the Dataset</h3>
        <p>When querying a collection of graphs, the <code>GRAPH</code> keyword is used to match
          patterns against named graphs. <code>GRAPH</code> can provide an IRI to select one graph or
          use a variable which will range over the IRI of all the named graphs in the query's RDF
          dataset.</p>
        <p>The use of <code>GRAPH</code> changes the active graph for matching graph patterns within
          that part of the query. Outside the use of <code>GRAPH</code>, matching is done using the
          default graph.</p>
        <p>The following two graphs will be used in examples:</p>
        <div class="exampleGroup">
          <pre class="data nohighlight">
<b># Named graph: http://example.org/foaf/aliceFoaf
</b>@prefix  foaf:     &lt;http://xmlns.com/foaf/0.1/&gt; .
@prefix  rdf:      &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .
@prefix  rdfs:     &lt;http://www.w3.org/2000/01/rdf-schema#&gt; .

_:a  foaf:name     "Alice" .
_:a  foaf:mbox     &lt;mailto:alice@work.example&gt; .
_:a  foaf:knows    _:b .

_:b  foaf:name     "Bob" .
_:b  foaf:mbox     &lt;mailto:bob@work.example&gt; .
_:b  foaf:nick     "Bobby" .
_:b  rdfs:seeAlso  &lt;http://example.org/foaf/bobFoaf&gt; .

&lt;http://example.org/foaf/bobFoaf&gt;
rdf:type      foaf:PersonalProfileDocument .
          </pre>
          <pre class="data nohighlight">
<b># Named graph: http://example.org/foaf/bobFoaf</b>
@prefix  foaf:     &lt;http://xmlns.com/foaf/0.1/&gt; .
@prefix  rdf:      &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .
@prefix  rdfs:     &lt;http://www.w3.org/2000/01/rdf-schema#&gt; .

_:z  foaf:mbox     &lt;mailto:bob@work.example&gt; .
_:z  rdfs:seeAlso  &lt;http://example.org/foaf/bobFoaf&gt; .
_:z  foaf:nick     "Robert" .

&lt;http://example.org/foaf/bobFoaf&gt;
        rdf:type      foaf:PersonalProfileDocument .
          </pre>
        </div>
        <section id="accessByLabel">
          <h4>Accessing Graph Names</h4>
          <p>The query below matches the graph pattern against each of the named graphs in the
            dataset and forms solutions which have the <code>src</code> variable bound to IRIs of the
            graph being matched. The graph pattern is matched with the active graph being each of the
            named graphs in the dataset.</p>
          <div class="queryGroup">
            <pre class="query nohighlight">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;

SELECT ?src ?bobNick
FROM NAMED &lt;http://example.org/foaf/aliceFoaf&gt;
FROM NAMED &lt;http://example.org/foaf/bobFoaf&gt;
WHERE
{
    GRAPH ?src
    { ?x foaf:mbox &lt;mailto:bob@work.example&gt; .
      ?x foaf:nick ?bobNick
    }
}
            </pre>
            <p>The query result gives the name of the graphs where the information was found and the
              value for Bob's nick:</p>
            <div class="result">
              <div id="table105"></div>
              <table class="resultTable">
                <tbody>
                  <tr>
                    <th>src</th>
                    <th>bobNick</th>
                  </tr>
                  <tr>
                    <td>&lt;http://example.org/foaf/aliceFoaf&gt;</td>
                    <td>"Bobby"</td>
                  </tr>
                  <tr>
                    <td>&lt;http://example.org/foaf/bobFoaf&gt;</td>
                    <td>"Robert"</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </section>
        <section id="restrictByLabel">
          <h4>Restricting by Graph IRI</h4>
          <p>The query can restrict the matching applied to a specific graph by supplying the graph
            IRI. This sets the active graph to the graph named by the IRI. This query looks for Bob's
            nick as given in the graph <code>http://example.org/foaf/bobFoaf</code>.</p>
          <div class="queryGroup">
            <pre class="query nohighlight">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX data: &lt;http://example.org/foaf/&gt;

SELECT ?nick
FROM NAMED &lt;http://example.org/foaf/aliceFoaf&gt;
FROM NAMED &lt;http://example.org/foaf/bobFoaf&gt;
WHERE
{
    GRAPH data:bobFoaf {
        ?x foaf:mbox &lt;mailto:bob@work.example&gt; .
        ?x foaf:nick ?nick 
    }
}
            </pre>
            <p>which yields a single solution:</p>
            <div class="result">
              <div id="table106"></div>
              <table class="resultTable">
                <tbody>
                  <tr>
                    <th>nick</th>
                  </tr>
                  <tr>
                    <td>"Robert"</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </section>
        <section id="restrictInQuery">
          <h4>Restricting Possible Graph IRIs</h4>
          <p>A variable used in the <code>GRAPH</code> clause may also be used in another
            <code>GRAPH</code> clause or in a graph pattern matched against the default graph in the
            dataset.</p>
          <p>The query below uses the graph with IRI <code>http://example.org/foaf/aliceFoaf</code>
            to find the profile document for Bob; it then matches another pattern against that graph.
            The pattern in the second <code>GRAPH</code> clause finds the blank node (variable
            <code>w</code>) for the person with the same mail box (given by variable <code>mbox</code>)
            as found in the first <code>GRAPH</code> clause (variable <code>whom</code>), because the
            blank node used to match for variable <code>whom</code> from Alice's FOAF file is not the
            same as the blank node in the profile document (they are in different graphs).</p>
          <div class="queryGroup">
            <pre class="query nohighlight">
PREFIX  data:  &lt;http://example.org/foaf/&gt;
PREFIX  foaf:  &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX  rdfs:  &lt;http://www.w3.org/2000/01/rdf-schema#&gt;

SELECT ?mbox ?nick ?ppd
FROM NAMED &lt;http://example.org/foaf/aliceFoaf&gt;
FROM NAMED &lt;http://example.org/foaf/bobFoaf&gt;
WHERE {
    GRAPH data:aliceFoaf {
        ?alice foaf:mbox &lt;mailto:alice@work.example&gt; ;
               foaf:knows ?whom .
        ?whom  foaf:mbox ?mbox ;
               rdfs:seeAlso ?ppd .
        ?ppd  a foaf:PersonalProfileDocument .
    }
    GRAPH ?ppd {
        ?w foaf:mbox ?mbox ;
           foaf:nick ?nick
    }
}
            </pre>
            <div class="result">
              <div id="table107"></div>
              <table class="resultTable">
                <tbody>
                  <tr>
                    <th>mbox</th>
                    <th>nick</th>
                    <th>ppd</th>
                  </tr>
                  <tr>
                    <td>&lt;mailto:bob@work.example&gt;</td>
                    <td>"Robert"</td>
                    <td>&lt;http://example.org/foaf/bobFoaf&gt;</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </section>
        <p>Any triple in Alice's FOAF file giving Bob's <code>nick</code> is not used to provide a
          nick for Bob because the pattern involving variable <code>nick</code> is restricted by
          <code>ppd</code> to a particular Personal Profile Document.</p>
        <section id="namedAndDefaultGraph">
          <h4>Named and Default Graphs</h4>
          <p>Query patterns can involve both the default graph and the named graphs. In this example,
            an aggregator has read in a Web resource on two different occasions. Each time a graph is
            read into the aggregator, it is given an IRI by the local system. The graphs are nearly the
            same but the email address for "Bob" has changed.</p>
          <p>In this example, the default graph is being used to record the provenance information
            and the RDF data actually read is kept in two separate graphs, each of which is given a
            different IRI by the system. The RDF dataset consists of two named graphs and the
            information about them.</p>
          <p>RDF Dataset:</p>
          <div class="exampleGroup">
            <pre class="data nohighlight">
# <b>Default graph</b>
@prefix dc: &lt;http://purl.org/dc/elements/1.1/&gt; .
@prefix g:  &lt;tag:example.org,2005-06-06:&gt; .
@prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt; .

g:graph1 dc:publisher "Bob" .
g:graph1 dc:date "2004-12-06"^^xsd:date .

g:graph2 dc:publisher "Bob" .
g:graph2 dc:date "2005-01-10"^^xsd:date .
            </pre>
            <pre class="data nohighlight">
# <b>Graph: locally allocated IRI: tag:example.org,2005-06-06:graph1</b>
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a foaf:name "Alice" .
_:a foaf:mbox &lt;mailto:alice@work.example&gt; .

_:b foaf:name "Bob" .
_:b foaf:mbox &lt;mailto:bob@oldcorp.example.org&gt; .
            </pre>
            <pre class="data nohighlight">
# <b>Graph: locally allocated IRI: tag:example.org,2005-06-06:graph2</b>
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a foaf:name "Alice" .
_:a foaf:mbox &lt;mailto:alice@work.example&gt; .

_:b foaf:name "Bob" .
_:b foaf:mbox &lt;mailto:bob@newcorp.example.org&gt; .
            </pre>
            <p>This query finds email addresses, detailing the name of the person and the date the
              information was discovered.</p>
            <div class="queryGroup">
              <pre class="query nohighlight">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX dc:   &lt;http://purl.org/dc/elements/1.1/&gt;

SELECT ?name ?mbox ?date
WHERE {
   ?g dc:publisher ?name ;
      dc:date ?date .
   GRAPH ?g { 
       ?person foaf:name ?name ; foaf:mbox ?mbox
   }
}
              </pre>
              <p>The results show that the email address for "Bob" has changed.</p>
              <div class="result">
                <div id="table108"></div>
                <table class="resultTable">
                  <tbody>
                    <tr>
                      <th>name</th>
                      <th>mbox</th>
                      <th>date</th>
                    </tr>
                    <tr>
                      <td>"Bob"</td>
                      <td>&lt;mailto:bob@oldcorp.example.org&gt;</td>
                      <td>"2004-12-06"^^xsd:date</td>
                    </tr>
                    <tr>
                      <td>"Bob"</td>
                      <td>&lt;mailto:bob@newcorp.example.org&gt;</td>
                      <td>"2005-01-10"^^xsd:date</td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
          </div>
        </section>
      </section>
    </section>
    <section id="basic-federated-query">
      <h2>Basic Federated Query</h2>
      <p>This document incorporates the syntax for SPARQL federation extensions.</p>
      <p>This feature is defined in the document [[[SPARQL11-FEDERATED-QUERY]]].</p>
    </section>
    <section id="solutionModifiers">
      <h2>Solution Sequences and Modifiers</h2>
      <p>Query patterns generate an unordered collection of solutions, each 
        <a href="#defn_sparqlSolutionMapping">solution</a> being a partial function from variables to RDF
        terms. These solutions are then treated as a sequence (a solution sequence), initially in no
        specific order; any sequence modifiers are then applied to create another sequence. Finally,
        this latter sequence is used to generate one of the results of a <a href="#QueryForms">SPARQL
          query form</a>.</p>
      <p>A <span class="definedTerm">solution sequence modifier</span> is one of:</p>
      <ul>
        <li>
          <a href="#modOrderBy">Order</a> modifier: put the solutions in order
        </li>
        <li>
          <a href="#modProjection">Projection</a> modifier: choose certain variables
        </li>
        <li>
          <a href="#modDistinct">Distinct</a> modifier: ensure solutions in the sequence are unique
        </li>
        <li>
          <a href="#modReduced">Reduced</a> modifier: permit elimination of some non-distinct
          solutions
        </li>
        <li>
          <a href="#modOffset">Offset</a> modifier: control where the solutions start from in the
          overall sequence of solutions
        </li>
        <li>
          <a href="#modResultLimit">Limit</a> modifier: restrict the number of solutions
        </li>
      </ul>
      <p>Modifiers are applied in the order given by the list above.</p>
      <section id="modOrderBy">
        <h3>ORDER BY</h3>
        <p>The <code>ORDER BY</code> clause establishes the order of a solution sequence.</p>
        <p>Following the <code>ORDER BY</code> clause is a sequence of order comparators, composed of
          an expression and an optional order modifier (either <code>ASC()</code> or
          <code>DESC()</code>). Each ordering comparator is either ascending (indicated by the
          <code>ASC()</code> modifier or by no modifier) or descending (indicated by the
          <code>DESC()</code> modifier).</p>
        <div class="exampleGroup">
          <div class="queryGroup">
            <pre class="query nohighlight">
PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;

SELECT ?name
WHERE { ?x foaf:name ?name }
ORDER BY ?name
            </pre>
          </div>
        </div>
        <div class="exampleGroup">
          <div class="queryGroup">
            <pre class="query nohighlight">
PREFIX     :    &lt;http://example.org/ns#&gt;
PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;

SELECT ?name
WHERE { ?x foaf:name ?name ; :empId ?emp }
ORDER BY DESC(?emp)
            </pre>
          </div>
        </div>
        <div class="exampleGroup">
          <div class="queryGroup">
            <pre class="query nohighlight">
PREFIX     :    &lt;http://example.org/ns#&gt;
PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;

SELECT ?name
WHERE { ?x foaf:name ?name ; :empId ?emp }
ORDER BY ?name DESC(?emp)
            </pre>
          </div>
        </div>
        <p>The <a href="#op_lt">"&lt;" operator</a> (see the <a href="#OperatorMapping">Operator
            Mapping</a> and <a href="#operatorExtensibility">17.3.1 Operator Extensibility</a>) defines
          the relative order of pairs of <code>numerics</code>,
          <code>xsd:strings</code>, <code>xsd:booleans</code> and <code>xsd:dateTimes</code>. Pairs of
          IRIs are ordered by comparing them as literals with datatype <code>xsd:string</code>.</p>
        <p>SPARQL also fixes an order between some kinds of RDF terms that would not otherwise be
          ordered:</p>
        <ol>
          <li>(Lowest) no value assigned to the variable or expression in this solution.</li>
          <li>Blank nodes</li>
          <li>IRIs</li>
          <li>RDF literals</li>
        </ol>
        <p>SPARQL does not define a total ordering of all possible RDF terms. Here are a few examples
          of pairs of terms for which the relative order is undefined:</p>
        <ul>
          <li>"a" and "a"@en_gb (a literal with datatype <code>xsd:string</code> and a literal with a language tag)</li>
          <li>"a"@en_gb and "b"@en_gb (two literals with language tags)</li>
          <li>"a" and "1"^^xsd:integer (a literal with datatype <code>xsd:string</code> and a literal with a supported
            datatype)</li>
          <li>"1"^^my:integer and "2"^^my:integer (two unsupported datatypes)</li>
          <li>"1"^^xsd:integer and "2"^^my:integer (a supported datatype and an unsupported
            datatype)</li>
        </ul>
        <p>This list of variable bindings is in ascending order:</p>
        <div class="result">
          <table class="resultTable">
            <thead>
              <tr>
                <th>RDF Term</th>
                <th>Reason</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td></td>
                <td>Unbound results sort earliest.</td>
              </tr>
              <tr>
                <td><code>_:z</code></td>
                <td>Blank nodes follow unbound.</td>
              </tr>
              <tr>
                <td><code>_:a</code></td>
                <td>There is no relative ordering of blank nodes.</td>
              </tr>
              <tr>
                <td><code>&lt;http://script.example/Latin&gt;</code></td>
                <td>IRIs follow blank nodes.</td>
              </tr>
              <tr>
                <td><code>&lt;http://script.example/Кириллица&gt;</code></td>
                <td>The character in the 23rd position, "К", has a unicode codepoint 0x41A, which is
                  higher than 0x4C ("L").</td>
              </tr>
              <tr>
                <td><code>&lt;http://script.example/漢字&gt;</code></td>
                <td>The character in the 23rd position, "漢", has a unicode codepoint 0x6F22, which is
                  higher than 0x41A ("К").</td>
              </tr>
              <tr>
                <td><code>"http://script.example/Latin"</code></td>
                <td><code>xsd:strings</code> follow IRIs.</td>
              </tr>
            </tbody>
          </table>
        </div>
        <p>The ascending order of two solutions with respect to an ordering comparator is established
          by substituting the solution bindings into the expressions and comparing them with the
          <a href="#op_lt">"&lt;" operator</a>. The descending order is the reverse of the ascending
          order.</p>
        <p>The relative order of two solutions is the relative order of the two solutions with
          respect to the first ordering comparator in the sequence. For solutions where the
          substitutions of the solution bindings produce the same RDF term, the order is the relative
          order of the two solutions with respect to the next ordering comparator. The relative order
          of two solutions is undefined if no order expression evaluated for the two solutions produces
          distinct RDF terms.</p>
        <p>Ordering a sequence of solutions always results in a sequence with the same number of
          solutions in it.</p>
        <p>Using <code>ORDER BY</code> on a solution sequence for a <code>CONSTRUCT</code> or
          <code>DESCRIBE</code> query has no direct effect because only <code>SELECT</code> returns a
          sequence of results. Used in combination with <code>LIMIT</code> and <code>OFFSET</code>,
          <code>ORDER BY</code> can be used to return results generated from a different slice of the
          solution sequence. An <code>ASK</code> query does not include <code>ORDER BY</code>,
          <code>LIMIT</code> or <code>OFFSET</code>.</p>
      </section>
      <section id="modProjection">
        <h3>Projection</h3>
        <p>The solution sequence can be transformed into one involving only a subset of the
          variables. For each solution in the sequence, a new solution is formed using a specified
          selection of the variables using the SELECT query form.</p>
        <p>The following example shows a query to extract just the names of people described in an
          RDF graph using FOAF properties.</p>
        <div class="exampleGroup">
          <pre class="data nohighlight">
@prefix foaf:        &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a  foaf:name       "Alice" .
_:a  foaf:mbox       &lt;mailto:alice@work.example&gt; .

_:b  foaf:name       "Bob" .
_:b  foaf:mbox       &lt;mailto:bob@work.example&gt; .
          </pre>
          <div class="queryGroup">
            <pre class="query nohighlight">
PREFIX foaf:       &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name
WHERE
{ ?x foaf:name ?name }
            </pre>
            <div class="result">
              <table class="resultTable">
                <tbody>
                  <tr>
                    <th>name</th>
                  </tr>
                  <tr>
                    <td>"Bob"</td>
                  </tr>
                  <tr>
                    <td>"Alice"</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>
      </section>
      <section id="modDuplicates">
        <h3>Duplicate Solutions</h3>
        <p>A solution sequence with no <code>DISTINCT</code> or <code>REDUCED</code> query modifier
          will preserve duplicate solutions.</p>
        <div class="exampleGroup">
          <p>Data:</p>
          <pre class="data nohighlight">
@prefix  foaf:  &lt;http://xmlns.com/foaf/0.1/&gt; .

_:x    foaf:name   "Alice" .
_:x    foaf:mbox   &lt;mailto:alice@example.com&gt; .

_:y    foaf:name   "Alice" .
_:y    foaf:mbox   &lt;mailto:asmith@example.com&gt; .

_:z    foaf:name   "Alice" .
_:z    foaf:mbox   &lt;mailto:alice.smith@example.com&gt; .
          </pre>
          <div class="queryGroup">
            <p>Query:</p>
            <pre class="query nohighlight">
PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name WHERE { ?x foaf:name ?name }
            </pre>
            <div class="result">
              <p>Results:</p>
              <table class="resultTable">
                <tbody>
                  <tr>
                    <th>name</th>
                  </tr>
                  <tr>
                    <td>"Alice"</td>
                  </tr>
                  <tr>
                    <td>"Alice"</td>
                  </tr>
                  <tr>
                    <td>"Alice"</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
          <p>The modifiers <code>DISTINCT</code> and <code>REDUCED</code> affect whether duplicates
            are included in the query results.</p>
          <section id="modDistinct">
            <h4>DISTINCT</h4>
            <p>The <code>DISTINCT</code> solution modifier eliminates duplicate solutions. Only one
              solution solution that binds the same variables to the same RDF terms is returned from
              the query.</p>
            <div class="queryGroup">
              <pre class="query nohighlight">
PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT DISTINCT ?name WHERE { ?x foaf:name ?name }
              </pre>
              <div class="result">
                <table class="resultTable">
                  <tbody>
                    <tr>
                      <th>name</th>
                    </tr>
                    <tr>
                      <td>"Alice"</td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
            <p id="defunSELECT">Note that, per the <a href="#solutionModifiers">order of solution
                sequence modifiers</a>, duplicates are eliminated before either limit or offset is
              applied.</p>
          </section>
          <section id="modReduced">
            <h4>REDUCED</h4>
            <p>While the <code>DISTINCT</code> modifier ensures that duplicate solutions are
              eliminated from the solution set, <code>REDUCED</code> simply permits them to be
              eliminated. The cardinality of any set of variable bindings in a <code>REDUCED</code>
              solution set is at least one and not more than the cardinality of the solution set with
              no <code>DISTINCT</code> or <code>REDUCED</code> modifier. For example, using the data
              above, the query</p>
            <div class="queryGroup">
              <pre class="query nohighlight">
PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT REDUCED ?name WHERE { ?x foaf:name ?name }
              </pre>
              <p>may have one, two (shown here) or three solutions:</p>
              <div class="result">
                <table class="resultTable">
                  <tbody>
                    <tr>
                      <th>name</th>
                    </tr>
                    <tr>
                      <td>"Alice"</td>
                    </tr>
                    <tr>
                      <td>"Alice"</td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
          </section>
        </div>
      </section>
      <section id="modOffset">
        <h3>OFFSET</h3>
        <p><code>OFFSET</code> causes the solutions generated to start after the specified number of
          solutions. An <code>OFFSET</code> of zero has no effect.</p>
        <p>Using <code>LIMIT</code> and <code>OFFSET</code> to select different subsets of the query
          solutions will not be useful unless the order is made predictable by using <code>ORDER
            BY</code>.</p>
        <div class="exampleGroup">
          <div class="queryGroup">
            <pre class="query nohighlight">
PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;

SELECT  ?name
WHERE   { ?x foaf:name ?name }
ORDER BY ?name
LIMIT   5
OFFSET  10
            </pre>
          </div>
        </div>
      </section>
      <section id="modResultLimit">
        <h3>LIMIT</h3>
        <p>The <code>LIMIT</code> clause puts an upper bound on the number of solutions returned. If
          the number of actual solutions, after <code>OFFSET</code> is applied, is greater than the
          limit, then at most the limit number of solutions will be returned.</p>
        <div class="exampleGroup">
          <div class="queryGroup">
            <pre class="query nohighlight">
PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;

SELECT ?name
WHERE { ?x foaf:name ?name }
LIMIT 20
            </pre>
          </div>
        </div>
        <p>A <code>LIMIT</code> of 0 would cause no results to be returned. A limit may not be
          negative.</p>
      </section>
    </section>
    <section id="QueryForms">
      <h2>Query Forms</h2>
      <p>SPARQL has four query forms. These query forms use the solutions from pattern matching to
        form result sets or RDF graphs. The query forms are:</p>
      <blockquote>
        <dl>
          <dt>
            <a href="#select">SELECT</a>
          </dt>
          <dd>Returns all, or a subset of, the variables bound in a query pattern match.</dd>
          <dt>
            <a href="#construct">CONSTRUCT</a>
          </dt>
          <dd>Returns an RDF graph constructed by substituting variables in a set of triple
            templates.</dd>
          <dt>
            <a href="#ask">ASK</a>
          </dt>
          <dd>Returns a boolean indicating whether a query pattern matches or not.</dd>
          <dt>
            <a href="#describe">DESCRIBE</a>
          </dt>
          <dd>Returns an RDF graph that describes the resources found.</dd>
        </dl>
      </blockquote>
      <p>Formats such as [[[SPARQL11-RESULTS-JSON]]], [[[RDF-SPARQL-XMLRES]]] or
        [[[SPARQL11-RESULTS-CSV-TSV]]] can be used to serialize the result set from a
        <code>SELECT</code> query or the boolean result of an <code>ASK</code> query.</p>
      <section id="select">
        <h3>SELECT</h3>
        <p>The SELECT form of results returns variables and their bindings directly. It combines the
          operations of projecting the required variables with introducing new variable bindings into a
          query solution.</p>
        <section id="selectproject">
          <h4>Projection</h4>
          <p>Specific variables and their bindings are returned when a list of variable names is
            given in the SELECT clause. The syntax <code>SELECT *</code> is an abbreviation that
            selects all of the variables that are <a href="#variableScope">in-scope</a> at that point
            in the query. It excludes variables only used in <code>FILTER</code>, in the right-hand
            side of <code>MINUS</code>, and takes account of subqueries.</p>
          <p>Use of <code>SELECT *</code> is only permitted when the query does not have a
            <code>GROUP BY</code> clause.</p>
          <div class="exampleGroup">
            <pre class="data nohighlight">
@prefix  foaf:  &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a    foaf:name   "Alice" .
_:a    foaf:knows  _:b .
_:a    foaf:knows  _:c .

_:b    foaf:name   "Bob" .

_:c    foaf:name   "Clare" .
_:c    foaf:nick   "CT" .         
            </pre>
            <div class="queryGroup">
              <pre class="query nohighlight">
PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?nameX ?nameY ?nickY
WHERE
{ ?x foaf:knows ?y ;
  foaf:name ?nameX .
  ?y foaf:name ?nameY .
  OPTIONAL { ?y foaf:nick ?nickY }
}</pre>
              <div class="result">
                <div id="table33"></div>
                <table class="resultTable">
                  <tbody>
                    <tr>
                      <th>nameX</th>
                      <th>nameY</th>
                      <th>nickY</th>
                    </tr>
                    <tr>
                      <td>"Alice"</td>
                      <td>"Bob"</td>
                      <td></td>
                    </tr>
                    <tr>
                      <td>"Alice"</td>
                      <td>"Clare"</td>
                      <td>"CT"</td>
                    </tr>
                  </tbody>
                </table>
              </div>
              <p>Result sets can be accessed by a local API but also can be serialized into either
                JSON, XML, CSV or TSV.</p>
              <p>[[[SPARQL11-RESULTS-JSON]]]:</p>
              <div class="result">
                <pre class="resultSet">
{
    "head": {
        "vars": [ "nameX" , "nameY" , "nickY" ]
    } ,
    "results": {
        "bindings": [
          {
            "nameX": { "type": "literal" , "value": "Alice" } ,
            "nameY": { "type": "literal" , "value": "Bob" }
          } ,
          {
            "nameX": { "type": "literal" , "value": "Alice" } ,
            "nameY": { "type": "literal" , "value": "Clare" } ,
            "nickY": { "type": "literal" , "value": "CT" }
          }
        ]
    }
}
                </pre>
              </div>
              <p>[[[RDF-SPARQL-XMLRES]]]:</p>
              <div class="result">
                <pre class="resultSet">
&lt;?xml version="1.0"?&gt;
&lt;sparql xmlns="http://www.w3.org/2005/sparql-results#"&gt;
&lt;head&gt;
&lt;variable name="nameX"/&gt;
&lt;variable name="nameY"/&gt;
&lt;variable name="nickY"/&gt;
&lt;/head&gt;
&lt;results&gt;
&lt;result&gt;
&lt;binding name="nameX"&gt;
&lt;literal&gt;Alice&lt;/literal&gt;
&lt;/binding&gt;
&lt;binding name="nameY"&gt;
&lt;literal&gt;Bob&lt;/literal&gt;
&lt;/binding&gt;
&lt;/result&gt;
&lt;result&gt;
&lt;binding name="nameX"&gt;
&lt;literal&gt;Alice&lt;/literal&gt;
&lt;/binding&gt;
&lt;binding name="nameY"&gt;
&lt;literal&gt;Clare&lt;/literal&gt;
&lt;/binding&gt;
&lt;binding name="nickY"&gt;
&lt;literal&gt;CT&lt;/literal&gt;
&lt;/binding&gt;
&lt;/result&gt;
&lt;/results&gt;
&lt;/sparql&gt;
                </pre>
              </div>
            </div>
          </div>
        </section>
        <section id="selectExpressions">
          <h4>SELECT Expressions</h4>
          <p>As well as choosing which variables from the pattern matching are included in the
            results, the SELECT clause can also introduce new variables. The rules of assignment in
            SELECT expression are the same as for assignment in BIND. The expression combines variable
            bindings already in the query solution, or defined earlier in the SELECT clause, to produce
            a binding in the query solution.</p>
          <p>The scoping for <code>(expr AS v)</code> applies immediately. In <code>SELECT</code>
            expressions, the variable may be used in an expression later in the same
            <code>SELECT</code> clause and may not be be assigned again in the same <code>SELECT</code>
            clause.</p>
          <p>Example:</p>
          <div class="exampleGroup">
            <p>Data:</p>
            <pre class="data nohighlight">
@prefix dc:   &lt;http://purl.org/dc/elements/1.1/&gt; .
@prefix :     &lt;http://example.org/book/&gt; .
@prefix ns:   &lt;http://example.org/ns#&gt; .

:book1  dc:title  "SPARQL Tutorial" .
:book1  ns:price  42 .
:book1  ns:discount 0.2 .

:book2  dc:title  "The Semantic Web" .
:book2  ns:price  23 .
:book2  ns:discount 0.25 .</pre>
            <p>Query:</p>
            <div class="queryGroup">
              <pre class="query nohighlight">
PREFIX  dc:  &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX  ns:  &lt;http://example.org/ns#&gt;
SELECT  ?title (?p*(1-?discount) AS ?price)
{ ?x ns:price ?p .
  ?x dc:title ?title . 
  ?x ns:discount ?discount 
}
              </pre>
              <p>Results:</p>
              <div class="result">
                <table class="resultTable">
                  <tbody>
                    <tr>
                      <th>title</th>
                      <th>price</th>
                    </tr>
                    <tr>
                      <td>"The Semantic Web"</td>
                      <td>17.25</td>
                    </tr>
                    <tr>
                      <td>"SPARQL Tutorial"</td>
                      <td>33.6</td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
          </div>
          <p>New variables can also be used in expressions if they are introduced earlier,
            syntactically, in the same SELECT clause:</p>
          <div class="exampleGroup">
            <div class="queryGroup">
              <pre class="query nohighlight">
PREFIX  dc:  &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX  ns:  &lt;http://example.org/ns#&gt;
SELECT  ?title (?p AS ?fullPrice) (?fullPrice*(1-?discount) AS ?customerPrice)
{ ?x ns:price ?p .
  ?x dc:title ?title . 
  ?x ns:discount ?discount 
}
              </pre>
              <p>Results:</p>
              <div class="result">
                <table class="resultTable">
                  <tbody>
                    <tr>
                      <th>title</th>
                      <th>fullPrice</th>
                      <th>customerPrice</th>
                    </tr>
                    <tr>
                      <td>"The Semantic Web"</td>
                      <td>23</td>
                      <td>17.25</td>
                    </tr>
                    <tr>
                      <td>"SPARQL Tutorial"</td>
                      <td>42</td>
                      <td>33.6</td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
          </div>
        </section>
      </section>
      <section id="construct">
        <h3>CONSTRUCT</h3>
        <p>The <code>CONSTRUCT</code> query form returns a single RDF graph specified by a graph
          template. The result is an RDF graph formed by taking each query solution in the solution
          sequence, substituting for the variables in the graph template, and combining the triples
          into a single RDF graph by set union.</p>
        <p>If any such instantiation produces a triple containing an unbound variable or an illegal
          RDF construct, such as a literal in subject or predicate position, then that triple is not
          included in the output RDF graph. The graph template can contain triples with no variables
          (known as ground or explicit triples), and these also appear in the output RDF graph returned
          by the CONSTRUCT query form.</p>
        <div class="exampleGroup">
          <pre class="data nohighlight">
@prefix  foaf:  &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a    foaf:name   "Alice" .
_:a    foaf:mbox   &lt;mailto:alice@example.org&gt; .
          </pre>
          <div class="queryGroup">
            <pre class="query nohighlight">
PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX vcard:   &lt;http://www.w3.org/2001/vcard-rdf/3.0#&gt;
CONSTRUCT   { &lt;http://example.org/person#Alice&gt; vcard:FN ?name }
WHERE       { ?x foaf:name ?name }
            </pre>
            <p>creates vcard properties from the FOAF information:</p>
            <div class="result">
              <pre class="resultGraph" style="text-align:left;">
@prefix vcard: &lt;http://www.w3.org/2001/vcard-rdf/3.0#&gt; .

&lt;http://example.org/person#Alice&gt; vcard:FN "Alice" .
              </pre>
            </div>
          </div>
        </div>
        <section id="templatesWithBNodes">
          <h4>Templates with Blank Nodes</h4>
          <p>A template can create an RDF graph containing blank nodes. The blank node labels are
            scoped to the template for each solution. If the same label occurs twice in a template,
            then there will be one blank node created for each query solution, but there will be
            different blank nodes for triples generated by different query solutions.</p>
          <div class="exampleGroup">
            <pre class="data nohighlight">
@prefix  foaf:  &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a    foaf:givenname   "Alice" .
_:a    foaf:family_name "Hacker" .

_:b    foaf:firstname   "Bob" .
_:b    foaf:surname     "Hacker" .
            </pre>
            <div class="queryGroup">
              <pre class="query nohighlight">
PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX vcard:   &lt;http://www.w3.org/2001/vcard-rdf/3.0#&gt;

CONSTRUCT {
     ?x  vcard:N _:v .
    _:v vcard:givenName ?gname .
    _:v vcard:familyName ?fname
} WHERE {
    { ?x foaf:firstname ?gname } UNION  { ?x foaf:givenname   ?gname } .
    { ?x foaf:surname   ?fname } UNION  { ?x foaf:family_name ?fname } .
}
              </pre>
              <p>creates vcard properties corresponding to the FOAF information:</p>
              <div class="result">
                <pre class="resultGraph">
@prefix vcard: &lt;http://www.w3.org/2001/vcard-rdf/3.0#&gt; .

_:v1 vcard:N         _:x .
_:x vcard:givenName  "Alice" .
_:x vcard:familyName "Hacker" .

_:v2 vcard:N         _:z .
_:z vcard:givenName  "Bob" .
_:z vcard:familyName "Hacker" .
                </pre>
              </div>
            </div>
          </div>
          <p>The use of variable <code>x</code> in the template, which in this example will be bound
            to blank nodes with labels <code>_:a</code> and <code>_:b</code> in the data, causes
            different blank node labels (<code>_:v1</code> and <code>_:v2</code>) in the resulting RDF
            graph.</p>
        </section>
        <section id="accessingRdfGraphs">
          <h4>Accessing Graphs in the RDF Dataset</h4>
          <p>Using <code>CONSTRUCT</code>, it is possible to extract parts or the whole of graphs
            from the target RDF dataset. This first example returns the graph (if it is in the dataset)
            with IRI label <code>http://example.org/aGraph</code>; otherwise, it returns an empty
            graph.</p>
          <div class="exampleGroup">
            <div class="queryGroup">
              <pre class="query nohighlight">
CONSTRUCT { ?s ?p ?o } WHERE { GRAPH &lt;http://example.org/aGraph&gt; { ?s ?p ?o } . }
              </pre>
            </div>
          </div>
          <p>The access to the graph can be conditional on other information. For example, if the
            default graph contains metadata about the named graphs in the dataset, then a query like
            the following one can extract one graph based on information about the named graph:</p>
          <div class="exampleGroup">
            <div class="queryGroup">
              <pre class="query nohighlight">
PREFIX  dc: &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX app: &lt;http://example.org/ns#&gt;
PREFIX xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt;

CONSTRUCT { ?s ?p ?o } WHERE
{
    GRAPH ?g { ?s ?p ?o } .
    ?g dc:publisher &lt;http://www.w3.org/&gt; .
    ?g dc:date ?date .
    FILTER ( app:customDate(?date) &gt; "2005-02-28T00:00:00Z"^^xsd:dateTime ) .
}
              </pre>
            </div>
          </div>
          <p>where <code>app:customDate</code> identifies an <a href="#extensionFunctions">extension
              function</a> to turn the date format into an <code>xsd:dateTime</code> RDF term.</p>
        </section>
        <section id="SolModandCONSTRUCT">
          <h4>Solution Modifiers and CONSTRUCT</h4>
          <p>The solution modifiers of a query affect the results of a <code>CONSTRUCT</code> query.
            In this example, the output graph from the <code>CONSTRUCT</code> template is derived from
            just two of the solutions from graph pattern matching. The query outputs a graph with the
            names of the people with the top two sites, rated by hits. The triples in the RDF graph are
            not ordered.</p>
          <div class="exampleGroup">
            <pre class="data nohighlight">
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .
@prefix site: &lt;http://example.org/stats#&gt; .

_:a foaf:name "Alice" .
_:a site:hits 2349 .

_:b foaf:name "Bob" .
_:b site:hits 105 .

_:c foaf:name "Eve" .
_:c site:hits 181 .
            </pre>
            <div class="queryGroup">
              <pre class="query nohighlight">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX site: &lt;http://example.org/stats#&gt;

CONSTRUCT { [] foaf:name ?name }
WHERE
{ [] foaf:name ?name ;
  site:hits ?hits .
}
ORDER BY desc(?hits)
LIMIT 2
              </pre>
              <div class="result">
                <pre class="resultGraph">
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .
_:x foaf:name "Alice" .
_:y foaf:name "Eve" .
                </pre>
              </div>
            </div>
          </div>
        </section>
        <section id="constructWhere">
          <h4>CONSTRUCT WHERE</h4>
          <p>A short form for the CONSTRUCT query form is provided for the case where the template
            and the pattern are the same and the pattern is just a basic graph pattern (no
            <code>FILTER</code>s and no complex graph patterns are allowed in the short form). The
            keyword <code>WHERE</code> is required in the short form.</p>
          <p>The following two queries are the same; the first is a short form of the second.</p>
          <pre class="query nohighlight">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
CONSTRUCT WHERE { ?x foaf:name ?name } 
          </pre>
          <pre class="query nohighlight">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;

CONSTRUCT { ?x foaf:name ?name } 
WHERE
{ ?x foaf:name ?name }
          </pre>
        </section>
      </section>
      <section id="ask">
        <h3>ASK</h3>
        <p>Applications can use the <code>ASK</code> form to test whether or not a query pattern has
          a solution. No information is returned about the possible query solutions, just whether or
          not a solution exists.</p>
        <div class="exampleGroup">
          <pre class="data nohighlight">
@prefix foaf:       &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a  foaf:name       "Alice" .
_:a  foaf:homepage   &lt;http://work.example.org/alice/&gt; .

_:b  foaf:name       "Bob" .
_:b  foaf:mbox       &lt;mailto:bob@work.example&gt; .
          </pre>
          <div class="queryGroup">
            <pre class="query nohighlight">
PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;
ASK  { ?x foaf:name  "Alice" }
            </pre>
            <div class="result">
              <pre class="resultAsk">true</pre>
            </div>
            <p>The [[[RDF-SPARQL-XMLRES]]] form of this result set gives:</p>
            <div class="result">
              <pre class="resultSet">&lt;?xml version="1.0"?&gt;
                &lt;sparql xmlns="http://www.w3.org/2005/sparql-results#"&gt;
                &lt;head&gt;&lt;/head&gt;
                &lt;boolean&gt;true&lt;/boolean&gt;
                &lt;/sparql&gt;
              </pre>
            </div>
          </div>
          <p>On the same data, the following returns no match because Alice's <code>mbox</code> is
            not mentioned.</p>
          <div class="queryGroup">
            <pre class="query nohighlight">
PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;
ASK  {
   ?x foaf:name  "Alice" ;
      foaf:mbox  &lt;mailto:alice@work.example&gt;
}
            </pre>
            <div class="result">
              <pre class="resultAsk">false</pre>
            </div>
          </div>
        </div>
      </section>
      <section id="describe">
        <h3>DESCRIBE (Informative)</h3>
        <p>The <code>DESCRIBE</code> form returns a single result RDF graph containing RDF data about
          resources. This data is not prescribed by a SPARQL query, where the query client would need
          to know the structure of the RDF in the data source, but, instead, is determined by the
          SPARQL query processor. The query pattern is used to create a result set. The
          <code>DESCRIBE</code> form takes each of the resources identified in a solution, together
          with any resources directly named by IRI, and assembles a single RDF graph by taking a
          "description" which can come from any information available including the target RDF Dataset.
          The description is determined by the query service. The syntax <code>DESCRIBE *</code> is an
          abbreviation that describes all of the variables in a query.</p>
        <section id="explicitIRIs">
          <h4>Explicit IRIs</h4>
          <p>The <code>DESCRIBE</code> clause itself can take IRIs to identify the resources. The
            simplest <code>DESCRIBE</code> query is just an IRI in the <code>DESCRIBE</code>
            clause:</p>
          <div class="exampleGroup">
            <div class="queryGroup">
              <pre class="query nohighlight">
DESCRIBE &lt;http://example.org/&gt;
              </pre>
            </div>
          </div>
        </section>
        <section id="identifyingResources">
          <h4>Identifying Resources</h4>
          <p>The resources to be described can also be taken from the bindings to a query variable in
            a result set. This enables description of resources whether they are identified by IRI or
            by blank node in the dataset:</p>
          <div class="exampleGroup">
            <div class="queryGroup">
              <pre class="query nohighlight">
PREFIX foaf:   &lt;http://xmlns.com/foaf/0.1/&gt;
DESCRIBE ?x
WHERE    { ?x foaf:mbox &lt;mailto:alice@org&gt; }
              </pre>
            </div>
          </div>
          <p>The property <code>foaf:mbox</code> is defined as being an inverse functional property
            in the FOAF vocabulary. If treated as such, this query will return information about at
            most one person. If, however, the query pattern has multiple solutions, the RDF data for
            each is the union of all RDF graph descriptions.</p>
          <div class="exampleGroup">
            <div class="queryGroup">
              <pre class="query nohighlight">
PREFIX foaf:   &lt;http://xmlns.com/foaf/0.1/&gt;
DESCRIBE ?x
WHERE    { ?x foaf:name "Alice" }
              </pre>
            </div>
          </div>
          <p>More than one IRI or variable can be given:</p>
          <div class="exampleGroup">
            <div class="queryGroup">
              <pre class="query nohighlight">
PREFIX foaf:   &lt;http://xmlns.com/foaf/0.1/&gt;
DESCRIBE ?x ?y &lt;http://example.org/&gt;
WHERE    {?x foaf:knows ?y}
              </pre>
            </div>
          </div>
        </section>
        <section id="descriptionsOfResources">
          <h4>Descriptions of Resources</h4>
          <p>The RDF returned is determined by the information publisher. It may be information the
            service deems relevant to the resources being described. It may include information about
            other resources: for example, the RDF data for a book may also include details about the
            author.</p>
          <p>A simple query such as</p>
          <div class="exampleGroup">
            <div class="queryGroup">
              <pre class="query nohighlight">
PREFIX ent:  &lt;http://org.example.com/employees#&gt;
DESCRIBE ?x WHERE { ?x ent:employeeId "1234" }
              </pre>
              <p>might return a description of the employee and some other potentially useful
                details:</p>
              <div class="result">
                <pre class="resultGraph">
@prefix foaf:   &lt;http://xmlns.com/foaf/0.1/&gt; .
@prefix vcard:  &lt;http://www.w3.org/2001/vcard-rdf/3.0&gt; .
@prefix exOrg:  &lt;http://org.example.com/employees#&gt; .
@prefix rdf:    &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .
@prefix owl:    &lt;http://www.w3.org/2002/07/owl#&gt;

_:a     exOrg:employeeId    "1234" ;
        foaf:mbox_sha1sum   "bee135d3af1e418104bc42904596fe148e90f033" ;
        vcard:N
          [ vcard:Family       "Smith" ;
            vcard:Given        "John"  ] .
foaf:mbox_sha1sum  rdf:type  owl:InverseFunctionalProperty .
                </pre>
              </div>
            </div>
          </div>
          <p>which includes the blank node closure for the 
            <a data-cite="vcard-rdf#" class="inform">vCard vocabulary</a> <code>vcard:N</code>.
            Other possible mechanisms for deciding what
            information to return include Concise Bounded Descriptions [[CBD]].</p>
          <p>For a vocabulary such as FOAF, where the resources are typically blank nodes, returning
            sufficient information to identify a node such as the InverseFunctionalProperty
            <code>foaf:mbox_sha1sum</code> as well as information like name and other details recorded
            would be appropriate. In the example, the match to the <code>WHERE</code> clause was
            returned, but this is not required.</p>
        </section>
      </section>
    </section>
    <section id="expressions">
      <h2>Expressions and Testing Values</h2>
      <p>SPARQL <code>FILTERs</code> restrict the solutions of a graph pattern match according to a
        given <a href="#rConstraint">constraint</a>. Specifically, <code>FILTERs</code> eliminate any
        solutions that, when substituted into the expression, either result in an effective boolean
        value of <code>false</code> or produce an error. Effective boolean values are defined in
        section <a href="#ebv">17.2.2 <em>Effective Boolean Value</em></a> and errors are defined in
        [[[XQUERY-31]]] [[XQUERY-31]] section <a data-cite="XQUERY-31#dt-type-error">2.3.1, <em>Kinds of
            Errors</em></a>. These errors have no effect outside of <code>FILTER</code> evaluation.</p>
      <div class="exampleGroup">
        <p><a data-cite="RDF12-CONCEPTS#dfn-literal">RDF Literals</a> have datatypes 
          that determine the value of the literal.</p>
        <pre class="data nohighlight">
@prefix a:          &lt;http://www.w3.org/2000/10/annotation-ns#&gt; .
@prefix dc:         &lt;http://purl.org/dc/elements/1.1/&gt; .

_:a   a:annotates   &lt;http://www.w3.org/TR/rdf-sparql-query/&gt; .
_:a   dc:date       "2004-12-31T19:00:00-05:00" .

_:b   a:annotates   &lt;http://www.w3.org/TR/rdf-sparql-query/&gt; .
_:b   dc:date       "2004-12-31T19:01:00-05:00"^^&lt;http://www.w3.org/2001/XMLSchema#dateTime&gt; .</pre>
        <p>The object of the first <code>dc:date</code> triple is a 
          <a data-cite="RDF12-CONCEPTS#dfn-simple-literal">simple literal</a>
          that has a datatype of <code>xsd:string</code>.
          The second has the datatype <code>xsd:dateTime</code>.
          They are different <a data-cite="RDF12-CONCEPTS#dfn-rdf-term">RDF terms</a>
          with different values.
        </p>
        <p>SPARQL expressions are constructed according to the grammar and provide access to
          functions (named by IRI) and operator functions (invoked by keywords and symbols in the
          SPARQL grammar). SPARQL operators can be used to compare the values of literals:</p>
        <div class="queryGroup">
          <pre class="query nohighlight">
PREFIX a:      &lt;http://www.w3.org/2000/10/annotation-ns#&gt;
PREFIX dc:     &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX xsd:    &lt;http://www.w3.org/2001/XMLSchema#&gt;

SELECT ?annot
WHERE { ?annot  a:annotates  &lt;http://www.w3.org/TR/rdf-sparql-query/&gt; .
        ?annot  dc:date      ?date .
        FILTER ( ?date &gt; "2005-01-01T00:00:00Z"^^xsd:dateTime ) 
}
          </pre>
        </div>
      </div>
      <p>The SPARQL operators are listed in <a href="#OperatorMapping">section 17.3</a> and are
        associated with their productions in the grammar.</p>
      <p>In addition, SPARQL provides the ability to invoke arbitrary functions, including a subset
        of the XPath casting functions, listed in <a href="#FunctionMapping">section 17.5</a>. These
        functions are invoked by name (an IRI) within a SPARQL query. For example:</p>
      <pre class="query nohighlight">
        ... FILTER ( xsd:dateTime(?date) &lt; xsd:dateTime("2005-01-01T00:00:00Z") ) ...</pre>
      <p>Typographical convention in this section: XPath operators are labeled with the prefix
        <code>op:</code>. XPath operators have no namespace; <code>op:</code> is a labeling
        convention.</p>
      <section id="operandDataTypes">
        <h3>Operand Data Types</h3>
        <p>SPARQL functions and operators operate on RDF terms and SPARQL variables. A subset of
          these functions and operators are taken from the [[[XPATH-FUNCTIONS]]] [[XPATH-FUNCTIONS]] and have XML Schema
          <a data-cite="XPATH20#dt-typed-value">typed value</a> arguments and return types. RDF
          <code>literals</code> passed as arguments to these functions and operators are mapped
          to XML Schema typed values with a <a data-cite="XPATH20#dt-string-value">string value</a> of
          the <code>lexical form</code> and an 
          <a href="http://www.w3.org/TR/xmlschema-2/#dt-atomic">atomic datatype</a> corresponding to the
          <span class="type datatypeIRI">datatype IRI</span>. The returned typed values are mapped back
          to RDF <code>literals</code> the same way.</p>
        <p>SPARQL has additional operators which operate on specific subsets of RDF terms. When
          referring to a type, the following terms denote a <code>literal</code> with the
          corresponding [[[XMLSCHEMA-2]]] [[XMLSCHEMA-2]] <span class="type datatypeIRI">datatype
            IRI</span>:</p>
        <ul>
          <li><code><a data-cite="XMLSCHEMA-2#dt-integer">xsd:integer</a></code></li>
          <li><code><a data-cite="XMLSCHEMA-2#dt-decimal">xsd:decimal</a></code></li>
          <li><code><a data-cite="XMLSCHEMA-2#dt-float">xsd:float</a></code></li>
          <li><code><a data-cite="XMLSCHEMA-2#dt-double">xsd:double</a></code></li>
          <li><code><a data-cite="XMLSCHEMA-2#dt-string">xsd:string</a></code></li>
          <li><code><a data-cite="XMLSCHEMA-2#dt-boolean">xsd:boolean</a></code></li>
          <li><code><a data-cite="XMLSCHEMA-2#dt-dateTime">xsd:dateTime</a></code></li>
        </ul>
        <p>The following terms identify additional types used in SPARQL value tests:</p>
        <ul>
          <li><span class="type numeric">numeric</span> denotes <code>literals</code> with
            datatypes <code>xsd:integer</code>, <code>xsd:decimal</code>, <code>xsd:float</code>, and
            <code>xsd:double</code>.</li>
          <li><span class="type RDFterm">RDF term</span> denotes the types <code>IRI</code>,
            <code>literal</code>, and <code>blank node</code>.</li>
          <li><span class="type variable">variable</span> denotes a SPARQL variable.</li>
        </ul>
        <p>The following types are derived from <span class="type numeric">numeric</span> types and
          are valid arguments to functions and operators taking <span class="type numeric">numeric</span> arguments:</p>
        <ul>
          <li>
            <a data-cite="XMLSCHEMA-2#dt-nonPositiveInteger"><code>xsd:nonPositiveInteger</code></a>
          </li>
          <li>
            <a data-cite="XMLSCHEMA-2#dt-negativeInteger"><code>xsd:negativeInteger</code></a>
          </li>
          <li>
            <a data-cite="XMLSCHEMA-2#dt-long"><code>xsd:long</code></a>
          </li>
          <li>
            <a data-cite="XMLSCHEMA-2#dt-int"><code>xsd:int</code></a>
          </li>
          <li>
            <a data-cite="XMLSCHEMA-2#dt-short"><code>xsd:short</code></a>
          </li>
          <li>
            <a data-cite="XMLSCHEMA-2#dt-byte"><code>xsd:byte</code></a>
          </li>
          <li>
            <a data-cite="XMLSCHEMA-2#dt-nonNegativeInteger"><code>xsd:nonNegativeInteger</code></a>
          </li>
          <li>
            <a data-cite="XMLSCHEMA-2#dt-unsignedLong"><code>xsd:unsignedLong</code></a>
          </li>
          <li>
            <a data-cite="XMLSCHEMA-2#dt-unsignedInt"><code>xsd:unsignedInt</code></a>
          </li>
          <li>
            <a data-cite="XMLSCHEMA-2#dt-unsignedShort"><code>xsd:unsignedShort</code></a>
          </li>
          <li>
            <a data-cite="XMLSCHEMA-2#dt-unsignedByte"><code>xsd:unsignedByte</code></a>
          </li>
          <li>
            <a data-cite="XMLSCHEMA-2#dt-positiveInteger"><code>xsd:positiveInteger</code></a>
          </li>
        </ul>
        <p>SPARQL language extensions may treat additional types as being derived from XML schema
          datatypes.</p>
      </section>
      <section id="evaluation">
        <h3>Filter Evaluation</h3>
        <p>SPARQL provides a subset of the functions and operators defined by 
          XQuery <a data-cite="XQUERY-31#mapping">Operator Mapping</a>. 
          The XQuery section <a data-cite="XQUERY-31#id-expression-processing">Expression Processing</a>
          describes the invocation of
          XPath functions. The following rules accommodate the differences in the data and execution
          models between XQuery and SPARQL:</p>
        <ul>
          <li>Unlike XPath/XQuery, SPARQL functions do not process node sequences. When interpreting
            the semantics of XPath functions, assume that each argument is a sequence of a single
            node.</li>
          <li>Functions invoked with an argument of the wrong type will produce a 
            <a data-cite="XQUERY-31#dt-type-error">type error</a>. Effective boolean value arguments (labeled
            "xsd:boolean (EBV)" in the operator mapping table below), are coerced to
            <code>xsd:boolean</code> using the <a href="#ebv">EBV rules</a> in section 17.2.2.
          </li>
          <li>Apart from <a href="#func-bound">BOUND</a>, <a href="#func-coalesce">COALESCE</a>,
            <a href="#func-filter-exists">NOT EXISTS</a> and <a href="#func-filter-exists">EXISTS</a>,
            all functions and operators operate on RDF Terms and will produce a type error if any
            arguments are unbound.
          </li>
          <li>Any expression other than <a href="#func-logical-or">logical-or</a> (<code>||</code>)
            or <a href="#func-logical-and">logical-and</a> (<code>&amp;&</code>) that encounters an
            error will produce that error.
          </li>
          <li>A <a href="#func-logical-or">logical-or</a> that encounters an error on only one branch
            will return TRUE if the other branch is TRUE and an error if the other branch is FALSE.
          </li>
          <li>A <a href="#func-logical-and">logical-and</a> that encounters an error on only one
            branch will return an error if the other branch is TRUE and FALSE if the other branch is
            FALSE.
          </li>
          <li>A <a href="#func-logical-or">logical-or</a> or <a href="#func-logical-and">logical-and</a> that encounters errors on both branches will produce
            <em>either</em> of the errors.
          </li>
        </ul>
        <p>The logical-and and logical-or truth table for true (<span class="truth">T</span>), false
          (<span class="truth">F</span>), and error (<span class="truth error">E</span>) is as
          follows:</p>
        <div id="truthTable"></div>
        <table class="truthTable">
          <thead>
            <tr>
              <th>A</th>
              <th>B</th>
              <th>A || B</th>
              <th>A &amp;& B</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <th>T</th>
              <th>T</th>
              <td>T</td>
              <td>T</td>
            </tr>
            <tr>
              <th>T</th>
              <th>F</th>
              <td>T</td>
              <td>F</td>
            </tr>
            <tr>
              <th>F</th>
              <th>T</th>
              <td>T</td>
              <td>F</td>
            </tr>
            <tr>
              <th>F</th>
              <th>F</th>
              <td>F</td>
              <td>F</td>
            </tr>
          </tbody>
          <tbody>
            <tr>
              <th>T</th>
              <th><span class="error">E</span></th>
              <td>T</td>
              <td><span class="error">E</span></td>
            </tr>
            <tr>
              <th><span class="error">E</span></th>
              <th>T</th>
              <td>T</td>
              <td><span class="error">E</span></td>
            </tr>
            <tr>
              <th>F</th>
              <th><span class="error">E</span></th>
              <td><span class="error">E</span></td>
              <td>F</td>
            </tr>
            <tr>
              <th><span class="error">E</span></th>
              <th>F</th>
              <td><span class="error">E</span></td>
              <td>F</td>
            </tr>
            <tr>
              <th><span class="error">E</span></th>
              <th><span class="error">E</span></th>
              <td><span class="error">E</span></td>
              <td><span class="error">E</span></td>
            </tr>
          </tbody>
        </table>
        <section id="invocation">
          <h4>Invocation</h4>
          <p>SPARQL defines a syntax for invoking functions on a list of arguments. Unless otherwise
            noted, these are invoked as follows:</p>
          <ul>
            <li>Argument expressions are evaluated, producing argument values. The order of argument
              evaluation is not defined.</li>
            <li>Numeric arguments are promoted as necessary to fit the expected types for that
              function or operator.</li>
            <li>The function or operator is invoked on the argument values.</li>
          </ul>
          <p>If any of these steps fails, the invocation generates an error. The effects of errors
            are defined in <a href="#evaluation">Filter Evaluation</a>.</p>
          <p>There are also "<a href="#func-forms">functional forms</a>" which have different
            evaluation rules to functions as specified by each such form.</p>
        </section>
        <section id="ebv">
          <h4>Effective Boolean Value (EBV)</h4>
          <p>Effective boolean value is used to calculate the arguments to the logical functions
            <a href="#func-logical-and">logical-and</a>, <a href="#func-logical-or">logical-or</a>, and
            <a data-cite="XPATH-FUNCTIONS#func-not">fn:not</a>, as well as evaluate the result of a
            <code>FILTER</code> expression.</p>
          <p>The XQuery <a data-cite="XQUERY-31#id-ebv">Effective Boolean Value</a> rules rely on the
            definition of XPath's <a data-cite="XPATH-FUNCTIONS#func-boolean">fn:boolean</a>. The following
            rules reflect the rules for <code>fn:boolean</code> applied to the argument types present
            in SPARQL queries:</p>
          <ul>
            <li>The EBV of any literal whose type is <code>xsd:boolean</code> or 
              <span class="type">numeric</span> is false if the lexical form is not valid for that
              datatype, such as <code>"abc"^^xsd:integer</code>.</li>
            <li>If the argument is a <span class="type typedLiteral">typed literal</span> with a
              <span class="type datatype">datatype</span> of <code>xsd:boolean</code>, and it has a
              valid lexical form, the EBV is the value of that argument.</li>
            <li>If the argument is a literal with a 
              <span class="type datatype">datatype</span> of <code>xsd:string</code>, the EBV is false if the
              operand value has zero length; otherwise the EBV is true.</li>
            <li>If the argument is a <span class="type numeric">numeric</span> type or a 
              <span class="type typedLiteral">typed literal</span> with a datatype derived from a 
              <span class="type numeric">numeric</span> type, and it has a valid lexical form, the EBV is false if
              the operand value is NaN or is numerically equal to zero; otherwise the EBV is true.</li>
            <li>All other arguments, including unbound arguments, produce a type error.</li>
          </ul>
          <p>An EBV of <code>true</code> is represented as a <span class="type typedLiteral">typed
              literal</span> with a datatype of <code>xsd:boolean</code> and a lexical value of "true";
            an EBV of false is represented as a <span class="type literal">literal</span>
            with a datatype of <code>xsd:boolean</code> and a lexical value of "false".</p>
        </section>
      </section>
      <section id="OperatorMapping">
        <h3>Operator Mapping</h3>
        <p>The SPARQL grammar identifies a set of operators 
          (for instance, <code><span class="token">&amp;&amp;</span></code>, 
          <code><span class="token">*</span></code>, <code><span class="token">isIRI</span></code>) used
          to construct constraints. The following table associates each of these grammatical
          productions with the appropriate operands and an operator function defined by either
          [[[XPATH-FUNCTIONS]]] [[XPATH-FUNCTIONS]] or the SPARQL operators specified in <a href="#SparqlOps">section
            17.4</a>. When selecting the operator definition for a given set of parameters, the
          definition with the most specific parameters applies. For instance, when evaluating
          <code>xsd:integer = xsd:signedInt</code>, the definition for <code>=</code> with two
          <code>numeric</code> parameters applies, rather than the one with two
          <span class="type RDFterm">RDF terms</span>. The table is arranged so that the upper-most viable
          candidate is the most specific. Operators invoked without appropriate operands result in a
          type error.</p>
        <p>SPARQL follows XPath's scheme for numeric type promotions and subtype substitution for
          arguments to numeric operators. The <a data-cite="XPATH20#mapping">XPath Operator Mapping</a>
          rules for <span class="type numeric">numeric</span> operands (<code>xsd:integer</code>,
          <code>xsd:decimal</code>, <code>xsd:float</code>, <code>xsd:double</code>, and types derived
          from a <span class="type numeric">numeric</span> type) apply to SPARQL operators as well (see
          [[[XPATH20]]] [[XPATH20]] for definitions of <a data-cite="XPATH20#promotion">numeric type
            promotions</a> and <a data-cite="XPATH20#dt-subtype-substitution">subtype substitution</a>).
          Some of the operators are associated with nested function expressions, e.g.
          <code>fn:not(op:numeric-equal(A, B))</code>. Note that per the XPath definitions,
          <code>fn:not</code> and <code>op:numeric-equal</code> produce an error if their argument is
          an error.</p>
        <p>The collation for <code>fn:compare</code> is <a data-cite="XPATH-FUNCTIONS#collations">defined by
            XPath</a> and identified by
          <code>http://www.w3.org/2005/xpath-functions/collation/codepoint</code>. This collation
          allows for string comparison based on code point values. Codepoint string equivalence can be
          tested with <span class="type RDFterm">RDF term</span> equivalence.</p>

        <table title="SPARQL Unary Operators" class="FAndOTable">
          <caption>
            SPARQL Unary Operators
          </caption>
          <tbody>
            <tr>
              <th class="major" scope="col">Operator</th>
              <th class="major" scope="col">Type(A)</th>
              <th class="major" scope="col">Function</th>
              <th class="major" scope="col">Result type</th>
            </tr>
            <tr>
              <th colspan="4" class="subHeading" scope="col">XQuery Unary Operators</th>
            </tr>
            <tr>
              <th scope="row">
                <a href="#rUnaryExpression" title="UnaryExpression"><span class="FAOTtoken">!</span>
                  A</a>
              </th>
              <td>
                xsd:boolean <a href="#ebv-arg">(EBV)</a>
              </td>
              <td class="xpathOp">
                <a data-cite="XPATH-FUNCTIONS#func-not">fn:not</a>(A)
              </td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row">
                <a href="#rUnaryExpression" title="UnaryExpression"><span class="FAOTtoken">+</span>
                  A</a>
              </th>
              <td><span class="type numeric">numeric</span></td>
              <td class="xpathOp">
                <a data-cite="XPATH-FUNCTIONS#func-numeric-unary-plus">op:numeric-unary-plus</a>(A)
              </td>
              <td><span class="type numeric">numeric</span></td>
            </tr>
            <tr>
              <th scope="row">
                <a href="#rUnaryExpression" title="UnaryExpression"><span class="FAOTtoken">-</span>
                  A</a>
              </th>
              <td><span class="type numeric">numeric</span></td>
              <td class="xpathOp">
                <a data-cite="XPATH-FUNCTIONS#func-numeric-unary-minus">op:numeric-unary-minus</a>(A)
              </td>
              <td><span class="type numeric">numeric</span></td>
            </tr>
          </tbody>
        </table>
        <table title="SPARQL Binary Operators" class="FAndOTable">
          <caption>
            SPARQL Binary Operators
          </caption>
          <tbody>
            <tr>
              <th class="major" scope="col">Operator</th>
              <th class="major" scope="col">Type(A)</th>
              <th class="major" scope="col">Type(B)</th>
              <th class="major" scope="col">Function</th>
              <th class="major" scope="col">Result type</th>
            </tr>
            <tr>
              <th colspan="5" class="subHeading" scope="col">Logical Connectives</th>
            </tr>
            <tr>
              <th>
                <a href="#rConditionalOrExpression" title="ConditionalOrExpression">A <span class="FAOTtoken">||</span> B</a>
              </th>
              <td>
                xsd:boolean <a href="#ebv-arg">(EBV)</a>
              </td>
              <td>
                xsd:boolean <a href="#ebv-arg">(EBV)</a>
              </td>
              <td class="sparqlOp">
                <a href="#func-logical-or" class="SPARQLoperator">logical-or</a>(A, B)
              </td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th>
                <a href="#rConditionalAndExpression" title="ConditionalAndExpression">A <span class="FAOTtoken">&amp;&</span> B</a>
              </th>
              <td>
                xsd:boolean <a href="#ebv-arg">(EBV)</a>
              </td>
              <td>
                xsd:boolean <a href="#ebv-arg">(EBV)</a>
              </td>
              <td class="sparqlOp">
                <a href="#func-logical-and" class="SPARQLoperator">logical-and</a>(A, B)
              </td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th colspan="5" class="subHeading" scope="col">XPath Tests</th>
            </tr>
            <tr>
              <th scope="row">
                <a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">=</span> B</a>
              </th>
              <td><span class="type numeric">numeric</span></td>
              <td><span class="type numeric">numeric</span></td>
              <td class="xpathOp">
                <a data-cite="XPATH-FUNCTIONS#func-numeric-equal">op:numeric-equal</a>(A, B)
              </td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row">
                <a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">=</span> B</a>
              </th>
              <td>xsd:string</td>
              <td>xsd:string</td>
              <td class="xpathOp">
                <a data-cite="XPATH-FUNCTIONS#func-numeric-equal">op:numeric-equal</a>(<a data-cite="XPATH-FUNCTIONS#func-compare">fn:compare</a>(<a href="#func-str" class="FAOTtoken">STR</a>(A), <a href="#func-str" class="FAOTtoken">STR</a>(B)), 0)
              </td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row">
                <a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">=</span> B</a>
              </th>
              <td>xsd:boolean</td>
              <td>xsd:boolean</td>
              <td class="xpathOp">
                <a data-cite="XPATH-FUNCTIONS#func-boolean-equal">op:boolean-equal</a>(A, B)
              </td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row">
                <a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">=</span> B</a>
              </th>
              <td>xsd:dateTime</td>
              <td>xsd:dateTime</td>
              <td class="xpathOp">
                <a data-cite="XPATH-FUNCTIONS#func-dateTime-equal">op:dateTime-equal</a>(A, B)
              </td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row">
                <a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">!=</span> B</a>
              </th>
              <td><span class="type numeric">numeric</span></td>
              <td><span class="type numeric">numeric</span></td>
              <td class="xpathOp">
                <a data-cite="XPATH-FUNCTIONS#func-not">fn:not</a>(<a data-cite="XPATH-FUNCTIONS#func-numeric-equal">op:numeric-equal</a>(A, B))
              </td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row">
                <a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">!=</span> B</a>
              </th>
              <td>xsd:string</td>
              <td>xsd:string</td>
              <td class="xpathOp">
                <a data-cite="XPATH-FUNCTIONS#func-not">fn:not</a>(<a data-cite="XPATH-FUNCTIONS#func-numeric-equal">op:numeric-equal</a>(<a data-cite="XPATH-FUNCTIONS#func-compare">fn:compare</a>(<a href="#func-str" class="FAOTtoken">STR</a>(A), <a href="#func-str" class="FAOTtoken">STR</a>(B)), 0))
              </td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row">
                <a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">!=</span> B</a>
              </th>
              <td>xsd:boolean</td>
              <td>xsd:boolean</td>
              <td class="xpathOp">
                <a data-cite="XPATH-FUNCTIONS#func-not">fn:not</a>(<a data-cite="XPATH-FUNCTIONS#func-boolean-equal">op:boolean-equal</a>(A, B))
              </td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row">
                <a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">!=</span> B</a>
              </th>
              <td>xsd:dateTime</td>
              <td>xsd:dateTime</td>
              <td class="xpathOp">
                <a data-cite="XPATH-FUNCTIONS#func-not">fn:not</a>(<a data-cite="XPATH-FUNCTIONS#func-dateTime-equal">op:dateTime-equal</a>(A, B))
              </td>
              <td>xsd:boolean</td>
            </tr>
            <tr id="op_lt">
              <th scope="row">
                <a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&lt;</span> B</a>
              </th>
              <td><span class="type numeric">numeric</span></td>
              <td><span class="type numeric">numeric</span></td>
              <td class="xpathOp">
                <a data-cite="XPATH-FUNCTIONS#func-numeric-less-than">op:numeric-less-than</a>(A, B)
              </td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row">
                <a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&lt;</span> B</a>
              </th>
              <td>xsd:string</td>
              <td>xsd:string</td>
              <td class="xpathOp">
                <a data-cite="XPATH-FUNCTIONS#func-numeric-equal">op:numeric-equal</a>(<a data-cite="XPATH-FUNCTIONS#func-compare">fn:compare</a>(<a href="#func-str" class="FAOTtoken">STR</a>(A), <a href="#func-str" class="FAOTtoken">STR</a>(B)), -1)
              </td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row">
                <a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&lt;</span> B</a>
              </th>
              <td>xsd:boolean</td>
              <td>xsd:boolean</td>
              <td class="xpathOp">
                <a data-cite="XPATH-FUNCTIONS#func-boolean-less-than">op:boolean-less-than</a>(A, B)
              </td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row">
                <a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&lt;</span> B</a>
              </th>
              <td>xsd:dateTime</td>
              <td>xsd:dateTime</td>
              <td class="xpathOp">
                <a data-cite="XPATH-FUNCTIONS#func-dateTime-less-than">op:dateTime-less-than</a>(A, B)
              </td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row">
                <a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&gt;</span> B</a>
              </th>
              <td><span class="type numeric">numeric</span></td>
              <td><span class="type numeric">numeric</span></td>
              <td class="xpathOp">
                <a data-cite="XPATH-FUNCTIONS#func-numeric-greater-than">op:numeric-greater-than</a>(A, B)
              </td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row">
                <a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&gt;</span> B</a>
              </th>
              <td>xsd:string</td>
              <td>xsd:string</td>
              <td class="xpathOp">
                <a data-cite="XPATH-FUNCTIONS#func-numeric-equal">op:numeric-equal</a>(<a data-cite="XPATH-FUNCTIONS#func-compare">fn:compare</a>(<a href="#func-str" class="FAOTtoken">STR</a>(A), <a href="#func-str" class="FAOTtoken">STR</a>(B)), 1)
              </td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row">
                <a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&gt;</span> B</a>
              </th>
              <td>xsd:boolean</td>
              <td>xsd:boolean</td>
              <td class="xpathOp">
                <a data-cite="XPATH-FUNCTIONS#func-boolean-greater-than">op:boolean-greater-than</a>(A, B)
              </td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row">
                <a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&gt;</span> B</a>
              </th>
              <td>xsd:dateTime</td>
              <td>xsd:dateTime</td>
              <td class="xpathOp">
                <a data-cite="XPATH-FUNCTIONS#func-dateTime-greater-than">op:dateTime-greater-than</a>(A, B)
              </td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row">
                <a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&lt;=</span> B</a>
              </th>
              <td><span class="type numeric">numeric</span></td>
              <td><span class="type numeric">numeric</span></td>
              <td class="xpathOp">
                <a href="#func-logical-or" class="SPARQLoperator">logical-or</a>(<a data-cite="XPATH-FUNCTIONS#func-numeric-less-than">op:numeric-less-than</a>(A, B),
                <a data-cite="XPATH-FUNCTIONS#func-numeric-equal">op:numeric-equal</a>(A, B))
              </td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row">
                <a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&lt;=</span> B</a>
              </th>
              <td>xsd:string</td>
              <td>xsd:string</td>
              <td class="xpathOp">
                <a data-cite="XPATH-FUNCTIONS#func-not">fn:not</a>(<a data-cite="XPATH-FUNCTIONS#func-numeric-equal">op:numeric-equal</a>(<a data-cite="XPATH-FUNCTIONS#func-compare">fn:compare</a>(<a href="#func-str" class="FAOTtoken">STR</a>(A), <a href="#func-str" class="FAOTtoken">STR</a>(B)), 1))
              </td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row">
                <a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&lt;=</span> B</a>
              </th>
              <td>xsd:boolean</td>
              <td>xsd:boolean</td>
              <td class="xpathOp">
                <a data-cite="XPATH-FUNCTIONS#func-not">fn:not</a>(<a data-cite="XPATH-FUNCTIONS#func-boolean-greater-than">op:boolean-greater-than</a>(A, B))
              </td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row">
                <a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&lt;=</span> B</a>
              </th>
              <td>xsd:dateTime</td>
              <td>xsd:dateTime</td>
              <td class="xpathOp">
                <a data-cite="XPATH-FUNCTIONS#func-not">fn:not</a>(<a data-cite="XPATH-FUNCTIONS#func-dateTime-greater-than">op:dateTime-greater-than</a>(A, B))
              </td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row">
                <a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&gt;=</span> B</a>
              </th>
              <td><span class="type numeric">numeric</span></td>
              <td><span class="type numeric">numeric</span></td>
              <td class="xpathOp">
                <a href="#func-logical-or" class="SPARQLoperator">logical-or</a>(<a data-cite="XPATH-FUNCTIONS#func-numeric-greater-than">op:numeric-greater-than</a>(A, B),
                <a data-cite="XPATH-FUNCTIONS#func-numeric-equal">op:numeric-equal</a>(A, B))
              </td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row">
                <a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&gt;=</span> B</a>
              </th>
              <td>xsd:string</td>
              <td>xsd:string</td>
              <td class="xpathOp">
                <a data-cite="XPATH-FUNCTIONS#func-not">fn:not</a>(<a data-cite="XPATH-FUNCTIONS#func-numeric-equal">op:numeric-equal</a>(<a data-cite="XPATH-FUNCTIONS#func-compare">fn:compare</a>(<a href="#func-str" class="FAOTtoken">STR</a>(A), <a href="#func-str" class="FAOTtoken">STR</a>(B)), -1))
              </td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row">
                <a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&gt;=</span> B</a>
              </th>
              <td>xsd:boolean</td>
              <td>xsd:boolean</td>
              <td class="xpathOp">
                <a data-cite="XPATH-FUNCTIONS#func-not">fn:not</a>(<a data-cite="XPATH-FUNCTIONS#func-boolean-less-than">op:boolean-less-than</a>(A, B))
              </td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row">
                <a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&gt;=</span> B</a>
              </th>
              <td>xsd:dateTime</td>
              <td>xsd:dateTime</td>
              <td class="xpathOp">
                <a data-cite="XPATH-FUNCTIONS#func-not">fn:not</a>(<a data-cite="XPATH-FUNCTIONS#func-dateTime-less-than">op:dateTime-less-than</a>(A, B))
              </td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th colspan="5" class="subHeading" scope="col">XPath Arithmetic</th>
            </tr>
            <tr>
              <th scope="row">
                <a href="#rMultiplicativeExpression" title="MultiplicativeExpression">A <span class="FAOTtoken">*</span> B</a>
              </th>
              <td><span class="type numeric">numeric</span></td>
              <td><span class="type numeric">numeric</span></td>
              <td class="xpathOp">
                <a data-cite="XPATH-FUNCTIONS#func-numeric-multiply">op:numeric-multiply</a>(A, B)
              </td>
              <td><span class="type numeric">numeric</span></td>
            </tr>
            <tr>
              <th scope="row">
                <a href="#rMultiplicativeExpression" title="MultiplicativeExpression">A <span class="FAOTtoken">/</span> B</a>
              </th>
              <td><span class="type numeric">numeric</span></td>
              <td><span class="type numeric">numeric</span></td>
              <td class="xpathOp">
                <a data-cite="XPATH-FUNCTIONS#func-numeric-divide">op:numeric-divide</a>(A, B)
              </td>
              <td><span class="type numeric">numeric</span>; but xsd:decimal if both operands are
                xsd:integer</td>
            </tr>
            <tr>
              <th scope="row">
                <a href="#rAdditiveExpression" title="AdditiveExpression">A <span class="FAOTtoken">+</span> B</a>
              </th>
              <td><span class="type numeric">numeric</span></td>
              <td><span class="type numeric">numeric</span></td>
              <td class="xpathOp">
                <a data-cite="XPATH-FUNCTIONS#func-numeric-add">op:numeric-add</a>(A, B)
              </td>
              <td><span class="type numeric">numeric</span></td>
            </tr>
            <tr>
              <th scope="row">
                <a href="#rAdditiveExpression" title="AdditiveExpression">A <span class="FAOTtoken">-</span> B</a>
              </th>
              <td><span class="type numeric">numeric</span></td>
              <td><span class="type numeric">numeric</span></td>
              <td class="xpathOp">
                <a data-cite="XPATH-FUNCTIONS#func-numeric-subtract">op:numeric-subtract</a>(A, B)
              </td>
              <td><span class="type numeric">numeric</span></td>
            </tr>
            <tr>
              <th colspan="5" class="subHeading" scope="col">SPARQL Tests</th>
            </tr>
            <tr>
              <th>
                <a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">=</span> B</a>
              </th>
              <td><span class="type RDFterm">RDF term</span></td>
              <td><span class="type RDFterm">RDF term</span></td>
              <td class="xpathOp">
                <a href="#func-RDFterm-equal" class="SPARQLoperator">RDFterm-equal</a>(A, B)
              </td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th>
                <a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">!=</span> B</a>
              </th>
              <td><span class="type RDFterm">RDF term</span></td>
              <td><span class="type RDFterm">RDF term</span></td>
              <td class="xpathOp">
                <a data-cite="XPATH-FUNCTIONS#func-not">fn:not</a>(<a href="#func-RDFterm-equal" class="SPARQLoperator">RDFterm-equal</a>(A, B))
              </td>
              <td>xsd:boolean</td>
            </tr>
          </tbody>
        </table>
        <div id="ebv-arg"></div>xsd:boolean function arguments marked with "(EBV)" are
        coerced to xsd:boolean by evaluating the <a href="#ebv">effective boolean value of that
          argument.</a>
        <section id="operatorExtensibility">
          <h4>Operator Extensibility</h4>
          <p>SPARQL language extensions may provide additional associations between operators and
            operator functions; this amounts to adding rows to the table above. No additional operator
            may yield a result that replaces any result other than a type error.
            The consequence of this rule is that SPARQL <code>FILTER</code>s will
            produce <em>at least</em> the same intermediate bindings after applying a
            <code>FILTER</code> as an unextended implementation.</p>
          <p>Additional mappings of the '&lt;' operator are expected to control the relative ordering
            of the operands, specifically, when used in an <a href="#modOrderBy"><code>ORDER
                BY</code></a> clause.</p>
        </section>
      </section>
      <section id="SparqlOps">
        <h3>Function Definitions</h3>
        <p>This section defines the operators and functions introduced by the SPARQL Query language.
          The examples show the behavior of the operators as invoked by the appropriate grammatical
          constructs.</p>
        <section id="func-forms">
          <h4>Functional Forms</h4>
          <section id="func-bound">
            <h5>BOUND</h5>
            <pre class="prototype nohighlight"><span class="return">xsd:boolean</span>  <span class="operator">BOUND</span> (<span class="type">variable</span> <span class="name">var</span>)</pre>
            <p>Returns <code>true</code> if <code>var</code> is bound to a value. Returns false
              otherwise. Variables with the value NaN or INF are considered bound.</p>
            <div class="exampleGroup">
              <p>Data:</p>
              <pre class="data nohighlight">
@prefix foaf:        &lt;http://xmlns.com/foaf/0.1/&gt; .
@prefix dc:          &lt;http://purl.org/dc/elements/1.1/&gt; .
@prefix xsd:          &lt;http://www.w3.org/2001/XMLSchema#&gt; .

_:a  foaf:givenName  "Alice".

_:b  foaf:givenName  "Bob" .
_:b  dc:date         "2005-04-04T04:04:04Z"^^xsd:dateTime .
              </pre>
              <div class="queryGroup">
                <pre class="query nohighlight">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX dc:   &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX xsd:   &lt;http://www.w3.org/2001/XMLSchema#&gt;
SELECT ?givenName
WHERE {
   ?x foaf:givenName  ?givenName .
   OPTIONAL { ?x dc:date ?date } .
   FILTER ( bound(?date) )
}
                </pre>
                <p>Query result:</p>
                <div class="result">
                  <table class="resultTable">
                    <tbody>
                      <tr>
                        <th>givenName</th>
                      </tr>
                      <tr>
                        <td>"Bob"</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
              <p>One may test whether a graph pattern is <em>not</em> expressed by specifying an
              <code>OPTIONAL</code> graph pattern
              that introduces a variable and testing to see whether the variable is not
                <span class="term">bound</span>
                This is called <em>Negation as Failure</em> in logic programming.</p>
              <div class="queryGroup">
                <p>This query matches the people with a <code>name</code> but <em>no</em> expressed
                  <code>date</code>:</p>
                <pre class="query nohighlight">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX dc:   &lt;http://purl.org/dc/elements/1.1/&gt;
SELECT ?name
WHERE { 
    ?x foaf:givenName  ?name .
    OPTIONAL { ?x dc:date ?date } .
    FILTER (!bound(?date))
 }
                </pre>
                <p>Query result:</p>
                <div class="result">
                  <table class="resultTable">
                    <tbody>
                      <tr>
                        <th>name</th>
                      </tr>
                      <tr>
                        <td>"Alice"</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
            <p>Because Bob's <code>dc:date</code> was known, <code>"Bob"</code> was not a solution to
              the query.</p>
          </section>
          <section id="func-if">
            <h5>IF</h5>
            <pre class="prototype nohighlight"><span class="return">rdfTerm</span>  <span class="operator">IF</span> (<span class="expression">expression1</span>, <span class="expression">expression2</span>, <span class="expression">expression3</span>)</pre>
            <p>The <code>IF</code> function form evaluates the first argument, interprets it as a
              <a href="#ebv">effective boolean value</a>, then returns the value of
              <code>expression2</code> if the EBV is true, otherwise it returns the value of
              <code>expression3</code>. Only one of <code>expression2</code> and
              <code>expression3</code> is evaluated. If evaluating the first argument raises an error,
              then an error is raised for the evaluation of the <code>IF</code> expression.</p>
            <p>Examples: Suppose ?x = 2, ?z = 0 and ?y is not bound in some query solution:</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>IF(?x = 2, "yes", "no")</code></td>
                    <td>returns "yes"</td>
                  </tr>
                  <tr>
                    <td><code>IF(bound(?y), "yes", "no")</code></td>
                    <td>returns "no"</td>
                  </tr>
                  <tr>
                    <td><code>IF(?x=2, "yes", 1/?z)</code></td>
                    <td>returns "yes", the expression <code>1/?z</code> is not evaluated</td>
                  </tr>
                  <tr>
                    <td><code>IF(?x=1, "yes", 1/?z)</code></td>
                    <td>raises an error</td>
                  </tr>
                  <tr>
                    <td><code>IF("2" &gt; 1, "yes", "no")</code></td>
                    <td>raises an error</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-coalesce">
            <h5>COALESCE</h5>
            <pre class="prototype nohighlight">
              <span class="return">rdfTerm</span> <span class="operator">COALESCE</span>(<span
class="expression">expression, ....</span>)
            </pre>
            <p>The <code>COALESCE</code> function form returns the RDF term value of the first
              expression that evaluates without error. In SPARQL, evaluating an unbound variable raises
              an error.</p>
            <p>If none of the arguments evaluates to an RDF term, an error is raised. If no
              expressions are evaluated without error, an error is raised.</p>
            <p>Examples: Suppose ?x = 2 and ?y is not bound in some query solution:</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>COALESCE(?x, 1/0)</code></td>
                    <td>returns 2, the value of <code>x</code></td>
                  </tr>
                  <tr>
                    <td><code>COALESCE(1/0, ?x)</code></td>
                    <td>returns 2</td>
                  </tr>
                  <tr>
                    <td><code>COALESCE(5, ?x)</code></td>
                    <td>returns 5</td>
                  </tr>
                  <tr>
                    <td><code>COALESCE(?y, 3)</code></td>
                    <td>returns 3</td>
                  </tr>
                  <tr>
                    <td><code>COALESCE(?y)</code></td>
                    <td>raises an error because <code>y</code> is not bound.</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-filter-exists">
            <h5>NOT EXISTS and EXISTS</h5>
            <p>There is a filter operator <code>EXISTS</code> that takes a graph pattern.
              <code>EXISTS</code> returns <code>true</code>/<code>false</code> depending on whether the
              pattern matches the dataset given the bindings in the current group graph pattern, the
              dataset and the <a href="#defn_ActiveGraph">active graph</a> at this point in the query
              evaluation. No additional binding of variables occurs. The <code>NOT EXISTS</code> form
              translates into <code>fn:not(EXISTS{...})</code>.</p>
            <pre class="prototype nohighlight"> 
<span class="return">xsd:boolean</span>  <span class="operator">NOT EXISTS</span> { <span class="pattern">pattern</span> }
            </pre>
            <p>Returns <code>false</code> if <code>pattern</code> matches. Returns true
              otherwise.</p>
            <p><code>NOT EXISTS { pattern }</code> is equivalent to <code>fn:not(EXISTS { pattern
                })</code>.</p>
            <pre class="prototype nohighlight"> 
<span class="return">xsd:boolean</span> EXISTS { <span class="pattern">pattern</span> }
            </pre>
            <p>Returns <code>true</code> if <code>pattern</code> matches. Returns false
              otherwise.</p>
            <p>Variables in the <code>pattern</code> that are bound in the current 
              <a data-cite="SPARQL11-QUERY#defn_sparqlSolutionMapping">solution mapping</a> take the value that they
              have from the solution mapping. Variables in the pattern <code>pattern</code> that are
              not bound in the current solution mapping take part in pattern matching.</p>
            <p>To facilitate this, we introduce a function <a href="#defn_exists">Exists</a> that
              evaluates a SPARQL Algebra expression and returns true or false, depending on whether
              there are any solutions to the pattern, given the solution mapping being tested by the
              filter operation.</p>
          </section>
          <section id="func-logical-or">
            <h5>logical-or</h5>
            <pre class="prototype nohighlight">
              <span class="return">xsd:boolean</span> <span class="operator" style="text-transform: none;">logical-or</span> (<span class="type">xsd:boolean</span> <span class="name">left</span>, <span class="type">xsd:boolean</span> <span class="name">right</span>)
            </pre>
            <p>This function cannot be used directly in expressions. 
              The purpose of this function is to define the semantics of the "<code>||</code>" operator.</p>
            <p>The function returns a logical <code>OR</code> of <code>left</code> and <code>right</code>. 
              Note that <span class="SPARQLoperator">logical-or</span> operates on the 
              <a href="#ebv">effective boolean value</a> of its arguments.</p>
            <p>Note: see section 17.2, <a href="#evaluation">Filter Evaluation</a>, for the
              <code>||</code> operator's treatment of errors.</p>
          </section>
          <section id="func-logical-and">
            <h5>logical-and</h5>
            <pre class="prototype nohighlight">
              <span class="return">xsd:boolean</span> <span class="operator" style="text-transform: none;">logical-and</span> (<span class="type">xsd:boolean</span> <span class="name">left</span>, <span class="type">xsd:boolean</span> <span class="name">right</span>)
            </pre>
            <p>This function cannot be used directly in expressions. The purpose of this function is to define the semantics of the "<code>&amp;&amp;</code>" operator.</p>
            <p>The function returns a logical <code>AND</code> of <code>left</code> and <code>right</code>.
              Note that <span class="SPARQLoperator">logical-and</span> operates on the 
              <a href="#ebv">effective boolean value</a> of its arguments.</p>
            <p>Note: see section 17.2, <a href="#evaluation">Filter Evaluation</a>, for the
              <code>&amp;&</code> operator's treatment of errors.</p>
          </section>
          <section id="func-RDFterm-equal">
            <h5>RDFterm-equal</h5>
            <pre class="prototype nohighlight">
              <span class="return">xsd:boolean</span> <span class="operator" style="text-transform: none;">RDFterm-equal</span> (<span class="type"><span class="type RDFterm">RDF term</span></span> <span class="name">term1</span>, <span class="type"><span class="type RDFterm">RDF term</span></span> <span class="name">term2</span>)
            </pre>
            <p>This function cannot be used directly in expressions. The purpose of this function is to define the semantics of the "=" operator when applied to two RDF terms that do not fall into any of the other, more concrete cases covered in the operator mapping table in Section&nbsp;<a href="#OperatorMapping" class="sectionRef"></a>.</p>
            <p>The function is defined as follows:</p>
            <ul>
                <li>Returns TRUE if <code>term1</code> and <code>term2</code> are <em>equal</em> RDF terms, as defined below.</li>
                <li>Produces a type error if <code>term1</code> and <code>term2</code> are both literals having the
              same <a data-cite="RDF12-CONCEPTS#dfn-datatype-iri">datatype IRI</a>; this datatype IRI is <em>not</em> in the
              set of <a data-cite="RDF12-CONCEPTS#dfn-recognized-datatype-iri">recognized datatype IRIs</a>; and the
              <a data-cite="RDF12-CONCEPTS#dfn-lexical-form">lexical forms</a> of the two literals are different from one another.</li>
                <li>Returns FALSE otherwise.</li>
            </ul>
            <p>
              <code>term1</code> and <code>term2</code> are <em>equal</em> RDF terms if any of the following is
              true:</p>
            <ul>
              <li>
                <span class="name">term1</span> is an <span class="IRI type">IRI</span> and <span class="name">term2</span> is an <span class="IRI type">IRI</span>
                such that these two <span class="IRI type">IRIs</span> are equal as per the notion of <a data-cite="RDF12-CONCEPTS#dfn-iri-equality">IRI equality</a> of
                [[RDF12-CONCEPTS]].
              </li>
              <li>
                <span class="name">term1</span> is a <span class="literal type">literal</span> and
                <span class="name">term2</span> is a <span class="literal type">literal</span> such that
                these two <span class="literal type">literals</span> are equal as per the notion of <a data-cite="RDF12-CONCEPTS#dfn-literal-term-equality">Literal term equality</a> of
                [[RDF12-CONCEPTS]].
              </li>
              <li>
                <span class="name">term1</span> is a <span class="literal type">literal</span> and
                <span class="name">term2</span> is a <span class="literal type">literal</span>
                such that the <a data-cite="RDF12-CONCEPTS#dfn-datatype-iri">datatype IRI</a>
                of each of these two literals is in the set of
                <a data-cite="RDF12-CONCEPTS#dfn-recognized-datatype-iri">recognized datatype IRIs</a>
                and both literals have the same <a data-cite="RDF12-CONCEPTS#dfn-literal-value">literal value</a>.
              </li>
              <li>
                <span class="name">term1</span> and <span class="name">term2</span> are the same
                <span class="bnode type">blank node</span>.
              </li>
            </ul>
            <p id="func-RDFterm-equal-note1" class="note">
              An extended implementation may support additional datatypes for literals. An
              implementation processing a query that tests for equivalence of literals with non-recognized datatypes
              (and non-identical lexical form and datatype IRI) returns an error, indicating that it
              is unable to determine whether or not the values of the compared literals are equivalent. For example, an
              unextended implementation will produce an error when testing either <span class="queryExcerpt"><code>"iiii"^^my:romanNumeral =
                  "iv"^^my:romanNumeral</code></span> or <span class="queryExcerpt"><code>"iiii"^^my:romanNumeral !=
                  "iv"^^my:romanNumeral</code></span>.</p>
            <div class="exampleGroup">
              <pre class="data nohighlight">
@prefix foaf:       &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a  foaf:name       "Alice".
_:a  foaf:mbox       &lt;mailto:alice@work.example&gt; .

_:b  foaf:name       "Ms A.".
_:b  foaf:mbox       &lt;mailto:alice@work.example&gt; .
              </pre>
              <div class="queryGroup">
                <p>This query finds the people who have multiple <code>foaf:name</code> triples:</p>
                <pre class="query nohighlight">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name1 ?name2
WHERE {
    ?x foaf:name  ?name1 ;
       foaf:mbox  ?mbox1 .
    ?y foaf:name  ?name2 ;
       foaf:mbox  ?mbox2 .
    FILTER (?mbox1 = ?mbox2 &amp;& ?name1 != ?name2)
}</pre>
                <p>Query result:</p>
                <div class="result">
                  <table class="resultTable">
                    <tbody>
                      <tr>
                        <th>name1</th>
                        <th>name2</th>
                      </tr>
                      <tr>
                        <td>"Alice"</td>
                        <td>"Ms A."</td>
                      </tr>
                      <tr>
                        <td>"Ms A."</td>
                        <td>"Alice"</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
            <p>In this query for documents that were annotated at a specific date and time (New
              Year's Day 2005, measures in timezone +00:00), the RDF terms are not the same, but have
              equivalent values according to their datatype:</p>
            <div class="exampleGroup">
              <pre class="data nohighlight">
@prefix a:          &lt;http://www.w3.org/2000/10/annotation-ns#&gt; .
@prefix dc:         &lt;http://purl.org/dc/elements/1.1/&gt; .

_:b   a:annotates   &lt;http://www.w3.org/TR/rdf-sparql-query/&gt; .
_:b   dc:date       "2004-12-31T19:00:00-05:00"^^&lt;http://www.w3.org/2001/XMLSchema#dateTime&gt; .</pre>
              <div class="queryGroup">
                <pre class="query nohighlight">
PREFIX a:      &lt;http://www.w3.org/2000/10/annotation-ns#&gt;
PREFIX dc:     &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX xsd:    &lt;http://www.w3.org/2001/XMLSchema#&gt;

SELECT ?annotates
WHERE {
    ?annot  a:annotates  ?annotates .
    ?annot  dc:date      ?date .
    FILTER ( ?date = xsd:dateTime("2005-01-01T00:00:00Z") ) 
}
                </pre>
                <div class="result">
                  <table class="resultTable">
                    <tbody>
                      <tr>
                        <th>annotates</th>
                      </tr>
                      <tr>
                        <td>&lt;http://www.w3.org/TR/rdf-sparql-query/&gt;</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
          </section>
          <section id="func-sameTerm">
            <h5>sameTerm</h5>
            <pre class="prototype nohighlight"> <span class="return">xsd:boolean</span>  <span class="operator">sameTerm</span> (<span class="type"><span class="type RDFterm">RDF term</span></span> <span class="name">term1</span>, <span class="type"><span class="type RDFterm">RDF term</span></span> <span class="name">term2</span>)</pre>
            <p>Returns TRUE if <code>term1</code> and <code>term2</code> are the same RDF term as
              defined in [[[RDF12-CONCEPTS]]] [[RDF12-CONCEPTS]]; returns FALSE otherwise.</p>
            <div class="exampleGroup">
              <pre class="data nohighlight">
@prefix foaf:       &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a  foaf:name       "Alice".
_:a  foaf:mbox       &lt;mailto:alice@work.example&gt; .

_:b  foaf:name       "Ms A.".
_:b  foaf:mbox       &lt;mailto:alice@work.example&gt; .
              </pre>
              <div class="queryGroup">
                <p>This query finds the people who have multiple <code>foaf:name</code> triples:</p>
                <pre class="query nohighlight">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name1 ?name2
WHERE {
    ?x foaf:name  ?name1 ;
       foaf:mbox  ?mbox1 .
    ?y foaf:name  ?name2 ;
       foaf:mbox  ?mbox2 .
    FILTER (sameTerm(?mbox1, ?mbox2) &amp;& !sameTerm(?name1, ?name2))
}
                </pre>
                <p>Query result:</p>
                <div class="result">
                  <table class="resultTable">
                    <tbody>
                      <tr>
                        <th>name1</th>
                        <th>name2</th>
                      </tr>
                      <tr>
                        <td>"Alice"</td>
                        <td>"Ms A."</td>
                      </tr>
                      <tr>
                        <td>"Ms A."</td>
                        <td>"Alice"</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
            <p>Unlike <span class="operator">RDFterm-equal</span>, <span class="operator">sameTerm</span> can be used to test for non-equivalent <span class="type typedLiteral">typed literals</span> with unsupported datatypes:</p>
            <div class="exampleGroup">
              <pre class="data nohighlight">
@prefix :          &lt;http://example.org/WMterms#&gt; .
@prefix t:         &lt;http://example.org/types#&gt; .

_:c1  :label        "Container 1" .
_:c1  :weight       "100"^^t:kilos .
_:c1  :displacement  "100"^^t:liters .

_:c2  :label        "Container 2" .
_:c2  :weight       "100"^^t:kilos .
_:c2  :displacement  "85"^^t:liters .

_:c3  :label        "Container 3" .
_:c3  :weight       "85"^^t:kilos .
_:c3  :displacement  "85"^^t:liters .
              </pre>
              <div class="queryGroup">
                <pre class="query nohighlight">
PREFIX  :      &lt;http://example.org/WMterms#&gt;
PREFIX  t:     &lt;http://example.org/types#&gt;

SELECT ?aLabel1 ?bLabel
WHERE { 
   ?a  :label        ?aLabel .
   ?a  :weight       ?aWeight .
   ?a  :displacement ?aDisp .

   ?b  :label        ?bLabel .
   ?b  :weight       ?bWeight .
   ?b  :displacement ?bDisp .

   FILTER ( sameTerm(?aWeight, ?bWeight) &amp;& !sameTerm(?aDisp, ?bDisp)) 
}
                </pre>
                <div class="result">
                  <table class="resultTable">
                    <tbody>
                      <tr>
                        <th>aLabel</th>
                        <th>bLabel</th>
                      </tr>
                      <tr>
                        <td>"Container 1"</td>
                        <td>"Container 2"</td>
                      </tr>
                      <tr>
                        <td>"Container 2"</td>
                        <td>"Container 1"</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
            <p>The test for boxes with the same weight may also be done with the '=' operator
              (<a href="#func-RDFterm-equal" class="SPARQLoperator">RDFterm-equal</a>) as the test for
              <code>"100"^^t:kilos = "85"^^t:kilos</code> will result in an error, eliminating that
              potential solution.</p>
          </section>
          <section id="func-in">
            <h5>IN</h5>
            <pre class="prototype nohighlight">
<span class="return">boolean</span>  rdfTerm <span class="operator">IN</span> (<span class="expression">expression</span>, <span class="expression">...</span>)
            </pre>
            <p>The <code>IN</code> operator tests whether the RDF term on the left-hand side is found
              in the list of values of the expressions on the right-hand side. The test is done with "="
              operator, which tests for the same value, as determined by the 
              <a href="#OperatorMapping">operator mapping</a>.</p>
            <p>A list of zero terms on the right-hand side is legal.</p>
            <p>Errors in comparisons cause the <code>IN</code> expression to raise an error if the
              RDF term being tested is not found elsewhere in the list of terms.</p>
            <p>The <code>IN</code> operator is equivalent to the SPARQL expression:</p>
            <pre>(rdfTerm = expression1) || (rdfTerm = expression2) || ...</pre>
            <p>
              If <code>IN</code> is used with an expression to produce the
              <code>rdfTerm</code> then that expression is evaluated only once, 
              before evaluating the <code>IN</code> expression.
            </p>
            <p>Examples:</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>2 IN (1, 2, 3)</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>2 IN ()</code></td>
                    <td>false</td>
                  </tr>
                  <tr>
                    <td><code>2 IN (&lt;http://example/iri&gt;, "str", 2.0)</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>2 IN (1/0, 2)</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>2 IN (2, 1/0)</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>2 IN (3, 1/0)</code></td>
                    <td>raises an error</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-not-in">
            <h5>NOT IN</h5>
            <pre class="prototype nohighlight">
<span class="return">boolean</span>  rdfTerm <span class="operator">NOT IN</span> (<span class="expression">expression</span>, <span class="expression">...</span>)
</pre>
            <p>The <code>NOT IN</code> operator tests whether the RDF term on the left-hand side is
              not found in the values of list of the expressions on the right-hand side. The test is done
              with "!=" operator, which tests that two values are not the same value, as determined by the 
              <a href="#OperatorMapping">operator mapping</a>.</p>
            <p>A list of zero terms on the right-hand side is legal.</p>
            <p>Errors in comparisons cause the <code>NOT IN</code> expression to raise an error if
              the RDF term being tested is not found to be elsewhere in the list of
              terms.</p>
            <p>The <code>NOT IN</code> operator is equivalent to the SPARQL expression:</p>
            <pre>(rdfTerm != expression1) &amp;& (rdfTerm != expression2) &amp;& ...</pre>
            <p>
              If <code>NOT IN</code> is used with an expression to produce the
              <code>rdfTerm</code>, then that expression is evaluated only once, 
              before evaluating the <code>NOT IN</code> expression.
            </p>
            <p><code>NOT IN (...)</code> is equivalent to <code>!(IN (...))</code>.</p>
            <p>Examples:</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>2 NOT IN (1, 2, 3)</code></td>
                    <td>false</td>
                  </tr>
                  <tr>
                    <td><code>2 NOT IN ()</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>2 NOT IN (&lt;http://example/iri&gt;, "str", 2.0)</code></td>
                    <td>false</td>
                  </tr>
                  <tr>
                    <td><code>2 NOT IN (1/0, 2)</code></td>
                    <td>false</td>
                  </tr>
                  <tr>
                    <td><code>2 NOT IN (2, 1/0)</code></td>
                    <td>false</td>
                  </tr>
                  <tr>
                    <td><code>2 NOT IN (3, 1/0)</code></td>
                    <td>raises an error</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
        </section>
        <section id="func-rdfTerms">
          <h4>Functions on RDF Terms</h4>
          <section id="func-isIRI">
            <h5>isIRI</h5>
            <pre class="prototype nohighlight">
<span class="return">xsd:boolean</span>  <span class="operator">isIRI</span> (<span class="type">RDF term</span> <span class="name">term</span>)
<span class="return">xsd:boolean</span>  <span class="operator">isURI</span> (<span class="type">RDF term</span> <span class="name">term</span>)
            </pre>
            <p>Returns <code>true</code> if <code>term</code> is an 
              <span class="type IRI">IRI</span>. 
              Returns <code>false</code> otherwise. 
              <span class="operator">isURI</span> is an alternate spelling for the 
              <span class="operator">isIRI</span> operator.
            </p>
            <div class="exampleGroup">
              <pre class="data nohighlight">
@prefix foaf:       &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a  foaf:name       "Alice".
_:a  foaf:mbox       &lt;mailto:alice@work.example&gt; .

_:b  foaf:name       "Bob" .
_:b  foaf:mbox       "bob@work.example" .
              </pre>
              <div class="queryGroup">
                <p>This query matches the people with a <code>name</code> and an <code>mbox</code>
                  which is an IRI:</p>
                <pre class="query nohighlight">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name ?mbox
WHERE {
    ?x foaf:name  ?name ;
       foaf:mbox  ?mbox .
    FILTER isIRI(?mbox) 
}
                </pre>
                <p>Query result:</p>
                <div class="result">
                  <table class="resultTable">
                    <tbody>
                      <tr>
                        <th>name</th>
                        <th>mbox</th>
                      </tr>
                      <tr>
                        <td>"Alice"</td>
                        <td>&lt;mailto:alice@work.example&gt;</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
          </section>
          <section id="func-isBlank">
            <h5>isBLANK</h5>
            <pre class="prototype nohighlight"> <span class="return">xsd:boolean</span>  <span class="operator">isBLANK</span> (<span class="type"><span class="type">RDF term</span></span> <span class="name">term</span>)</pre>
            <p>Returns <code>true</code> if <code>term</code> is a <span class="type bNode">blank
                node</span>. Returns <code>false</code> otherwise.</p>
            <div class="exampleGroup">
              <pre class="data nohighlight">
@prefix a:          &lt;http://www.w3.org/2000/10/annotation-ns#&gt; .
@prefix dc:         &lt;http://purl.org/dc/elements/1.1/&gt; .
@prefix foaf:       &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a   a:annotates   &lt;http://www.w3.org/TR/rdf-sparql-query/&gt; .
_:a   dc:creator    "Alice B. Toeclips" .

_:b   a:annotates   &lt;http://www.w3.org/TR/rdf-sparql-query/&gt; .
_:b   dc:creator    _:c .
_:c   foaf:given    "Bob".
_:c   foaf:family   "Smith".
              </pre>
              <div class="queryGroup">
                <p>This query matches the people with a <code>dc:creator</code> which uses predicates
                  from the FOAF vocabulary to express the name.</p>
                <pre class="query nohighlight">
PREFIX a:      &lt;http://www.w3.org/2000/10/annotation-ns#&gt;
PREFIX dc:     &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX foaf:   &lt;http://xmlns.com/foaf/0.1/&gt;

SELECT ?given ?family
WHERE { 
    ?annot  a:annotates  &lt;http://www.w3.org/TR/rdf-sparql-query/&gt; .
    ?annot  dc:creator   ?c .
    OPTIONAL { ?c  foaf:given   ?given ; foaf:family  ?family } .
    FILTER isBLANK(?c)
}</pre>
                <p>Query result:</p>
                <div class="result">
                  <table class="resultTable">
                    <tbody>
                      <tr>
                        <th>given</th>
                        <th>family</th>
                      </tr>
                      <tr>
                        <td>"Bob"</td>
                        <td>"Smith"</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
            <p>In this example, there were two objects of <code>dc:creator</code> predicates, but
              only one (<code>_:c</code>) was a blank node.</p>
          </section>
          <section id="func-isLiteral">
            <h5>isLITERAL</h5>
            <pre class="prototype nohighlight"> <span class="return">xsd:boolean</span>  <span class="operator">isLITERAL</span> (<span class="type"><span class="type">RDF term</span></span> <span class="name">term</span>)</pre>
            <p>Returns <code>true</code> if <code>term</code> is a <span class="type literal">literal</span>. Returns <code>false</code> otherwise.</p>
            <div class="exampleGroup">
              <pre class="data nohighlight">
@prefix foaf:       &lt;http://xmlns.com/foaf/0.1/&gt; .
                
_:a  foaf:name       "Alice".
_:a  foaf:mbox       &lt;mailto:alice@work.example&gt; .

_:b  foaf:name       "Bob" .
_:b  foaf:mbox       "bob@work.example" .
              </pre>
              <div class="queryGroup">
                <p>This query is similar to the one in <a href="#func-isIRI">17.4.2.1</a> except that
                  is matches the people with a <code>name</code> and an <code>mbox</code> which is a
                  literal. This could be used to look for erroneous data (<code>foaf:mbox</code> should
                  only have an IRI as its object).</p>
                <pre class="query nohighlight">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name ?mbox
WHERE {
    ?x foaf:name  ?name ;
       foaf:mbox  ?mbox .
    FILTER isLiteral(?mbox)
}
                </pre>
                <p>Query result:</p>
                <div class="result">
                  <table class="resultTable">
                    <tbody>
                      <tr>
                        <th>name</th>
                        <th>mbox</th>
                      </tr>
                      <tr>
                        <td>"Bob"</td>
                        <td>"bob@work.example"</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
          </section>
          <section id="func-isNumeric">
            <h5>isNUMERIC</h5>
            <pre class="prototype nohighlight"> <span class="return">xsd:boolean</span>  <span class="operator">isNUMERIC</span> (<span class="type"><span class="type">RDF term</span></span> <span class="name">term</span>)</pre>
            <p>Returns <code>true</code> if <code>term</code> is a numeric value. Returns
              <code>false</code> otherwise. <code>term</code> is numeric if it has an appropriate
              datatype (see the section <a href="#operandDataTypes">Operand Data Types</a>) and has a
              valid lexical form, making it a valid argument to functions and operators taking numeric
              arguments.</p>
            <p>Examples:</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>isNUMERIC(12)</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>isNUMERIC("12")</code></td>
                    <td>false</td>
                  </tr>
                  <tr>
                    <td><code>isNUMERIC("12"^^xsd:nonNegativeInteger)</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>isNUMERIC("1200"^^xsd:byte)</code></td>
                    <td>false</td>
                  </tr>
                  <tr>
                    <td><code>isNUMERIC(&lt;http://example/&gt;)</code></td>
                    <td>false</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-str">
            <h5>STR</h5>
            <pre class="prototype nohighlight">
<span class="return">xsd:string</span>  <span class="operator">STR</span> (<span class="type"><span class="type literal">literal</span></span> <span class="name">ltrl</span>)
<span class="return">xsd:string</span>  <span class="operator">STR</span> (<span class="type"><span class="type IRI">IRI</span></span> <span class="name">rsrc</span>)
            </pre>
            <p>Returns the <span class="type lexicalForm">lexical form</span> of <code>ltrl</code> (a
              <span class="type literal">literal</span>); returns the codepoint representation of
              <code>rsrc</code> (an <span class="type IRI">IRI</span>). This is useful for examining
              parts of an IRI, for instance, the host-name.</p>
            <div class="exampleGroup">
              <pre class="data nohighlight">
@prefix foaf:       &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a  foaf:name       "Alice".
_:a  foaf:mbox       &lt;mailto:alice@work.example&gt; .

_:b  foaf:name       "Bob" .
_:b  foaf:mbox       &lt;mailto:bob@home.example&gt; .
              </pre>
              <div class="queryGroup">
                <p>This query selects the set of people who use their <code>work.example</code>
                  address in their foaf profile:</p>
                <pre class="query nohighlight">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name ?mbox
WHERE {
    ?x foaf:name  ?name ;
      foaf:mbox  ?mbox .
    FILTER regex(str(?mbox), "@work\\.example$")
}
                </pre>
                <p>Query result:</p>
                <div class="result">
                  <table class="resultTable">
                    <tbody>
                      <tr>
                        <th>name</th>
                        <th>mbox</th>
                      </tr>
                      <tr>
                        <td>"Alice"</td>
                        <td>&lt;mailto:alice@work.example&gt;</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
          </section>
          <section id="func-lang">
            <h5>LANG</h5>
            <pre class="prototype nohighlight"> <span class="return">xsd:string</span>  <span class="operator">LANG</span> (<span class="type"><span class="type literal">literal</span></span> <span class="name">ltrl</span>)
            </pre>
            <p>Returns the <span class="type langTag">language tag</span> of <code>ltrl</code>, if it
              has one. It returns <code>""</code> if 
              <code>ltrl</code> has no <span class="type langTag">language tag</span>. 
              Note that the RDF data model does not include
              literals with an empty <span class="type langTag">language tag</span>.</p>
            <div class="exampleGroup">
              <pre class="data nohighlight">
@prefix foaf:       &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a  foaf:name       "Robert"@en.
_:a  foaf:name       "Roberto"@es.
_:a  foaf:mbox       &lt;mailto:bob@work.example&gt; .
              </pre>
              <div class="queryGroup">
                <p>This query finds the Spanish <code>foaf:name</code> and
                  <code>foaf:mbox</code>:</p>
                <pre class="query nohighlight">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name ?mbox
WHERE {
    ?x foaf:name  ?name ;
       foaf:mbox  ?mbox .
    FILTER ( lang(?name) = "es" )
}
                </pre>
                <p>Query result:</p>
                <div class="result">
                  <table class="resultTable">
                    <tbody>
                      <tr>
                        <th>name</th>
                        <th>mbox</th>
                      </tr>
                      <tr>
                        <td>"Roberto"@es</td>
                        <td>&lt;mailto:bob@work.example&gt;</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
          </section>
          <section id="func-datatype">
            <h5>DATATYPE</h5>
            <pre class="prototype nohighlight"> <span class="return"><span class="type IRI">iri</span></span>  <span class="operator">DATATYPE</span> (<span class="type"><span class="type">literal</span></span> <span class="name">literal</span>)
            </pre>
            <p>Returns the <span class="type datatypeIRI">datatype IRI</span> of a
              <code>literal</code>.</p>
            <p class="note">
                The datatype of a literal with a <a data-cite="RDF12-CONCEPTS#dfn-language-tag">language tag</a> is <code>rdf:langString</code>.
            </p>
            <div class="exampleGroup">
              <pre class="data nohighlight">
@prefix foaf:       &lt;http://xmlns.com/foaf/0.1/&gt; .
@prefix eg:         &lt;http://biometrics.example/ns#&gt; .
@prefix xsd:        &lt;http://www.w3.org/2001/XMLSchema#&gt; .

_:a  foaf:name       "Alice".
_:a  eg:shoeSize     "9.5"^^xsd:float .

_:b  foaf:name       "Bob".
_:b  eg:shoeSize     "42"^^xsd:integer .
              </pre>
              <div class="queryGroup">
                <p>This query finds the <code>foaf:name</code> and <code>foaf:shoeSize</code> of
                  everyone with a shoeSize that is an integer:</p>
                <pre class="query nohighlight">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX xsd:  &lt;http://www.w3.org/2001/XMLSchema#&gt;
PREFIX eg:   &lt;http://biometrics.example/ns#&gt;
SELECT ?name ?shoeSize
WHERE { 
    ?x foaf:name  ?name ;
       eg:shoeSize  ?shoeSize .
    FILTER ( datatype(?shoeSize) = xsd:integer )
}</pre>
                <p>Query result:</p>
                <div class="result">
                  <table class="resultTable">
                    <tbody>
                      <tr>
                        <th>name</th>
                        <th>shoeSize</th>
                      </tr>
                      <tr>
                        <td>"Bob"</td>
                        <td>42</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
            <div class="note">
              <p>In [[[RDF-SPARQL-QUERY]]] the <code>DATATYPE</code> function was not defined for
                literals with a language tag. Therefore, an unextended implementation would raise an
                error when <code>DATATYPE</code> was called with a literal with a language tag.
                <a href="#operatorExtensibility">Operator extensibility</a> allows implementations to
                return a result rather than raise an error. SPARQL 1.2 defines the result of
                <code>DATATYPE</code> applied to a literal with a language tag to be
                <code>rdf:langString</code>.</p>
            </div>
            <div class="wgNote">
              The SPARQL Working Group is using <code>rdf:langString</code> based on the latest
              Working Drafts of the RDF Working Group. This usage should be considered experimental
              (and non-normative) until/unless <code>rdf:langString</code> becomes part of an updated
              RDF Recommendation.
            </div>
          </section>
          <section id="func-iri">
            <h5>IRI</h5>
            <pre class="prototype nohighlight">
              <span class="return">iri</span>  <span class="operator">IRI</span>(<span class="type">xsd:string</span>)
              <span class="return">iri</span>  <span class="operator">IRI</span>(<span class="type">iri</span>)
              <span class="return">iri</span>  <span class="operator">URI</span>(<span class="type">xsd:string</span>)
              <span class="return">iri</span>  <span class="operator">URI</span>(<span class="type">iri</span>)</pre>
            <p>The <code>IRI</code> function constructs an IRI by resolving the string argument (see
              [[RFC3986]] and [[RFC3987]] or any later RFC that superceeds RFC 3986 or RFC 3987). The
              IRI is resolved against the base IRI of the query and must result in an absolute IRI.</p>
            <p>The <code>URI</code> function is a synonym for <a href="#func-iri"><code>IRI</code></a>.</p>
            <p>If the function is passed an IRI, it returns the IRI unchanged.</p>
            <p>Passing any RDF term other than a literal with datatype <code>xsd:string</code> or an IRI is an
              error.</p>
            <p>An implementation <em class="rfc2119" title="Keyword in RFC 2119 context">MAY</em>
              normalize the IRI.</p>
            <p>Examples:</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>IRI("http://example/")</code></td>
                    <td>&lt;http://example/&gt;</td>
                  </tr>
                  <tr>
                    <td><code>IRI(&lt;http://example/&gt;)</code></td>
                    <td>&lt;http://example/&gt;</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-bnode">
            <h5>BNODE</h5>
            <pre class="prototype nohighlight"><span class="return">blank node</span>  <span class="operator">BNODE</span>()</pre>
            <pre class="prototype nohighlight"><span class="return">blank node</span>  <span class="operator">BNODE</span>(<span class="type">xsd:string</span>)</pre>
            <p>The <code>BNODE</code> function constructs a blank node that is distinct from all
              blank nodes in the dataset being queried and distinct from all blank nodes created by
              calls to this constructor for other query solutions. If the no argument form is used,
              every call results in a distinct blank node. If the form with an <code>xsd:string</code> literal is used,
              every call results in distinct blank nodes for different <code>xsd:string</code> literals, and the same
              blank node for calls with the same <code>xsd:string</code> literal within expressions for one <a href="#defn_sparqlSolutionMapping">solution mapping</a>.
            </p>
            <p>This functionality is compatible with the <a href="#templatesWithBNodes">treatment of
                blank nodes in SPARQL CONSTRUCT templates</a>.</p>
          </section>
          <section id="func-strdt">
            <h5>STRDT</h5>
            <pre class="prototype nohighlight"><span class="return">literal</span>  <span class="operator">STRDT</span>(<span class="type">xsd:string</span> lexicalForm, <span class="type">IRI</span> datatypeIRI)</pre>
            <p>The <code>STRDT</code> function constructs a literal with lexical form and type as
              specified by the arguments.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>STRDT("123", xsd:integer)</code></td>
                    <td>"123"^^&lt;http://www.w3.org/2001/XMLSchema#integer&gt;</td>
                  </tr>
                  <tr>
                    <td><code>STRDT("iiii", &lt;http://example/romanNumeral&gt;)</code></td>
                    <td>"iiii"^^&lt;http://example/romanNumeral&gt;</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-strlang">
            <h5>STRLANG</h5>
            <pre class="prototype nohighlight"><span class="return">literal</span>  <span class="operator">STRLANG</span>(<span class="type">xsd:string</span> lexicalForm, <span class="type">xsd:string</span> langTag)</pre>
            <p>The <code>STRLANG</code> function constructs a literal with lexical form and language
              tag as specified by the arguments.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>STRLANG("chat", "en")</code></td>
                    <td>"chat"@en</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-uuid">
            <h5>UUID</h5>
            <pre class="prototype nohighlight"><span class="return">iri</span>  <span class="operator">UUID</span>()</pre>
            <p>Return a fresh IRI from the [[[RFC4122]]]. Each call of <code>UUID()</code> returns a
              different UUID. It must not be the "nil" UUID (all zeroes). The variant and version of
              the UUID is implementation dependent.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>UUID()</code></td>
                    <td><code>&lt;urn:uuid:b9302fb5-642e-4d3b-af19-29a8f6d894c9&gt;</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-struuid">
            <h5>STRUUID</h5>
            <pre class="prototype nohighlight"><span class="return">xsd:string</span>  <span class="operator">STRUUID</span>()</pre>
            <p>Return a string that is the scheme-specific part of UUID. That is, as a literal with datatype <code>xsd:string</code>,
              the result of generating a UUID, converting to a literal with datatype <code>xsd:string</code> and removing the
              initial <code>urn:uuid:</code>.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>STRUUID()</code></td>
                    <td><code>"73cd4307-8a99-4691-a608-b5bda64fb6c1"</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
        </section>
        <section id="func-strings">
          <h4>Functions on Strings</h4>
          <section id="idp1887976">
            <h5>Strings in SPARQL Functions</h5>
            <section id="func-string">
              <h6>String arguments</h6>
              <p>Certain functions (e.g., <a href="#func-regex">REGEX</a>, <a href="#func-strlen">STRLEN</a>, <a href="#func-contains">CONTAINS</a>)
                take a <code>string literal</code> as an argument and accept a literal with datatype <code>xsd:string</code>, or a literal with a
                language tag. They then act on the lexical form
                of the literal.</p>
              <p>The term <code>string literal</code> is used in the function descriptions for this.
                Use of any other RDF term will cause a call to the function to raise an error.</p>
            </section>
            <section id="func-arg-compatibility">
              <h6>Argument Compatibility Rules</h6>
              <p>The functions <a href="#func-strstarts">STRSTARTS</a>, 
                <a href="#func-strends">STRENDS</a>,
                <a href="#func-contains">CONTAINS</a>, 
                <a href="#func-strbefore">STRBEFORE</a> and 
                <a href="#func-strafter">STRAFTER</a> take two
                arguments. These arguments must be compatible otherwise invocation of one of these
                functions raises an error.</p>
              <p>Compatibility of two arguments is defined as:</p>
              <ul>
                <li>The arguments are literals with datatype <code>xsd:string</code></li>
                <li>The arguments are literals with identical language tags</li>
                <li>The first argument is a literal with a language tag and the second argument is a literal with datatype <code>xsd:string</code></li>
              </ul>
              <div class="result">
                <table>
                  <tbody>
                    <tr>
                      <th>Argument1</th>
                      <th>Argument2</th>
                      <th>Compatible?</th>
                    </tr>
                    <tr>
                      <td>"abc"</td>
                      <td>"b"</td>
                      <td>yes</td>
                    </tr>
                    <tr>
                      <td>"abc"@en</td>
                      <td>"b"</td>
                      <td>yes</td>
                    </tr>
                    <tr>
                      <td>"abc"@en</td>
                      <td>"b"@en</td>
                      <td>yes</td>
                    </tr>
                    <tr>
                      <td>"abc"@fr</td>
                      <td>"b"@ja</td>
                      <td>no</td>
                    </tr>
                    <tr>
                      <td>"abc"</td>
                      <td>"b"@ja</td>
                      <td>no</td>
                    </tr>
                    <tr>
                      <td>"abc"</td>
                      <td>"b"@en</td>
                      <td>no</td>
                    </tr>
                  </tbody>
                </table>
              </div>
              <p class="note">
                <code>"abc"</code> is a                 
                <a data-cite="RDF12-CONCEPTS#dfn-simple-literal">simple literal</a>
                syntactic shorthand for <code>"abc"^^xsd:string</code>.
              </p>
            </section>
            <section id="idp1915512">
              <h6>String Literal Return Type</h6>
              <p>Functions that return a string literal do so with the string literal of the same
                kind as the first argument (literal with datatype <code>xsd:string</code>, literal with the same language tag).
                This includes <a href="#func-substr">SUBSTR</a>, <a href="#func-strbefore">STRBEFORE</a> and <a href="#func-strafter">STRAFTER</a>.
              </p>
              <p>The function <a href="#func-concat">CONCAT</a> returns a string literal based on the
                details of all its arguments.</p>
            </section>
          </section>
          <section id="func-strlen">
            <h5>STRLEN</h5>
            <pre class="prototype nohighlight"><span class="return">xsd:integer</span>  <span class="operator">STRLEN</span>(<span class="type">string literal</span> str)</pre>
            <p>The <code>strlen</code> function corresponds to the XPath
              <a data-cite="XPATH-FUNCTIONS#func-string-length">fn:string-length</a>
              function and returns an
              <code>xsd:integer</code> equal to the length in characters of the lexical form of the
              literal.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>strlen("chat")</code></td>
                    <td>4</td>
                  </tr>
                  <tr>
                    <td><code>strlen("chat"@en)</code></td>
                    <td>4</td>
                  </tr>
                  <tr>
                    <td><code>strlen("chat"^^xsd:string)</code></td>
                    <td>4</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-substr">
            <h5>SUBSTR</h5>
            <pre class="prototype nohighlight">
<span class="return">string literal</span>  <span class="operator">SUBSTR</span>(<span class="type">string literal</span> source, <span class="type">xsd:integer</span> startingLoc)
<span class="return">string literal</span>  <span class="operator">SUBSTR</span>(<span class="type">string literal</span> source, <span class="type">xsd:integer</span> startingLoc, <span class="type">xsd:integer</span> length)
            </pre>
            <p>The <code>substr</code> function corresponds to the XPath 
              <a data-cite="XPATH-FUNCTIONS#func-substring">fn:substring</a> function and returns a literal of the
              same kind (literal with datatype <code>xsd:string</code>, literal with the same language tag)
              as the <code>source</code> input parameter but with a lexical form derived from
              the substring of the lexical form of the source.</p>
            <p>The arguments <code>startingLoc</code> and <code>length</code> may be derived types of
              xsd:integer.</p>
            <p>The index of the first character in a strings is 1.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>substr("foobar", 4)</code></td>
                    <td>"bar"</td>
                  </tr>
                  <tr>
                    <td><code>substr("foobar"@en, 4)</code></td>
                    <td>"bar"@en</td>
                  </tr>
                  <tr>
                    <td><code>substr("foobar"^^xsd:string, 4)</code></td>
                    <td>"bar"^^xsd:string</td>
                  </tr>
                  <tr>
                    <td><code>substr("foobar", 4, 1)</code></td>
                    <td>"b"</td>
                  </tr>
                  <tr>
                    <td><code>substr("foobar"@en, 4, 1)</code></td>
                    <td>"b"@en</td>
                  </tr>
                  <tr>
                    <td><code>substr("foobar"^^xsd:string, 4, 1)</code></td>
                    <td>"b"^^xsd:string</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-ucase">
            <h5>UCASE</h5>
            <pre class="prototype nohighlight"><span class="return">string literal</span>  <span class="operator">UCASE</span>(<span class="type">string literal</span> str)</pre>
            <p>The <code>UCASE</code> function corresponds to the XPath 
              <a data-cite="XPATH-FUNCTIONS#func-upper-case">fn:upper-case</a>
              function. It returns a string literal
              whose lexical form is the upper case of the lexcial form of the argument.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>ucase("foo")</code></td>
                    <td>"FOO"</td>
                  </tr>
                  <tr>
                    <td><code>ucase("foo"@en)</code></td>
                    <td>"FOO"@en</td>
                  </tr>
                  <tr>
                    <td><code>ucase("foo"^^xsd:string)</code></td>
                    <td>"FOO"^^xsd:string</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-lcase">
            <h5>LCASE</h5>
            <pre class="prototype nohighlight"><span class="return">string literal</span>  <span class="operator">LCASE</span>(<span class="type">string literal</span> str)</pre>
            <p>The <code>LCASE</code> function corresponds to the XPath 
              <a data-cite="XPATH-FUNCTIONS#func-lower-case">fn:lower-case</a> function.
              It returns a string literal whose lexical form is the lower case of the lexcial form of the argument.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>lcase("BAR")</code></td>
                    <td>"bar"</td>
                  </tr>
                  <tr>
                    <td><code>lcase("BAR"@en)</code></td>
                    <td>"bar"@en</td>
                  </tr>
                  <tr>
                    <td><code>lcase("BAR"^^xsd:string)</code></td>
                    <td>"bar"^^xsd:string</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-strstarts">
            <h5>STRSTARTS</h5>
            <pre class="prototype nohighlight"><span class="return">xsd:boolean</span>  <span class="operator">STRSTARTS</span>(<span class="type">string literal</span> arg1, <span class="type">string literal</span> arg2)</pre>
            <p>The <code>STRSTARTS</code> function corresponds to the XPath <a data-cite="XPATH-FUNCTIONS#func-starts-with">fn:starts-with</a> function. The arguments must be
              <a href="#func-arg-compatibility">argument compatible</a> otherwise an error is
              raised.</p>
            <p>For such input pairs, the function returns true if the lexical form of
              <code>arg1</code> starts with the lexical form of <code>arg2</code>, otherwise it returns
              false.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>strStarts("foobar", "foo")</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>strStarts("foobar"@en, "foo"@en)</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>strStarts("foobar"^^xsd:string, "foo"^^xsd:string)</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>strStarts("foobar"^^xsd:string, "foo")</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>strStarts("foobar", "foo"^^xsd:string)</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>strStarts("foobar"@en, "foo")</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>strStarts("foobar"@en, "foo"^^xsd:string)</code></td>
                    <td>true</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-strends">
            <h5>STRENDS</h5>
            <pre class="prototype nohighlight"><span class="return">xsd:boolean</span>  <span class="operator">STRENDS</span>(<span class="type">string literal</span> arg1, <span class="type">string literal</span> arg2)</pre>
            <p>The <code>STRENDS</code> function corresponds to the XPath <a data-cite="XPATH-FUNCTIONS#func-ends-with">fn:ends-with</a> function. The arguments must be
              <a href="#func-arg-compatibility">argument compatible</a> otherwise an error is
              raised.</p>
            <p>For such input pairs, the function returns true if the lexical form of
              <code>arg1</code> ends with the lexical form of <code>arg2</code>, otherwise it returns
              false.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>strEnds("foobar", "bar")</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>strEnds("foobar"@en, "bar"@en)</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>strEnds("foobar"^^xsd:string, "bar"^^xsd:string)</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>strEnds("foobar"^^xsd:string, "bar")</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>strEnds("foobar", "bar"^^xsd:string)</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>strEnds("foobar"@en, "bar")</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>strEnds("foobar"@en, "bar"^^xsd:string)</code></td>
                    <td>true</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-contains">
            <h5>CONTAINS</h5>
            <pre class="prototype nohighlight"><span class="return">xsd:boolean</span>  <span class="operator">CONTAINS</span>(<span class="type">string literal</span> arg1, <span class="type">string literal</span> arg2)</pre>
            <p>The <code>CONTAINS</code> function corresponds to the XPath <a data-cite="XPATH-FUNCTIONS#func-contains">fn:contains</a>. The arguments must be <a href="#func-arg-compatibility">argument compatible</a> otherwise an error is raised.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>contains("foobar", "bar")</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>contains("foobar"@en, "foo"@en)</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>contains("foobar"^^xsd:string, "bar"^^xsd:string)</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>contains("foobar"^^xsd:string, "foo")</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>contains("foobar", "bar"^^xsd:string)</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>contains("foobar"@en, "foo")</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>contains("foobar"@en, "bar"^^xsd:string)</code></td>
                    <td>true</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-strbefore">
            <h5>STRBEFORE</h5>
            <pre class="prototype nohighlight"><span class="return">literal</span>  <span class="operator">STRBEFORE</span>(<span class="type">string literal</span> arg1, <span class="type">string literal</span> arg2)</pre>
            <p>The <code>STRBEFORE</code> function corresponds to the XPath <a data-cite="XPATH-FUNCTIONS#func-substring-before">fn:substring-before</a> function. The arguments
              must be <a href="#func-arg-compatibility">argument compatible</a> otherwise an error is
              raised.</p>
            <p>For compatible arguments, if the lexical part of the second argument occurs as a
              substring of the lexical part of the first argument, the function returns a literal of
              the same kind as the first argument <code>arg1</code> (literal with datatype <code>xsd:string</code>, literal with the same
              language tag). The lexical form of the result is the substring of the lexical
              form of <code>arg1</code> that precedes the first occurrence of the lexical form of
              <code>arg2</code>. If the lexical form of <code>arg2</code> is the empty string, this is
              considered to be a match and the lexical form of the result is the empty string.</p>
            <p>If there is no such occurrence, an empty literal with datatype <code>xsd:string</code> is returned.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td>strbefore("abc","b")</td>
                    <td>"a"</td>
                  </tr>
                  <tr>
                    <td>strbefore("abc"@en,"bc")</td>
                    <td>"a"@en</td>
                  </tr>
                  <tr>
                    <td>strbefore("abc"@en,"b"@cy)</td>
                    <td>error</td>
                  </tr>
                  <tr>
                    <td>strbefore("abc"^^xsd:string,"")</td>
                    <td>""^^xsd:string</td>
                  </tr>
                  <tr>
                    <td>strbefore("abc","xyz")</td>
                    <td>""</td>
                  </tr>
                  <tr>
                    <td>strbefore("abc"@en, "z"@en)</td>
                    <td>""</td>
                  </tr>
                  <tr>
                    <td>strbefore("abc"@en, "z")</td>
                    <td>""</td>
                  </tr>
                  <tr>
                    <td>strbefore("abc"@en, ""@en)</td>
                    <td>""@en</td>
                  </tr>
                  <tr>
                    <td>strbefore("abc"@en, "")</td>
                    <td>""@en</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-strafter">
            <h5>STRAFTER</h5>
            <pre class="prototype nohighlight"><span class="return">literal</span>  <span class="operator">STRAFTER</span>(<span class="type">string literal</span> arg1, <span class="type">string literal</span> arg2)</pre>
            <p>The <code>STRAFTER</code> function corresponds to the XPath <a data-cite="XPATH-FUNCTIONS#func-substring-after">fn:substring-after</a> function. The arguments
              must be <a href="#func-arg-compatibility">argument compatible</a> otherwise an error is
              raised.</p>
            <p>For compatible arguments, if the lexical part of the second argument occurs as a
              substring of the lexical part of the first argument, the function returns a literal of
              the same kind as the first argument <code>arg1</code> (literal with datatype <code>xsd:string</code>, literal with the same
              language tag). The lexical form of the result is the substring of the lexical
              form of <code>arg1</code> that follows the first occurrence of the lexical form of
              <code>arg2</code>. If the lexical form of <code>arg2</code> is the empty string, this is
              considered to be a match and the lexical form of the result is the lexical form of
              <code>arg1</code>.</p>
            <p>If there is no such occurrence, an empty literal with datatype <code>xsd:string</code> is returned.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td>strafter("abc","b")</td>
                    <td>"c"</td>
                  </tr>
                  <tr>
                    <td>strafter("abc"@en,"ab")</td>
                    <td>"c"@en</td>
                  </tr>
                  <tr>
                    <td>strafter("abc"@en,"b"@cy)</td>
                    <td>error</td>
                  </tr>
                  <tr>
                    <td>strafter("abc"^^xsd:string,"")</td>
                    <td>"abc"^^xsd:string</td>
                  </tr>
                  <tr>
                    <td>strafter("abc","xyz")</td>
                    <td>""</td>
                  </tr>
                  <tr>
                    <td>strafter("abc"@en, "z"@en)</td>
                    <td>""</td>
                  </tr>
                  <tr>
                    <td>strafter("abc"@en, "z")</td>
                    <td>""</td>
                  </tr>
                  <tr>
                    <td>strafter("abc"@en, ""@en)</td>
                    <td>"abc"@en</td>
                  </tr>
                  <tr>
                    <td>strafter("abc"@en, "")</td>
                    <td>"abc"@en</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-encode">
            <h5>ENCODE_FOR_URI</h5>
            <pre class="prototype nohighlight"><span class="return">xsd:string</span>  <span class="operator">ENCODE_FOR_URI</span>(<span class="type">string literal</span> ltrl)</pre>
            <p>The <code>ENCODE_FOR_URI</code> function corresponds to the XPath <a data-cite="XPATH-FUNCTIONS#func-encode-for-uri">fn:encode-for-uri</a> function. It returns a
              literal with datatype <code>xsd:string</code> with the lexical form obtained from the lexical form of its input after
              translating reserved characters according to the <a data-cite="XPATH-FUNCTIONS#func-encode-for-uri">fn:encode-for-uri</a>
              function.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>encode_for_uri("Los Angeles")</code></td>
                    <td><code>"Los%20Angeles"</code></td>
                  </tr>
                  <tr>
                    <td><code>encode_for_uri("Los Angeles"@en)</code></td>
                    <td><code>"Los%20Angeles"</code></td>
                  </tr>
                  <tr>
                    <td><code>encode_for_uri("Los Angeles"^^xsd:string)</code></td>
                    <td><code>"Los%20Angeles"</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-concat">
            <h5>CONCAT</h5>
            <pre class="prototype nohighlight"><span class="return">string literal</span>  <span class="operator">CONCAT</span>(<span class="type">string literal</span> <span>ltrl<sub>1</sub></span> ... <span class="type">string literal</span> <span>ltrl<sub>n</sub></span>)</pre>
            <p>The <code>CONCAT</code> function corresponds to the XPath <a data-cite="XPATH-FUNCTIONS#func-concat">fn:concat</a> function. The function accepts string
              literals as arguments.</p>
            <p>The lexical form of the returned literal is obtained by concatenating the lexical
              forms of its inputs. If all input literals are literals with identical language
              tags, then the returned literal is a literal with the same language tag, in all
              other cases, the returned literal is a literal with datatype <code>xsd:string</code>.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>concat("foo", "bar")</code></td>
                    <td>"foobar"</td>
                  </tr>
                  <tr>
                    <td><code>concat("foo"@en, "bar"@en)</code></td>
                    <td>"foobar"@en</td>
                  </tr>
                  <tr>
                    <td><code>concat("foo", "bar")</code></td>
                    <td>"foobar"</td>
                  </tr>
                  <tr>
                    <td><code>concat("foo"@en, "bar")</code></td>
                    <td>"foobar"</td>
                  </tr>
                  <tr>
                    <td><code>concat("foo"@en, "bar")</code></td>
                    <td>"foobar"</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-langMatches">
            <h5>langMATCHES</h5>
            <pre class="prototype nohighlight"> <span class="return">xsd:boolean</span>  <span class="operator">langMatches</span> (<span class="type"><span class="type">xsd:string</span></span> <span class="name">language-tag</span>, <span class="type"><span class="type">xsd:string</span></span> <span class="name">language-range</span>)
            </pre>
            <p>Returns <code>true</code> if <code>language-tag</code> (first argument) matches
              <code>language-range</code> (second argument) per the basic filtering scheme defined in
              [[RFC4647]] section 3.3.1. <code>language-range</code> is a basic language range per
              [[[RFC4647]]] [[RFC4647]] section 2.1. A <code>language-range</code> of "*" matches any
              non-empty <code>language-tag</code> string.</p>
            <div class="exampleGroup">
              <pre class="data nohighlight">
@prefix dc:       &lt;http://purl.org/dc/elements/1.1/&gt; .

_:a  dc:title         "That Seventies Show"@en .
_:a  dc:title         "Cette Série des Années Soixante-dix"@fr .
_:a  dc:title         "Cette Série des Années Septante"@fr-BE .
_:b  dc:title         "Il Buono, il Bruto, il Cattivo" .
              </pre>
              <div class="queryGroup">
                <p>This query uses <a href="#func-langMatches"><code>langMatches</code></a> and
                  <a href="#func-lang"><code>lang</code></a> to find the French titles for the show
                  known in English as "That Seventies Show":</p>
                <pre class="query nohighlight">
PREFIX dc: &lt;http://purl.org/dc/elements/1.1/&gt;
SELECT ?title
WHERE {
    ?x dc:title  "That Seventies Show"@en ;
       dc:title  ?title .
    FILTER langMatches( lang(?title), "FR" )
}
                </pre>
                <p>Query result:</p>
                <div class="result">
                  <table class="resultTable">
                    <tbody>
                      <tr>
                        <th>title</th>
                      </tr>
                      <tr>
                        <td>"Cette Série des Années Soixante-dix"@fr</td>
                      </tr>
                      <tr>
                        <td>"Cette Série des Années Septante"@fr-BE</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
              <div class="queryGroup">
                <p>The idiom <code>langMatches( lang( ?v ), "*" )</code> will not match literals
                  without a language tag as <code>lang( ?v )</code> will return an empty string, so</p>
                <pre class="query nohighlight add">
PREFIX dc: &lt;http://purl.org/dc/elements/1.1/&gt;
SELECT ?title
WHERE {
    ?x dc:title  ?title .
    FILTER langMatches( lang(?title), "*" )
}
                </pre>
                <p>will report all of the titles with a language tag:</p>
                <div class="result add">
                  <table class="resultTable">
                    <tbody>
                      <tr>
                        <th>title</th>
                      </tr>
                      <tr>
                        <td>"That Seventies Show"@en</td>
                      </tr>
                      <tr>
                        <td>"Cette Série des Années Soixante-dix"@fr</td>
                      </tr>
                      <tr>
                        <td>"Cette Série des Années Septante"@fr-BE</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
          </section>
          <section id="func-regex">
            <h5>REGEX</h5>
            <pre class="prototype nohighlight">
<span class="return">xsd:boolean</span>  <span class="operator">REGEX</span> (<span class="type"><span class="type">string literal</span></span> <span class="name">text</span>, <span class="type"><span class="type">xsd:string</span></span> <span class="name">pattern</span>)
<span class="return">xsd:boolean</span>  <span class="operator">REGEX</span> (<span class="type"><span class="type">string literal</span></span> <span class="name">text</span>, <span class="type"><span class="type">xsd:string</span></span> <span class="name">pattern</span>, <span class="type"><span class="type">xsd:string</span></span> <span class="name">flags</span>)
</pre>
            <p>Invokes the XPath <a data-cite="XPATH-FUNCTIONS#func-matches">fn:matches</a> function to match
              <code>text</code> against a regular expression <code>pattern</code>. The regular
              expression language is defined in XQuery 1.0 and XPath 2.0 Functions and Operators
              section <a data-cite="XPATH-FUNCTIONS#regex-syntax">7.6.1 Regular Expression Syntax</a>
              [[XPATH-FUNCTIONS]].</p>
            <div class="exampleGroup">
              <pre class="data nohighlight">
@prefix foaf:       &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a  foaf:name       "Alice".
_:b  foaf:name       "Bob" .
              </pre>
              <div class="queryGroup">
                <pre class="query nohighlight">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name
WHERE { 
    ?x foaf:name  ?name
    FILTER regex(?name, "^ali", "i")
}
                </pre>
                <p>Query result:</p>
                <div class="result">
                  <table class="resultTable">
                    <tbody>
                      <tr>
                        <th>name</th>
                      </tr>
                      <tr>
                        <td>"Alice"</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
          </section>
          <section id="func-replace">
            <h5>REPLACE</h5>
            <pre class="prototype nohighlight">
<span class="return"><span class="type">string literal</span></span>  <span class="operator">REPLACE</span> (<span class="type"><span class="type">string literal</span></span> arg, <span class="type"><span class="type">xsd:string</span></span> pattern, <span class="type"><span class="type">xsd:string</span></span> replacement )
<span class="return"><span class="type">string literal</span></span>  <span class="operator">REPLACE</span> (<span class="type"><span class="type">string literal</span></span> arg, <span class="type"><span class="type">xsd:string</span></span> pattern, <span class="type"><span class="type">xsd:string</span></span> replacement,  <span class="type"><span class="type">xsd:string</span></span> flags)
            </pre>
            <p>The <code>REPLACE</code> function corresponds to the XPath <a data-cite="XPATH-FUNCTIONS#func-replace">fn:replace</a> function. It replaces each non-overlapping
              occurrence of the regular expression <code>pattern</code> with the replacement string.
              Regular expession matching may involve modifier flags. See <a href="#func-regex">REGEX</a>.
            </p>
            <div class="result">
              <table class="resultTable">
                <tbody>
                  <tr>
                    <td>replace("abcd", "b", "Z")</td>
                    <td>"aZcd"</td>
                  </tr>
                  <tr>
                    <td>replace("abab", "B", "Z","i")</td>
                    <td>"aZaZ"</td>
                  </tr>
                  <tr>
                    <td>replace("abab", "B.", "Z","i")</td>
                    <td>"aZb"</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
        </section>
        <section id="func-numerics">
          <h4>Functions on Numerics</h4>
          <section id="func-abs">
            <h5>ABS</h5>
            <pre class="prototype nohighlight"> <span class="return">numeric</span>  <span class="operator">ABS</span> (<span class="type"><span class="type numeric">numeric</span></span> <span class="name">term</span>)</pre>
            <p>Returns the absolute value of <code>arg</code>. An error is raised if <code>arg</code>
              is not a numeric value.</p>
            <p>This function is the same as 
              <a data-cite="XPATH-FUNCTIONS#func-abs">fn:numeric-abs</a>
              for terms with a datatype from <a data-cite="XPATH-DATAMODEL#">XDM</a>.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>ABS(1)</code></td>
                    <td><code>1</code></td>
                  </tr>
                  <tr>
                    <td><code>ABS(-1.5)</code></td>
                    <td><code>1.5</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-round">
            <h5>ROUND</h5>
            <pre class="prototype nohighlight"> <span class="return">numeric</span>  <span class="operator">ROUND</span> (<span class="type"><span class="type numeric">numeric</span></span> <span class="name">term</span>)</pre>
            <p>Returns the number with no fractional part that is closest to the argument. If there
              are two such numbers, then the one that is closest to positive infinity is returned. An
              error is raised if <code>arg</code> is not a numeric value.</p>
            <p>This function is the same as <a data-cite="XPATH-FUNCTIONS#func-round">fn:numeric-round</a> for terms with a datatype from <a data-cite="XPATH-DATAMODEL#">XDM</a>.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>ROUND(2.4999)</code></td>
                    <td><code>2.0</code></td>
                  </tr>
                  <tr>
                    <td><code>ROUND(2.5)</code></td>
                    <td><code>3.0</code></td>
                  </tr>
                  <tr>
                    <td><code>ROUND(-2.5)</code></td>
                    <td><code>-2.0</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-ceil">
            <h5>CEIL</h5>
            <pre class="prototype nohighlight"> <span class="return">numeric</span>  <span class="operator">CEIL</span> (<span class="type"><span class="type numeric">numeric</span></span> <span class="name">term</span>)</pre>
            <p>Returns the smallest (closest to negative infinity) number with no fractional part
              that is not less than the value of <code>arg</code>. An error is raised if
              <code>arg</code> is not a numeric value.</p>
            <p>This function is the same as 
              <a data-cite="XPATH-FUNCTIONS#func-ceiling">fn:numeric-ceil</a>
              for terms with a datatype from <a data-cite="XPATH-DATAMODEL#">XDM</a>.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>CEIL(10.5)</code></td>
                    <td><code>11.0</code></td>
                  </tr>
                  <tr>
                    <td><code>CEIL(-10.5)</code></td>
                    <td><code>-10.0</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-floor">
            <h5>FLOOR</h5>
            <pre class="prototype nohighlight"> <span class="return">numeric</span>  <span class="operator">FLOOR</span> (<span class="type"><span class="type numeric">numeric</span></span> <span class="name">term</span>)</pre>
            <p>Returns the largest (closest to positive infinity) number with no fractional part that
              is not greater than the value of <code>arg</code>. An error is raised if <code>arg</code>
              is not a numeric value.</p>
            <p>This function is the same as
              <a data-cite="XPATH-FUNCTIONS#func-floor">fn:numeric-floor</a>
              for terms with a datatype from <a data-cite="XPATH-DATAMODEL#">XDM</a>.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>FLOOR(10.5)</code></td>
                    <td><code>10.0</code></td>
                  </tr>
                  <tr>
                    <td><code>FLOOR(-10.5)</code></td>
                    <td><code>-11.0</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="idp2130040">
            <h5>RAND</h5>
            <pre class="prototype nohighlight"> <span class="return">xsd:double</span>  <span class="operator">RAND</span> ( )</pre>
            <p>Returns a pseudo-random number between 0 (inclusive) and 1.0e0 (exclusive). Different
              numbers can be produced every time this function is invoked. Numbers should be produced
              with approximately equal probability.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>rand()</code></td>
                    <td><code>"0.31221030831984886"^^xsd:double</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
        </section>
        <section id="func-date-time">
          <h4>Functions on Dates and Times</h4>
          <section id="func-now">
            <h5>NOW</h5>
            <pre class="prototype nohighlight"> <span class="return">xsd:dateTime</span>  <span class="operator">NOW</span> ()</pre>
            <p>Returns an XSD dateTime value for the current query execution. All calls to this
              function in any one query execution must return the same value. The exact moment returned
              is not specified.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>NOW()</code></td>
                    <td><code>"2011-01-10T14:45:13.815-05:00"^^xsd:dateTime</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-year">
            <h5>YEAR</h5>
            <pre class="prototype nohighlight"> <span class="return">xsd:integer</span>  <span class="operator">YEAR</span> (<span class="type"><span class="type">xsd:dateTime</span></span> <span class="parm">arg</span>)</pre>
            <p>Returns the year part of <code>arg</code> as an integer.</p>
            <p>This function corresponds to <a data-cite="XPATH-FUNCTIONS#func-year-from-dateTime">fn:year-from-dateTime</a>.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>YEAR("2011-01-10T14:45:13.815-05:00"^^xsd:dateTime)</code></td>
                    <td><code>2011</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-month">
            <h5>MONTH</h5>
            <pre class="prototype nohighlight"> <span class="return">xsd:integer</span>  <span class="operator">MONTH</span> (<span class="type"><span class="type">xsd:dateTime</span></span> <span class="parm">arg</span>)</pre>
            <p>Returns the month part of <code>arg</code> as an integer.</p>
            <p>This function corresponds to <a data-cite="XPATH-FUNCTIONS#func-month-from-dateTime">fn:month-from-dateTime</a>.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>MONTH("2011-01-10T14:45:13.815-05:00"^^xsd:dateTime)</code></td>
                    <td><code>1</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-day">
            <h5>DAY</h5>
            <pre class="prototype nohighlight"> <span class="return">xsd:integer</span>  <span class="operator">DAY</span> (<span class="type"><span class="type">xsd:dateTime</span></span> <span class="parm">arg</span>)</pre>
            <p>Returns the day part of <code>arg</code> as an integer.</p>
            <p>This function corresponds to <a data-cite="XPATH-FUNCTIONS#func-day-from-dateTime">fn:day-from-dateTime</a>.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>day("2011-01-10T14:45:13.815-05:00"^^xsd:dateTime)</code></td>
                    <td><code>10</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-hours">
            <h5>HOURS</h5>
            <pre class="prototype nohighlight"> <span class="return">xsd:integer</span>  <span class="operator">HOURS</span> (<span class="type"><span class="type">xsd:dateTime</span></span> <span class="parm">arg</span>)</pre>
            <p>Returns the hours part of <code>arg</code> as an integer. The value is as given in the
              lexical form of the XSD dateTime.</p>
            <p>This function corresponds to <a data-cite="XPATH-FUNCTIONS#func-hours-from-dateTime">fn:hours-from-dateTime</a>.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>HOURS("2011-01-10T14:45:13.815-05:00"^^xsd:dateTime)</code></td>
                    <td><code>14</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-minutes">
            <h5>MINUTES</h5>
            <pre class="prototype nohighlight"> <span class="return">xsd:integer</span>  <span class="operator">MINUTES</span> (<span class="type"><span class="type">xsd:dateTime</span></span> <span class="parm">arg</span>)</pre>
            <p>Returns the minutes part of the lexical form of <code>arg</code>. The value is as
              given in the lexical form of the XSD dateTime.</p>
            <p>This function corresponds to <a data-cite="XPATH-FUNCTIONS#func-minutes-from-dateTime">fn:minutes-from-dateTime</a>.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>MINUTES("2011-01-10T14:45:13.815-05:00"^^xsd:dateTime)</code></td>
                    <td><code>45</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-seconds">
            <h5>SECONDS</h5>
            <pre class="prototype nohighlight"> <span class="return">xsd:decimal</span>  <span class="operator">SECONDS</span> (<span class="type"><span class="type">xsd:dateTime</span></span> <span class="parm">arg</span>)</pre>
              <p>Returns the seconds part of the lexical form of <code>arg</code>.</p>
              <p>This function corresponds to <a data-cite="XPATH-FUNCTIONS#func-seconds-from-dateTime">fn:seconds-from-dateTime</a>.</p>
              <div class="result">
                <table>
                  <tbody>
                    <tr>
                      <td><code>SECONDS("2011-01-10T14:45:13.815-05:00"^^xsd:dateTime)</code></td>
                    <td><code>13.815</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-timezone">
            <h5>TIMEZONE</h5>
            <pre class="prototype nohighlight"> <span class="return">xsd:dayTimeDuration</span>  <span class="operator">TIMEZONE</span> (<span class="type"><span class="type">xsd:dateTime</span></span> <span class="parm">arg</span>)</pre>
            <p>Returns the timezone part of <code>arg</code> as an xsd:dayTimeDuration.
              Raises an error if there is no timezone.</p>
            <p>This function corresponds to 
              <a data-cite="XPATH-FUNCTIONS#func-timezone-from-dateTime">fn:timezone-from-dateTime</a>
              except for the treatment of literals with no timezone.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>TIMEZONE("2011-01-10T14:45:13.815-05:00"^^xsd:dateTime)</code></td>
                    <td><code>"-PT5H"^^xsd:dayTimeDuration</code></td>
                  </tr>
                  <tr>
                    <td><code>TIMEZONE("2011-01-10T14:45:13.815Z"^^xsd:dateTime)</code></td>
                    <td><code>"PT0S"^^xsd:dayTimeDuration</code></td>
                  </tr>
                  <tr>
                    <td><code>TIMEZONE("2011-01-10T14:45:13.815"^^xsd:dateTime)</code></td>
                    <td>error</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-tz">
            <h5>TZ</h5>
            <pre class="prototype nohighlight"> <span class="return">xsd:string</span>  <span class="operator">TZ</span> (<span class="type"><span class="type">xsd:dateTime</span></span> <span class="parm">arg</span>)</pre>
            <p>Returns the timezone part of <code>arg</code> as a literal with datatype <code>xsd:string</code>. Returns the empty
              string if there is no timezone.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>TZ("2011-01-10T14:45:13.815-05:00"^^xsd:dateTime)</code></td>
                    <td><code>"-05:00"</code></td>
                  </tr>
                  <tr>
                    <td><code>TZ("2011-01-10T14:45:13.815Z"^^xsd:dateTime)</code></td>
                    <td><code>"Z"</code></td>
                  </tr>
                  <tr>
                    <td><code>TZ("2011-01-10T14:45:13.815"^^xsd:dateTime)</code></td>
                    <td><code>""</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
        </section>
        <section id="func-hash">
          <h4>Hash Functions</h4>
          <section id="func-md5">
            <h5>MD5</h5>
            <pre class="prototype nohighlight"> <span class="return">xsd:string</span>  <span class="operator">MD5</span> (<span class="type"><span class="type">xsd:string</span></span> <span class="name">arg</span>)</pre>
            <p>Returns the MD5 checksum, as a hex digit string, calculated on the lexical form of the <code>xsd:string</code>. Hex
              digits <em class="rfc2119" title="Keyword in RFC 2119 context">SHOULD</em> be in lower
              case.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>MD5("abc")</code></td>
                    <td><code>"900150983cd24fb0d6963f7d28e17f72"</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-sha1">
            <h5>SHA1</h5>
            <pre class="prototype nohighlight"> <span class="return">xsd:string</span>  <span class="operator">SHA1</span> (<span class="type"><span class="type">xsd:string</span></span> <span class="name">arg</span>)</pre>
            <p>Returns the SHA1 checksum, as a hex digit string, calculated on the lexical form of the <code>xsd:string</code>. Hex
              digits <em class="rfc2119" title="Keyword in RFC 2119 context">SHOULD</em> be in lower
              case.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>SHA1("abc")</code></td>
                    <td><code>"a9993e364706816aba3e25717850c26c9cd0d89d"</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-sha256">
            <h5>SHA256</h5>
            <pre class="prototype nohighlight"> <span class="return">xsd:string</span>  <span class="operator">SHA256</span> (<span class="type"><span class="type">xsd:string</span></span> <span class="name">arg</span>)</pre>
            <p>Returns the SHA256 checksum, as a hex digit string, calculated on the lexical form of the <code>xsd:string</code>. Hex
              digits <em class="rfc2119" title="Keyword in RFC 2119 context">SHOULD</em> be in lower
              case.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>SHA256("abc")</code></td>
                    <td>
                      <code>"ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad"</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-sha384">
            <h5>SHA384</h5>
            <pre class="prototype nohighlight"> <span class="return">xsd:string</span>  <span class="operator">SHA384</span> (<span class="type"><span class="type">xsd:string</span></span> <span class="name">arg</span>)</pre>
            <p>Returns the SHA384 checksum, as a hex digit string, calculated on the lexical form of the <code>xsd:string</code>. Hex
              digits <em class="rfc2119" title="Keyword in RFC 2119 context">SHOULD</em> be in lower
              case.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>SHA384("abc")</code></td>
                    <td>
                      <code>"cb00753f45a35e8bb5a03d699ac65007272c32ab0eded1631a8b605a43ff5bed8086072ba1e7cc2358baeca134c825a7"</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-sha512">
            <h5>SHA512</h5>
            <pre class="prototype nohighlight"> <span class="return">xsd:string</span>  <span class="operator">SHA512</span> (<span class="type"><span class="type">xsd:string</span></span> <span class="name">arg</span>)</pre>
            <p>Returns the SHA512 checksum, as a hex digit string, calculated on the lexical form of the <code>xsd:string</code>. Hex
              digits <em class="rfc2119" title="Keyword in RFC 2119 context">SHOULD</em> be in lower
              case.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>SHA512("abc")</code></td>
                    <td>
                      <code>"ddaf35a193617abacc417349ae20413112e6fa4e89a97ea20a9eeee64b55d39a2192992a274fc1a836ba3c23a3feebbd454d4423643ce80e2a9ac94fa54ca49f"</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
        </section>
      </section>
      <section id="FunctionMapping">
        <h3>XPath Constructor Functions</h3>
        <p>SPARQL imports a subset of the XPath constructor functions defined in [[[XPATH-FUNCTIONS]]]
          [[XPATH-FUNCTIONS]] in section <a data-cite="XPATH-FUNCTIONS#casting-from-primitive-to-primitive">17.1 Casting
            from primitive types to primitive types</a>. SPARQL constructors include all of the XPath
          constructors for the <a href="#operandDataTypes">SPARQL operand datatypes</a> plus the
          <a href="#operandDataTypes">additional datatypes</a> imposed by the RDF data model. Casting
          in SPARQL is performed by calling a constructor function for the target type on an operand of
          the source type.</p>
        <p>XPath defines only the casts from one XML Schema datatype to another. The remaining cast
          is defined as follows:</p>
        <ul>
          <li>Casting an <span class="IRI type">IRI</span> to an <code>xsd:string</code> produces a
            <span class="IRI literal">literal</span> with a lexical value of the codepoints
            comprising the IRI, and a datatype of <code>xsd:string</code>.</li>
        </ul>
        <p>The table below summarizes the casting operations that are always allowed 
          (<span class="castY">Y</span>), never allowed (<span class="castN">N</span>)
          and dependent on the lexical
          value (<span class="castM">M</span>). For example, a casting operation from an
          <code>xsd:string</code> (the first row) to an <code>xsd:float</code> (the second column) is
          dependent on the lexical value (<span class="castM">M</span>).</p>
        <blockquote>
          <p>bool = <a data-cite="XMLSCHEMA-2#boolean">xsd:boolean</a><br>
            dbl = <a data-cite="XMLSCHEMA-2#double">xsd:double</a><br>
            flt = <a data-cite="XMLSCHEMA-2#float">xsd:float</a><br>
            dec = <a data-cite="XMLSCHEMA-2#decimal">xsd:decimal</a><br>
            int = <a data-cite="XMLSCHEMA-2#integer">xsd:integer</a><br>
            dT = <a data-cite="XMLSCHEMA-2#dateTime">xsd:dateTime</a><br>
            str = <a data-cite="XMLSCHEMA-2#string">xsd:string</a><br>
            <span class="rdfDM">IRI</span> = <span class="type IRI">IRI</span></p>
        </blockquote>
        <table title="Casting table" class="casting" 
               style="border-spacing: 1px; border-width:1px">
          <colgroup>
            <col style="width: 13%">
            <col style="width: 11%">
            <col style="width: 11%">
            <col style="width: 11%">
            <col style="width: 11%">
            <col style="width: 11%">
            <col style="width: 11%">
            <col style="width: 11%">
          </colgroup>
          <thead>
            <tr>
              <th><span class="cancast" title="From\To">From \ To</span></th>
              <th><span class="cancast" title="string">str</span></th>
              <th><span class="cancast" title="float">flt</span></th>
              <th><span class="cancast" title="double">dbl</span></th>
              <th><span class="cancast" title="decimal">dec</span></th>
              <th><span class="cancast" title="integer">int</span></th>
              <th><span class="cancast" title="dateTime">dT</span></th>
              <th><span class="cancast" title="boolean">bool</span></th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <th><span class="cancast" title="string">str</span></th>
              <td class="castY" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast string to string? Yes">Y</span></td>
              <td class="castM" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast string to float? Maybe">M</span></td>
              <td class="castM" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast string to double? Maybe">M</span></td>
              <td class="castM" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast string to decimal? Maybe">M</span></td>
              <td class="castM" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast string to integer? Maybe">M</span></td>
              <td class="castM" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast string to dateTime? Maybe">M</span></td>
              <td class="castM" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast string to boolean? Maybe">M</span></td>
            </tr>
            <tr>
              <th><span class="cancast" title="float">flt</span></th>
              <td class="castY" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast float to string? Yes">Y</span></td>
              <td class="castY" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast float to float? Yes">Y</span></td>
              <td class="castY" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast float to double? Yes">Y</span></td>
              <td class="castM" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast float to decimal? Maybe">M</span></td>
              <td class="castM" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast float to integer? Maybe">M</span></td>
              <td class="castN" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast float to dateTime? No">N</span></td>
              <td class="castY" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast float to boolean? Yes">Y</span></td>
            </tr>
            <tr>
              <th><span class="cancast" title="double">dbl</span></th>
              <td class="castY" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast double to string? Yes">Y</span></td>
              <td class="castY" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast double to float? Yes">Y</span></td>
              <td class="castY" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast double to double? Yes">Y</span></td>
              <td class="castM" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast double to decimal? Maybe">M</span></td>
              <td class="castM" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast double to integer? Maybe">M</span></td>
              <td class="castN" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast double to dateTime? No">N</span></td>
              <td class="castY" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast double to boolean? Yes">Y</span></td>
            </tr>
            <tr>
              <th><span class="cancast" title="decimal">dec</span></th>
              <td class="castY" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast decimal to string? Yes">Y</span></td>
              <td class="castY" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast decimal to float? Yes">Y</span></td>
              <td class="castY" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast decimal to double? Yes">Y</span></td>
              <td class="castY" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast decimal to decimal? Yes">Y</span></td>
              <td class="castY" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast decimal to integer? Yes">Y</span></td>
              <td class="castN" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast decimal to dateTime? No">N</span></td>
              <td class="castY" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast decimal to boolean? Yes">Y</span></td>
            </tr>
            <tr>
              <th><span class="cancast" title="integer">int</span></th>
              <td class="castY" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast integer to string? Yes">Y</span></td>
              <td class="castY" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast integer to float? Yes">Y</span></td>
              <td class="castY" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast integer to double? Yes">Y</span></td>
              <td class="castY" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast integer to decimal? Yes">Y</span></td>
              <td class="castY" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast integer to integer? Yes">Y</span></td>
              <td class="castN" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast integer to dateTime? No">N</span></td>
              <td class="castY" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast integer to boolean? Yes">Y</span></td>
            </tr>
            <tr>
              <th><span class="cancast" title="dateTime">dT</span></th>
              <td class="castY" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast dateTime to string? Yes">Y</span></td>
              <td class="castN" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast dateTime to float? No">N</span></td>
              <td class="castN" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast dateTime to double? No">N</span></td>
              <td class="castN" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast dateTime to decimal? No">N</span></td>
              <td class="castN" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast dateTime to integer? No">N</span></td>
              <td class="castY" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast dateTime to dateTime? Yes">Y</span></td>
              <td class="castN" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast dateTime to boolean? No">N</span></td>
            </tr>
            <tr>
              <th><span class="cancast" title="boolean">bool</span></th>
              <td class="castY" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast boolean to string? Yes">Y</span></td>
              <td class="castY" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast boolean to float? Yes">Y</span></td>
              <td class="castY" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast boolean to double? Yes">Y</span></td>
              <td class="castY" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast boolean to decimal? Yes">Y</span></td>
              <td class="castY" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast boolean to integer? Yes">Y</span></td>
              <td class="castN" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast boolean to dateTime? No">N</span></td>
              <td class="castY" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast boolean to boolean? Yes">Y</span></td>
            </tr>
            <tr>
              <th><span class="cancast rdfDM" title="IRI">IRI</span></th>
              <td class="castY" style="vertical-align: middle; text-align: center;"><span class="cancast rdfDM" title=
                                                                                        "Cast IRI to string? Yes">Y</span></td>
              <td class="castN" style="vertical-align: middle; text-align: center;"><span class="cancast rdfDM" title=
                                                                                        "Cast IRI to float? No">N</span></td>
              <td class="castN" style="vertical-align: middle; text-align: center;"><span class="cancast rdfDM" title=
                                                                                        "Cast IRI to double? No">N</span></td>
              <td class="castN" style="vertical-align: middle; text-align: center;"><span class="cancast rdfDM" title=
                                                                                        "Cast IRI to decimal? No">N</span></td>
              <td class="castN" style="vertical-align: middle; text-align: center;"><span class="cancast rdfDM" title=
                                                                                        "Cast IRI to integer? No">N</span></td>
              <td class="castN" style="vertical-align: middle; text-align: center;"><span class="cancast rdfDM" title=
                                                                                        "Cast IRI to dateTime? No">N</span></td>
              <td class="castN" style="vertical-align: middle; text-align: center;"><span class="cancast rdfDM" title=
                                                                                        "Cast IRI to boolean? No">N</span></td>
            </tr>
          </tbody>
        </table>
      </section>
      <section id="extensionFunctions">
        <h3>Extensible Value Testing</h3>
        <p>It should be noted that any function or operator that is specified to return an error
          under some conditions is a valid extension point. That is, an implementation may return a
          non-error value in these error cases, and still be conformant with this recommendation.</p>
        <p>A <a href="#rPrimaryExpression">PrimaryExpression</a> grammar rule can be a call to an
          extension function named by an IRI. An extension function takes some number of RDF terms as
          arguments and returns an RDF term. The semantics of these functions are identified by the IRI
          that identifies the function.</p>
        <p>SPARQL queries using extension functions are likely to have limited interoperability.</p>
        <p>As an example, consider a function called <code>func:even</code>:</p>
        <pre class="prototype nohighlight"> <code>xsd:boolean</code>   <code>func:even</code> (<code><span class="type numeric">numeric</span></code> <code>value</code>)
        </pre>
        <div class="exampleGroup">
          <div class="queryGroup">
            <p>This function would be invoked in a FILTER as such:</p>
            <pre class="query nohighlight">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX func: &lt;http://example.org/functions#&gt;
SELECT ?name ?id
WHERE { 
    ?x foaf:name  ?name ;
       func:empId   ?id .
    FILTER (func:even(?id))
}
</pre>
          </div>
        </div>
        <p>For a second example, consider a function <code>aGeo:distance</code> that calculates the
          distance between two points, which is used here to find the places near Grenoble:</p>
        <pre class="prototype nohighlight">
          <code>xsd:double</code>   <code>aGeo:distance</code> (<code><span class="type numeric">numeric</span></code> <code>x1</code>, <code><span class="type numeric">numeric</span></code> <code>y1</code>, <code><span class="type numeric">numeric</span></code> <code>x2</code>, <code><span class="type numeric">numeric</span></code> <code>y2</code>)
        </pre>
        <div class="exampleGroup">
          <div class="queryGroup">
            <pre class="query nohighlight">
PREFIX aGeo: &lt;http://example.org/geo#&gt;

SELECT ?neighbor
WHERE {
    ?a aGeo:placeName "Grenoble" .
    ?a aGeo:locationX ?axLoc .
    ?a aGeo:locationY ?ayLoc .

    ?b aGeo:placeName ?neighbor .
    ?b aGeo:locationX ?bxLoc .
    ?b aGeo:locationY ?byLoc .

    FILTER ( aGeo:distance(?axLoc, ?ayLoc, ?bxLoc, ?byLoc) &lt; 10 ) .
}
            </pre>
          </div>
        </div>
        <p>An extension function might be used to test some application datatype not supported by the
          core SPARQL specification, it might be a transformation between datatype formats, for example
          into an XSD dateTime RDF term from another date format.</p>
      </section>
    </section>
    <section id="sparqlDefinition">
      <h2>Definition of SPARQL</h2>
      <p>This section defines the correct behavior for evaluation of graph patterns and solution
        modifiers, given a query string and an RDF dataset. It does not imply a SPARQL implementation
        must use the process defined here.</p>
      <p>The outcome of executing a SPARQL query is defined by a series of steps, starting from the
        SPARQL query as a string, turning that string into an abstract syntax form, then turning the
        abstract syntax into a SPARQL abstract query comprising operators from the SPARQL algebra. This
        abstract query is then evaluated on an RDF dataset.</p>
      <section id="initDefinitions">
        <h3>Initial Definitions</h3>
        <section id="sparqlDataset">
          <h4>RDF Dataset</h4>
          <div class="defn">
            <p><b>Definition: <span id="defn_RDFDataset">RDF Dataset</span></b></p>
            <p>An RDF dataset is a set:<br>
              { G, (&lt;u<sub>1</sub>&gt;, G<sub>1</sub>), (&lt;u<sub>2</sub>&gt;, G<sub>2</sub>), . .
              . (&lt;u<sub>n</sub>&gt;, G<sub>n</sub>) }<br>
              where G and each G<sub>i</sub> are graphs, and each &lt;u<sub>i</sub>&gt; is an IRI. Each
              &lt;u<sub>i</sub>&gt; is distinct.</p>
            <p>G is called the default graph. (&lt;u<sub>i</sub>&gt;, G<sub>i</sub>) are called named
              graphs.</p>
          </div>
          <div class="defn">
            <p><b>Definition: <span id="defn_ActiveGraph">Active Graph</span></b></p>
            <p>The <b>active graph</b> is the graph from the dataset used for basic graph pattern
              matching.</p>
          </div>
          <div class="defn">
            <div id="defn_RDFDatasetMerge">
              <b>Definition: RDF Dataset Merge</b>
            </div>
            <p>Let DS1 = { G1, (&lt;u1<sub>1</sub>&gt;, G1<sub>1</sub>), (&lt;u1<sub>2</sub>&gt;,
              G1<sub>2</sub>), . . . (&lt;u1<sub>n</sub>&gt;, G1<sub>n</sub>) },<br>
              and DS2 = { G2, (&lt;u2<sub>1</sub>&gt;, G2<sub>1</sub>), (&lt;u2<sub>2</sub>&gt;,
              G2<sub>2</sub>), . . . (&lt;u2<sub>m</sub>&gt;, G2<sub>m</sub>) }</p>
            <p>then we define the RDF Dataset Merge of DS1 and DS2 to be:<br>
              DS={ G, (&lt;u<sub>1</sub>&gt;, G<sub>1</sub>), (&lt;u<sub>2</sub>&gt;, G<sub>2</sub>), .
              . . (&lt;u<sub>k</sub>&gt;, G<sub>k</sub>) }<br>
              where:</p>
            <p>Write N1 for { &lt;u1<sub>j</sub>&gt; j = 1 to n }<br>
              Write N2 for { &lt;u2<sub>j</sub>&gt; j = 1 to m }<br></p>
            <ul>
              <li>G is the <a data-cite="RDF12-SEMANTICS#dfn-merge">merge</a> of G1 and G2
              </li>
              <li>(&lt;u<sub>i</sub>&gt;, G<sub>i</sub>) where &lt;u<sub>i</sub>&gt; is in N1 but not
                in N2</li>
              <li>(&lt;u<sub>i</sub>&gt;, G<sub>i</sub>) where &lt;u<sub>i</sub>&gt; is in N2 but not
                in N1</li>
              <li>(&lt;u<sub>i</sub>&gt;, G<sub>i</sub>) where &lt;u<sub>i</sub>&gt; is equal to
                &lt;u<sub>j</sub>&gt; in N1 and equal to &lt;u<sub>k</sub>&gt; in N2 and G<sub>i</sub>
                is the <a data-cite="RDF12-SEMANTICS#dfn-merge">merge</a> of G1<sub>j</sub> and G2<sub>k</sub>
              </li>
            </ul>
          </div>
        </section>
        <section id="sparqlQueryVariables">
          <h4>Query Variables</h4>
          <div class="defn">
            <p><b>Definition: <span id="defn_QueryVariable">Query Variable</span></b></p>
            <p>A <span class="definedTerm">query variable</span> is a member of the set V where V is
              infinite and disjoint from RDF-T.</p>
          </div>
        </section>
        <section id="sparqlTriplePatterns">
          <h4>Triple Patterns</h4>
          <div class="defn">
            <p><b>Definition: <span id="defn_TriplePattern">Triple Pattern</span></b></p>
            <p>A <span class="definedTerm">triple pattern</span> is member of the set:<br>
              (RDF-T ∪ V) x (I ∪ V) x (RDF-T ∪ V)</p>
          </div>
          <p>This definition of Triple Pattern includes literal subjects. 
            <a href="http://www.w3.org/2000/03/rdf-tracking/#rdfms-literalsubjects">
              This has been noted by RDF-core</a>.
          </p>
          <pre>"[The RDF core Working Group] noted that it is aware of no reason why literals should
            not be subjects and a future WG with a less restrictive charter may
            extend the syntaxes to allow literals as the subjects of statements."</pre>
          <p>Because RDF graphs may not contain literal subjects, any SPARQL triple pattern with a
            literal as subject will fail to match on any RDF graph.</p>
        </section>
        <section id="sparqlBasicGraphPatterns">
          <h4>Basic Graph Patterns</h4>
          <div class="defn">
            <p><b>Definition: <span id="defn_BasicGraphPattern">Basic Graph Pattern</span></b></p>
            <p>A <span class="definedTerm">Basic Graph Pattern</span> is a set of
              <a href="#defn_TriplePattern">Triple Patterns</a>.</p>
          </div>
          <p>The empty graph pattern is a basic graph pattern which is the empty set.</p>
        </section>
        <section id="sparqlPropertyPaths">
          <h4>Property Path Patterns</h4>
          <div class="defn">
            <p><b>Definition: <span id="defn_PropertyPath">Property Path</span></b></p>
            <p>A Property Path is a sequence of triples, t<sub>i</sub> in sequence ST, with n =
              length(ST)-1, such that, for i=0 to n, the object of t<sub>i</sub> is the same term as
              the subject of t<sub>i+1</sub>.</p>
            <p>We call the subject of t<sub>0</sub> the start of the path.</p>
            <p>We call the object of t<sub>n</sub> the end of the path.</p>
            <p>A Property Path is a path in graph G if each t<sub>i</sub> is a triple of G.</p>
          </div>
          <p>A property path does not span multiple graphs in a dataset.</p>
          <div class="defn">
            <p><b>Definition: <span id="defn_PropertyPathExpr">Property Path Expression</span></b></p>
            <p>
              A property path expression is an expression using the property path forms described
              above.
            </p>
          </div>
          <div class="defn">
            <p><b>Definition: <span id="defn_PropertyPathPattern">Property Path Pattern</span></b></p>
            <p>Let PP be the set of all property path expressions. A property path pattern is a
              member of the set:<br>
              (RDF-T ∪ V) x PP x (RDF-T ∪ V)</p>
          </div>
          <p>A Property Path Pattern is a generalization of a <a href="#defn_TriplePattern">Triple
              Pattern</a> to include a property path expression in the property position.</p>
        </section>
        <section id="sparqlSolutions">
          <h4>Solution Mapping</h4>
          <p>A solution mapping is a mapping from a set of variables to a set of RDF terms. We use
            the term 'solution' where it is clear.</p>
          <div class="defn">
            <p><b>Definition: <span id="defn_sparqlSolutionMapping">Solution Mapping</span></b></p>
            <p>A <b>solution mapping</b>, μ, is a partial function μ : V -&gt; RDF-T.</p>
            <p>The domain of μ, dom(μ), is the subset of V where μ is defined.</p>
          </div>
          <div class="defn">
            <p><b>Definition: <span id="defn_sparqlSolutionSequence">Solution Sequence</span></b></p>
            <p>A <b>solution sequence</b> is a list of solutions, possibly unordered.</p>
          </div>
          <p>Write expr(μ) for the value of the expression expr, using the terms for variables given
            by μ. Evaluation may result in an error.</p>
        </section>
        <section id="sparqlSolMod">
          <h4>Solution Sequence Modifiers</h4>
          <div class="defn">
            <p><b>Definition: <span id="defn_SolutionModifier">Solution Sequence Modifier</span></b></p>
            <p>A <span class="definedTerm">solution sequence modifier</span> is one of:</p>
            <ul>
              <li>
                <a href="#defn_algOrdered">Order By</a> modifier: put the solutions in order
              </li>
              <li>
                <a href="#defn_algProjection">Projection</a> modifier: choose certain variables
              </li>
              <li>
                <a href="#defn_algDistinct">Distinct</a> modifier: ensure solutions in the sequence
                are unique
              </li>
              <li>
                <a href="#defn_algReduced">Reduced</a> modifier: permit any non-distinct solutions to
                be eliminated
              </li>
              <li>
                <a href="#defn_algSlice">Offset</a> modifier: control where the solutions start from
                in the overall sequence of solutions
              </li>
              <li>
                <a href="#defn_algSlice">Limit</a> modifier: restrict the number of solutions
              </li>
            </ul>
          </div>
        </section>
        <section id="idp2427544">
          <h4>SPARQL Query</h4>
          <div class="defn">
            <p><b>Definition: <dfn data-lt="SPARQLQuery">SPARQL Query</dfn></b></p>
            <p>A <span class="definedTerm">SPARQL Abstract Query</span> is a tuple (E, DS, QF)
              where:</p>
            <ul>
              <li>E is a <a href="#sparqlAlgebra">SPARQL algebra</a> expression
              </li>
              <li>DS is an <a href="#defn_RDFDataset">RDF Dataset</a>
              </li>
              <li>QF is a <a href="#QueryForms">query form</a>
              </li>
            </ul>
          </div>
          <div class="defn">
            <p><b>Definition: <span id="defn_QueryUnit">Query Level</span></b></p>
            <p>A query level is a graph pattern, a set of group and aggregation, and a set of
              solution modifiers.</p>
          </div>
          <p>A query is a tree of "query levels", where each <a href="#subqueries">subquery</a> forms
            one query level in the tree.</p>
        </section>
      </section>
      <section id="sparqlQuery">
        <h3>Translation to the SPARQL Algebra</h3>
        <p>This section defines the process of converting graph patterns and solution modifiers in a
          SPARQL query string into a SPARQL algebra expression. The process described converts one
          level of query nesting, as formed by subqueries using the nested <code>SELECT</code> syntax and
          is applied recursively on subqueries. Each level consists of graph pattern matching and
          filtering, followed by the application of solution modifiers.</p>
        <p>The SPARQL query string is parsed and the abbreviations for IRIs and triple patterns given
          in <a href="#sparqlSyntax">section 4</a> are applied. At this point the abstract syntax tree
          is composed of:</p>
        <table class="plain">
          <tbody>
            <tr>
              <th>Patterns</th>
              <th>Modifiers</th>
              <th>Query Forms</th>
              <th>Other</th>
            </tr>
            <tr>
              <td>RDF terms</td>
              <td>DISTINCT</td>
              <td>SELECT</td>
              <td>VALUES</td>
            </tr>
            <tr>
              <td>Property path expression</td>
              <td>REDUCED</td>
              <td>CONSTRUCT</td>
              <td>SERVICE</td>
            </tr>
            <tr>
              <td>Property path patterns</td>
              <td>Projection</td>
              <td>DESCRIBE</td>
              <td>&nbsp;</td>
            </tr>
            <tr>
              <td>Groups</td>
              <td>ORDER BY</td>
              <td>ASK</td>
              <td>&nbsp;</td>
            </tr>
            <tr>
              <td>OPTIONAL</td>
              <td>LIMIT</td>
              <td>&nbsp;</td>
              <td>&nbsp;</td>
            </tr>
            <tr>
              <td>UNION</td>
              <td>OFFSET</td>
              <td>&nbsp;</td>
              <td>&nbsp;</td>
            </tr>
            <tr>
              <td>GRAPH</td>
              <td>Select expressions</td>
              <td>&nbsp;</td>
              <td>&nbsp;</td>
            </tr>
            <tr>
              <td>BIND</td>
              <td>&nbsp;</td>
              <td>&nbsp;</td>
              <td>&nbsp;</td>
            </tr>
            <tr>
              <td>GROUP BY</td>
              <td>&nbsp;</td>
              <td>&nbsp;</td>
              <td>&nbsp;</td>
            </tr>
            <tr>
              <td>HAVING</td>
              <td>&nbsp;</td>
              <td>&nbsp;</td>
              <td>&nbsp;</td>
            </tr>
            <tr>
              <td>MINUS</td>
              <td>&nbsp;</td>
              <td>&nbsp;</td>
              <td>&nbsp;</td>
            </tr>
            <tr>
              <td>FILTER</td>
              <td>&nbsp;</td>
              <td>&nbsp;</td>
              <td>&nbsp;</td>
            </tr>
          </tbody>
        </table>
        <p>The result of converting such an abstract syntax tree is a SPARQL query that uses the
          following symbols in the SPARQL algebra:</p>
        <table class="plain">
          <tbody>
            <tr>
              <th>Graph Pattern</th>
              <th>Solution Modifiers</th>
              <th>Property Path</th>
            </tr>
            <tr>
              <td>BGP</td>
              <td>ToList</td>
              <td>PredicatePath</td>
            </tr>
            <tr>
              <td>Join</td>
              <td>OrderBy</td>
              <td>InversePath</td>
            </tr>
            <tr>
              <td>LeftJoin</td>
              <td>Project</td>
              <td>SequencePath</td>
            </tr>
            <tr>
              <td>Filter</td>
              <td>Distinct</td>
              <td>AlernativePath</td>
            </tr>
            <tr>
              <td>Union</td>
              <td>Reduced</td>
              <td>ZeroOrMorePath</td>
            </tr>
            <tr>
              <td>Graph</td>
              <td>Slice</td>
              <td>OneOrMorePath</td>
            </tr>
            <tr>
              <td>Extend</td>
              <td>ToMultiSet</td>
              <td>ZeroOrOnePath</td>
            </tr>
            <tr>
              <td>Minus</td>
              <td>&nbsp;</td>
              <td>NegatedPropertySet</td>
            </tr>
            <tr>
              <td>Group</td>
              <td>&nbsp;</td>
              <td>&nbsp;</td>
            </tr>
            <tr>
              <td>Aggregation</td>
              <td>&nbsp;</td>
              <td>&nbsp;</td>
            </tr>
            <tr>
              <td>AggregateJoin</td>
              <td>&nbsp;</td>
              <td>&nbsp;</td>
            </tr>
          </tbody>
        </table>
        <p><i>Slice</i> is the combination of OFFSET and LIMIT.</p>
        <p><i>ToList</i> is used where conversion from the results of graph pattern matching to
          sequences occurs.</p>
        <p><i>ToMultiSet</i> is used where conversion from a solution sequence to a multiset
          occurs.</p>
        <section id="variableScope">
          <h4>Variable Scope</h4>
          <p>We define a variable to be <i>in-scope</i> if there is a way for a variable to be in the
            domain of a solution mapping at that point in the execution of the SPARQL algebra for the
            query. The definition below provides a way of determing this from the abstract syntax of a
            query.</p>
          <p>Note that a subquery with a projection can hide variables; use of a variable in
            <code>FILTER</code>, or in <code>MINUS</code> does not cause a variable to be in-scope
            outside of those forms.</p>
          <p>Let <b>P</b>, <b>P1</b>, <b>P2</b> be graph patterns and <b>E</b>,
            <b>E1</b>,...<b>En</b> be expressions. A variable <code>v</code> is in-scope if:</p>
          <table style="border-collapse: collapse; border-color: #000000; border-spacing:5px; border-width: 1px">
            <tbody>
              <tr>
                <th>Syntax Form</th>
                <th>In-scope variables</th>
              </tr>
              <tr>
                <td>Basic Graph Pattern (BGP)</td>
                <td><code>v</code> occurs in the BGP</td>
              </tr>
              <tr>
                <td>Path</td>
                <td><code>v</code> occurs in the path</td>
              </tr>
              <tr>
                <td>Group <code>{ P1 P2 ... }</code></td>
                <td><code>v</code> is in-scope if it is in-scope in one or more of P1, P2, ...</td>
              </tr>
              <tr>
                <td><code>GRAPH term { P }</code></td>
                <td><code>v</code> is <code>term</code> or <code>v</code> is in-scope in P</td>
              </tr>
              <tr>
                <td><code>{ P1 } UNION { P2 }</code></td>
                <td><code>v</code> is in-scope in P1 or in-scope in P2</td>
              </tr>
              <tr>
                <td><code>OPTIONAL {P}</code></td>
                <td><code>v</code> is in-scope in P</td>
              </tr>
              <tr>
                <td><code>SERVICE term {P}</code></td>
                <td><code>v</code> is <code>term</code> or <code>v</code> is in-scope in P</td>
              </tr>
              <tr>
                <td><code>BIND (expr AS v)</code></td>
                <td><code>v</code> is in-scope</td>
              </tr>
              <tr>
                <td><code>SELECT .. v .. { P }</code></td>
                <td><code>v</code> is in-scope</td>
              </tr>
              <tr>
                <td><code>SELECT ... (expr AS v)</code></td>
                <td><code>v</code> is in-scope</td>
              </tr>
              <tr>
                <td><code>GROUP BY (expr AS v)</code></td>
                <td><code>v</code> is in-scope</td>
              </tr>
              <tr>
                <td><code>SELECT * { P }</code></td>
                <td><code>v</code> is in-scope in <code>P</code></td>
              </tr>
              <tr>
                <td><code>VALUES v { values }</code></td>
                <td><code>v</code> is in-scope</td>
              </tr>
              <tr>
                <td><code>VALUES varlist { values }</code></td>
                <td><code>v</code> is in-scope if <code>v</code> is in <code>varlist</code></td>
              </tr>
            </tbody>
          </table>
          <p>The variable <code>v</code> must not be in-scope at the point of the <code>(expr AS
              v)</code> form. The scoping for <code>(expr AS v)</code> applies immediately in
            <code>SELECT</code> expressions.</p>
          <p>In <code>BIND (expr AS v)</code> requires that the variable <code>v</code> is not
            in-scope from the preceeding elements in the group graph pattern in which it is used.</p>
          <p>In <code>SELECT</code>, the variable <code>v</code> must not be in-scope in the graph
            pattern of the <code>SELECT</code> clause, nor used in another select expression earlier in
            the clause.</p>
        </section>
        <section id="convertGraphPattern">
          <h4>Converting Graph Patterns</h4>
          <p>This section describes the process for translating a SPARQL graph pattern into a SPARQL
            algebra expression. This process is applied to the group graph pattern (the unit between
            <code>{...}</code> delimiters) forming the <code>WHERE</code> clause of a query, and
            recursively to each syntactic element within the group graph pattern. The result of the
            translation is a SPARQL algebra expression.</p>
          <p>In summary, the steps are applied as follows:</p>
          <ul>
            <li>
              <a href="#sparqlExpandForms">Expand syntax forms</a> for IRIs, literals and triple
              patterns.
            </li>
            <li>
              <a href="#sparqlTranslatePathExpressions">Translate property path expressions</a>
            </li>
            <li>
              <a href="#sparqlTranslatePathPatterns">Convert some property path patterns to
                triples</a>
            </li>
            <li>
              <a href="#sparqlCollectFilters">Collect the <code>FILTER</code>s in the group</a>
            </li>
            <li>
              <a href="#sparqlTranslateBasicGraphPatterns">Translate Basic Graph Patterns</a>
            </li>
            <li>
              <a href="#sparqlTranslateGraphPatterns">Translate the remaining graph patterns in the
                group</a>
            </li>
            <li>
              <a href="#sparqlAddFilters">Add in Filters</a>
            </li>
            <li>
              <a href="#sparqlSimplification">Simplify the algebra expression</a>
            </li>
          </ul>
          <p>We write</p>
          <blockquote>
            translate(graph pattern)
          </blockquote>
          <p>for the algorthm described here to translate graph patterns.</p>
          <div class="wgNote">
            The working group notes that in SPARQL 1.0, the point at which the simplification step is
            applied leads to ambiguous transformation of queries involving a doubly nested filter and
            pattern in an optional:
            <pre><code>OPTIONAL { { ... FILTER ( ... ?x ... ) } }.</code>.</pre>
            <p>This is illustrated by two non-normative test cases:</p>
            <ul>
              <li>
                <a href="http://www.w3.org/2001/sw/DataAccess/tests/data-r2/optional-filter/manifest#dawg-optional-filter-005-not-simplified">
                  Simplification applied after all transformations</a> or not at all.
              </li>
              <li>
                <a href="http://www.w3.org/2001/sw/DataAccess/tests/data-r2/optional-filter/manifest#dawg-optional-filter-005-simplified">
                  Simplification applied during transformation</a>.
              </li>
            </ul>
          </div>
          <p>Applying the simpification step after all the translation of graph patterns is the
            preferred reading.</p>
          <section id="sparqlExpandForms">
            <h5>Expand Syntax Forms</h5>
            <p>Expand abbreviations for IRIs and triple patterns given in 
              <a href="#sparqlSyntax">section 4</a>.</p>
          </section>
          <section id="sparqlCollectFilters">
            <h5>Collect <code>FILTER</code> Elements</h5>
            <p><code>FILTER</code> expressions apply to the whole group graph pattern in which they
              appear. The algebra operators to perform filtering are added to the group after
              translation of each group element. We collect the filters together here and remove them
              from group, then <a href="#sparqlAddFilters">apply them to the whole translated group
                graph pattern</a>.</p>
            <p>In this step, we also translate graph patterns within <code>FILTER</code> expressions
              <a href="#func-filter-exists"><code>EXISTS</code> and <code>NOT EXISTS</code></a>.</p>

            <pre class="code nohighlightBlock">
Let FS := empty set
For each form FILTER(expr) in the group graph pattern:
    In expr, replace NOT EXISTS{P} with fn:not(<a href="#defn_evalExists">exists(translate(P)))</a> 
    In expr, replace EXISTS{P} with <a href="#defn_evalExists">exists(translate(P))</a>
    FS := FS ∪ {expr}
    End
</pre>
            <p>The set of filter expressions <code>FS</code> is <a href="#sparqlAddFilters">used
                later</a>.</p>
          </section>
          <section id="sparqlTranslatePathExpressions">
            <h5>Translate Property Path Expressions</h5>
            <p>The following table gives the translation of property paths expressions from SPARQL
              syntax to terms in the SPARQL algebra. This applies to all elements of a property path
              expression recursively.</p>
            <p>The <a href="#sparqlTranslatePathPatterns">next step after this one</a> translates
              certain forms to triple patterns, and these are converted later to basic graph patterns
              by adjacency (without intervening group pattern delimiters 
              <code>{</code> and <code>})</code> or
              other syntax forms. Overall, SPARQL syntax property paths of just an IRI become triple
              patterns and these are aggregated into basic graph patterns.</p>
            <p>Notes:</p>
            <ul>
              <li>The order of forms IRI and ^IRI in negated property sets is not relevant.</li>
            </ul>
            <p>We introduce the following symbols:</p>
            <ul>
              <li>link</li>
              <li>inv</li>
              <li>alt</li>
              <li>seq</li>
              <li>ZeroOrMorePath</li>
              <li>OneOrMorePath</li>
              <li>ZeroOrOnePath</li>
              <li>NPS (for NegatedPropertySet)</li>
            </ul>
            <table style="border-collapse: collapse; border-color: #000000; border-spacing: 5px; border-width: 1px">
              <tbody>
                <tr>
                  <th>Syntax Form (path)</th>
                  <th>Algebra (path)</th>
                </tr>
                <tr>
                  <td><code>iri</code></td>
                  <td><code>link(iri)</code></td>
                </tr>
                <tr>
                  <td><code>^path</code></td>
                  <td><code>inv(path)</code></td>
                </tr>
                <tr>
                  <td><code>!(:iri<sub>1</sub>|...|:iri<sub>n</sub>)</code></td>
                  <td><code>NPS({:iri<sub>1</sub> ... :iri<sub>n</sub>})</code></td>
                </tr>
                <tr>
                  <td><code>!(^:iri<sub>1</sub>|...|^:iri<sub>n</sub>)</code></td>
                  <td><code>inv(NPS({:iri<sub>1</sub> ... :iri<sub>n</sub>}))</code></td>
                </tr>
                <tr>
                  <td>
                    <code>!(:iri<sub>1</sub>|...|:iri<sub>i</sub>|^:iri<sub>i+1</sub>|...|^:iri<sub>m</sub>)</code>&nbsp;</td>
                  <td><code>alt(NPS({:iri<sub>1</sub> ...:iri<sub>i</sub>}),<br>
                      &nbsp;&nbsp;&nbsp;&nbsp;inv(NPS({:iri<sub>i+1</sub>, ..., :iri<sub>m</sub>}))
                      )</code></td>
                </tr>
                <tr>
                  <td><code>path1 / path2</code></td>
                  <td><code>seq(path1, path2)</code></td>
                </tr>
                <tr>
                  <td><code>path1 | path2</code></td>
                  <td><code>alt(path1, path2)</code></td>
                </tr>
                <tr>
                  <td><code>path*</code></td>
                  <td><code>ZeroOrMorePath(path)</code></td>
                </tr>
                <tr>
                  <td><code>path+</code></td>
                  <td><code>OneOrMorePath(path)</code></td>
                </tr>
                <tr>
                  <td><code>path?</code></td>
                  <td><code>ZeroOrOnePath(path)</code></td>
                </tr>
              </tbody>
            </table>
          </section>
          <section id="sparqlTranslatePathPatterns">
            <h5>Translate Property Path Patterns</h5>
            <p>The previous step translated <a href="#defn_PropertyPathExpr">property path
                expressions</a>. This step translates <a href="#defn_PropertyPathPattern">property path
                patterns</a>, which are a subject end point, property path expression and object end
              point, into triple patterns or wraps in a general algebra operation for path
              evaluation.</p>
            <p>Notes:</p>
            <ul>
              <li>X and Y are RDF terms or variables.</li>
              <li>?V is a fresh variable.</li>
              <li>P and Q are path expressions.</li>
              <li>These are only applied to property path patterns, not within property path
                expressions.</li>
              <li>Translations earlier in the table are applied in preference to the last
                translation.</li>
              <li>The final translation simply wraps any remaining property path expression to use a
                common form <code>Path(...)</code>.</li>
            </ul>
            <table style="border-collapse: collapse; border-color: #000000; border-spacing: 5px; border-width: 1px">
              <tbody>
                <tr>
                  <th>Algebra (path)</th>
                  <th>Translation</th>
                </tr>
                <tr>
                  <td><code>X link(iri) Y</code></td>
                  <td><code>X iri Y</code></td>
                </tr>
                <tr>
                  <td><code>X inv(iri) Y</code></td>
                  <td><code>Y iri X</code></td>
                </tr>
                <tr>
                  <td><code>X seq(P, Q) Y</code></td>
                  <td><code>X P ?V . ?V Q Y</code></td>
                </tr>
                <tr>
                  <td><code>X P Y</code></td>
                  <td><code>Path(X, P, Y)</code></td>
                </tr>
              </tbody>
            </table>
            <p>Examples of the whole path translation process (<code>?_V</code> is a fresh
              variable):</p>
            <div class="algExample">
              <div class="algExample1">
                ?s :p/:q ?o
              </div>
              <div class="algExample2">
                ?s :p ?_V .<br>
                ?_V :q ?o
              </div>
            </div>
            <div class="algExample">
              <div class="algExample1">
                ?s :p* ?o
              </div>
              <div class="algExample2">
                Path(?s, ZeroOrMorePath(link(:p)), ?o)
              </div>
            </div>
            <div class="algExample">
              <div class="algExample1">
                :list rdf:rest*/rdf:first ?member
              </div>
              <div class="algExample2">
                Path(:list, ZeroOrMorePath(link(rdf:rest)), ?_V) .<br>
                ?_V rdf:first ?member
              </div>
            </div>
          </section>
          <section id="sparqlTranslateBasicGraphPatterns">
            <h5>Translate Basic Graph Patterns</h5>
            <p>After translating property paths, any adjacent triple patterns are collected together
              to form a basic graph pattern <code>BGP(triples)</code>.</p>
          </section>
          <section id="sparqlTranslateGraphPatterns">
            <h5>Translate Graph Patterns</h5>
            <p>Next, we translate each remaining graph pattern form, recursively applying the
              translation process.</p>
            <blockquote>
              <p>If the form is <code><a href="#rGroupOrUnionGraphPattern">GroupOrUnionGraphPattern</a></code></p>
            </blockquote>

<pre class="code nohighlightBlock">Let A := undefined
          
For each element G in the GroupOrUnionGraphPattern
    If A is undefined
        A := Translate(G)
    Else
        A := Union(A, Translate(G))
    End

The result is A
            </pre>

            <blockquote>
              <p>If the form is <code><a href="#rGraphGraphPattern">GraphGraphPattern</a></code></p>
            </blockquote>

            <pre class="code nohighlightBlock">
If the form is GRAPH IRI GroupGraphPattern
    The result is Graph(IRI, Translate(GroupGraphPattern))
</pre>

            <pre class="code nohighlightBlock">
If the form is GRAPH Var GroupGraphPattern
    The result is Graph(Var, Translate(GroupGraphPattern))
</pre>

            <blockquote>
              <p>If the form is <code><a href="#rGroupGraphPattern">GroupGraphPattern</a></code>:</p>
            </blockquote>
<pre class="code nohighlightBlock">
Let FS := the empty set
Let G := the empty pattern, a basic graph pattern which is the empty set.

For each element E in the sequence of elements in the GroupGraphPattern

    If E is of the form OPTIONAL{P} 
        Let A := Translate(P)
        If A is of the form Filter(F, A2)
            G := LeftJoin(G, A2, F)
        Else 
            G := LeftJoin(G, A, true)
            End
        End

    If E is of the form MINUS{P}
        G := Minus(G, Translate(P))
        End

    If E is of the form BIND(expr AS var)
        G := Extend(G, var, expr)
        End

    If E is any other form 
        Let A := Translate(E)
        G := Join(G, A)
        End

   End
   
The result is G.
            </pre>
            <blockquote>
              <p>If the form is <a href="#rInlineData">InlineData</a></p>
            </blockquote>
            <pre class="code nohighlightBlock">The result is a multiset of solution mappings 'data'.</pre>
            <div id="data-block">
              <blockquote>
                <i>data</i> is formed by forming a solution mapping from the variable in the
                corresponding position in list of variables (or single variable), omitting a binding
                if the <a href="#rDataBlockValue">DataBlockValue</a>
                is the word <code>UNDEF</code>.
              </blockquote>
            </div>
            <blockquote>
              <p>If the form is <a href="#rSubSelect">SubSelect</a></p>
            </blockquote>
            <pre class="code nohighlightBlock">The result is ToMultiset(Translate(SubSelect))</pre>
          </section>
          <section id="sparqlAddFilters">
            <h5>Filters of Group</h5>
            <p>After the group has been translated, the filter expressions are added so they wil
              apply to the whole of the rest of the group:</p>
            <pre class="code nohighlightBlock">
If FS is not empty
    Let G := output of preceding step
    Let X := Conjunction of expressions in FS
    G := Filter(X, G)
End</pre>
          </section>
          <section id="sparqlSimplification">
            <h5>Simplification step</h5>
            <p>Some groups of one graph pattern become <code>join(Z, A)</code>, where Z is the empty
              basic graph pattern (which is the empty set). These can be replaced by A. The empty graph
              pattern Z is the identity for join:</p>
            <pre class="code nohighlightBlock">
Replace join(Z, A) by A
Replace join(A, Z) by A
</pre>
          </section>
        </section>
        <section id="sparqlAlgebraExamples">
          <h4>Examples of Mapped Graph Patterns</h4>
          <p>The second form of a rewrite example is the first with empty group joins removed by the
            simplification step.</p>
          <p>Example: group with a basic graph pattern consisting of a single triple pattern:</p>
          <div class="algExample">
            <div class="algExample1">
              { ?s ?p ?o }
            </div>
            <div class="algExample2">
              Join(Z, BGP(?s ?p ?o) )
            </div>
            <div class="algExample2">
              BGP(?s ?p ?o)
            </div>
          </div>
          <p>Example: group with a basic graph pattern consisting of two triple patterns:</p>
          <div class="algExample">
            <div class="algExample1">
              { ?s :p1 ?v1 ; :p2 ?v2 }
            </div>
            <div class="algExample2">
              BGP( ?s :p1 ?v1 . ?s :p2 ?v2 )
            </div>
          </div>
          <p>Example: group consisting of a union of two basic graph patterns:</p>
          <div class="algExample">
            <div class="algExample1">
              { { ?s :p1 ?v1 } UNION {?s :p2 ?v2 } }
            </div>
            <div class="algExample2">
              Union(Join(Z, BGP(?s :p1 ?v1)),<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Join(Z, BGP(?s :p2 ?v2)) )
            </div>
            <div class="algExample2">
              Union( BGP(?s :p1 ?v1) , BGP(?s :p2 ?v2) )
            </div>
          </div>
          <p>Example: group consisting of a union of a union and a basic graph pattern:</p>
          <div class="algExample">
            <div class="algExample1">
              { { ?s :p1 ?v1 } UNION {?s :p2 ?v2 } UNION {?s :p3 ?v3 } }
            </div>
            <div class="algExample2">
              Union(<br>
              &nbsp;&nbsp;&nbsp; Union( Join(Z, BGP(?s :p1 ?v1)),<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Join(Z, BGP(?s :p2 ?v2)))
              ,<br>
              &nbsp;&nbsp;&nbsp; Join(Z, BGP(?s :p3 ?v3)) )
            </div>
            <div class="algExample2">
              Union(<br>
              &nbsp;&nbsp;&nbsp; Union( BGP(?s :p1 ?v1) ,<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BGP(?s :p2 ?v2),<br>
              &nbsp;&nbsp;&nbsp; BGP(?s :p3 ?v3))
            </div>
          </div>
          <p>Example: group consisting of a basic graph pattern and an optional graph pattern:</p>
          <div class="algExample">
            <div class="algExample1">
              { ?s :p1 ?v1 OPTIONAL {?s :p2 ?v2 } }
            </div>
            <div class="algExample2">
              LeftJoin(<br>
              &nbsp;&nbsp;&nbsp; Join(Z, BGP(?s :p1 ?v1)),<br>
              &nbsp;&nbsp;&nbsp; Join(Z, BGP(?s :p2 ?v2)),<br>
              &nbsp;&nbsp;&nbsp; true)
            </div>
            <div class="algExample2">
              LeftJoin(BGP(?s :p1 ?v1), BGP(?s :p2 ?v2), true)
            </div>
          </div>
          <p>Example: group consisting of a basic graph pattern and two optional graph patterns:</p>
          <div class="algExample">
            <div class="algExample1">
              { ?s :p1 ?v1 OPTIONAL {?s :p2 ?v2 } OPTIONAL { ?s :p3 ?v3 } }
            </div>
            <div class="algExample2">
              LeftJoin(<br>
              &nbsp;&nbsp;&nbsp; LeftJoin(<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BGP(?s :p1 ?v1),<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BGP(?s :p2 ?v2),<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; true) ,<br>
              &nbsp;&nbsp;&nbsp; BGP(?s :p3 ?v3),<br>
              &nbsp;&nbsp;&nbsp; true)
            </div>
          </div>
          <p>Example: group consisting of a basic graph pattern and an optional graph pattern with a
            filter:</p>
          <div class="algExample">
            <div class="algExample1">
              { ?s :p1 ?v1 OPTIONAL {?s :p2 ?v2 FILTER(?v1&lt;3) } }
            </div>
            <div class="algExample2">
              LeftJoin(<br>
              &nbsp;&nbsp;&nbsp;&nbsp; Join(Z, BGP(?s :p1 ?v1)),<br>
              &nbsp;&nbsp;&nbsp;&nbsp; Join(Z, BGP(?s :p2 ?v2)),<br>
              &nbsp;&nbsp;&nbsp;&nbsp; (?v1&lt;3) )
            </div>
            <div class="algExample2">
              LeftJoin(<br>
              &nbsp;&nbsp;&nbsp; BGP(?s :p1 ?v1) ,<br>
              &nbsp;&nbsp;&nbsp; BGP(?s :p2 ?v2) ,<br>
              &nbsp;&nbsp; (?v1&lt;3) )
            </div>
          </div>
          <p>Example: group consisting of a union graph pattern and an optional graph pattern:</p>
          <div class="algExample">
            <div class="algExample1">
              { {?s :p1 ?v1} UNION {?s :p2 ?v2} OPTIONAL {?s :p3 ?v3} }
            </div>
            <div class="algExample2">
              LeftJoin(<br>
              &nbsp; Union(BGP(?s :p1 ?v1),<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BGP(?s :p2 ?v2)) ,<br>
              &nbsp; BGP(?s :p3 ?v3) ,<br>
              &nbsp; true )
            </div>
          </div>
          <p>Example: group consisting of a basic graph pattern, a filter and an optional graph
            pattern:</p>
          <div class="algExample">
            <div class="algExample1">
              { ?s :p1 ?v1 FILTER (?v1 &lt; 3 ) OPTIONAL {?s :p2 ?v2} }
            </div>
            <div class="algExample2">
              Filter( ?v1 &lt; 3 ,<br>
              &nbsp; LeftJoin( BGP(?s :p1 ?v1), BGP(?s :p2 ?v2), true) ,<br>
              &nbsp; )
            </div>
          </div>
          <p>Example: Pattern involving BIND:</p>
          <div class="algExample">
            <div class="algExample1">
              { ?s :p ?v . BIND (2*?v AS ?v2) ?s :p1 ?v2 }
            </div>
            <div class="algExample2">
              Join(<br>
              &nbsp;&nbsp; Extend( BGP(?s :p ?v), ?v2, 2*?v) ,<br>
              &nbsp;&nbsp; BGP(?s :p1 ?v2) )
            </div>
          </div>
          <p>Example: Pattern involving BIND, with a 
            <a href="#sparqlSimplification">simplification</a> step:</p>
          <div class="algExample">
            <div class="algExample1">
              { ?s :p ?v . {} BIND (2*?v AS ?v2) }
            </div>
            <div class="algExample2">
              Extend(<br>
              &nbsp;&nbsp; Join( <br>
              &nbsp;&nbsp;&nbsp;&nbsp; Join( {}, BGP(?s :p ?v)),<br>
              &nbsp;&nbsp;&nbsp;&nbsp; {}),<br>
              &nbsp;&nbsp; ?v2, 2*?v<br>
              )
            </div>
            <div class="algExample2">
              Extend(<br>
              &nbsp;&nbsp; BGP(?s :p ?v) ,<br>
              &nbsp;&nbsp; ?v2, 2*?v<br>
            )
            </div>
          </div>
          <p>Example: Pattern involving MINUS:</p>
          <div class="algExample">
            <div class="algExample1">
              { ?s :p ?v . MINUS {?s :p1 ?v2 } }
            </div>
            <div class="algExample2">
              Minus(<br>
              &nbsp;&nbsp; BGP(?s :p ?v)<br>
              &nbsp;&nbsp; BGP(?s :p1 ?v2)<br>
              )
            </div>
          </div>
          <p>Example: Pattern involving a subquery:</p>
          <div class="algExample">
            <div class="algExample1">
              { ?s :p ?o . {SELECT DISTINCT ?o {?o ?p ?z} } }
            </div>
            <div class="algExample2">
              Join(<br>
              &nbsp;&nbsp; BGP(?s :p ?o) ,<br>
              &nbsp;&nbsp; ToMultiSet(<br>
              &nbsp;&nbsp;&nbsp;&nbsp; Distinct(Project(BGP(?o ?p ?z), {?o})) )<br>
              &nbsp;&nbsp; )
            </div>
          </div>
        </section>
        <section id="convertGroupAggSelectExpressions">
          <h4>Converting Groups, Aggregates, HAVING, final VALUES clause and SELECT Expressions</h4>
          <p>In this step, we process clauses on the query level in the following order:</p>
          <ul>
            <li>Grouping</li>
            <li>Aggregates</li>
            <li>HAVING</li>
            <li>VALUES</li>
            <li>Select expressions</li>
          </ul>
          <section id="sparqlGroupAggregate">
            <h5>Grouping and Aggregation</h5>
            <p>Step: GROUP BY</p>
            <p>If the <code>GROUP BY</code> keyword is used, or there is implicit grouping due to the
              use of aggregates in the projection, then grouping is performed by the 
              <a href="#defn_algGroup">Group</a> function. It divides the solution set into groups of one or
              more solutions, with the same overall cardinality. In case of implicit grouping, a fixed
              constant (1) is used to group all solutions into a single group.</p>
            <p>Step: Aggregates</p>
            <p>
              The aggregation step is applied as a transformation on the query level, replacing
              aggregate expressions in the query level with Aggregation() algebraic
              expressions.
            </p>
            <p>
              The transformation for query levels that use any aggregates is given
              below:
            </p>

<pre class="code nohighlightBlock">Let A := the empty sequence
Let Q := the query level being evaluated
Let P := the algebra translation of the GroupGraphPattern of the query level
Let E := [], a list of pairs of the form (variable, expression)

If Q contains GROUP BY exprlist
   Let G := Group(exprlist, P)
Else If Q contains an aggregate in SELECT, HAVING, ORDER BY
   Let G := Group((1), P)
Else
   skip the rest of the aggregate step
   End

Global i := 1   # Initially 1 for each query processed

For each (X AS Var) in SELECT, each HAVING(X), and each ORDER BY X in Q
  For each unaggregated variable V in X
      Replace V with Sample(V)
      End
  For each aggregate R(args ; scalarvals) now in X
      # note scalarvals may be omitted, then it's equivalent to the empty set
      A<span><sub>i</sub></span> := Aggregation(args, R, scalarvals, G)
      Replace R(...) with agg<span><sub>i</sub></span> in Q
      i := i + 1
      End
  End

For each variable V appearing outside of an aggregate
   A<span><sub>i</sub></span> := Aggregation(V, Sample, {}, G)
   E := E append (V, agg<span><sub>i</sub></span>)
   i := i + 1
   End

A := A<span><sub>i</sub></span>, ..., A<span><sub>i-1</sub></span>
P := AggregateJoin(A)
</pre>
          </section>
          <section id="sparqlHavingClause">
            <h5>HAVING</h5>
            <p>The HAVING expression is evaluated using the same rules as FILTER().
              Note that, due to the logic position in which the HAVING clause is
              evaluated, expressions projected by the
              SELECT clause are not visible to the HAVING clause.</p>
            <pre class="code nohighlightBlock">
Let Q := the query level being evaluated
Let P := the algebra translation of the query level so far

For each HAVING(E) in Q
    P := Filter(E, P)
    End
</pre>

          </section>
          <section id="sparqlAlgebraFinalValues">
            <h5>VALUES</h5>
            <p>If the query has a trailing VALUES clause:</p>

<pre class="code nohighlightBlock">
Let P := the algebra translation of the query level so far
P := Join(P, ToMultiSet(data))
  where <i>data</i> is a solution sequence derived from the VALUES clause
</pre>

            <p>The translatation of the data is the same as for <a href="#data-block">inline
                data</a>.</p>
          </section>
          <section id="sparqlSelectExpressions">
            <h5>SELECT Expressions</h5>
            <p>Step: Select expressions</p>
            <p>We have two forms of the abstract syntax to consider:</p>

<pre class="code nohighlightBlock">
  SELECT selItem ... { pattern }
  SELECT * { pattern }
</pre>

<pre class="code nohighlightBlock">
Let X := algebra from earlier steps
Let VS := list of all variables visible in the pattern,
           so restricted by sub-SELECT projected variables and GROUP BY variables.
           Not visible: only in filter, exists/not exists, masked by a subselect, 
                        non-projected GROUP variables, only in the right hand side of MINUS

Let PV := {}, a set of variable names
Note, E is a list of pairs of the form (variable, expression), defined in <a href="#convertGroupAggSelectExpressions">section 18.2.4</a>.
  
If "SELECT *"
    PV := VS

If  "SELECT <code>selItem ...</code>:"  
    For each selItem:
        If selItem is a variable
            PV := PV ∪ { variable }
        End
        If selItem is (expr AS variable)
            variable must not appear in VS nor in PV; if it does then generate a syntax error and stop
            PV := PV ∪ { variable }
            E := E append (variable, expr) 
        End
    End

For each pair (var, expr) in E
    X := Extend(X, var, expr)
    End
  
Result is X  
The set PV is used later for projection.
            </pre>

            <p>The syntax error arises for use of a variable as the named target of AS (e.g. ... AS
              ?x) when the variable is used inside the WHERE clause of the SELECT or if already used as
              the target of AS in this SELECT expression.</p>
          </section>
        </section>
        <section id="convertSolMod">
          <h4>Converting Solution Modifiers</h4>
          <p>Solutions modifiers apply to the processing of a SPARQL query after pattern matching.
            The solution modifiers are applied to a query in the following order:</p>
          <ul>
            <li>Order by</li>
            <li>Projection</li>
            <li>Distinct</li>
            <li>Reduced</li>
            <li>Offset</li>
            <li>Limit</li>
          </ul>
          <p>Step: ToList</p>
          <p>ToList turns a multiset into a sequence with the same elements and cardinality. There is
            no implied ordering to the sequence; duplicates need not be adjacent.</p>
          <blockquote>
            <p>Let M := ToList(Pattern)</p>
          </blockquote>
          <section id="sparqlOrderBy">
            <h5>ORDER BY</h5>
            <p>If the query string has an ORDER BY clause</p>
            <blockquote>
              <p>M := OrderBy(M, list of order comparators)</p>
            </blockquote>
          </section>
          <section id="sparqlProjection">
            <h5>Projection</h5>
            <p>The set of projection variables, <code>PV</code>, was calculated in the
              <a href="#sparqlSelectExpressions">processing of SELECT expressions</a>.</p>
            <blockquote>
              <p>M := Project(M, PV)</p>
            </blockquote>
            <p>where vars is the set of variables mentioned in the SELECT clause or all named
              variables that are <a href="#variableScope">in-scope</a> in the query if SELECT *
              used.</p>
          </section>
          <section id="sparqlDistinct">
            <h5>DISTINCT</h5>
            <p>If the query contains DISTINCT,</p>
            <blockquote>
              <p>M := Distinct(M)</p>
            </blockquote>
          </section>
          <section id="sparqlReduced">
            <h5>REDUCED</h5>
            <p>If the query contains REDUCED,</p>
            <blockquote>
              <p>M := Reduced(M)</p>
            </blockquote>
          </section>
          <section id="sparqlOffsetLimit">
            <h5>OFFSET and LIMIT</h5>
            <p>If the query contains "OFFSET start" or "LIMIT length"</p>
            <blockquote>
              <p>M := Slice(M, start, length)</p>
              <blockquote>
                <p>start defaults to 0</p>
                <p>length defaults to (size(M)-start).</p>
              </blockquote>
            </blockquote>
          </section>
          <section id="sparqlAlgebraOutcome">
            <h5>Final Algebra Expression</h5>
            <blockquote>
              The overall abstract query is M.
            </blockquote>
          </section>
        </section>
      </section>
      <section id="BasicGraphPattern">
        <h3>Basic Graph Patterns</h3>
        <p>When matching graph patterns, the possible solutions form a 
          <a href="https://en.wikipedia.org/w/index.php?title=Multiset">multiset</a>, 
          also known as a <i>bag</i>. A multiset is an
          unordered collection of elements in which each element may appear more than once. It is
          described by a set of elements and a cardinality function giving the number of occurrences of
          each element from the set in the multiset.</p>
        <p>Write μ for solution mappings.</p>
        <p>Write μ<sub>0</sub> for the mapping such that dom(μ<sub>0</sub>) is the empty set.</p>
        <p>Write Ω<sub>0</sub> for the multiset consisting of exactly the empty mapping
          μ<sub>0,</sub> with cardinality 1. This is the join identity.</p>
        <p>Write μ(x) for the solution mapping variable x to RDF term t : { (x, t) }</p>
        <p>Write Ω(x) for the multiset consisting of exactly μ(?x-&gt;t), that is, { { (x, t) } }
          with cardinality 1.</p>
        <div class="defn">
          <p><b>Definition: <span id="defn_algCompatibleMapping">Compatible Mappings</span></b></p>
          <p>Two solution mappings μ<sub>1</sub> and μ<sub>2</sub> are compatible if, for every
            variable v in dom(μ<sub>1</sub>) and in dom(μ<sub>2</sub>), μ<sub>1</sub>(v) =
            μ<sub>2</sub>(v).</p>
        </div>
        <p>Here, μ<sub>1</sub>(v) = μ<sub>2</sub>(v) means that μ<sub>1</sub>(v) and μ<sub>2</sub>(v)
          are the same RDF term.</p>
        <p>If μ<sub>1</sub> and μ<sub>2</sub> are compatible then μ<sub>1</sub> ∪ μ<sub>2</sub> is
          also a mapping. Write merge(μ<sub>1</sub>, μ<sub>2</sub>) for μ<sub>1</sub> ∪
          μ<sub>2</sub></p>
        <p>Write card[Ω](μ) for the cardinality of solution mapping μ in a multiset of mappings
          Ω.</p>
        <section id="BGPsparql">
          <h4>SPARQL Basic Graph Pattern Matching</h4>
          <p>A basic graph pattern is matched against the active graph for that part of the query.
            Basic graph patterns can be instantiated by replacing both variables and blank nodes by
            terms, giving two notions of instance. Blank nodes are replaced using an
            <a data-cite="RDF12-SEMANTICS#dfn-instance">RDF instance mapping</a>, &nbsp;σ, from blank nodes to RDF terms;
            variables are replaced by a solution mapping from query variables to RDF terms.</p>
          <div class="defn">
            <p><b>Definition: <span id="defn_PatternInstanceMapping">Pattern Instance Mapping</span></b></p>
            <p>A <b>Pattern Instance Mapping</b>, P, is the combination of an RDF instance mapping,
              σ, and solution mapping, μ. P(x) = μ(σ(x))</p>
          </div>
          <p>For a BGP 'x', P(x) denotes the result of replacing blank nodes b in x for which σ is
            defined with σ(b) and all variables v in x for which μ is defined with μ(v).</p>
          <p>Any pattern instance mapping defines a unique solution mapping and a unique RDF instance
            mapping obtained by restricting it to query variables and blank nodes respectively.</p>
          <div class="defn">
            <b>Definition: Basic Graph Pattern Matching</b>
            <p>Let BGP be a basic graph pattern and let G be an RDF graph.</p>
            <p>μ is a <b>solution</b> for BGP from G when there is a pattern instance mapping P such
              that P(BGP) is a subgraph of G and μ is the restriction of P to the query variables in
              BGP.</p>
            <p>card[Ω](μ) = card[Ω](number of distinct RDF instance mappings, σ, such that P = μ(σ)
              is a pattern instance mapping and P(BGP) is a subgraph of G).</p>
          </div>
          <p>If a basic graph pattern is the empty set, then the solution is Ω<sub>0</sub>.</p>
        </section>
        <section id="BGPsparqlBNodes">
          <h4>Treatment of Blank Nodes</h4>
          <p>This definition allows the solution mapping to bind a variable in a basic graph pattern,
            BGP, to a blank node in G. Since SPARQL treats blank node identifiers in a results format
            document ([[[RDF-SPARQL-XMLRES]]], [[[SPARQL11-RESULTS-JSON]]] and
            [[[SPARQL11-RESULTS-CSV-TSV]]]) as scoped to the document, they cannot be understood as
            identifying nodes in the active graph of the dataset. If DS is the dataset of a query,
            pattern solutions are therefore understood to be not from the active graph of DS itself,
            but from an RDF graph, called the <i>scoping graph,</i> which is graph-equivalent to the
            active graph of DS but shares no blank nodes with DS or with BGP. The same scoping graph is
            used for all solutions to a single query. The scoping graph is purely a theoretical
            construct; in practice, the effect is obtained simply by the document scope conventions for
            blank node identifiers.</p>
          <p>Since RDF blank nodes allow infinitely many redundant solutions for many patterns, there
            can be infinitely many pattern solutions (obtained by replacing blank nodes by different
            blank nodes). It is necessary, therefore, to somehow delimit the solutions for a basic
            graph pattern. SPARQL uses the subgraph match criterion to determine the solutions of a
            basic graph pattern. There is one solution for each distinct pattern instance mapping from
            the basic graph pattern to a subset of the active graph.</p>
          <p>This is optimized for ease of computation rather than redundancy elimination. It allows
            query results to contain redundancies even when the active graph of the dataset is
            <a data-cite="RDF12-SEMANTICS#dfn-lean">lean</a>, and it allows logically equivalent datasets to
            yield different query results.</p>
        </section>
      </section>
      <section id="PropertyPathPatterns">
        <h3>Property Path Patterns</h3>
        <p>This section defines the evaluation of <a href="#defn_PropertyPathPattern">property path
            patterns</a>. A property path pattern is a subject endpoint (an RDF term or a variable), a
          property path express and an object endpoint. The 
          <a href="#sparqlTranslatePathExpressions">translation of property path expressions</a> converts some
          forms to other SPARQL expressions, such as converting property paths of length one to triple
          patterns, which in turn are combined into basic graph patterns. This leaves property path
          operators ZeroOrOnePath, ZeroOrMorePath, OneOrMorePath and NegatedPropertySets and also path
          expressions contained within these operators.</p>
        <p>All remaining property path expressions are present in the algebra in the form
          <code>Path(X, path, Y)</code> for endpoints X and Y. For example: syntax<code>(:p/:q)*</code>
          is a ZeroOrMorePath expression involving a sequence property path becoming the algebra
          expession <code>ZeroOrMorePath(seq(link(:p), link(:q)))</code>.</p>
        <div class="defn">
          <div id="pp-eval-notation">
            <b>Notation</b>
          </div>
          <p>Write</p>
          <pre>eval(Path(X, PP, Y))</pre>
          <p>for the evaluation of the property path patterns. This produces a multiset of solution
            mappings μ, each solution mapping having a binding for variables used (each of X and Y can
            be a variable). Some operators only produce a set of solution mappings.</p>
          <p>Write</p>
          <pre>
Var(x<sub>1</sub>, x<sub>2</sub>, ..., x<sub>n</sub>) = { x<sub>i</sub> | i in 1...n and x<sub>i</sub> is a variable
}
          </pre>
          <p>for the variables in <code>x<sub>1</sub>, x<sub>2</sub>, ..., x<sub>n</sub></code>.</p>
          <p>Write</p>
          <table style="border-collapse: collapse; border-color: #000000; border-spacing: 10px ; border-width: 1px">
            <tbody>
              <tr>
                <td><code>x:term</code></td>
                <td>when <code>x</code> is an RDF term</td>
              </tr>
              <tr>
                <td><code>x:var</code></td>
                <td>when <code>x</code> is a variable</td>
              </tr>
              <tr>
                <td><code>x:path</code></td>
                <td>when <code>x</code> is a path expression</td>
              </tr>
            </tbody>
          </table>
        </div>
        <p>All evaluation is carried out by matching the <a href="#defn_ActiveGraph">active graph</a>
          at that point in the overall query evaluation. We omit explicitly including the active graph
          in each definition for clarity.</p>
        <div class="defn">
          <p><b>Definition: <span id="defn_evalPP_predicate">Evaluation of Predicate Property Path</span></b></p>
          <p>Let Path(X, link(iri), Y) be an predicate inverse property path pattern, using some IRI
            iri.</p>
            <pre>
eval(Path(X, link(iri), Y)) = <a href="#BasicGraphPattern">evaluation of basic graph pattern</a> {X iri Y}
            </pre>
        </div>
        <p>If both X and Y are variables, this is the same as:</p>
        <pre>
eval(Path(X:var, link(iri), Y:var)) = { (X, xn) (Y, yn) | xn and yn are RDF terms and triple (xn iri yn) is in the active graph }</pre>
        <p>If X is a variable and Y an RDF term:</p>
        <pre>
eval(Path(X:var, link(iri), Y:term)) = { (X, xn) | xn is an RDF term and triple (xn iri Y) is in the active graph
}
        </pre>
        <p>If X is an RDF term and Y is a variable:</p>
        <pre>
eval(Path(X:term, link(iri), Y:var)) = { (Y, yn) | yn is an RDF term and triple (X iri yn) is in the active graph
}
        </pre>
        <p>If both X and Y are RDF terms:</p>
        <pre>
eval(Path(X:term, link(iri), Y:term)) 
    = { μ<sub>0</sub> } if triple (X iri Y) is in the active graph
    = { { } } = Ω<sub>0</sub> 

eval(Path(X:term, link(iri), Y:term)) = { } if triple (X iri Y) is not in the active graph
        </pre>
        <p>Informally, evaluating a Predicate Property Path is the same as executing a subquery
          <code>SELECT * { <i>X P Y</i> }</code> at that point in the query evaluation.</p>
        <div class="defn">
          <p><b>Definition: <span id="defn_evalPP_inverse">Evaluation of Inverse Property Path</span></b></p>
          <p>Let P be a property path expression, then:</p>
          <pre>eval(Path(X, inv(P), Y)) = eval(Path(Y, P, X))</pre>
        </div>
        <div class="defn">
          <p><b>Definition: <span id="defn_evalPP_sequence">Evaluation of Sequence Property Path</span></b></p>
          <p>Let P and Q be property path expressions. Let V be a fresh variable.</p>
          <pre>A = Join( eval(Path(X, P, V)), eval(Path(V, Q, Y)) )</pre>
          <pre>eval(Path(X, seq(P,Q), Y)) = Project(A, Var(X,Y))</pre>
        </div>
        <p>Informally, this is the same as:</p>
        <pre>SELECT * { X P _:a . _:a Q Y }</pre>
        <p>using the fact that a blank node <code>_:a</code> acts like a variable (under simple
          entailment) except it does not appear in the results from <code>SELECT *</code>.</p>
        <div class="defn">
          <p><b>Definition: <span id="defn_evalPP_alternative">Evaluation of Alternative Property Path</span></b></p>
          <p>Let P and Q be property path expressions.</p>
          <pre>
eval(Path(X, alt(P,Q), Y)) = 
    Union(eval(Path(X, P, Y)), eval(Path(X, Q, Y)))
          </pre>
        </div>
        <p>Informally, this is the same as:</p>
        <pre>SELECT * { { X P Y } UNION { X Q Y } }</pre>
        <div class="defn">
          <p><b>Definition: <span id="defn_nodeSet">Node set of a graph</span></b></p>
          <p>The node set of a graph G, nodes(G), is:</p>
          <p>nodes(G) = { n | n is an RDF term that is used as a subject or object of a triple of
            G}</p>
        </div>
        <div class="defn">
          <p><b>Definition: <span id="defn_evalPP_ZeroOrOnePath">Evaluation of ZeroOrOnePath</span></b></p>
          <pre>
eval(Path(X:term, ZeroOrOnePath(P), Y:var)) = 
    { (Y, yn) | yn = X or {(Y, yn)} in eval(Path(X,P,Y)) }
</pre>
          <pre>
eval(Path(X:var, ZeroOrOnePath(P), Y:term)) =
    { (X, xn) | xn = Y or {(X, xn)} in eval(Path(X,P,Y)) }
          </pre>
          <pre>
eval(Path(X:term, ZeroOrOnePath(P), Y:term)) = 
    { {} } if X = Y or eval(Path(X,P,Y)) is not empty
    { } othewise</pre>
          <pre>
eval(Path(X:var, ZeroOrOnePath(P), Y:var)) = 
    { (X, xn) (Y, yn) | either (yn in nodes(G) and xn = yn) or {(X,xn), (Y,yn)} in eval(Path(X,P,Y)) }</pre>
        </div>
        <p>We define an auxillary function, ALP, used in the definitions of ZeroOrMorePath and
          OneOrMorePath. Note that the algorithm given here serves to specify the feature. An
          implementation is free to implement evaluation by any method that produces the same results
          for the query overall. The ZeroOrMorePath and OneOrMorePath forms return matches based on
          distinct nodes connected by the path.</p>
        <p>The matching algorithm is based on following all paths, and detecting when a graph node
          (subject or object), has been already visited on the path.</p>
        <p>Informally, this algorithm attempts to extend the multiset of results by one application
          of <code>path</code> at each step, noting which nodes it has visited for this particular path. If
          a node has been visited for the path under consideration, it is not a candidate for another
          step.</p>
        <div class="defn">
          <p><b>Definition: <span id="defn_evalALP_1">Function ALP</span></b></p>
          <pre>
Let eval(x:term, path) be the evaluation of 'path', starting at RDF term x, 
 and returning a multiset of RDF terms reached 
 by repeated matches of path.

  ALP(x:term, path) = 
      Let V = empty set
      ALP(x:term, path, V)
      return is V

  # V is the set of nodes visited

  ALP(x:term, path, V:set of RDF terms) =
      if ( x in V ) return 
      add x to V
      X = eval(x,path) 
      For n:term in X
          ALP(n, path, V)
          End
</pre>
        </div>
        <div class="defn">
          <p><b>Definition: Evaluation of</b></p>
          <div id="defn_evalZeroOrMorePath">
            <b>ZeroOrMorePath</b>
          </div>
          <pre>
eval(Path(X:term, ZeroOrMorePath(path), vy:var)) =
    { { (vy, n) } | n in ALP(X, path) }

eval(Path(vx:var, ZeroOrMorePath(path), vy:var)) =
    { { (vx, t), (vy, n) } |  t in nodes(G), (vy, n) in eval(Path(t, ZeroOrMorePath(path), vy)) }

eval(Path(vx:var, ZeroOrMorePath(path), y:term)) = 
    eval(Path(y:term, ZeroOrMorePath(inv(path)), vx:var))

eval(Path(x:term, ZeroOrMorePath(path), y:term)) = 
    { { } } if { (vy:var,y) } in eval(Path(x, ZeroOrMorePath(path) vy)
    { } otherwise
          </pre>
        </div>
        <div class="defn">
          <p><b>Definition: Evaluation of</b></p>
          <div id="defn_evalOneOrMorePath">
            <b>OneOrMorePath</b>
          </div>
          <p>eval(Path(X, OneOrMorePath(path), Y))</p>
          <pre>
# For OneOrMorePath, we take one step of the path then start
# recording nodes for results.

eval(Path(x:term, OneOrMorePath(path), vy:var)) =
    Let X = eval(x, path)
    Let V = the empty multiset
    For n in X
        ALP(n, path, V)
    End
    result is V

eval(Path(vx:var, OneOrMorePath(path), vy:var)) =
     { { (vx, t), (vy, n) } |  t in nodes(G), (vy, n) in eval(Path(t, OneOrMorePath(path), vy)) }

eval(Path(vx:var, OneOrMorePath(path), y:term)) =
    eval(Path(y:term, OneOrMorePath(inv(path)), vx))

eval(Path(x:term, OneOrMorePath(path), y:term)) =
    { { } } if { (vy:var, y) } in eval(Path(x, OneOrMorePath(path), vy))
    { } otherwise
</pre>
        </div>
        <div class="defn">
          <p><b>Definition: <span id="eval_negatedPropertySet">Evaluation of NegatedPropertySet</span></b></p>
          <pre class="code nohighlight">
Write μ' as the extension of a solution mapping:
μ'(μ,x) = μ(x)   if x is a variable
μ'(μ,t) = t      if t is a RDF term
          </pre>
          <pre class="code nohighlight">
Let x and y be variables or RDF terms, and S a set of IRIs:

   eval(Path(x, NPS(S), y)) = { μ | ∃ triple(μ'(μ,x), p, μ'(μ,y)) in G, such that the IRI of p ∉ S }
          </pre>
        </div>
      </section>
      <section id="sparqlAlgebra">
        <h3>SPARQL Algebra</h3>
        <p>For each remaining symbol in a SPARQL abstract query, we define an operator for
          evaluation. The SPARQL algebra operators of the same name are used to evaluate SPARQL
          abstract query nodes as described in the section "<a href="#sparqlAlgebraEval">Evaluation
            Semantics</a>". Evaluation of basic graph patterns and property path patterns has been
          described above.</p>
        <div class="defn">
          <p><b>Definition: <span id="defn_algFilter">Filter</span></b></p>
          <p>Let Ω be a multiset of solution mappings and expr be an expression. We define:</p>
          <p>Filter(expr, Ω, D(G)) = { μ | μ in Ω and expr(μ) is an expression that has an
            effective boolean value of true }</p>
          <p>card[Filter(expr, Ω, D(G))](μ) = card[Ω](μ)</p>
          <blockquote>
            Note that evaluating an <code>exists(pattern)</code> expression uses the dataset and
            active graph, D(G). See the <a href="#defn_evalFilter">evaluation of filter</a>.
          </blockquote>
        </div>
        <div class="defn">
          <p><b>Definition: <span id="defn_algJoin">Join</span></b></p>
          <p>Let Ω<sub>1</sub> and Ω<sub>2</sub> be multisets of solution mappings. We define:</p>
          <p>Join(Ω<sub>1</sub>, Ω<sub>2</sub>) = { merge(μ<sub>1</sub>, μ<sub>2</sub>) |
            μ<sub>1</sub> in Ω<sub>1</sub> and μ<sub>2</sub> in Ω<sub>2</sub>, and μ<sub>1</sub> and
            μ<sub>2</sub> are compatible }</p>
          <p>card[Join(Ω<sub>1</sub>, Ω<sub>2</sub>)](μ) =<br>
            &nbsp;&nbsp;&nbsp; for each merge(μ<sub>1</sub>, μ<sub>2</sub>), μ<sub>1</sub> in
            Ω<sub>1</sub> and μ<sub>2</sub> in Ω<sub>2</sub> such that μ = merge(μ<sub>1</sub>,
            μ<sub>2</sub>),<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sum over (μ<sub>1</sub>, μ<sub>2</sub>),
            card[Ω<sub>1</sub>](μ<sub>1</sub>)*card[Ω<sub>2</sub>](μ<sub>2</sub>)</p>
        </div>
        <p>It is possible that a solution mapping μ in a Join can arise in different solution
          mappings, μ<sub>1</sub> and μ<sub>2</sub> in the multisets being joined. The cardinality
          of&nbsp; μ is the sum of the cardinalities from all possibilities.</p>
        <div class="defn">
          <p><b>Definition: <span id="defn_algDiff">Diff</span></b></p>
          <p>Let Ω<sub>1</sub> and Ω<sub>2</sub> be multisets of solution mappings and expr be an
            expression. We define:</p>
          <p>Diff(Ω<sub>1</sub>, Ω<sub>2</sub>, expr) = { μ | μ in Ω<sub>1</sub> such that ∀ μ′ in
            Ω<sub>2</sub>, either μ and μ′ are not compatible or μ and μ' are compatible and
            expr(merge(μ, μ')) does not have an effective boolean value of true }</p>
          <p>card[Diff(Ω<sub>1</sub>, Ω<sub>2</sub>, expr)](μ) = card[Ω<sub>1</sub>](μ)</p>
        </div>
        <p>The evaluation of expr(merge(μ, μ')) does not have an effective boolean
          value of true if it evaluates to false or if it raises an error.</p>
        <p>Diff is used internally for the definition of LeftJoin.</p>
        <div class="defn">
          <p><b>Definition: <span id="defn_algLeftJoin">LeftJoin</span></b></p>
          <p>Let Ω<sub>1</sub> and Ω<sub>2</sub> be multisets of solution mappings and expr be an
            expression. We define:</p>
          <p>LeftJoin(Ω<sub>1</sub>, Ω<sub>2</sub>, expr) = Filter(expr, Join(Ω<sub>1</sub>,
            Ω<sub>2</sub>)) ∪ Diff(Ω<sub>1</sub>, Ω<sub>2</sub>, expr)</p>
          <p>card[LeftJoin(Ω<sub>1</sub>, Ω<sub>2</sub>, expr)](μ) = card[Filter(expr,
            Join(Ω<sub>1</sub>, Ω<sub>2</sub>))](μ) + card[Diff(Ω<sub>1</sub>, Ω<sub>2</sub>,
            expr)](μ)</p>
        </div>

        <div class="defn">
          <p><b>Definition: <span id="defn_algUnion">Union</span></b></p>
          <p>Let Ω<sub>1</sub> and Ω<sub>2</sub> be multisets of solution mappings. We define:</p>
          <p>Union(Ω<sub>1</sub>, Ω<sub>2</sub>) = { μ | μ in Ω<sub>1</sub> or μ in Ω<sub>2</sub>
            }</p>
          <p>card[Union(Ω<sub>1</sub>, Ω<sub>2</sub>)](μ) = card[Ω<sub>1</sub>](μ) +
            card[Ω<sub>2</sub>](μ)</p>
        </div>
        <div class="defn">
          <p><b>Definition: <span id="defn_algMinus">Minus</span></b></p>
          <p>Let Ω<sub>1</sub> and Ω<sub>2</sub> be multisets of solution mappings. We define:</p>
          <p>Minus(Ω<sub>1</sub>, Ω<sub>2</sub>) = { μ | μ in Ω<sub>1</sub> . ∀ μ' in
            Ω<sub>2</sub>, either μ and μ' are not compatible or dom(μ) and dom(μ') are disjoint
            }</p>
          <p>card[Minus(Ω<sub>1</sub>, Ω<sub>2</sub>)](μ) = card[Ω<sub>1</sub>](μ)</p>
        </div>
        <p>The additional restriction on dom(μ) and dom(μ') is added because otherwise if there is
          a solution mapping in Ω<sub>2</sub> that has no variables in common with the solution
          mappings of Ω<sub>1</sub>, then Minus(Ω<sub>1</sub>, Ω<sub>2</sub>) would be empty,
          regardless of the rest of Ω<sub>2</sub>. The empty solution mapping is compatible with
          every other solution mapping so <code>P MINUS {}</code> would otherwise be empty for any
          pattern <code>P</code>.</p>
        <div class="defn">
          <p><b>Definition: <span id="defn_extend">Extend</span></b></p>
          <p>Let μ be a solution mapping, Ω a multiset of solution mappings, <i>var</i> a variable
            and <i>expr</i> be an <a href="#expressions">expression</a>, then we define:</p>
          <p>Extend(μ, var, expr) = μ ∪ { (var,value) | var not in dom(μ) and value = expr(μ) }</p>
          <p>Extend(μ, var, expr) = μ if var not in dom(μ) and expr(μ) is an error</p>
          <p>Extend is undefined when var in dom(μ).</p>
          <p>Extend(Ω, var, expr) = { Extend(μ, var, expr) | μ in Ω }</p>
        </div>
        <p>Write [ x | C ] for a sequence of elements where C is a condition on x.</p>
        <p>Write card[L](x) to be the cardinality of x in L.</p>
        <div class="defn">
          <p><b>Definition: <span id="defn_algToList">ToList</span></b></p>
          <p>Let Ω be a multiset of solution mappings. We define:</p>
          <p>ToList(Ω) = a sequence of mappings μ in Ω in any order, with card[Ω](μ) occurrences of
            μ</p>
          <p>card[ToList(Ω)](μ) = card[Ω](μ)</p>
        </div>
        <div class="defn">
          <p><b>Definition: <span id="defn_algOrdered">OrderBy</span></b></p>
          <p>Let Ψ be a sequence of solution mappings. We define:</p>
          <div id="defn_algOrderBy">
            OrderBy
          </div>(Ψ, condition) = [ μ | μ in Ψ and the sequence satisfies the ordering condition]
          <p>card[OrderBy(Ψ, condition)](μ) = card[Ψ](μ)</p>
        </div>
        <div class="defn">
          <p><b>Definition: <span id="defn_algProjection">Project</span></b></p>
          <p>Let Ψ be a sequence of solution mappings and PV a set of variables.</p>
          <p>For mapping μ, write Proj(μ, PV) to be the restriction of μ to variables in PV.</p>
          <p>Project(Ψ, PV) = [ Proj(Ψ[μ], PV) | μ in Ψ ]</p>
          <p>card[Project(Ψ, PV)](μ) = card[Ψ](μ)</p>
          <p>The order of Project(Ψ, PV) must preserve any ordering given by OrderBy.</p>
        </div>
        <div class="defn">
          <p><b>Definition: <span id="defn_algDistinct">Distinct</span></b></p>
          <p>Let Ψ be a sequence of solution mappings. We define:</p>
          <p>Distinct(Ψ) = [ μ | μ in Ψ ]</p>
          <p>card[Distinct(Ψ)](μ) = 1</p>
          <p>The order of Distinct(Ψ) must preserve any ordering given by OrderBy.</p>
        </div>
        <div class="defn">
          <p><b>Definition: <span id="defn_algReduced">Reduced</span></b></p>
          <p>Let Ψ be a sequence of solution mappings. We define:</p>
          <p>Reduced(Ψ) = [ μ | μ in Ψ ]</p>
          <p>card[Reduced(Ψ)](μ) is between 1 and card[Ψ](μ)</p>
          <p>The order of Reduced(Ψ) must preserve any ordering given by OrderBy.</p>
        </div>
        <p>The Reduced solution sequence modifier does not guarantee a defined cardinality.</p>
        <div class="defn">
          <p><b>Definition: <span id="defn_algSlice">Slice</span></b></p>
          <p>Let Ψ be a sequence of solution mappings. We define:</p>
          <div id="defn_algOrderBy2">
            Slice
          </div>(Ψ, start, length)[i] = Ψ[start+i] for i = 0 to (length-1)
        </div>
        <div class="defn">
          <p><b>Definition: <span id="defn_algToMultiSet">ToMultiSet</span></b></p>
          <p>Let Ψ be a solution sequence. We define:</p>
          <p>ToMultiSet(Ψ) = { μ | μ in Ψ }</p>
          <p>card[ToMultiSet(Ψ)](μ) = card[Ψ](μ)</p>
        </div>
        <p>ListEval is a function which is used to evaluate a list of expressions against a
          solution and return a list of the resulting values.</p>
        <div class="defn">
          <div id="defn_algToMultiset">
            <b>Definition: ToMultiset</b>
          </div>
          <p>ToMultiset turns a sequence into a multiset with the same elements and cardinality as
            the sequence. The order of the sequence has no effect on the resulting multiset, and
            duplicates are preserved.</p>
        </div>
        <div class="defn">
          <p><b>Definition: <span id="defn_exists">Exists</span></b></p>
          <p>exists(pattern) is a function that returns true if the pattern
            <a href="#defn_evalExists">evaluates</a> to a non-empty solution sequence, given the current
            solution mapping and active graph at the time of evaluation; otherwise it returns
            false.</p>
        </div>
        <section id="aggregateAlgebra">
          <h4>Aggregate Algebra</h4>
          <p>Group is a function which groups a solution sequence into multiple solutions, based on
            some attribute of the solutions.</p>
          <div class="defn">
            <div id="defn_algGroup">
              <b>Definition: Group</b>
            </div>
            <p>Group evaluates a list of expressions against a solution sequence, producing a set
              of partial functions from keys to solution sequences.</p>
            <p>Group(exprlist, Ω) = { ListEval(exprlist, μ) → { μ' | μ' in Ω, ListEval(exprlist, μ)
              = ListEval(exprlist, μ') } | μ in Ω }</p>
          </div>
          <div class="defn">
            <p><b>Definition: ListEval</b></p>
            <p>ListEval((expr<sub>1</sub>, ..., expr<sub>n</sub>), μ) returns a list
              (e<sub>1</sub>, ..., e<sub>n</sub>), where e<sub>i</sub> = expr<sub>i</sub>(μ) or
              error.</p>
            <p>ListEval retains errors resulting from the evaluation of the list elements.</p>
          </div>
          <p>Note that, although the result of a ListEval can be an error, and errors may be used
            to group, solutions containing error values are removed at projection time.</p>
          <p>ListEval((unbound), μ) = (error), as the evaluation of an unbound expression is an
            error.</p>
          <p>Aggregation, a function which calculates a scalar value as an output of the aggregate
            expression. It is used in the SELECT clause, the HAVING evaluation process, and in ORDER
            BY (where required). Aggregation calculates aggregated values over groups of solutions,
            using set functions.</p>
          <div class="defn">
            <div id="defn_algAggregation">
              <b>Definition: Aggregation</b>
            </div>
            <p>Let <i>exprlist</i> be a list of expressions or *, <i>func</i> a set function,
              <i>scalarvals</i> a set of partial functions (possibly empty) passed from the aggregate
              in the query, and let { key<sub>1</sub>→Ω<sub>1</sub>, ...,
              key<sub>m</sub>→Ω<sub>m</sub> } be a multiset of partial functions from keys to
              solution sequences as produced by the grouping step.</p>
            <p>Aggregation applies the set function func to the given multiset and produces a
              single value for each key and partition of solutions for that key.</p>
            <p>Aggregation(exprlist, func, scalarvals, { key<sub>1</sub>→Ω<sub>1</sub>, ...,
              key<sub>m</sub>→Ω<sub>m</sub> } )<br>
              &nbsp;&nbsp;&nbsp;= { (key, F(Ω)) | key → Ω in { key<sub>1</sub>→Ω<sub>1</sub>, ...,
              key<sub>m</sub>→Ω<sub>m</sub> } }</p>
            <p>where<br>
              &nbsp;&nbsp;M(Ω) = { ListEval(exprlist, μ) | μ in Ω }<br>
              &nbsp;&nbsp;F(Ω) = func(M(Ω), scalarvals), for non-DISTINCT<br>
              &nbsp;&nbsp;F(Ω) = func(Distinct(M(Ω)), scalarvals), for DISTINCT</p>
            <p><b>Special Case:</b> when <code>COUNT</code> is used with the expression
              <code>*</code> the value of F will be the cardinality of the group solution sequence,
              <code>card[Ω]</code>, or <code>card[Distinct(Ω)]</code> if the <code>DISTINCT</code>
              keyword is present.</p>
          </div>
          <p><i>scalarvals</i> are used to pass values to the underlying set function, bypassing
            the mechanics of the grouping. For example, the aggregate expression
            <code>GROUP_CONCAT(?x ; separator="|")</code> has a scalarvals argument of { "separator"
            → "|" }.</p>
          <p>All aggregates may have the <code>DISTINCT</code> keyword as the first token in their
            argument list. If this keyword is present then first argument to func is Distinct(M).</p>
          <p>Example</p>
          <p>Given a solution multiset (Ω) with the following values:</p>
          <table>
            <tbody>
              <tr>
                <td>solution</td>
                <td>?x</td>
                <td>?y</td>
                <td>?z</td>
              </tr>
              <tr>
                <td>μ<sub>1</sub></td>
                <td>1</td>
                <td>2</td>
                <td>3</td>
              </tr>
              <tr>
                <td>μ<sub>2</sub></td>
                <td>1</td>
                <td>3</td>
                <td>4</td>
              </tr>
              <tr>
                <td>μ<sub>3</sub></td>
                <td>2</td>
                <td>5</td>
                <td>6</td>
              </tr>
            </tbody>
          </table>
          <p>And the query expression SELECT (ex:agg(?y, ?z) AS ?agg) WHERE { ?x ?y ?z } GROUP BY
            ?x.</p>
          <p>We produce G = Group((?x), Ω) = { ( (1), { μ<sub>1</sub>, μ<sub>2</sub> } ), ( (2), {
            μ<sub>3</sub> } ) }</p>
          <p>And so Aggregation((?y, ?z), ex:agg, {}, G) =<br>
            { ((1), eg:agg({(2, 3), (3, 4)}, {})), ((2), eg:agg({(5, 6)}, {})) }.</p>
          <div class="defn">
            <p><b>Definition: AggregateJoin</b></p>
            <p>Let S<sub>1</sub>, ..., S<sub>n</sub> be a list of sets, where each set
              S<sub>i</sub> contains key to (aggregated) value maps as produced by Aggregate.</p>
            <p>Let K = { key | key in dom(S<sub>j</sub>) for some 1 &lt;= j &lt;= n } be the set of
              keys, then<br>
              AggregateJoin(S<sub>1</sub>, ..., S<sub>n</sub>) = { agg<sub>1</sub>→val<sub>1</sub>,
              ..., agg<sub>n</sub>→val<sub>n</sub> | key in K and key→val<sub>i</sub> in
              S<sub>i</sub> for each 1 &lt;= i &lt;= n }</p>
          </div>
          <p>Flatten is a function which is used to collapse multisets of lists into a multiset, so
            for example { (1, 2), (3, 4) } becomes { 1, 2, 3, 4 }.</p>
          <div class="defn">
            <p><b>Definition: Flatten</b></p>
            <p>The Flatten(M) function takes a multiset of lists, M {(L<sub>1</sub>, L<sub>2</sub>,
              ...), ...}, and returns the multiset { x | L in M and x in L }.</p>
          </div>
          <section id="setFunctions">
            <h5>Set Functions</h5>
            <p>The set functions which underlie SPARQL aggregates all have a common signature:
              SetFunc(M), or SetFunc(M, scalarvals) where M is a multiset of lists, and scalarvals is
              one or more scalar values that are passed to the set function indirectly via the ( ...
              ; key=value ) syntax for aggregates in the SPARQL grammar. The only use of this that is
              supported by the built-in aggregates in SPARQL Query 1.1 is <code>GROUP_CONCAT</code>,
              as in <code>GROUP_CONCAT(?x ; separator=", ")</code>.</p>
            <p>Note that the name "Set Function" is somewhat historical — the arguments to set
              functions are in fact multisets. The name is retained due to the commonality with SQL
              Set Functions, which also operate over multisets.</p>
            <p>The set functions defined in this document are Count, Sum, Min, Max, Avg,
              GroupConcat, and Sample — corresponding to the aggregates <code>COUNT</code>,
              <code>SUM</code>, <code>MIN</code>, <code>MAX</code>, <code>AVG</code>,
              <code>GROUP_CONCAT</code>, and <code>SAMPLE</code>. Definitions may be found in the
              following sections. Systems may choose to expand this set using local extensions, using
              the same notation as for functions and casts. Note that, unless the ; separator is used
              this requires the parser to know whether some IRI refers to a function, cast, or
              aggregate before it can determine if there are any errors in a query where aggregates
              are used.</p>
          </section>

          <section id="aggCount">
            <h5>Count</h5>
            <p>Count is a SPARQL set function which counts the number of times a given expression
              has a bound, non-error value within the aggregate group.</p>
            <div class="defn">
              <p><b>Definition: <span id="defn_aggCount">Count</span></b></p>
              <pre class="code nohighlight">xsd:integer Count(multiset M)</pre>
              <p>N = Flatten(M)</p>
              <p>remove error elements from N</p>
              <p>Count(M) = card[N]</p>
            </div>
          </section>
          <section id="aggSum">
            <h5>Sum</h5>
            <p>Sum is a SPARQL set function that returns the numeric value obtained by summing
              the values within the aggregate group. Type promotion happens as per the op:numeric-add
              function, applied transitively, (see definition below) so the value of SUM(?x), in an
              aggregate group where ?x has values 1 (integer), 2.0e0 (float), and 3.0 (decimal) will
              be 6.0 (float).</p>
            <div class="defn">
              <p><b>Definition: <span id="defn_aggSum">Sum</span></b></p>
              <pre class="code nohighlight">numeric Sum(multiset M)</pre>
              <p>Sum(M) = Sum(ToList(Flatten(M))).</p>
              <p>Sum(S) = op:numeric-add(S<sub>1</sub>, Sum(S<sub>2..n</sub>)) when card[S] &gt;
                1<br>
                Sum(S) = op:numeric-add(S<sub>1</sub>, 0) when card[S] = 1<br>
                Sum(S) = "0"^^xsd:integer when card[S] = 0</p>
              <p>In this way, Sum({1, 2, 3}) = op:numeric-add(1, op:numeric-add(2,
                op:numeric-add(3, 0))).</p>
            </div>
          </section>
          <section id="aggAvg">
            <h5>Avg</h5>
            <div id="defn_algAvg"></div>The Avg set function calculates the
            average value for an expression over a group. It is defined in terms of Sum and Count.
            <div class="defn">
              <p><b>Definition: <span id="defn_aggAvg">Avg</span></b></p>
              <pre class="code nohighlight">numeric Avg(multiset M)</pre>
              <p>Avg(M) = "0"^^xsd:integer, where Count(M) = 0</p>
              <p>Avg(M) = Sum(M) / Count(M), where Count(M) &gt; 0</p>
            </div>
            <p>For example, Avg({1, 2, 3}) = Sum({1, 2, 3})/Count({1, 2, 3}) = 6/3 = 2.</p>
          </section>
          <section id="aggMin">
            <h5>Min</h5>
            <p>Min is a SPARQL set function that returns the minimum value from a group
              respectively.</p>
            <p>It makes use of the SPARQL ORDER BY ordering definition, to allow ordering over
              arbitrarily typed expressions.</p>
            <div class="defn">
              <p><b>Definition: <span id="defn_aggMin">Min</span></b></p>
              <pre class="code nohighlight">term Min(multiset M)</pre>
              <p>Min(M) = Min(ToList(Flatten(M)))</p>
              <p>Min({}) = error.</p>
              <p>The flattened multiset of values passed as an argument is converted to a sequence
                S, this sequence is ordered as per the <code>ORDER BY ASC</code> clause.</p>
              <p>Min(S) = S<sub>0</sub></p>
            </div>
          </section>
          <section id="aggMax">
            <h5>Max</h5>
            <p>Max is a SPARQL set function that returns the maximum value from a group
              respectively.</p>
            <p>It makes use of the SPARQL ORDER BY ordering definition, to allow ordering over
              arbitrarily typed expressions.</p>
            <div class="defn">
              <p><b>Definition: <span id="defn_aggMax">Max</span></b></p>
              <pre class="code nohighlight">term Max(multiset M)</pre>
              <p>Max(M) = Max(ToList(Flatten(M)))</p>
              <p>Max({}) = error.</p>
              <p>The multiset of values passed as an argument is converted to a sequence S, this
                sequence is ordered as per the <code>ORDER BY DESC</code> clause.</p>
              <p>Max(S) = S<sub>0</sub></p>
            </div>
          </section>
          <section id="aggGroupConcat">
            <h5>GroupConcat</h5>
            <p>GroupConcat is a set function which performs a string concatenation across the
              values of an expression with a group. The order of the strings is not specified. The
              separator character used in the concatenation may be given with the scalar argument
              SEPARATOR.</p>
            <div class="defn">
              <p><b>Definition: <span id="defn_aggGroupConcat">GroupConcat</span></b></p>
              <pre class="code nohighlight">literal GroupConcat(multiset M)</pre>
              <p>If the "separator" scalar argument is absent from GROUP_CONCAT then it is taken to
                be the "space" character, unicode codepoint U+0020.</p>
              <p>The multiset of values, M passed as an argument is converted to a sequence S.</p>
              <p>GroupConcat(M, scalarvals) = GroupConcat(Flatten(M), scalarvals("separator"))</p>
              <p>GroupConcat(S, sep) = "", where <span style=
                                                       "font-size: 140%">|</span>S<span style="font-size: 140%">|</span> = 0</p>
              <p>GroupConcat(S, sep) = CONCAT("", S<sub>0</sub>), where 
                <span style="font-size: 140%">|</span>S<span style="font-size: 140%">|</span> = 1</p>
              <p>GroupConcat(S, sep) = CONCAT(S<sub>0</sub>, sep, GroupConcat(S<sub>1..n-1</sub>,
                sep)), where <span style="font-size: 140%">|</span>S<span style="font-size: 140%">|</span> &gt; 1</p>
            </div>
            <p>For example, GroupConcat({"a", "b", "c"}, {"separator" → "."}) = "a.b.c".</p>
          </section>
          <section id="aggSample">
            <h5>Sample</h5>
            <p>Sample is a set function which returns an arbitrary value from the multiset passed
              to it.</p>
            <div class="defn">
              <p><b>Definition: <span id="defn_aggSample">Sample</span></b></p>
              <pre class="code nohighlight">RDFTerm Sample(multiset M)</pre>
              <p>Sample(M) = v, where v in Flatten(M)</p>
              <p>Sample({}) = error</p>
            </div>
            <p>For example, given Sample({"a", "b", "c"}), "a", "b", and "c" are all valid return
              values. Note that Sample() is not required to be deterministic for a given input, the
              only restriction is that the output value must be present in the input multiset.</p>
          </section>
        </section>
        <section id="sparqlAlgebraEval">
          <h3>Evaluation Semantics</h3>
          <p>We define eval(D(G), algebra expression) as the evaluation of an algebra expression with
            respect to a dataset D having active graph G. The active graph is initially the default
            graph.</p>
          <pre class="box">
D : a dataset
D(G) : D a dataset with active graph G (the one patterns match against)
D[i] : The graph with IRI i in dataset D
P, P1, P2 : graph patterns
L : a solution sequence
F : an expression
          </pre>
          <div class="defn">
            <p><b>Definition: <span id="defn_evalBasicGraphPattern">Evaluation of a Basic Graph Pattern</span></b></p>
            <pre class="code nohighlight">eval(D(G), BGP) = multiset of solution mappings</pre>
            <p>See section <a href="#BasicGraphPattern">Basic Graph Patterns</a></p>
          </div>
          <div class="defn">
            <p><b>Definition: <span id="defn_evalPropertyPathPattern">Evaluation of a Property Path Pattern</span></b></p>
            <pre class="code nohighlight">eval(D(G), Path(X, path, Y)) = multiset of solution mappings</pre>
            <p>See section <a href="#defn_PropertyPathExpr">Property Path Expresions</a></p>
          </div>
          <div class="defn">
            <p><b>Definition: <span id="defn_evalFilter">Evaluation of Filter</span></b></p>
            <pre class="code nohighlight">eval(D(G), Filter(F, P)) = Filter(F, eval(D(G),P), D(G))</pre>
          </div>
          <p>'substitute' is a filter function in support of the evaluation of 
            <a href="#func-filter-exists"><code>EXISTS</code>
              and <code>NOT EXISTS</code></a> forms which were translated to <code>exists</code>.</p>
          <div class="defn">
            <p><b>Definition: <span id="defn_substitute">Substitute</span></b></p>
            <p>Let μ be a solution mapping.</p>
            <blockquote>
              <p>substitute(<i>pattern</i>, μ) = the pattern formed by replacing every occurrence of
                a variable v in <i>pattern</i> by μ(v) for each v in dom(μ)</p>
            </blockquote>
          </div>
          <div class="defn">
            <p><b>Definition: <span id="defn_evalExists">Evaluation of Exists</span></b></p>
            <p>Let μ be the current solution mapping for a filter and P a graph pattern:</p>
            <blockquote>
              The value exists(P), given D(G) is true if and only if eval(D(G), substitute(P, μ)) is
              a non-empty sequence.
            </blockquote>
          </div>
          <div class="defn">
            <p><b>Definition: <span id="defn_evalJoin">Evaluation of Join</span></b></p>
            <pre class="code nohighlight">eval(D(G), Join(P1, P2)) = Join(eval(D(G), P1), eval(D(G), P2))</pre>
          </div>
          <div class="defn">
            <p><b>Definition: <span id="defn_evalLeftJoin">Evaluation of LeftJoin</span></b></p>
            <pre class="code nohighlight">
eval(D(G), LeftJoin(P1, P2, F)) = LeftJoin(eval(D(G), P1), eval(D(G), P2), F)
            </pre>
          </div>
          <div class="defn">
            <p><b>Definition: <span id="defn_evalUnion">Evaluation of Union</span></b></p>
            <pre class="code nohighlight">eval(D(G), Union(P1,P2)) = Union(eval(D(G), P1), eval(D(G), P2))</pre>
          </div>
          <div class="defn">
            <p><b>Definition: <span id="defn_evalGraph">Evaluation of Graph</span></b></p>
            <pre class="code nohighlight">
if IRI is a graph name in D
    eval(D(G), Graph(IRI,P)) = eval(D(D[IRI]), P)
            </pre>
            <pre class="code nohighlight">
              if IRI is not a graph name in D
                  eval(D(G), Graph(IRI,P)) = the empty multiset
            </pre>
            <pre class="code nohighlight">
eval(D(G), Graph(var,P)) =
    Let R be the empty multiset
    foreach IRI i in D
        R := Union(R, Join( eval(D(D[i]), P) , Ω(?var-&gt;i) ) )
    the result is R
            </pre>
          </div>
          <p>The evaluation of graph uses the SPARQL algebra union operator. The cardinality of a
            solution mapping is the sum of the cardinalities of that solution mapping in each join
            operation.</p>
          <div class="defn">
            <div id="defn_evalGroup">
              <b>Definition: Evaluation of Group</b>
            </div>
            <p>eval(D(G), Group(exprlist, P)) = Group(exprlist, eval(D(G), P))</p>
          </div>
          <div class="defn">
            <div id="defn_evalAggregation">
              <b>Definition: Evaluation of Aggregation</b>
            </div>
            <p>eval(D(G), Aggregation(exprlist, func, scalarvals, P)) = Aggregation(exprlist, func,
              scalarvals, eval(D(G), P))</p>
          </div>
          <div class="defn">
            <div id="defn_evalAggregateJoin">
              <b>Definition: Evaluation of AggregateJoin</b>
            </div>
            <p>eval(D(G), AggregateJoin(A<sub>1</sub>, ..., A<sub>n</sub>)) =
              AggregateJoin(eval(D(G), A<sub>1</sub>), ..., eval(D(G), A<sub>n</sub>))</p>
          </div>
          <p>Note that if eval(D(G), A<sub>i</sub>) is an error, it is ignored.</p>
          <div class="defn">
            <p><b>Definition: <span id="defn_evalExtend">Evaluation of Extend</span></b></p>
            <pre class="code nohighlight">
eval(D(G), Extend(P, var, expr)) = Extend(eval(D(G), P), var, expr)
            </pre>
          </div>
          <div class="defn">
            <p><b>Definition: <span id="defn_evalList">Evaluation of ToList</span></b></p>
            <pre class="code nohighlight">eval(D(G), ToList(P)) = ToList(eval(D(G), P))</pre>
          </div>
          <div class="defn">
            <p><b>Definition: <span id="defn_evalDistinct">Evaluation of Distinct</span></b></p>
            <pre class="code nohighlight">eval(D(G), Distinct(L)) = Distinct(eval(D(G), L))
            </pre>
          </div>
          <div class="defn">
            <p><b>Definition: <span id="defn_evalReduced">Evaluation of Reduced</span></b></p>
            <pre class="code nohighlight">eval(D(G), Reduced(L)) = Reduced(eval(D(G), L))
            </pre>
          </div>
          <div class="defn">
            <p><b>Definition: <span id="defn_evalProject">Evaluation of Project</span></b></p>
            <pre class="code nohighlight">eval(D(G), Project(L, vars)) = Project(eval(D(G), L), vars)
            </pre>
          </div>
          <div class="defn">
            <p><b>Definition: <span id="defn_evalOrderBy">Evaluation of OrderBy</span></b></p>
            <pre class="code nohighlight">eval(D(G), OrderBy(L, condition)) = OrderBy(eval(D(G), L), condition)
            </pre>
          </div>
          <div class="defn">
            <p><b>Definition: <span id="defn_evalToMultiSet">Evaluation of ToMultiSet</span></b></p>
            <pre class="code nohighlight">eval(D(G), ToMultiSet(L)) = ToMultiSet(eval(D), M))</pre>
          </div>
          <div class="defn">
            <p><b>Definition: <span id="defn_evalSlice">Evaluation of Slice</span></b></p>
            <pre class="code nohighlight">
eval(D(G), Slice(L, start, length)) = Slice(eval(D(G), L), start, length)
            </pre>
          </div>
        </section>
        <section id="sparqlBGPExtend">
          <h3>Extending SPARQL Basic Graph Matching</h3>
          <p>The overall SPARQL design can be used for queries which assume a more elaborate form of
            entailment than simple entailment, by re-writing the matching conditions for basic graph
            patterns. Since it is an open research problem to state such conditions in a single general
            form which applies to all forms of entailment and optimally eliminates needless or
            inappropriate redundancy, this document only gives necessary conditions which any such
            solution should satisfy. These will need to be extended to full definitions for each
            particular case.</p>
          <p>Basic graph patterns stand in the same relation to triple patterns that RDF graphs do to
            RDF triples, and much of the same terminology can be applied to them. In particular, two
            basic graph patterns are said to be <i>equivalent</i> if there is a bijection M between the
            terms of the triple patterns that maps blank nodes to blank nodes and maps variables,
            literals and IRIs to themselves, such that a triple ( s, p, o ) is in the first pattern if
            and only if the triple ( M(s), M(p), M(o) ) is in the second. This definition extends that
            for RDF graph equivalence to basic graph patterns by preserving variable names across
            equivalent patterns.</p>
          <p>An <i>entailment regime</i> specifies</p>
          <ol>
            <li>a subset of RDF graphs called <i>well-formed</i> for the regime</li>
            <li>an <i>entailment</i> relation between subsets of well-formed graphs and well-formed
              graphs.</li>
          </ol>
          <p>Detailed definitions for querying various entailment regimes can be found in
            [[[SPARQL11-ENTAILMENT]]].</p>
          <p>Some entailment regimes can categorize some RDF graphs as inconsistent. For example, the
            RDF graph:</p>
          <pre class="data nohighlight">
_:x rdf:type xsd:string .
_:x rdf:type xsd:decimal .
          </pre>
          <p>is D-inconsistent when D contains the XSD datatypes. The effect of a query on an
            inconsistent graph is not covered by this specification, but must be specified by the
            particular SPARQL extension.</p>
          <p>An entailment regime E must provide conditions on basic graph pattern evaluation such
            that for any basic graph pattern BGP, any RDF graph G, and any evaluation that satisfies
            the conditions, the resulting multiset of solutions is uniquely determined up to RDF graph
            equivalence. We denote the multiset of solutions from evaluating BGP over G using E with
            Eval-E(G, BGP).<br>
            An entailment regime must further satisfy the following conditions:</p>
          <ol>
            <li>For any E-consistent active graph AG, the entailment regime E uniquely specifies a
              <a href="#BGPsparqlBNodes">scoping graph</a> SG that is E-equivalent to AG.
            </li>
            <li>A set of well-formed graphs for E is specified such that, for any basic graph pattern
              BGP, scoping graph SG, and solution mapping μ in Eval-E(SG, BGP), the graph μ(BGP) is
              well-formed for E.</li>
            <li>For any basic graph pattern BGP and scoping graph SG, if μ<sub>1</sub>, ...,
              μ<sub>n</sub> in Eval-E(SG, BGP) and BGP<sub>1</sub>, ..., BGP<sub>n</sub> are basic
              graph patterns all equivalent to BGP but not sharing any blank nodes with each other or
              with SG, then
              <blockquote>
                <p>SG E-entails (SG union μ<sub>1</sub>(BGP<sub>1</sub>) union ... union
                  μ<sub>n</sub>(BGP<sub>n</sub>))</p>
              </blockquote>
              <p>These conditions do not fully determine the set of possible answers, since RDF
                allows unlimited amounts of redundancy. In addition, therefore, the following must
                hold.</p>
            </li>
            <li>Entailment regimes should provide conditions to prevent trivial infinite solution
              multisets as appropriate to the regime.</li>
          </ol>
          <section id="sparqlBGPExtend-notes">
            <h4>Notes</h4>
            <p>(a) SG will often be graph equivalent to AG, but restricting this to E-equivalence
              allows some forms of normalization, for example elimination of semantic redundancies, to
              be applied to the source documents before querying.</p>
            <p>(b) The construction in condition 3 ensures that any blank nodes introduced by the
              solution mapping are used in a way which is internally consistent with the way that blank
              nodes occur in SG. This ensures that blank node identifiers occur in more than one answer
              in an answer set only when the blank nodes so identified are indeed identical in SG. If
              the extension does not allow bindings to blank nodes, then this condition can be
              simplified to the condition:</p>
            <blockquote>
              <p>SG E-entails μ(BGP) for each solution mapping μ.</p>
            </blockquote>
            <p>(c) These conditions do not impose the SPARQL requirement that SG shares no blank
              nodes with AG or BGP. In particular, it allows SG to actually be AG. This allows query
              protocols in which blank node identifiers retain their meaning between the query and the
              source document, or across multiple queries. Such protocols are not supported by the
              current SPARQL protocol specification, however.</p>
            <p>(d) Since conditions 1 to 3 are only necessary conditions on answers, condition 4
              allows cases where the set of legal answers can be restricted in various ways.</p>
            <p>(e) None of these conditions refer explicitly to instance mappings on blank nodes in
              BGP. For some entailment regimes, the existential interpretation of blank nodes cannot be
              fully captured by the existence of a single instance mapping. These conditions allow such
              regimes to give blank nodes in query patterns a 'fully existential' reading.</p>
            <p>It is straightforward to show that SPARQL satisfies these conditions for the case
              where E is simple entailment, given that the SPARQL condition on SG is that it is
              graph-equivalent to AG but shares no blank nodes with AG or BGP (which satisfies the
              first condition). The only condition which is nontrivial is (3).</p>
            <p>For every solution mapping μ<sub>i</sub>, there is, by definition of basic graph
              pattern matching, an RDF instance mapping σ<sub>i</sub> such that
              P<sub>i</sub>(BGP<sub>i</sub>) is a subgraph of SG where P<sub>i</sub> is the pattern
              instance mapping composed of μ<sub>i</sub> and σ<sub>i</sub>. Since BGP<sub>i</sub> and
              SG have no blank nodes in common, the ranges of σ<sub>i</sub> and μ<sub>i</sub> contain
              no blank nodes from BGP<sub>i</sub>; therefore, the solution mapping μ<sub>i</sub> and
              the RDF instance mapping σ<sub>i</sub> of P<sub>i</sub> commute, so
              P<sub>i</sub>(BGP<sub>i</sub>) = σ<sub>i</sub>(μ<sub>i</sub>(BGP<sub>i</sub>)). So</p>
            <p>P<sub>1</sub>(BGP<sub>1</sub>) union ... union P<sub>n</sub>(BGP<sub>n</sub>)<br>
              = σ<sub>1</sub>(μ<sub>1</sub>(BGP<sub>1</sub>)) union ... union
              σ<sub>n</sub>(μ<sub>n</sub>(BGP<sub>n</sub>))<br>
              = [ σ<sub>1</sub> + ... + σ<sub>n</sub>]( μ<sub>1</sub>(BGP<sub>1</sub>) union ... union
              μ<sub>n</sub>(BGP<sub>n</sub>) )</p>
            <p>since the domains of the σ<sub>i</sub> RDF instance mappings are all mutually
              exclusive. Since they are also exclusive from SG,</p>
            <p>SG union [ σ<sub>1</sub> + ... + σ<sub>n</sub>]( μ<sub>1</sub>(BGP<sub>1</sub>) union
              ... union μ<sub>n</sub>(BGP<sub>n</sub>) )<br>
              = [ σ<sub>1</sub> + ... + σ<sub>n</sub>](SG union μ<sub>1</sub>(BGP<sub>1</sub>) union
              ... union μ<sub>n</sub>(BGP<sub>n</sub>) )</p>
            <p>i.e.</p>
            <p>SG union μ<sub>1</sub>(BGP<sub>1</sub>) union ... union
              μ<sub>n</sub>(BGP<sub>n</sub>)</p>
            <p>has an instance which is a subgraph of SG, so is simply entailed by SG by the
              <a data-cite="RDF12-SEMANTICS#dfn-interpolation">RDF interpolation lemma</a> [[RDF12-SEMANTICS]].</p>
          </section>
        </section>
      </section>
    </section>

    <section id="grammar">
      <h2>SPARQL Grammar</h2>
      <p>The SPARQL grammar covers both SPARQL Query and [[[SPARQL11-UPDATE]]].</p>
      <section id="queryString">
        <h3>SPARQL Request String</h3>
        <p>
          A <dfn data-lt="SPARQLRequestString">SPARQL Request String</dfn> is
          a <a>SPARQL Query String</a> or <a>SPARQL Update String</a> and is a Unicode character string
          (c.f. section 6.1 String concepts of [[CHARMOD]]) in the language defined by the following
          grammar.</p>
        <p>
          A <dfn data-lt="SPARQLQueryString">SPARQL Query String</dfn> starts
          at the <a href="#rQueryUnit">QueryUnit</a> production.</p>
        <p>
          A <dfn data-lt="SPARQLUpdateString">SPARQL Update String</dfn> starts
          at the <a href="#rUpdateUnit">UpdateUnit</a> production.</p>
        <p>For compatibility with future versions of Unicode, the characters in this string may
          include Unicode codepoints that are unassigned as of the date of this publication (see
          [[[UAX31]]] [[UAX31]] section 4 Pattern Syntax). For productions with excluded character
          classes (for example <code>[^&lt;&gt;'{}|^`]</code>), the characters are excluded from the
          range <code>#x0 - #x10FFFF</code>.</p>
      </section>

      <section id="codepointEscape">
        <h3>Codepoint Escape Sequences</h3>
        <p>A SPARQL Query String is processed for codepoint escape sequences before parsing by the
          grammar defined in EBNF below. The codepoint escape sequences for a SPARQL query string
          are:</p>
        <span class="doc-ref" id="table68"></span>
        <table title="Codepoint escapes">
          <colgroup>
            <col style="width: 40%">
            <col>
          </colgroup>
          <tbody>
            <tr>
              <th class="major">Escape</th>
              <th class="major">Unicode code point</th>
            </tr>
            <tr>
              <td>
                <span class="token">'\u'</span> <a href="#HEX">HEX</a> <a href="#HEX">HEX</a>
                <a href="#HEX">HEX</a> <a href="#HEX">HEX</a>
              </td>
              <td>A Unicode code point in the range U+0 to U+FFFF inclusive corresponding to the
                encoded hexadecimal value.</td>
            </tr>
            <tr>
              <td>
                <span class="token">'\U'</span> <a href="#HEX">HEX</a> <a href="#HEX">HEX</a>
                <a href="#HEX">HEX</a> <a href="#HEX">HEX</a> <a href="#HEX">HEX</a> <a href="#HEX">HEX</a> <a href="#HEX">HEX</a> <a href="#HEX">HEX</a>
              </td>
              <td>A Unicode code point in the range U+0 to U+10FFFF inclusive corresponding to the
                encoded hexadecimal value.</td>
            </tr>
          </tbody>
        </table>
        <p>where <a href="#HEX">HEX</a> is a hexadecimal character</p>
        <blockquote>
          <p><code><span class="doc-ref" id="HEX">HEX</span> ::= [0-9] | [A-F] | [a-f]</code></p>
        </blockquote>
        <p>Examples:</p>
        <pre class="query nohighlight">
          &lt;ab\u00E9xy&gt;        # Codepoint 00E9 is Latin small e with acute - é
          \u03B1:a            # Codepoint x03B1 is Greek small alpha - α
          a\u003Ab            # a:b -- codepoint x3A is colon</pre>
        <p>Codepoint escape sequences can appear anywhere in the query string. They are processed
          before parsing based on the grammar rules and so may be replaced by codepoints with
          significance in the grammar, such as "<code>:</code>" marking a prefixed name.</p>
        <p>These escape sequences are not included in the grammar below. Only escape sequences for
          characters that would be legal at that point in the grammar may be given. For example, the
          variable "<code>?x\u0020y</code>" is not legal (<code>\u0020</code> is a space and is not
          permitted in a variable name).</p>
      </section>
      <section id="whitespace">
        <h3>White Space</h3>
        <p>White space (production <code><a href="#rWS">WS</a></code>) is used to separate two
          terminals which would otherwise be (mis-)recognized as one terminal. Rule names below in
          capitals indicate where white space is significant; these form a possible choice of
          terminals for constructing a SPARQL parser. White space is significant in strings.
          Otherwise, white space is ignored between tokens.</p>
        <p>For example:</p>
        <blockquote>
          <p><code>?a&lt;?b&amp;&amp;?c&gt;?d</code></p>
        </blockquote>
        <p>is the token sequence variable '<code>?a</code>', an IRI
          '<code>&lt;?b&amp;&amp;?c&gt;</code>', and variable '<code>?d</code>', not a expression
          involving the operator '<code>&amp;&</code>' connecting two expression using
          '<code>&lt;</code>' (less than) and '<code>&gt;</code>' (greater than).</p>
      </section>
      <section id="grammarComments">
        <h3>Comments</h3>
        <p>Comments in SPARQL queries take the form of '<code>#</code>', outside an IRI or string,
          and continue to the end of line (marked by characters <code>0x0D</code> or
          <code>0x0A</code>) or end of file if there is no end of line after the comment marker.
          Comments are treated as white space.</p>
      </section>
      <section id="iriRefs">
        <h3>IRI References</h3>
        <p>Text matched by the <code><a href="#rIRIREF">IRIREF</a></code> production and
          <code><a href="#rPrefixedName">PrefixedName</a></code> (after prefix expansion) production,
          after escape processing, must conform to the generic syntax of IRI references in section
          2.2 of RFC 3987 "ABNF for IRI References and IRIs" [[RFC3987]]. For example, the
          <code><a href="#rIRIREF">IRIREF</a></code> <code>&lt;abc#def&gt;</code> may occur in a
          SPARQL query string, but the <code><a href="#rIRIREF">IRIREF</a></code>
          <code>&lt;abc##def&gt;</code> must not.</p>
        <p>Base IRIs declared with the <span class="token">BASE</span> keyword must be absolute
          IRIs. A prefix declared with the <span class="token">PREFIX</span> keyword may not be
          re-declared in the same query. See section 4.1.1, 
          <a href="#QSynIRI">Syntax of IRI Terms</a>, for a description of <span class="token">BASE</span> and
          <span class="token">PREFIX</span>.</p>
      </section>
      <section id="grammarBNodes">
        <h3>Blank Nodes and Blank Node Labels</h3>
        <p>Blank nodes can not be used in:</p>
        <ul>
          <li><code><a href="#rDeleteWhere">DELETE WHERE</a></code></li>
          <li><code><a href="#rDeleteData">DELETE DATA</a></code></li>
          <li>a <code><a href="#rDeleteClause">DeleteClause</a></code></li>
        </ul>
        <p>in a <a data-cite="SPARQL11-UPDATE#terminology">SPARQL Update request</a>.</p>
        <p>Blank node labels are scoped to the <a>SPARQL Request String</a> in which they occur.
          Different uses of the same blank node label in a request
          string refer to the same blank node. Fresh blank nodes are generated for each request;
          blank nodes can not be referenced by label across requests.</p>
        <p>The same blank node label can not be used in:</p>
        <ul>
          <li>two basic graph patterns in a SPARQL Query</li>
          <li>two <code><a href="#rModify">WHERE</a></code> clauses within a single SPARQL Update
            request</li>
          <li>two <code><a href="#rInsertData">INSERT DATA</a></code> operations within a single
            SPARQL Update request</li>
        </ul>
        <p>Note that the same blank node label can occur in different
          <a href="#rQuadPattern">QuadPattern</a> clauses in a [[[SPARQL11-UPDATE]]] request.</p>
      </section>
      <section id="grammarEscapes">
        <h3>Escape sequences in strings</h3>
        <p>In addition to the <a href="#codepointEscape">codepoint escape sequences</a>, the
          following escape sequences apply to any <code><a href="#rString">string</a></code> production (e.g.
          <code><a href="#rSTRING_LITERAL1">STRING_LITERAL1</a></code>,
          <code><a href="#rSTRING_LITERAL2">STRING_LITERAL2</a></code>,
          <code><a href="#rSTRING_LITERAL_LONG1">STRING_LITERAL_LONG1</a></code>,
          <code><a href="#rSTRING_LITERAL_LONG2">STRING_LITERAL_LONG2</a></code>):</p>
        <table title="String escapes">
          <colgroup>
            <col style="width: 40%">
            <col>
          </colgroup>
          <tbody>
            <tr>
              <th class="major">Escape</th>
              <th class="major">Unicode code point</th>
            </tr>
            <tr>
              <td><span class="token">'\t'</span></td>
              <td>U+0009 (tab)</td>
            </tr>
            <tr>
              <td><span class="token">'\n'</span></td>
              <td>U+000A (line feed)</td>
            </tr>
            <tr>
              <td><span class="token">'\r'</span></td>
              <td>U+000D (carriage return)</td>
            </tr>
            <tr>
              <td><span class="token">'\b'</span></td>
              <td>U+0008 (backspace)</td>
            </tr>
            <tr>
              <td><span class="token">'\f'</span></td>
              <td>U+000C (form feed)</td>
            </tr>
            <tr>
              <td><span class="token">'\"'</span></td>
              <td>U+0022 (quotation mark, double quote mark)</td>
            </tr>
            <tr>
              <td><span class="token">"\'"</span></td>
              <td>U+0027 (apostrophe-quote, single quote mark)</td>
            </tr>
            <tr>
              <td><span class="token">'\\'</span></td>
              <td>U+005C (backslash)</td>
            </tr>
          </tbody>
        </table>
        <p>Examples:</p>
        <pre class="query nohighlight">
          "abc\n"
          "xy\rz"
          'xy\tz'
        </pre>
      </section>
      <section id="sparqlGrammar">
        <h3>Grammar</h3>
        <p>The EBNF notation used in the grammar is defined in 
          Extensible Markup Language (XML) 1.1 
          [[xml11]] 
          section 6 <a data-cite="xml11#sec-notation">Notation</a>.</p>
        <p>Notes:</p>
        <ol>
          <li>Keywords are matched in a case-insensitive manner with the exception of
            the keyword '<code>a</code>'  which, in line with Turtle and N3, is used
            in place of the IRI <code>rdf:type</code>
            (in full, <code><a href="http://www.w3.org/1999/02/22-rdf-syntax-ns#type">http://www.w3.org/1999/02/22-rdf-syntax-ns#type</a></code>).</li>
          <li>Escape sequences are case sensitive.</li>
          <li>When tokenizing the input and choosing grammar rules, the longest match is chosen.</li>
          <li>The SPARQL grammar is LL(1) when the rules with uppercased names are used as terminals.</li>
          <li>There are two entry points into the grammar: <code>QueryUnit</code> for SPARQL queries,
            and <code>UpdateUnit</code> for SPARQL Update requests.</li>
          <li>In signed numbers, no white space is allowed between the sign and the number.
            The <code><a href="#rAdditiveExpression">AdditiveExpression</a></code> grammar rule allows for this by
            covering the two cases of an expression followed by a signed number. These 
            produce an addition or subtraction of the unsigned number as appropriate.</li>
          <li>The tokens <code><a href="#rInsertData">INSERT DATA</a></code>, 
            <code><a href="#rDeleteData">DELETE DATA</a></code> and 
            <code><a href="#rDeleteWhere">DELETE WHERE</a></code> allow any amount of white space between the words.
            The single space version is used in the grammar for clarity.</li>
          <li>The <code><a href="#rQuadData">QuadData</a></code> and 
            <code><a href="#rQuadPattern">QuadPattern</a></code> 
            rules both use rule <code><a href="#rQuads">Quads</a></code>. The rule
            <code><a href="#rQuadData">QuadData</a></code>, used in 
            <a href="#rInsertData"><code>INSERTDATA</code></a> and 
            <a href="#rDeleteData"><code>DELETE DATA</code></a>, 
            must not allow variables in the quad patterns.</li>
          <li>Blank node syntax is not allowed in <code><a href="#rDeleteWhere">DELETE WHERE</a></code>,
            the <code><a href="#rDeleteClause">DeleteClause</a></code> for 
            <code>DELETE</code>,
            nor in <code><a href="#rDeleteData">DELETE DATA</a></code>.</li>
          <li>Rules for limiting the use of blank node labels are given in <a href="#grammarBNodes">section 19.6</a>.</li>
          <li>The number of variables in the variable list of <code>VALUES</code> block 
            must be the same as the number of each list of associated values in the <code>DataBlock</code>.</li>
          <li>Variables introduced by <code>AS</code> in a <code>SELECT</code> clause
            must not already be <a href="#variableScope">in-scope</a>.</li>
          <li>The variable assigned in a <code>BIND</code> clause must not be already 
            in-use within the immediately preceding <code><a href="#rTriplesBlock">TriplesBlock</a></code> within a
            <code><a href="#rGroupGraphPattern">GroupGraphPattern</a></code>.</li>
          <li>Aggregate functions can be one of the 
            <a href="#rAggregate">built-in keywords for aggregates</a> 
            or a custom aggregate, which is syntactically a <a href="#rFunctionCall">function
              call</a>. Aggregate functions may only be used in 
            <a href="#rSelectClause">SELECT</a>, <a href="#rHavingClause">HAVING</a>
            and <a href="#rOrderClause">ORDER BY</a> clauses.</li>
          <li>Only custom aggregate functions use the <code>DISTINCT</code> keyword
            in a <a href="#rFunctionCall">function call</a>.</li>
        </ol>
        <div class="grammarTable">
          <table>
            <tbody>
              <tr style="vertical-align: baseline">
                <td><code>[1]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rQueryUnit">QueryUnit</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rQuery">Query</a> </code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[2]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rQuery">Query</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rPrologue">Prologue</a><br>
                    ( <a href="#rSelectQuery">SelectQuery</a> | <a href="#rConstructQuery">ConstructQuery</a> | <a href="#rDescribeQuery">DescribeQuery</a> | <a href="#rAskQuery">AskQuery</a> )<br>
                    <a href="#rValuesClause">ValuesClause</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[3]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rUpdateUnit">UpdateUnit</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rUpdate">Update</a> </code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[4]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rPrologue">Prologue</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code>( <a href="#rBaseDecl">BaseDecl</a> | <a href="#rPrefixDecl">PrefixDecl</a> )*</code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[5]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rBaseDecl">BaseDecl</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'BASE'</span> <a href="#rIRIREF">IRIREF</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[6]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rPrefixDecl">PrefixDecl</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'PREFIX'</span> <a href="#rPNAME_NS">PNAME_NS</a> <a href="#rIRIREF">IRIREF</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[7]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rSelectQuery">SelectQuery</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rSelectClause">SelectClause</a> <a href="#rDatasetClause">DatasetClause</a>* <a href="#rWhereClause">WhereClause</a> <a href="#rSolutionModifier">SolutionModifier</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[8]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rSubSelect">SubSelect</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rSelectClause">SelectClause</a> <a href="#rWhereClause">WhereClause</a> <a href="#rSolutionModifier">SolutionModifier</a> <a href="#rValuesClause">ValuesClause</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[9]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rSelectClause">SelectClause</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'SELECT'</span> ( <span class="token">'DISTINCT'</span> | <span class="token">'REDUCED'</span> )? ( ( <a href="#rVar">Var</a> | ( <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">'AS'</span> <a href="#rVar">Var</a> <span class="token">')'</span> ) )+ | <span class="token">'*'</span>
                    )</code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[10]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rConstructQuery">ConstructQuery</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'CONSTRUCT'</span> ( <a href="#rConstructTemplate">ConstructTemplate</a> <a href="#rDatasetClause">DatasetClause</a>* <a href="#rWhereClause">WhereClause</a> <a href="#rSolutionModifier">SolutionModifier</a> | <a href="#rDatasetClause">DatasetClause</a>* <span class="token">'WHERE'</span> <span class="token">'{'</span> <a href="#rTriplesTemplate">TriplesTemplate</a>? <span class="token">'}'</span> <a href="#rSolutionModifier">SolutionModifier</a> )</code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[11]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rDescribeQuery">DescribeQuery</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'DESCRIBE'</span> ( <a href="#rVarOrIri">VarOrIri</a>+ | <span class="token">'*'</span> ) <a href="#rDatasetClause">DatasetClause</a>* <a href="#rWhereClause">WhereClause</a>? <a href="#rSolutionModifier">SolutionModifier</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[12]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rAskQuery">AskQuery</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'ASK'</span> <a href="#rDatasetClause">DatasetClause</a>* <a href="#rWhereClause">WhereClause</a> <a href="#rSolutionModifier">SolutionModifier</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[13]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rDatasetClause">DatasetClause</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'FROM'</span> ( <a href="#rDefaultGraphClause">DefaultGraphClause</a> | <a href="#rNamedGraphClause">NamedGraphClause</a> )</code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[14]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rDefaultGraphClause">DefaultGraphClause</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rSourceSelector">SourceSelector</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[15]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rNamedGraphClause">NamedGraphClause</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'NAMED'</span> <a href="#rSourceSelector">SourceSelector</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[16]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rSourceSelector">SourceSelector</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#riri">iri</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[17]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rWhereClause">WhereClause</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'WHERE'</span>? <a href="#rGroupGraphPattern">GroupGraphPattern</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[18]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rSolutionModifier">SolutionModifier</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rGroupClause">GroupClause</a>? <a href="#rHavingClause">HavingClause</a>? <a href="#rOrderClause">OrderClause</a>? <a href="#rLimitOffsetClauses">LimitOffsetClauses</a>?</code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[19]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rGroupClause">GroupClause</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'GROUP'</span> <span class="token">'BY'</span> <a href="#rGroupCondition">GroupCondition</a>+</code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[20]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rGroupCondition">GroupCondition</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rBuiltInCall">BuiltInCall</a> | <a href="#rFunctionCall">FunctionCall</a> | <span class="token">'('</span> <a href="#rExpression">Expression</a> ( <span class="token">'AS'</span> <a href="#rVar">Var</a> )? <span class="token">')'</span> | <a href="#rVar">Var</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[21]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rHavingClause">HavingClause</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'HAVING'</span> <a href="#rHavingCondition">HavingCondition</a>+</code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[22]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rHavingCondition">HavingCondition</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rConstraint">Constraint</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[23]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rOrderClause">OrderClause</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'ORDER'</span> <span class="token">'BY'</span> <a href="#rOrderCondition">OrderCondition</a>+</code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[24]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rOrderCondition">OrderCondition</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code>( ( <span class="token">'ASC'</span> | <span class="token">'DESC'</span> ) <a href="#rBrackettedExpression">BrackettedExpression</a> )<br>
                    | ( <a href="#rConstraint">Constraint</a> | <a href="#rVar">Var</a> )</code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[25]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rLimitOffsetClauses">LimitOffsetClauses</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rLimitClause">LimitClause</a> <a href="#rOffsetClause">OffsetClause</a>? | <a href="#rOffsetClause">OffsetClause</a> <a href="#rLimitClause">LimitClause</a>?</code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[26]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rLimitClause">LimitClause</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'LIMIT'</span> <a href="#rINTEGER">INTEGER</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[27]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rOffsetClause">OffsetClause</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'OFFSET'</span> <a href="#rINTEGER">INTEGER</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[28]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rValuesClause">ValuesClause</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code>( <span class="token">'VALUES'</span> <a href="#rDataBlock">DataBlock</a> )?</code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[29]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rUpdate">Update</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rPrologue">Prologue</a> ( <a href="#rUpdate1">Update1</a> ( <span class="token">';'</span> <a href="#rUpdate">Update</a> )? )?</code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[30]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rUpdate1">Update1</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rLoad">Load</a> | <a href="#rClear">Clear</a> | <a href="#rDrop">Drop</a> | <a href="#rAdd">Add</a> | <a href="#rMove">Move</a> | <a href="#rCopy">Copy</a> |
                    <a href="#rCreate">Create</a> | <a href="#rInsertData">InsertData</a> | <a href="#rDeleteData">DeleteData</a> | <a href="#rDeleteWhere">DeleteWhere</a> | <a href="#rModify">Modify</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[31]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rLoad">Load</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'LOAD'</span> <span class="token">'SILENT'</span>? <a href="#riri">iri</a> ( <span class="token">'INTO'</span> <a href="#rGraphRef">GraphRef</a>
                    )?</code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[32]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rClear">Clear</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'CLEAR'</span> <span class="token">'SILENT'</span>? <a href="#rGraphRefAll">GraphRefAll</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[33]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rDrop">Drop</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'DROP'</span> <span class="token">'SILENT'</span>? <a href="#rGraphRefAll">GraphRefAll</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[34]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rCreate">Create</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'CREATE'</span> <span class="token">'SILENT'</span>? <a href="#rGraphRef">GraphRef</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[35]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rAdd">Add</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'ADD'</span> <span class="token">'SILENT'</span>? <a href="#rGraphOrDefault">GraphOrDefault</a> <span class="token">'TO'</span> <a href="#rGraphOrDefault">GraphOrDefault</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[36]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rMove">Move</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'MOVE'</span> <span class="token">'SILENT'</span>? <a href="#rGraphOrDefault">GraphOrDefault</a> <span class="token">'TO'</span> <a href="#rGraphOrDefault">GraphOrDefault</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[37]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rCopy">Copy</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'COPY'</span> <span class="token">'SILENT'</span>? <a href="#rGraphOrDefault">GraphOrDefault</a> <span class="token">'TO'</span> <a href="#rGraphOrDefault">GraphOrDefault</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[38]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rInsertData">InsertData</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'INSERT DATA'</span> <a href="#rQuadData">QuadData</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[39]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rDeleteData">DeleteData</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'DELETE DATA'</span> <a href="#rQuadData">QuadData</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[40]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rDeleteWhere">DeleteWhere</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'DELETE WHERE'</span> <a href="#rQuadPattern">QuadPattern</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[41]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rModify">Modify</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code>( <span class="token">'WITH'</span> <a href="#riri">iri</a> )? ( <a href="#rDeleteClause">DeleteClause</a> <a href="#rInsertClause">InsertClause</a>? | <a href="#rInsertClause">InsertClause</a> ) <a href="#rUsingClause">UsingClause</a>* <span class="token">'WHERE'</span> <a href="#rGroupGraphPattern">GroupGraphPattern</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[42]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rDeleteClause">DeleteClause</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'DELETE'</span> <a href="#rQuadPattern">QuadPattern</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[43]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rInsertClause">InsertClause</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'INSERT'</span> <a href="#rQuadPattern">QuadPattern</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[44]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rUsingClause">UsingClause</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'USING'</span> ( <a href="#riri">iri</a> | <span class="token">'NAMED'</span> <a href="#riri">iri</a> )</code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[45]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rGraphOrDefault">GraphOrDefault</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'DEFAULT'</span> | <span class="token">'GRAPH'</span>? <a href="#riri">iri</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[46]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rGraphRef">GraphRef</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'GRAPH'</span> <a href="#riri">iri</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[47]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rGraphRefAll">GraphRefAll</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rGraphRef">GraphRef</a> | <span class="token">'DEFAULT'</span> | <span class="token">'NAMED'</span> | <span class="token">'ALL'</span></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[48]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rQuadPattern">QuadPattern</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'{'</span> <a href="#rQuads">Quads</a> <span class="token">'}'</span></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[49]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rQuadData">QuadData</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'{'</span> <a href="#rQuads">Quads</a> <span class="token">'}'</span></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[50]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rQuads">Quads</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rTriplesTemplate">TriplesTemplate</a>? ( <a href="#rQuadsNotTriples">QuadsNotTriples</a> <span class="token">'.'</span>? <a href="#rTriplesTemplate">TriplesTemplate</a>? )*</code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[51]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rQuadsNotTriples">QuadsNotTriples</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'GRAPH'</span> <a href="#rVarOrIri">VarOrIri</a> <span class="token">'{'</span> <a href="#rTriplesTemplate">TriplesTemplate</a>? <span class="token">'}'</span></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[52]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rTriplesTemplate">TriplesTemplate</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rTriplesSameSubject">TriplesSameSubject</a> ( <span class="token">'.'</span> <a href="#rTriplesTemplate">TriplesTemplate</a>? )?</code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[53]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rGroupGraphPattern">GroupGraphPattern</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'{'</span> ( <a href="#rSubSelect">SubSelect</a> | <a href="#rGroupGraphPatternSub">GroupGraphPatternSub</a> ) <span class="token">'}'</span></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[54]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rGroupGraphPatternSub">GroupGraphPatternSub</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rTriplesBlock">TriplesBlock</a>? ( <a href="#rGraphPatternNotTriples">GraphPatternNotTriples</a> <span class="token">'.'</span>? <a href="#rTriplesBlock">TriplesBlock</a>? )*</code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[55]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rTriplesBlock">TriplesBlock</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rTriplesSameSubjectPath">TriplesSameSubjectPath</a> ( <span class="token">'.'</span> <a href="#rTriplesBlock">TriplesBlock</a>? )?</code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[56]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rGraphPatternNotTriples">GraphPatternNotTriples</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rGroupOrUnionGraphPattern">GroupOrUnionGraphPattern</a> | <a href="#rOptionalGraphPattern">OptionalGraphPattern</a> | <a href="#rMinusGraphPattern">MinusGraphPattern</a> | <a href="#rGraphGraphPattern">GraphGraphPattern</a> | <a href="#rServiceGraphPattern">ServiceGraphPattern</a> | <a href="#rFilter">Filter</a> | <a href="#rBind">Bind</a> | <a href="#rInlineData">InlineData</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[57]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rOptionalGraphPattern">OptionalGraphPattern</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'OPTIONAL'</span> <a href="#rGroupGraphPattern">GroupGraphPattern</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[58]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rGraphGraphPattern">GraphGraphPattern</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'GRAPH'</span> <a href="#rVarOrIri">VarOrIri</a> <a href="#rGroupGraphPattern">GroupGraphPattern</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[59]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rServiceGraphPattern">ServiceGraphPattern</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'SERVICE'</span> <span class="token">'SILENT'</span>? <a href="#rVarOrIri">VarOrIri</a> <a href="#rGroupGraphPattern">GroupGraphPattern</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[60]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rBind">Bind</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'BIND'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">'AS'</span> <a href="#rVar">Var</a> <span class="token">')'</span></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[61]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rInlineData">InlineData</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'VALUES'</span> <a href="#rDataBlock">DataBlock</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[62]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rDataBlock">DataBlock</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rInlineDataOneVar">InlineDataOneVar</a> | <a href="#rInlineDataFull">InlineDataFull</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[63]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rInlineDataOneVar">InlineDataOneVar</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rVar">Var</a> <span class="token">'{'</span> <a href="#rDataBlockValue">DataBlockValue</a>* <span class="token">'}'</span></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[64]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rInlineDataFull">InlineDataFull</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code>( <a href="#rNIL">NIL</a> | <span class="token">'('</span> <a href="#rVar">Var</a>* <span class="token">')'</span> ) <span class="token">'{'</span> ( <span class="token">'('</span> <a href="#rDataBlockValue">DataBlockValue</a>* <span class="token">')'</span> | <a href="#rNIL">NIL</a> )* <span class="token">'}'</span></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[65]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rDataBlockValue">DataBlockValue</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#riri">iri</a> | <a href="#rRDFLiteral">RDFLiteral</a> | <a href="#rNumericLiteral">NumericLiteral</a> | <a href="#rBooleanLiteral">BooleanLiteral</a> |
                    <span class="token">'UNDEF'</span></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[66]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rMinusGraphPattern">MinusGraphPattern</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'MINUS'</span> <a href="#rGroupGraphPattern">GroupGraphPattern</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[67]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rGroupOrUnionGraphPattern">GroupOrUnionGraphPattern</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rGroupGraphPattern">GroupGraphPattern</a> ( <span class="token">'UNION'</span> <a href="#rGroupGraphPattern">GroupGraphPattern</a> )*</code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[68]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rFilter">Filter</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'FILTER'</span> <a href="#rConstraint">Constraint</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[69]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rConstraint">Constraint</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rBrackettedExpression">BrackettedExpression</a> | <a href="#rBuiltInCall">BuiltInCall</a> | <a href="#rFunctionCall">FunctionCall</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[70]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rFunctionCall">FunctionCall</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#riri">iri</a> <a href="#rArgList">ArgList</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[71]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rArgList">ArgList</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rNIL">NIL</a> | <span class="token">'('</span> <span class="token">'DISTINCT'</span>? <a href="#rExpression">Expression</a> ( <span class="token">','</span>
                    <a href="#rExpression">Expression</a> )* <span class="token">')'</span></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[72]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rExpressionList">ExpressionList</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rNIL">NIL</a> | <span class="token">'('</span> <a href="#rExpression">Expression</a> ( <span class="token">','</span> <a href="#rExpression">Expression</a> )*
                    <span class="token">')'</span></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[73]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rConstructTemplate">ConstructTemplate</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'{'</span> <a href="#rConstructTriples">ConstructTriples</a>? <span class="token">'}'</span></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[74]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rConstructTriples">ConstructTriples</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rTriplesSameSubject">TriplesSameSubject</a> ( <span class="token">'.'</span> <a href="#rConstructTriples">ConstructTriples</a>? )?</code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[75]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rTriplesSameSubject">TriplesSameSubject</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rVarOrTerm">VarOrTerm</a> <a href="#rPropertyListNotEmpty">PropertyListNotEmpty</a> | <a href="#rTriplesNode">TriplesNode</a> <a href="#rPropertyList">PropertyList</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[76]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rPropertyList">PropertyList</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rPropertyListNotEmpty">PropertyListNotEmpty</a>?</code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[77]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rPropertyListNotEmpty">PropertyListNotEmpty</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rVerb">Verb</a> <a href="#rObjectList">ObjectList</a> ( <span class="token">';'</span> ( <a href="#rVerb">Verb</a> <a href="#rObjectList">ObjectList</a> )?
                    )*</code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[78]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rVerb">Verb</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rVarOrIri">VarOrIri</a> | <span class="token">'a'</span></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[79]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rObjectList">ObjectList</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rObject">Object</a> ( <span class="token">','</span> <a href="#rObject">Object</a> )*</code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[80]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rObject">Object</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rGraphNode">GraphNode</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[81]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rTriplesSameSubjectPath">TriplesSameSubjectPath</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rVarOrTerm">VarOrTerm</a> <a href="#rPropertyListPathNotEmpty">PropertyListPathNotEmpty</a> | <a href="#rTriplesNodePath">TriplesNodePath</a> <a href="#rPropertyListPath">PropertyListPath</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[82]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rPropertyListPath">PropertyListPath</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rPropertyListPathNotEmpty">PropertyListPathNotEmpty</a>?</code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[83]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rPropertyListPathNotEmpty">PropertyListPathNotEmpty</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code>( <a href="#rVerbPath">VerbPath</a> | <a href="#rVerbSimple">VerbSimple</a> ) <a href="#rObjectListPath">ObjectListPath</a> ( <span class="token">';'</span> ( ( <a href="#rVerbPath">VerbPath</a> | <a href="#rVerbSimple">VerbSimple</a> ) <a href="#rObjectListPath">ObjectListPath</a> )? )*</code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[84]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rVerbPath">VerbPath</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rPath">Path</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[85]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rVerbSimple">VerbSimple</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rVar">Var</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[86]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rObjectListPath">ObjectListPath</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rObjectPath">ObjectPath</a> ( <span class="token">','</span> <a href="#rObjectPath">ObjectPath</a> )*</code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[87]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rObjectPath">ObjectPath</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rGraphNodePath">GraphNodePath</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[88]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rPath">Path</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rPathAlternative">PathAlternative</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[89]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rPathAlternative">PathAlternative</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rPathSequence">PathSequence</a> ( <span class="token">'|'</span> <a href="#rPathSequence">PathSequence</a> )*</code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[90]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rPathSequence">PathSequence</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rPathEltOrInverse">PathEltOrInverse</a> ( <span class="token">'/'</span> <a href="#rPathEltOrInverse">PathEltOrInverse</a> )*</code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[91]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rPathElt">PathElt</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rPathPrimary">PathPrimary</a> <a href="#rPathMod">PathMod</a>?</code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[92]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rPathEltOrInverse">PathEltOrInverse</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rPathElt">PathElt</a> | <span class="token">'^'</span> <a href="#rPathElt">PathElt</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[93]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rPathMod">PathMod</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'?'</span> | <span class="token">'*'</span> | <span class="token">'+'</span></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[94]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rPathPrimary">PathPrimary</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#riri">iri</a> | <span class="token">'a'</span> | <span class="token">'!'</span> <a href="#rPathNegatedPropertySet">PathNegatedPropertySet</a> | <span class="token">'('</span> <a href="#rPath">Path</a> <span class="token">')'</span></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[95]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rPathNegatedPropertySet">PathNegatedPropertySet</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rPathOneInPropertySet">PathOneInPropertySet</a> | <span class="token">'('</span> ( <a href="#rPathOneInPropertySet">PathOneInPropertySet</a> ( <span class="token">'|'</span> <a href="#rPathOneInPropertySet">PathOneInPropertySet</a> )* )? <span class="token">')'</span></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[96]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rPathOneInPropertySet">PathOneInPropertySet</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#riri">iri</a> | <span class="token">'a'</span> | <span class="token">'^'</span> ( <a href="#riri">iri</a> | <span class="token">'a'</span> )</code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[97]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rInteger">Integer</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rINTEGER">INTEGER</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[98]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rTriplesNode">TriplesNode</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rCollection">Collection</a> | <a href="#rBlankNodePropertyList">BlankNodePropertyList</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[99]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rBlankNodePropertyList">BlankNodePropertyList</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'['</span> <a href="#rPropertyListNotEmpty">PropertyListNotEmpty</a> <span class="token">']'</span></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[100]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rTriplesNodePath">TriplesNodePath</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rCollectionPath">CollectionPath</a> | <a href="#rBlankNodePropertyListPath">BlankNodePropertyListPath</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[101]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rBlankNodePropertyListPath">BlankNodePropertyListPath</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'['</span> <a href="#rPropertyListPathNotEmpty">PropertyListPathNotEmpty</a> <span class="token">']'</span></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[102]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rCollection">Collection</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'('</span> <a href="#rGraphNode">GraphNode</a>+ <span class="token">')'</span></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[103]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rCollectionPath">CollectionPath</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'('</span> <a href="#rGraphNodePath">GraphNodePath</a>+ <span class="token">')'</span></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[104]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rGraphNode">GraphNode</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rVarOrTerm">VarOrTerm</a> | <a href="#rTriplesNode">TriplesNode</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[105]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rGraphNodePath">GraphNodePath</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rVarOrTerm">VarOrTerm</a> | <a href="#rTriplesNodePath">TriplesNodePath</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[106]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rVarOrTerm">VarOrTerm</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rVar">Var</a> | <a href="#rGraphTerm">GraphTerm</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[107]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rVarOrIri">VarOrIri</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rVar">Var</a> | <a href="#riri">iri</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[108]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rVar">Var</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rVAR1">VAR1</a> | <a href="#rVAR2">VAR2</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[109]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rGraphTerm">GraphTerm</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#riri">iri</a> | <a href="#rRDFLiteral">RDFLiteral</a> | <a href="#rNumericLiteral">NumericLiteral</a> | <a href="#rBooleanLiteral">BooleanLiteral</a> | <a href="#rBlankNode">BlankNode</a> | <a href="#rNIL">NIL</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[110]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rExpression">Expression</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rConditionalOrExpression">ConditionalOrExpression</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[111]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rConditionalOrExpression">ConditionalOrExpression</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rConditionalAndExpression">ConditionalAndExpression</a> ( <span class="token">'||'</span> <a href="#rConditionalAndExpression">ConditionalAndExpression</a>
                    )*</code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[112]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rConditionalAndExpression">ConditionalAndExpression</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rValueLogical">ValueLogical</a> ( <span class="token">'&amp;&amp;'</span> <a href="#rValueLogical">ValueLogical</a> )*</code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[113]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rValueLogical">ValueLogical</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rRelationalExpression">RelationalExpression</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[114]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rRelationalExpression">RelationalExpression</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rNumericExpression">NumericExpression</a> ( <span class="token">'='</span> <a href="#rNumericExpression">NumericExpression</a> | <span class="token">'!='</span>
                    <a href="#rNumericExpression">NumericExpression</a> | <span class="token">'&lt;'</span> <a href="#rNumericExpression">NumericExpression</a> | <span class="token">'&gt;'</span>
                    <a href="#rNumericExpression">NumericExpression</a> | <span class="token">'&lt;='</span> <a href="#rNumericExpression">NumericExpression</a> | <span class="token">'&gt;='</span>
                    <a href="#rNumericExpression">NumericExpression</a> | <span class="token">'IN'</span> <a href="#rExpressionList">ExpressionList</a> | <span class="token">'NOT'</span> <span class="token">'IN'</span> <a href="#rExpressionList">ExpressionList</a> )?</code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[115]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rNumericExpression">NumericExpression</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rAdditiveExpression">AdditiveExpression</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[116]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rAdditiveExpression">AdditiveExpression</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rMultiplicativeExpression">MultiplicativeExpression</a> ( <span class="token">'+'</span> <a href="#rMultiplicativeExpression">MultiplicativeExpression</a> |
                    <span class="token">'-'</span> <a href="#rMultiplicativeExpression">MultiplicativeExpression</a> | ( <a href="#rNumericLiteralPositive">NumericLiteralPositive</a> | <a href="#rNumericLiteralNegative">NumericLiteralNegative</a> ) ( ( <span class="token">'*'</span> <a href="#rUnaryExpression">UnaryExpression</a> ) | ( <span class="token">'/'</span>
                    <a href="#rUnaryExpression">UnaryExpression</a> ) )* )*</code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[117]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rMultiplicativeExpression">MultiplicativeExpression</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rUnaryExpression">UnaryExpression</a> ( <span class="token">'*'</span> <a href="#rUnaryExpression">UnaryExpression</a> | <span class="token">'/'</span> <a href="#rUnaryExpression">UnaryExpression</a> )*</code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[118]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rUnaryExpression">UnaryExpression</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code>&nbsp;&nbsp;<span class="token">'!'</span> <a href="#rPrimaryExpression">PrimaryExpression</a><br>
                    | <span class="token">'+'</span> <a href="#rPrimaryExpression">PrimaryExpression</a><br>
                    | <span class="token">'-'</span> <a href="#rPrimaryExpression">PrimaryExpression</a><br>
                    | <a href="#rPrimaryExpression">PrimaryExpression</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[119]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rPrimaryExpression">PrimaryExpression</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rBrackettedExpression">BrackettedExpression</a> | <a href="#rBuiltInCall">BuiltInCall</a> | <a href="#ririOrFunction">iriOrFunction</a> | <a href="#rRDFLiteral">RDFLiteral</a> | <a href="#rNumericLiteral">NumericLiteral</a> | <a href="#rBooleanLiteral">BooleanLiteral</a> | <a href="#rVar">Var</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[120]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rBrackettedExpression">BrackettedExpression</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[121]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rBuiltInCall">BuiltInCall</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code>&nbsp;&nbsp;<a href="#rAggregate">Aggregate</a><br>
                    | <span class="token">'STR'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                    | <span class="token">'LANG'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                    | <span class="token">'LANGMATCHES'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a>
                    <span class="token">')'</span><br>
                    | <span class="token">'DATATYPE'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                    | <span class="token">'BOUND'</span> <span class="token">'('</span> <a href="#rVar">Var</a> <span class="token">')'</span><br>
                    | <span class="token">'IRI'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                    | <span class="token">'URI'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                    | <span class="token">'BNODE'</span> ( <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> | <a href="#rNIL">NIL</a> )<br>
                    | <span class="token">'RAND'</span> <a href="#rNIL">NIL</a><br>
                    | <span class="token">'ABS'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                    | <span class="token">'CEIL'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                    | <span class="token">'FLOOR'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                    | <span class="token">'ROUND'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                    | <span class="token">'CONCAT'</span> <a href="#rExpressionList">ExpressionList</a><br>
                    | <a href="#rSubstringExpression">SubstringExpression</a><br>
                    | <span class="token">'STRLEN'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                    | <a href="#rStrReplaceExpression">StrReplaceExpression</a><br>
                    | <span class="token">'UCASE'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                    | <span class="token">'LCASE'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                    | <span class="token">'ENCODE_FOR_URI'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                    | <span class="token">'CONTAINS'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a>
                    <span class="token">')'</span><br>
                    | <span class="token">'STRSTARTS'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a>
                    <span class="token">')'</span><br>
                    | <span class="token">'STRENDS'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a>
                    <span class="token">')'</span><br>
                    | <span class="token">'STRBEFORE'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a>
                    <span class="token">')'</span><br>
                    | <span class="token">'STRAFTER'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a>
                    <span class="token">')'</span><br>
                    | <span class="token">'YEAR'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                    | <span class="token">'MONTH'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                    | <span class="token">'DAY'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                    | <span class="token">'HOURS'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                    | <span class="token">'MINUTES'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                    | <span class="token">'SECONDS'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                    | <span class="token">'TIMEZONE'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                    | <span class="token">'TZ'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                    | <span class="token">'NOW'</span> <a href="#rNIL">NIL</a><br>
                    | <span class="token">'UUID'</span> <a href="#rNIL">NIL</a><br>
                    | <span class="token">'STRUUID'</span> <a href="#rNIL">NIL</a><br>
                    | <span class="token">'MD5'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                    | <span class="token">'SHA1'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                    | <span class="token">'SHA256'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                    | <span class="token">'SHA384'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                    | <span class="token">'SHA512'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                    | <span class="token">'COALESCE'</span> <a href="#rExpressionList">ExpressionList</a><br>
                    | <span class="token">'IF'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a>
                    <span class="token">','</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                    | <span class="token">'STRLANG'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a>
                    <span class="token">')'</span><br>
                    | <span class="token">'STRDT'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a>
                    <span class="token">')'</span><br>
                    | <span class="token">'sameTerm'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a>
                    <span class="token">')'</span><br>
                    | <span class="token">'isIRI'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                    | <span class="token">'isURI'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                    | <span class="token">'isBLANK'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                    | <span class="token">'isLITERAL'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                    | <span class="token">'isNUMERIC'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                    | <a href="#rRegexExpression">RegexExpression</a><br>
                    | <a href="#rExistsFunc">ExistsFunc</a><br>
                    | <a href="#rNotExistsFunc">NotExistsFunc</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[122]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rRegexExpression">RegexExpression</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'REGEX'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a>
                    ( <span class="token">','</span> <a href="#rExpression">Expression</a> )? <span class="token">')'</span></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[123]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rSubstringExpression">SubstringExpression</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'SUBSTR'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a>
                    ( <span class="token">','</span> <a href="#rExpression">Expression</a> )? <span class="token">')'</span></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[124]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rStrReplaceExpression">StrReplaceExpression</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'REPLACE'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a> ( <span class="token">','</span> <a href="#rExpression">Expression</a> )?
                    <span class="token">')'</span></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[125]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rExistsFunc">ExistsFunc</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'EXISTS'</span> <a href="#rGroupGraphPattern">GroupGraphPattern</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[126]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rNotExistsFunc">NotExistsFunc</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'NOT'</span> <span class="token">'EXISTS'</span> <a href="#rGroupGraphPattern">GroupGraphPattern</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[127]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rAggregate">Aggregate</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code>&nbsp;&nbsp;<span class="token">'COUNT'</span> <span class="token">'('</span> <span class="token">'DISTINCT'</span>? ( <span class="token">'*'</span> | <a href="#rExpression">Expression</a> ) <span class="token">')'</span><br>
                    | <span class="token">'SUM'</span> <span class="token">'('</span> <span class="token">'DISTINCT'</span>? <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                    | <span class="token">'MIN'</span> <span class="token">'('</span> <span class="token">'DISTINCT'</span>? <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                    | <span class="token">'MAX'</span> <span class="token">'('</span> <span class="token">'DISTINCT'</span>? <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                    | <span class="token">'AVG'</span> <span class="token">'('</span> <span class="token">'DISTINCT'</span>? <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                    | <span class="token">'SAMPLE'</span> <span class="token">'('</span> <span class="token">'DISTINCT'</span>? <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                    | <span class="token">'GROUP_CONCAT'</span> <span class="token">'('</span> <span class="token">'DISTINCT'</span>? <a href="#rExpression">Expression</a> ( <span class="token">';'</span> <span class="token">'SEPARATOR'</span> <span class="token">'='</span> <a href="#rString">String</a> )? <span class="token">')'</span></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[128]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="ririOrFunction">iriOrFunction</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#riri">iri</a> <a href="#rArgList">ArgList</a>?</code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[129]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rRDFLiteral">RDFLiteral</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rString">String</a> ( <a href="#rLANGTAG">LANGTAG</a> | ( <span class="token">'^^'</span> <a href="#riri">iri</a> ) )?</code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[130]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rNumericLiteral">NumericLiteral</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rNumericLiteralUnsigned">NumericLiteralUnsigned</a> | <a href="#rNumericLiteralPositive">NumericLiteralPositive</a> | <a href="#rNumericLiteralNegative">NumericLiteralNegative</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[131]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rNumericLiteralUnsigned">NumericLiteralUnsigned</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rINTEGER">INTEGER</a> | <a href="#rDECIMAL">DECIMAL</a> | <a href="#rDOUBLE">DOUBLE</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[132]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rNumericLiteralPositive">NumericLiteralPositive</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rINTEGER_POSITIVE">INTEGER_POSITIVE</a> | <a href="#rDECIMAL_POSITIVE">DECIMAL_POSITIVE</a> | <a href="#rDOUBLE_POSITIVE">DOUBLE_POSITIVE</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[133]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rNumericLiteralNegative">NumericLiteralNegative</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rINTEGER_NEGATIVE">INTEGER_NEGATIVE</a> | <a href="#rDECIMAL_NEGATIVE">DECIMAL_NEGATIVE</a> | <a href="#rDOUBLE_NEGATIVE">DOUBLE_NEGATIVE</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[134]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rBooleanLiteral">BooleanLiteral</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'true'</span> | <span class="token">'false'</span></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[135]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rString">String</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rSTRING_LITERAL1">STRING_LITERAL1</a> | <a href="#rSTRING_LITERAL2">STRING_LITERAL2</a> | <a href="#rSTRING_LITERAL_LONG1">STRING_LITERAL_LONG1</a> | <a href="#rSTRING_LITERAL_LONG2">STRING_LITERAL_LONG2</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[136]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="riri">iri</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rIRIREF">IRIREF</a> | <a href="#rPrefixedName">PrefixedName</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[137]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rPrefixedName">PrefixedName</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rPNAME_LN">PNAME_LN</a> | <a href="#rPNAME_NS">PNAME_NS</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[138]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rBlankNode">BlankNode</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rBLANK_NODE_LABEL">BLANK_NODE_LABEL</a> | <a href="#rANON">ANON</a></code></td>
              </tr>
            </tbody>
          </table>
        </div>
        <p>Productions for terminals:</p>
        <div class="grammarTable">
          <table>
            <tbody>
              <tr style="vertical-align: baseline">
                <td><code>[139]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rIRIREF">IRIREF</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'&lt;' ([^&lt;&gt;"{}|^`\]-[#x00-#x20])* '&gt;'</span></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[140]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rPNAME_NS">PNAME_NS</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rPN_PREFIX">PN_PREFIX</a>? ':'</code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[141]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rPNAME_LN">PNAME_LN</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rPNAME_NS">PNAME_NS</a> <a href="#rPN_LOCAL">PN_LOCAL</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[142]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rBLANK_NODE_LABEL">BLANK_NODE_LABEL</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code>'_:' ( <a href="#rPN_CHARS_U">PN_CHARS_U</a> | [0-9] ) ((<a href="#rPN_CHARS">PN_CHARS</a>|'.')* <a href="#rPN_CHARS">PN_CHARS</a>)?</code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[143]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rVAR1">VAR1</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code>'?' <a href="#rVARNAME">VARNAME</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[144]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rVAR2">VAR2</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code>'$' <a href="#rVARNAME">VARNAME</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[145]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rLANGTAG">LANGTAG</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code>'@' [a-zA-Z]+ ('-' [a-zA-Z0-9]+)*</code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[146]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rINTEGER">INTEGER</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code>[0-9]+</code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[147]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rDECIMAL">DECIMAL</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code>[0-9]* '.' [0-9]+</code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[148]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rDOUBLE">DOUBLE</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code>[0-9]+ '.' [0-9]* <a href="#rEXPONENT">EXPONENT</a> | '.' ([0-9])+ <a href="#rEXPONENT">EXPONENT</a> | ([0-9])+ <a href="#rEXPONENT">EXPONENT</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[149]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rINTEGER_POSITIVE">INTEGER_POSITIVE</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'+'</span> <a href="#rINTEGER">INTEGER</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[150]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rDECIMAL_POSITIVE">DECIMAL_POSITIVE</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'+'</span> <a href="#rDECIMAL">DECIMAL</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[151]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rDOUBLE_POSITIVE">DOUBLE_POSITIVE</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'+'</span> <a href="#rDOUBLE">DOUBLE</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[152]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rINTEGER_NEGATIVE">INTEGER_NEGATIVE</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'-'</span> <a href="#rINTEGER">INTEGER</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[153]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rDECIMAL_NEGATIVE">DECIMAL_NEGATIVE</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'-'</span> <a href="#rDECIMAL">DECIMAL</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[154]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rDOUBLE_NEGATIVE">DOUBLE_NEGATIVE</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'-'</span> <a href="#rDOUBLE">DOUBLE</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[155]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rEXPONENT">EXPONENT</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code>[eE] [+-]? [0-9]+</code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[156]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rSTRING_LITERAL1">STRING_LITERAL1</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code>"'" ( ([^#x27#x5C#xA#xD]) | <a href="#rECHAR">ECHAR</a> )* "'"</code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[157]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rSTRING_LITERAL2">STRING_LITERAL2</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code>'"' ( ([^#x22#x5C#xA#xD]) | <a href="#rECHAR">ECHAR</a> )* '"'</code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[158]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rSTRING_LITERAL_LONG1">STRING_LITERAL_LONG1</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code>"'''" ( ( "'" | "''" )? ( [^'\] | <a href="#rECHAR">ECHAR</a> ) )* "'''"</code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[159]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rSTRING_LITERAL_LONG2">STRING_LITERAL_LONG2</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code>'"""' ( ( '"' | '""' )? ( [^"\] | <a href="#rECHAR">ECHAR</a> ) )* '"""'</code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[160]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rECHAR">ECHAR</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code>'\' [tbnrf\"']</code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[161]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rNIL">NIL</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code>'(' <a href="#rWS">WS</a>* ')'</code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[162]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rWS">WS</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code>#x20 | #x9 | #xD | #xA</code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[163]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rANON">ANON</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code>'[' <a href="#rWS">WS</a>* ']'</code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[164]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rPN_CHARS_BASE">PN_CHARS_BASE</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code>[A-Z] | [a-z] | [#x00C0-#x00D6] | [#x00D8-#x00F6] | [#x00F8-#x02FF] | [#x0370-#x037D] | [#x037F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] |
                    [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]</code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[165]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rPN_CHARS_U">PN_CHARS_U</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rPN_CHARS_BASE">PN_CHARS_BASE</a> | '_'</code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[166]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rVARNAME">VARNAME</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code>( <a href="#rPN_CHARS_U">PN_CHARS_U</a> | [0-9] ) ( <a href="#rPN_CHARS_U">PN_CHARS_U</a> | [0-9] | #x00B7 | [#x0300-#x036F] | [#x203F-#x2040] )*</code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[167]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rPN_CHARS">PN_CHARS</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rPN_CHARS_U">PN_CHARS_U</a> | '-' | [0-9] | #x00B7 | [#x0300-#x036F] | [#x203F-#x2040]</code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[168]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rPN_PREFIX">PN_PREFIX</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rPN_CHARS_BASE">PN_CHARS_BASE</a> ((<a href="#rPN_CHARS">PN_CHARS</a>|'.')* <a href="#rPN_CHARS">PN_CHARS</a>)?</code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[169]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rPN_LOCAL">PN_LOCAL</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code>(<a href="#rPN_CHARS_U">PN_CHARS_U</a> | ':' | [0-9] | <a href="#rPLX">PLX</a> ) ((<a href="#rPN_CHARS">PN_CHARS</a> | '.' | ':' | <a href="#rPLX">PLX</a>)* (<a href="#rPN_CHARS">PN_CHARS</a> | ':' | <a href="#rPLX">PLX</a>) )?</code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[170]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rPLX">PLX</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rPERCENT">PERCENT</a> | <a href="#rPN_LOCAL_ESC">PN_LOCAL_ESC</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[171]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rPERCENT">PERCENT</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code>'%' <a href="#rHEX">HEX</a> <a href="#rHEX">HEX</a></code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[172]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rHEX">HEX</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code>[0-9] | [A-F] | [a-f]</code></td>
              </tr>
              <tr style="vertical-align: baseline">
                <td><code>[173]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rPN_LOCAL_ESC">PN_LOCAL_ESC</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code>'\' ( '_' | '~' | '.' | '-' | '!' | '$' | '&amp;' | "'" | '(' | ')' | '*' | '+' | ',' | ';' | '=' | '/' | '?' | '#' | '@' | '%' )</code></td>
              </tr>
            </tbody>
          </table>
        </div>
      </section>
    </section>

    <section id="conformance">
      <h2>Conformance</h2>
      <p>See Section <a href="#grammar">19 SPARQL Grammar</a> regarding conformance of 
        <a>SPARQL Query strings</a>, and section 
        <a href="#QueryForms">16 Query Forms</a> for conformance of query results. 
        See section <a href="#mediaType">22. Internet Media Type</a> for conformance 
        to the application/sparql-query media type.</p>
      <p>This specification is intended for use in conjunction with the [[[SPARQL11-PROTOCOL]]]
        [[SPARQL11-PROTOCOL]], the [[[RDF-SPARQL-XMLRES]]] [[RDF-SPARQL-XMLRES]], the
        [[[SPARQL11-RESULTS-JSON]]] [[SPARQL11-RESULTS-JSON]] and the [[[SPARQL11-RESULTS-CSV-TSV]]]
        [[SPARQL11-RESULTS-CSV-TSV]]. See those specifications for their conformance criteria.</p>
      <p>Note that the SPARQL protocol describes a means for conveying SPARQL queries to an SPARQL
        query processing service and returning the query results to the entity that requested
        them.</p>
    </section>

    <section id="mediaType">
      <h2>Internet Media Type, File Extension and Macintosh File Type</h2>
      <p>The Internet Media Type / MIME Type for the SPARQL Query Language is
        "<code>application/sparql-query</code>".</p>
      <p>It is recommended that sparql query files have the extension ".rq" (lowercase) on all
        platforms.</p>
      <p>It is recommended that sparql query files stored on Macintosh HFS file systems be given a
        file type of "TEXT".</p>
      <div class="mime">
        <dl>
          <dt>Type name:</dt>
          <dd>application</dd>
          <dt>Subtype name:</dt>
          <dd>sparql-query</dd>
          <dt>Required parameters:</dt>
          <dd>None</dd>
          <dt>Optional parameters:</dt>
          <dd>None</dd>
          <dt>Encoding considerations:</dt>
          <dd>The syntax of the SPARQL Query Language is expressed over code points in Unicode
            [[UNICODE]]. The encoding is always UTF-8 [[RFC3629]].</dd>
          <dd>Unicode code points may also be expressed using an \uXXXX (U+0 to U+FFFF) or
            \UXXXXXXXX syntax (for U+10000 onwards) where X is a hexadecimal digit [0-9A-F]</dd>
          <dt>Security considerations:</dt>
          <dd>
            See SPARQL Query appendix C, <a href="#security">Security Considerations</a> as well as
            [[[RFC3629]]] [[RFC3629]] section 7, Security Considerations.
          </dd>
          <dt>Interoperability considerations:</dt>
          <dd>There are no known interoperability issues.</dd>
          <dt>Published specification:</dt>
          <dd>This specification.</dd>
          <dt>Applications which use this media type:</dt>
          <dd>No known applications currently use this media type.</dd>
          <dt>Additional information:</dt>
          <dt>Magic number(s):</dt>
          <dd>A SPARQL query may have the string 'PREFIX' (case independent) near the beginning of
            the document.</dd>
          <dt>File extension(s):</dt>
          <dd>".rq"</dd>
          <dt>Base URI:</dt>
          <dd>The SPARQL 'BASE &lt;IRIref&gt;' term can change the current base URI for relative
            IRIrefs in the query language that are used sequentially later in the document.</dd>
          <dt>Macintosh file type code(s):</dt>
          <dd>"TEXT"</dd>
          <dt>Person & email address to contact for further information:</dt>
          <dd>public-rdf-dawg-comments@w3.org</dd>
          <dt>Intended usage:</dt>
          <dd>COMMON</dd>
          <dt>Restrictions on usage:</dt>
          <dd>None</dd>
          <dt>Author/Change controller:</dt>
          <dd>The SPARQL 1.2 specification is a work product of the World Wide Web Consortium's
            RDF-star Working Group. The W3C has change control over these specifications.</dd>
        </dl>
      </div>
    </section>
    
    <!-- BODY -->
    <section id="privacy">
      <h2>Privacy Considerations</h2>
      <p>TODO</p>
    </section>

    <section id="security">
      <h2>Security Considerations</h2>
      <p>SPARQL queries using FROM, FROM NAMED, or GRAPH may cause the specified URI to be
          dereferenced. This may cause additional use of network, disk or CPU resources along with
          associated secondary issues such as denial of service. The security issues of [[[RFC3986]]]
          [[RFC3986]] Section 7 should be considered. In addition, the contents of <code>file:</code>
          URIs can in some cases be accessed, processed and returned as results, providing unintended
          access to local resources.</p>
        <p>SPARQL requests may cause additional requests to be issued from the SPARQL endpoint, such
          as FROM NAMED. The endpoint is potentially within an organisations firewall or DMZ, and so
          such queries may be a source of indirection attacks.</p>
        <p>The SPARQL language permits extensions, which will have their own security
          implications.</p>
        <p>Multiple IRIs may have the same appearance. Characters in different scripts may look
          similar (a Cyrillic "о" may appear similar to a Latin "o"). A character followed by combining
          characters may have the same visual representation as another character (LATIN SMALL LETTER E
          followed by COMBINING ACUTE ACCENT has the same visual representation as LATIN SMALL LETTER E
          WITH ACUTE). Users of SPARQL must take care to construct queries with IRIs that match the
          IRIs in the data. Further information about matching of similar characters can be found in
          [[[UTR36]]] [[UTR36]] and [[[RFC3987]]] [[RFC3987]] Section 8.</p>
    </section>
    
    <section id="internationalization">
      <h2>Internationalization Considerations</h2>
      <p>TODO</p>                
    </section>

    <section class="appendix informative" id="changes-from-sparql11">
      <h2>Change Log</h2>
      <p>TODO</p>
    </section>   

    <section id="index"></section>

  </body>
</html>
