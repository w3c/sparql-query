<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8" />
    <title>SPARQL 1.2 Query Language</title>

    <script src="https://www.w3.org/Tools/respec/respec-w3c" class="remove"></script>
    <script src="./common/local-biblio.js" class="remove"></script>
    <script src="./common/fixup.js" class="remove"></script>

    <script class="remove">
      // All config options at https://respec.org/docs/
      var respecConfig = {
        group:                "rdf-star" ,
        localBiblio:          localBibliography,
        specStatus:           "ED",
        edDraftURI:           "https://w3c.github.io/sparql-query/spec/",
        testSuiteURI:         "https://w3c.github.io/rdf-tests/",
        shortName:            "sparql12-query",
        copyrightStart:       "2008",
         
        github:               "https://github.com/w3c/sparql-query",
        wgPublicList:         "public-rdf-star-wg",

//        implementationReportURI: "https://w3c.github.io/sparql12-query/reports/",
//        errata:               "https://w3c.github.io/sparql12-query/errata/",

        previousPublishDate:  "2013-03-21",
        prevRecURI:           "https://www.w3.org/TR/2013/REC-sparql11-query-20130321",
        prevRecShortname:     "sparql11-query",
        previousMaturity:     "REC",
        
        editors: [
           { name: "Olaf Hartig", w3cid: "112469"},
           { name: "Andy Seaborne", w3cid: "29909" },
           { name: "Ruben Taelman", w3cid: "84199"},
           { name: "Gregory Williams", w3cid: "38870"},
           { name: "Thomas Pellissier Tanon", w3cid: "73758"},
         ],
        formerEditors: [
          { name: "Steve Harris" },
          { name: "Andy Seaborne" },
          { name: "Eric Prud'hommeaux" },
        ],

        //doJsonLd:     true,
        
        lint: { "no-unused-dfns": false }
      };
    </script>

    <style>
.wgNote	{ border: 0.2em solid red;
      padding: 0.5em ;
      margin: 1em 1em 1em 2em ; }

.box     { border: thin solid #888888;
           page-break-inside: avoid ;
           background-color: #F8F8F8 ; padding:1em ;
           margin-left:0 ; margin-right: 2ex; 
           margin-top: 0.1ex ; margin-bottom: 0.1ex ;
         }


/* == General Tag Treatment == */
pre		           { margin: 1em 4em 1em 2.5em ; /* Top Right Bottom Left */
                   padding: 1ex;
                   /*overflow: auto;*/
                   page-break-inside: avoid ; }

/* Tables */
table, td	      { text-align: left; }
td, th          { border-style: solid;
                  border-width: 1px;
                  border-color: black;
                  border-bottom-color: gray;
                  border-right-color: gray; }
td.annotation, th.annotation { border-style: none; border-bottom-style: dotted; }
table.plain	{ border-spacing: 0px; padding: 0px ; border-collapse: collapse ; }
                  /* cellpadding="0" cellspacing="1" style="border-collapse: collapse */


th.major	{ background-color: #005a9c;
                  color: white; }
.subHeading	{ text-align: left;
                  background-color: #CCCCCC; }
th, td		{ padding: 3px; }
td		{ font-size: 85%; }
th a:link	{ text-decoration: none; }
th a:hover	{ background-color:#FFFF99;
                  text-decoration: underline; }

/* == Prototypes == */
pre.prototype	{ background-color:#f7f8ff;
                  border:thin solid #8888aa;
                  margin: 1em 1em 1em 0em ; }
.return, .type	{ color: #177 }

/* Definitions */
.defn		{ margin-left:0 ; margin-right: 2ex; 
                  margin-top: 0.1ex ; margin-bottom: 0.1ex ;
                  /*border: double 1px #888888; *//* Buggy */
                  border: thin solid #888888;
                  padding: 1ex 2ex 0.5ex 2ex ; /* top, right, bottom, left */
                  page-break-inside: avoid ;
                  background-color: #F0F8F8 ; }
div.defn p	{ margin-top: 1ex ; margin-bottom: 1.5ex ;}
div.defn ul	{ margin-top: 1ex ; margin-bottom: 1.5ex ; }
span.definedTerm	{font-weight: bold;}
div.indentedFormula { margin-left: 5ex ; margin-top: 2mm ; margin-bottom: 2mm ; }

div.grammarExtract
                { border: thin solid #888888;
                  padding: 1ex 2ex 1ex 2ex ; /* top, right, bottom, left */
                  margin: 1em 6em 1em 2em ; 
                  page-break-inside: avoid ;
                  background-color: #F8F8F8 ;
                  width: fit-content; }

/* Examples */
pre.data	{ border: thin solid #88AA88;
                  background-color: #E8F0E8;
                  margin: 1em 1em 1em 0em ; }

pre.dataExcerpt	{ border: thin solid #88AA88;
                  background-color: #E8F0E8;
                  margin: 1em 1em 1em 0em ; }
/* Example Queries */
.query          { background-color:#f7f8ff; }
.queryExcerpt   { background-color:#f7f8ff; }
pre.query	{ border:thin solid #8888aa;
                  margin: 1em 1em 1em 0em ; }
/* Example Results */
.result		{ border: thin solid  #888888 ;
                  background-color: #F0F0F0 ; }
pre.resultGraph	{  margin: 0em 0em 0em 0em ; /* Top Right Bottom Left */
                   padding: 0ex;
                   font-size: 100% ;
                   page-break-inside: avoid ; }
pre.resultSet	{  margin: 0em 0em 0em 0em ; /* Top Right Bottom Left */
                   padding: 0ex;
                   font-size: 100% ;
                   page-break-inside: avoid ; }
pre.resultAsk	{  margin: 0em 0em 0em 0em ; /* Top Right Bottom Left */
                   padding: 0ex;
                   font-size: 100% ;
                   page-break-inside: avoid ; }
pre.resultTurtle{  margin: 0em 0em 0em 0em ; /* Top Right Bottom Left */
                   padding: 0ex;
                   font-size: 100% ;
                   page-break-inside: avoid ; }

pre.result	{ margin: 1em 1em 1em 0em ; }

div.result	{ font-family: monospace;
                  margin:  1em 1em 1em 0em ;
                  padding: 1ex ;}

.result table	{ border-collapse: collapse; }
.result table td{ border-width: 1px ;
                  border-color : black ; 
                  font-family: monospace ;
                  empty-cells: show;
                  padding-left: 1ex ; padding-right: 1ex ;
                  vertical-align:top;
                  text-align: left ; } 
/*  spacing: 0 ;*/
.result table th{ border-width: 1px ;
                  font-family: monospace ;
                  border-color: black ;
                  empty-cells: show;
                  padding-left: 1ex ; padding-right: 1ex ;
                  vertical-align:top;
                  text-align:center; } 

/* Examples : Algebra */
div.algExample {  border: thin solid #888888;
                  page-break-inside: avoid ;
                  padding:0.5em ; margin:0.5em ;
                  margin-left: 2em ; margin-right: 2em ;
                  font-family:monospace ; }

div.algExample1 { padding:0.5em ; background-color: #F0F0FF ; }
div.algExample2 { padding:0.5em ; margin-top: 0.5em ; background-color: #F0FFF0 ; }

/* Grammar Mark-up */
.operator	{ color: #3f3f5f; }
.function	{ color: #3f3f5f; }

/* Tuned to cope with different browsers behaviours */
div.grammarTable table	{ border-style: solid ;
			  border-width: 1px ;
			  border-color: #AAA ;
			  border-spacing: 0px ; 
			  border-collapse: collapse ; }

div.grammarTable table * { border-left-width: 0px ;
			   border-right-width: 0px ;
			   border-color: #AAA ; } 

div.grammarTable table * tr   { border-top-style: solid ;
			  border-top-width: 1px ;
			  border-top-color: #AAA ; } 

.grammar	{ text-align: left ;
                  vertical-align: top ; }
.token		{ color: #3f3f5f; }
table.FAndOTable .token		{ color: #00c; }
table.FAndOTable .token:visited		{ color: #a0c; }
.gRuleHead	{ font-style: italic ;
                  font-family: monospace ; }
.gRuleBody	{ font-family: monospace ; }
.gRuleLabel	{ font-family: monospace ; }

.code		{ font-family: monospace; font-size: 100%; }
pre.code	{ font-family: monospace; font-size: 100%; margin: 0 ; }

/* Table of Contents */
.toc		{ text-indent: 0; }

/* References to the Rdf Data Model */
span.rdfDM	{ color: #11d; }


/* Truth Table */
  .truth	{ font-family: monospace; }
  .error	{ color: #ff1f1f; }
  table.truthTable td	{ text-align: center; font-family: monospace; }
  table.truthTable th	{ background-color: #dfdfdf; }
  table.truthTable tbody th	{ font-weight: normal; font-family: monospace; }

/* Casting table */
table.casting	{ font-size: x-small; }

.castY	{ background-color: #7FFF7F;
                  color: black; }

.castN	{ background-color: #FF7F7F;
                  color: black; }

.castM	{ background-color: white;
                  color: black; }

span.cancast:hover { background-color: #ffa;
                     color: black; }

.SPARQLoperator	{ font-weight: 600; }

      /* ReSpec */
      dfn { font-style: normal ; }
      /* ReSpec */

      code           { font-family: monospace; }

      div.constraint,
      div.issue,

      div.exampleInner pre { margin-left: 1em;
                             margin-top: 0em; margin-bottom: 0em}
      div.exampleOuter {border: 4px double gray;
                        margin: 0em; padding: 0em}
      div.exampleInner { background-color: #d5dee3;
                         border-top-width: 4px;
                         border-top-style: double;
                         border-top-color: #d3d3d3;
                         border-bottom-width: 4px;
                         border-bottom-style: double;
                         border-bottom-color: #d3d3d3;
                         padding: 4px; margin: 0em }
      div.exampleWrapper { margin: 4px }
      div.exampleHeader { font-weight: bold;
                          margin: 4px}

      @media print	{ .defn { margin: 1em 1em 1em 1em ; } }

      @media (max-width: 850px) {
        table th, table td { font-size: 12px; padding: 3px 4px;}
        .result table tr td:nth-child(2n), .result table  tr th:nth-child(2n) { overflow-wrap: anywhere; min-width: 90px; }
        div.result { overflow-x: scroll; width: fit-content; max-width: 100%; }
        pre.query	{ margin: 1em 1em 1em 0em; }
    }                   
      @media (max-width: 767px) {
        table { word-break: normal; overflow-wrap: anywhere; }
        .FAndOTable { overflow-x: scroll; display: block; max-width: 100% }
        .grammarTable { overflow-x: scroll; }
        .grammarTable table tr td:last-child { overflow-wrap: anywhere!important; }
      }
    </style>
  </head>
  <body>
    <section id="abstract">
      <h2>Abstract</h2>
      <p>
        RDF is a directed, labeled graph data model for representing information in the
        Web. This specification defines the syntax and semantics of the SPARQL Query Language for
        RDF. SPARQL can be used to express queries across diverse data sources, whether the data is
        stored natively as RDF or viewed as RDF via middleware. SPARQL contains capabilities for
        querying required and optional graph patterns along with their conjunctions and
        disjunctions. SPARQL also supports aggregation, subqueries, negation, creating values by
        expressions, extensible value testing, and constraining queries by source RDF graph. The results
        of SPARQL queries can be result sets or RDF graphs.
      </p>
    </section>

    <section id="sotd" class="introductory updateable-rec">
      <p>
        This specification is published by the
        <a href="https://www.w3.org/groups/wg/rdf-star">RDF Star Working Group</a> as part of the
        update of specifications for format and errata.
      </p>

      <section id="related" data-include="common/sparql-related.html"></section>
    </section>

    <!-- BODY -->
    <section id="introduction">
      <h2>Introduction</h2>
      <p>
        RDF is a directed, labeled graph data model for representing information in the Web. RDF is
        often used to represent, among other things, personal information, social networks, metadata
        about digital artifacts, as well as to provide a means of integration over disparate sources of
        information. This specification defines the syntax and semantics of the SPARQL Query Language
        for RDF.
      </p>
      <p>
        The SPARQL Query Language for RDF is designed to meet the use cases and
        requirements identified by the RDF Data Access Working Group in [[RDF-DAWG-UC]],
        the SPARQL 1.1 Working Group in [[SPARQL-FEATURES]], and the RDF-star Working Group.
      </p>
      <section id="docOutline">
        <h3>Document Outline</h3>
        <p>
          Unless otherwise noted in the section heading, all sections and appendices in this
          document are normative.
        </p>
        <p>
          This section of the document, <a href="#introduction">section 1</a>, introduces the SPARQL
          Query Language specification. It presents the organization of this specification document and
          the conventions used throughout the specification.
        </p>
        <p>
          <a href="#basicpatterns">Section 2</a> of the specification introduces the SPARQL query
          language itself via a series of example queries and query results. 
          <a href="#termConstraint">Section 3</a> continues the introduction of the SPARQL query language with
          more examples that demonstrate SPARQL's ability to express constraints on the RDF terms that
          appear in a query's results.
        </p>
        <p>
          <a href="#sparqlSyntax">Section 4</a> presents details of the SPARQL query language's
          syntax. It is a companion to the full grammar of the language and defines how grammatical
          constructs represent IRIs, blank nodes, literals, and variables. Section 4 also defines the
          meaning of several grammatical constructs that serve as syntactic sugar for more verbose
          expressions.
        </p>
        <p>
          <a href="#GraphPattern">Section 5</a> introduces basic graph patterns and group graph
          patterns, the building blocks from which more complex SPARQL query patterns are constructed.
          Sections 6, 7, and 8 present constructs that combine SPARQL graph patterns into larger graph
          patterns. In particular, <a href="#optionals">Section 6</a> introduces the ability to make
          portions of a query optional; <a href="#alternatives">Section 7</a> introduces the ability to
          express the disjunction of alternative graph patterns; and <a href="#negation">Section 8</a>
          introduces patterns to test for the absense of information.
        </p>
        <p>
          <a href="#propertypaths">Section 9</a> adds property paths to graph pattern matching,
          giving a compact representation of queries and also the ability to match arbitrary length
          paths in the graph.
        </p>
        <p>
          <a href="#assignment">Section 10</a> describes the forms of assignment possible
          in SPARQL.
        </p>
        <p>
          <a href="#aggregates">Sections 11</a> introduces the mechanism to group and
          aggregate results, which can be incorporated as subqueries as described
          in <a href="#subqueries">Section 12</a>.
        </p>
        <p>
          <a href="#rdfDataset">Section 13</a> introduces the ability to constrain
          portions of a query to particular source graphs. Section 13 also presents
          SPARQL's mechanism for defining the source graphs for a query.
        </p>
        <p>
          <a href="#basic-federated-query">Section 14</a> refers to the separate document
          [[[SPARQL11-FEDERATED-QUERY]]].
        </p>
        <p>
          <a href="#solutionModifiers">Section 15</a> defines the constructs that affect
          the solutions of a query by ordering, slicing, projecting, limiting, and
          removing duplicates from a sequence of solutions.
        </p>
        <p>
          <a href="#QueryForms">Section 16</a> defines the four types of SPARQL queries
          that produce results in different forms.
        </p>
        <p>
          <a href="#expressions">Section 17</a> defines SPARQL's extensible value testing
          and expression framework. It presents the functions and operators that can be
          used to constrain the values that appear in a query's results and also calculate
          new values to be returned by a query.
        </p>
        <p>
          <a href="#sparqlDefinition">Section 18</a> is a formal definition of the
          evaluation of SPARQL graph patterns and solution modifiers.
        </p>
        <p>
          <a href="#grammar">Section 19</a> contains the normative definition of the syntax for the
          SPARQL query and [[[SPARQL11-UPDATE]]] languages, as given by a grammar expressed in EBNF
          notation.
        </p>
      </section>
    
      <section id="docConventions">
        <h3>Document Conventions</h3>
        <section id="docNamespaces">
          <h4>Namespaces</h4>
          <p>In this document, examples assume the following namespace prefix definitions
            unless otherwise stated:</p>
          <div style="text-align: center;">
            <table style="border-collapse: collapse; border-color: #000000; border-spacing: 5px; border-width: 1px">
              <tbody>
                <tr>
                  <th>Prefix</th>
                  <th>IRI</th>
                </tr>
                <tr>
                  <td><code>rdf:</code></td>
                  <td><code>http://www.w3.org/1999/02/22-rdf-syntax-ns#</code></td>
                </tr>
                <tr>
                  <td><code>rdfs:</code></td>
                  <td><code>http://www.w3.org/2000/01/rdf-schema#</code></td>
                </tr>
                <tr>
                  <td><code>xsd:</code></td>
                  <td><code>http://www.w3.org/2001/XMLSchema#</code></td>
                </tr>
                <tr>
                  <td><code>fn:</code></td>
                  <td><code>http://www.w3.org/2005/xpath-functions#</code></td>
                </tr>
                <tr>
                  <td><code>sfn:</code></td>
                  <td><code>http://www.w3.org/ns/sparql#</code></td>
                </tr>
              </tbody>
            </table>
          </div>
        </section>
        <section id="docDataDesc">
          <h4>Data Descriptions</h4>
          <p>This document uses the [[[TURTLE]]] [[TURTLE]] data format to show each triple
            explicitly. Turtle allows IRIs to be abbreviated with prefixes:</p>
          <pre class="data nohighlight">
            PREFIX dc:   &lt;http://purl.org/dc/elements/1.1/&gt;
            PREFIX :     &lt;http://example.org/book/&gt;

            :book1  dc:title  "SPARQL Tutorial" .
          </pre>
        </section>
        <section id="docResultDesc">
          <h4>Result Descriptions</h4>
          <p>Result sets are illustrated in tabular form.</p>
          <div class="result">
            <div id="table39"></div>
            <table class="resultTable">
              <tbody>
                <tr>
                  <th>x</th>
                  <th>y</th>
                  <th>z</th>
                </tr>
                <tr>
                  <td>"Alice"</td>
                  <td><code>&lt;http://example/a&gt;</code></td>
                  <td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>A 'binding' is a pair (<a href="#defn_QueryVariable">variable</a>,
            <a data-cite="RDF12-CONCEPTS#dfn-rdf-term">RDF term</a>). 
            In this result set, there are three variables:
            <code>x</code>, <code>y</code> and <code>z</code> (shown as column headers). Each solution
            is shown as one row in the body of the table.&nbsp; Here, there is a single solution, in
            which variable <code>x</code> is bound to <code>"Alice"</code>, variable <code>y</code> is
            bound to <code>&lt;http://example/a&gt;</code>, and variable <code>z</code> is not bound to
            an RDF term. Variables are not required to be bound in a solution.</p>
        </section>
        <section id="docTerminology">
          <h4>Terminology</h4>
          <p>The SPARQL language includes IRIs.
            Note that all IRIs in SPARQL queries are absolute; they may or may not include a fragment
            identifier [[RFC3987]], section 3.1. IRIs include URIs [[RFC3986]] and URLs. The abbreviated
            forms (<a href="#QSynIRI">relative IRIs and prefixed names</a>) in the SPARQL syntax are
            resolved to produce absolute IRIs.</p>
          <p>The following terms are defined in [[[RDF12-CONCEPTS]]] [[RDF12-CONCEPTS]] and used in
            SPARQL:</p>

          <ul>
            <li>
              <a data-cite="RDF12-CONCEPTS#dfn-iri">IRI</a>
            </li>
            <li>
              <a data-cite="RDF12-CONCEPTS#dfn-literal">literal</a>
            </li>
            <li>
              <a data-cite="RDF12-CONCEPTS#dfn-lexical-form">lexical form</a>
            </li>
            <li>
              <a data-cite="RDF12-CONCEPTS#dfn-language-tag">language tag</a>
            </li>
            <li>
              <!-- Resolve clash with i18-glossery --> 
              <a data-cite="RDF12-CONCEPTS#dfn-base-direction" class="lint-ignore">base direction</a> 
            </li>
            <li>
              <a data-cite="RDF12-CONCEPTS#dfn-datatype-iri">datatype IRI</a>
            </li>
            <li>
              <a data-cite="RDF12-CONCEPTS#dfn-blank-node">blank node</a>
            </li>
            <li>
              <a data-cite="RDF12-CONCEPTS#dfn-triple-term">triple term</a>
            </li>
            <li>
              <a data-cite="RDF12-CONCEPTS#dfn-rdf-term">RDF term</a>
            </li>
          </ul>

          <p>
            Blank node identifiers are 
            <a data-cite="?RDF12-CONCEPTS#note-bnode-id">part of
            SPARQL and RDF concrete serializations</a>.
            In this document, the syntax form "<code>_:abc</code>" is used where the
            <a data-cite="RDF12-CONCEPTS#dfn-blank-node-identifier">blank node identifier</a> 
            is <code>abc</code>.  and the "<code>_:</code>" is
            the Turtle and SPARQL syntax used to introduce blank nodes with
            identifiers.
          </p>
        </section>
      </section>
    </section>
    <section id="basicpatterns">
      <h2>Making Simple Queries (Informative)</h2>
      <p>Most forms of SPARQL query contain a set of triple patterns called a <em>basic graph
          pattern</em>. Triple patterns are like RDF triples except that each of the subject, predicate
        and object may be a variable. A basic graph pattern <em>matches</em> a subgraph of the RDF data
        when an <a data-cite="RDF12-CONCEPTS#dfn-rdf-term">RDF term</a> from that subgraph may be substituted for the
        variables and the result is RDF graph equivalent to the subgraph.</p>
      <section id="WritingSimpleQueries">
        <h3>Writing a Simple Query</h3>
        <p>The example below shows a SPARQL query to find the title of a book from the given data
          graph. The query consists of two parts: the <code>SELECT</code> clause identifies the
          variables to appear in the query results, and the <code>WHERE</code> clause provides the
          basic graph pattern to match against the data graph. The basic graph pattern in this example
          consists of a single triple pattern with a single variable (<code>?title</code>) in the
          object position.</p>
        <div class="exampleGroup">
          <p>Data:</p>
          <pre class="data nohighlight">
            &lt;http://example.org/book/book1&gt; &lt;http://purl.org/dc/elements/1.1/title&gt; "SPARQL Tutorial" .</pre>
          <div class="queryGroup">
            <p>Query:</p>
            <pre class="query nohighlight">
SELECT ?title
WHERE
{
    &lt;http://example.org/book/book1&gt; &lt;http://purl.org/dc/elements/1.1/title&gt; ?title .
}
</pre>
            <p>This query, on the data above, has one solution:</p>
            <p>Query Result:</p>
            <div class="result">
              <div id="table109"></div>
              <table class="resultTable">
                <tbody>
                  <tr>
                    <th>title</th>
                  </tr>
                  <tr>
                    <td>"SPARQL Tutorial"</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>
      </section>
      <section id="MultipleMatches">
        <h3>Multiple Matches</h3>
        <p>The result of a query is a <a href="#defn_sparqlSolutionSequence">solution sequence</a>,
          corresponding to the ways in which the query's graph pattern matches the data. There may be
          zero, one or multiple solutions to a query.</p>
        <p>Data:</p>
        <div class="exampleGroup">
<pre class="data nohighlight">PREFIX foaf:  &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a  foaf:name   "Johnny Lee Outlaw" .
_:a  foaf:mbox   &lt;mailto:jlow@example.com&gt; .
_:b  foaf:name   "Peter Goodguy" .
_:b  foaf:mbox   &lt;mailto:peter@example.org&gt; .
_:c  foaf:mbox   &lt;mailto:carol@example.org&gt; .
</pre>
          <p>Query:</p>
          <div class="queryGroup">
            <pre class="query nohighlight">
PREFIX foaf:   &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name ?mbox
WHERE
{ ?x foaf:name ?name .
  ?x foaf:mbox ?mbox }
</pre>
            <p>Query Result:</p>
            <div class="result">
              <table class="resultTable">
                <tbody>
                  <tr>
                    <th>name</th>
                    <th>mbox</th>
                  </tr>
                  <tr>
                    <td>"Johnny Lee Outlaw"</td>
                    <td>&lt;mailto:jlow@example.com&gt;</td>
                  </tr>
                  <tr>
                    <td>"Peter Goodguy"</td>
                    <td>&lt;mailto:peter@example.org&gt;</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>
        <p>Each solution gives one way in which the selected variables can be bound to RDF terms so
          that the query pattern matches the data. The result set gives all the possible solutions. In
          the above example, the following two subsets of the data provided the two matches.</p>
        <pre class="data nohighlightExcerpt"> 
_:a foaf:name  "Johnny Lee Outlaw" .
_:a foaf:box   &lt;mailto:jlow@example.com&gt; .
</pre>
        <pre class="data nohighlightExcerpt"> 
_:b foaf:name  "Peter Goodguy" .
_:b foaf:box   &lt;mailto:peter@example.org&gt; .
</pre>
        <p>This is a <a href="#BGPsparql">basic graph pattern match</a>; all the variables used in
          the query pattern must be bound in every solution.</p>
      </section>
      <section id="matchingRDFLiterals">
        <h3>Matching RDF Literals</h3>
        <p>The data below contains three RDF literals:</p>
        <div class="exampleGroup">
          <pre class="data nohighlight">
PREFIX dt:   &lt;http://example.org/datatype#&gt;
PREFIX ns:   &lt;http://example.org/ns#&gt;
PREFIX :     &lt;http://example.org/ns#&gt;
PREFIX xsd:  &lt;http://www.w3.org/2001/XMLSchema#&gt;

:x   ns:p     "cat"@en .
:y   ns:p     "42"^^xsd:integer .
:z   ns:p     "abc"^^dt:specialDatatype .
</pre>
          <p>Note that, in Turtle, <code>"cat"@en</code> is an RDF literal with a lexical form "cat"
            and a language tag "en"; <code>"42"^^xsd:integer</code> is a literal with the
            datatype <code>http://www.w3.org/2001/XMLSchema#integer</code>; and
            <code>"abc"^^dt:specialDatatype</code> is a literal with the datatype
            <code>http://example.org/datatype#specialDatatype</code>.</p>
        </div>
        <p>This RDF data is the data graph for the query examples in sections 2.3.1â€“2.3.3.</p>
        <section id="matchLangTags">
          <h4>Matching Literals with Language Tags</h4>
          <p>Language tags in SPARQL are expressed using <code>@</code> and the language tag, as
            defined in [[[BCP47]]] [[BCP47]].</p>
          <p>This following query has no solution because <code>"cat"</code> is not the same RDF
            literal as <code>"cat"@en</code>:</p>
          <div class="queryGroup">
            <pre class="query nohighlight">SELECT ?v WHERE { ?v ?p "cat" }</pre>
            <div class="result">
              <table class="resultTable">
                <tbody>
                  <tr>
                    <th>&nbsp;&nbsp; v&nbsp;&nbsp;&nbsp;&nbsp;</th>
                  </tr>
                </tbody>
              </table>
            </div>
            <p>but the query below will find a solution where variable <code>v</code> is bound to
              <code>:x</code> because the language tag is specified and matches the given data:</p>
            <pre class="query nohighlight">SELECT ?v WHERE { ?v ?p "cat"@en }
            </pre>
            <div class="result">
              <table class="resultTable">
                <tbody>
                  <tr>
                    <th>v</th>
                  </tr>
                  <tr>
                    <td>&lt;http://example.org/ns#x&gt;</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </section>
        <section id="matchNumber">
          <h4>Matching Literals with Numeric Types</h4>
          <p>Integers in a SPARQL query indicate an RDF literal with the datatype
            <code>xsd:integer</code>. For example: <code>42</code> is a shortened form of&nbsp;
            <code>"42"^^&lt;http://www.w3.org/2001/XMLSchema#integer&gt;</code>.</p>
          <p>The pattern in the following query has a solution with variable <code>v</code> bound to
            <code>:y</code>.</p>
          <div class="queryGroup">
            <pre class="query nohighlight">SELECT ?v WHERE { ?v ?p 42 }
            </pre>
            <div class="result">
              <div id="table60"></div>
              <table class="resultTable">
                <tbody>
                  <tr>
                    <th>v</th>
                  </tr>
                  <tr>
                    <td>&lt;http://example.org/ns#y&gt;</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
          <p><a href="#QSynLiterals">Section 4.1.2</a> defines SPARQL shortened forms for
            <code>xsd:float</code> and <code>xsd:double</code>.</p>
        </section>
        <section id="matchArbDT">
          <h4>Matching Literals with Arbitrary Datatypes</h4>
          <p>The following query has a solution with variable <code>v</code> bound to
            <code>:z</code>. The query processor does not have to have any understanding of the values
            in the space of the datatype. Because the lexical form and datatype IRI both match, the
            literal matches.</p>
          <div class="queryGroup">
            <pre class="query nohighlight">
              SELECT ?v WHERE { ?v ?p "abc"^^&lt;http://example.org/datatype#specialDatatype&gt; }
            </pre>
            <div class="result">
              <div id="table61"></div>
              <table class="resultTable">
                <tbody>
                  <tr>
                    <th>v</th>
                  </tr>
                  <tr>
                    <td>&lt;http://example.org/ns#z&gt;</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </section>
      </section>
      <section id="BlankNodesInResults">
        <h3>Blank Node Identifiers in Query Results</h3>
        <p>
          Query results can contain blank nodes. Blank nodes in the example
          result sets in this document are written in the form "_:" followed by a
          <a data-cite="RDF12-CONCEPTS#dfn-blank-node-identifier">blank node identifier</a>.
        </p>
        <p>Blank node identifiers are scoped to a result set (see "[[[RDF-SPARQL-XMLRES]]]" and
          "[[[SPARQL11-RESULTS-JSON]]]") or, for the <code>CONSTRUCT</code> query form, the result
          graph. Use of the same identifier within a result set indicates the same blank node.</p>
        <div class="exampleGroup">
          Data:
<pre class="data nohighlight">
PREFIX foaf:  &lt;http://xmlns.com/foaf/0.1/&gt;

_:a  foaf:name   "Alice" .
_:b  foaf:name   "Bob" .
</pre>
          <div class="queryGroup">
            Query:
<pre class="query nohighlight">
PREFIX foaf:   &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?x ?name
WHERE  { ?x foaf:name ?name }
</pre>
            <div class="result">
              <div id="table56"></div>
              <table class="resultTable">
                <tbody>
                  <tr>
                    <th>x</th>
                    <th>name</th>
                  </tr>
                  <tr>
                    <td>_:c</td>
                    <td>"Alice"</td>
                  </tr>
                  <tr>
                    <td>_:d</td>
                    <td>"Bob"</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
          <p>
            The results above could equally be given with different blank node
            identifiers because the blank node identifiers in the results only
            indicate whether RDF terms in the solutions are the same or
            different.
          </p>
          <div class="result">
            <div id="table57"></div>
            <table class="resultTable">
              <tbody>
                <tr>
                  <th>x</th>
                  <th>name</th>
                </tr>
                <tr>
                  <td>_:r</td>
                  <td>"Alice"</td>
                </tr>
                <tr>
                  <td>_:s</td>
                  <td>"Bob"</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
        <p>
          These two results have the same information: the blank nodes used to
          match the query are different in the two solutions. There need not be
          any relation between a blank node identifier
          <code>_:a</code> in the result set and a blank node identifier
          used in the syntax for the data.
        </p>
        <p>
          An application writer should not expect blank node identifiers in a
          query to refer to a particular blank node in the data.
        </p>
      </section>
      <section id="CreatingValuesWithExpressions">
        <h3>Creating Values with Expressions</h3>
        <p>SPARQL 1.2 allows values to be created from complex expressions. The queries below show how
          the <a href="#func-concat">CONCAT</a> function can be used to concatenate first names and
          last names from FOAF data, then assign the value using an 
          <a href="#selectExpressions">expression in the <code>SELECT</code> clause</a> and also assign the
          value by using the <a href="#bind">BIND</a> form.</p>
        <div class="exampleGroup">
          Data:
          <pre class="data nohighlight">
PREFIX foaf:  &lt;http://xmlns.com/foaf/0.1/&gt;
            
_:a  foaf:givenName   "John" .
_:a  foaf:surname  "Doe" .
</pre>
          <div class="queryGroup">
            Query:
            <pre class="query nohighlight">
PREFIX foaf:   &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ( CONCAT(?G, " ", ?S) AS ?name )
WHERE  { ?P foaf:givenName ?G ; foaf:surname ?S }
</pre>
            Query:
<pre class="query nohighlight">
PREFIX foaf:   &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name
WHERE  { 
    ?P foaf:givenName ?G ; 
       foaf:surname ?S 
    BIND(CONCAT(?G, " ", ?S) AS ?name)
}
</pre>
            <div class="result">
              <div id="table59"></div>
              <table class="resultTable">
                <tbody>
                  <tr>
                    <th>name</th>
                  </tr>
                  <tr>
                    <td>"John Doe"</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>
      </section>
      <section id="constructGraph">
        <h3>Building RDF Graphs</h3>
        <p>SPARQL has several <a href="#QueryForms">query forms</a>. The <code>SELECT</code> query
          form returns variable bindings. The <code>CONSTRUCT</code> query form returns an RDF graph.
          The graph is built based on a template which is used to generate RDF triples based on the
          results of matching the graph pattern of the query.</p>
        <div class="exampleGroup">
          <p>Data:</p>
          <pre class="data nohighlight">
PREFIX org:    &lt;http://example.com/ns#&gt;

_:a  org:employeeName   "Alice" .
_:a  org:employeeId     12345 .

_:b  org:employeeName   "Bob" .
_:b  org:employeeId     67890 .
</pre>
          <div class="queryGroup">
            <p>Query:</p>
            <pre class="query nohighlight">
PREFIX foaf:   &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX org:    &lt;http://example.com/ns#&gt;

CONSTRUCT { ?x foaf:name ?name }
WHERE  { ?x org:employeeName ?name }
</pre>
            <p>Results:</p>
            <div class="result">
              <pre class="resultGraph">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
                
_:x foaf:name "Alice" .
_:y foaf:name "Bob" .
</pre>
            </div>
          </div>
          <p>which can be serialized in <a data-cite="RDF12-XML#">RDF/XML</a> as:</p>
          <div class="result">
            <pre class="resultGraph" style="text-align: left;">
&lt;rdf:RDF
   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
   xmlns:foaf="http://xmlns.com/foaf/0.1/" &gt;

  &lt;rdf:Description&gt;
    &lt;foaf:name&gt;Alice&lt;/foaf:name&gt;
  &lt;/rdf:Description&gt;
  &lt;rdf:Description&gt;
    &lt;foaf:name&gt;Bob&lt;/foaf:name&gt;
  &lt;/rdf:Description&gt;
&lt;/rdf:RDF&gt;
</pre>
          </div>
        </div>
      </section>
    </section>
    <section id="termConstraint">
      <h2>RDF Term Constraints (Informative)</h2>
      <p>Graph pattern matching produces a solution sequence, where each solution has a set of
        bindings of variables to RDF terms. SPARQL <code>FILTER</code>s restrict solutions to those for
        which the filter expression evaluates to <code>TRUE</code>.</p>
      <p>This section provides an informal introduction to SPARQL <code>FILTER</code>s; their
        semantics are defined in section '<a href="#expressions">Expressions and Testing Values</a>'
        where there is a <a href="#SparqlOps">comprehensive function library</a>. The examples in this
        section share one input graph:</p>
      <div class="exampleGroup">
        Data:
        <pre class="data nohighlight">
PREFIX dc:   &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX :     &lt;http://example.org/book/&gt;
PREFIX ns:   &lt;http://example.org/ns#&gt;

:book1  dc:title  "SPARQL Tutorial" .
:book1  ns:price  42 .
:book2  dc:title  "The Semantic Web" .
:book2  ns:price  23 .
        </pre>
      </div>
      <section id="restrictString">
        <h3>Restricting the Value of Strings</h3>
        <p>SPARQL <code>FILTER</code> functions like <code><a href="#func-regex">regex</a></code> can
          test RDF literals. <code>regex</code> matches only <a href="#func-string">string
            literals</a>. <code>regex</code> can be used to match the lexical forms of other literals by
          using the <a href="#func-str">str</a> function.</p>
        <p>Query:</p>
        <div class="queryGroup">
          <pre class="query nohighlight">
PREFIX  dc:  &lt;http://purl.org/dc/elements/1.1/&gt;
SELECT  ?title
WHERE   { 
    ?x dc:title ?title
    FILTER regex(?title, "^SPARQL") 
}
</pre>
          <p>Query Result:</p>
          <div class="result">
            <div id="table63"></div>
            <table class="resultTable">
              <tbody>
                <tr>
                  <th>title</th>
                </tr>
                <tr>
                  <td>"SPARQL Tutorial"</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
        <p>Regular expression matches may be made case-insensitive with the "<code>i</code>"
          flag.</p>
        <p>Query:</p>
        <div class="queryGroup">
          <pre class="query nohighlight">
PREFIX  dc:  &lt;http://purl.org/dc/elements/1.1/&gt;
SELECT  ?title
WHERE   { 
    ?x dc:title ?title
    FILTER regex(?title, "web", "i" ) 
}
</pre>
          <p>Query Result:</p>
          <div class="result">
            <div id="table64"></div>
            <table class="resultTable">
              <tbody>
                <tr>
                  <th>title</th>
                </tr>
                <tr>
                  <td>"The Semantic Web"</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
        <p>The regular expression language is <a data-cite="XPATH-FUNCTIONS-31#regex-syntax">defined by XQuery
            and XPath Functions and Operators</a> and is based on
          <a data-cite="XMLSCHEMA11-2#dt-regex">XML Schema Regular Expressions</a>.</p>
      </section>
      <section id="restrictNumber">
        <h3>Restricting Numeric Values</h3>
        <p>SPARQL <code>FILTER</code>s can restrict on arithmetic expressions.</p>
        <p>Query:</p>
        <div class="queryGroup">
          <pre class="query nohighlight">
PREFIX  dc:  &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX  ns:  &lt;http://example.org/ns#&gt;

SELECT  ?title ?price
WHERE   {
    ?x ns:price ?price .
    FILTER (?price &lt; 30.5)
    ?x dc:title ?title . 
}
</pre>
          <p>Query Result:</p>
          <div class="result">
            <div id="table58"></div>
            <table class="resultTable">
              <tbody>
                <tr>
                  <th>title</th>
                  <th>price</th>
                </tr>
                <tr>
                  <td>"The Semantic Web"</td>
                  <td>23</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
      </section>
      <p>By constraining the <code>price</code> variable, only <code>:book2</code> matches the query
        because only <code>:book2</code> has a price less than <code>30.5</code>, as the filter
        condition requires.</p>
      <section id="otherTermConstraints">
        <h3>Other Term Constraints</h3>
        <p>In addition to <span class="type numeric">numeric</span> types, SPARQL supports types
          <code>xsd:string</code>, <code>xsd:boolean</code> and <code>xsd:dateTime</code>
          (see <a href="#operandDataTypes">Operand Data Types</a>). Section <a href="#OperatorMapping">Operator
            Mapping</a> describes the operators and section <a href="#SparqlOps">Function Definitions</a>
          the functions that can be that can be applied to RDF terms.</p>
      </section>
    </section>
    <section id="sparqlSyntax">
      <h2>SPARQL Syntax</h2>
      <p>
        This section covers the syntax used by SPARQL for 
        <a data-cite="RDF12-CONCEPTS#dfn-rdf-term">RDF terms</a>
        and <a href="#sparqlTriplePatterns">triple patterns</a>. 
        The full grammar is given in <a href="#grammar">section 19</a>.
      </p>
      <section id="syntaxTerms">
        <h3>RDF Term Syntax</h3>
        <section id="QSynIRI">
          <h4>Syntax for IRIs</h4>
          <p>The <a href="#riri">iri</a> production designates the set of IRIs [[RFC3987]]; IRIs are
            a generalization of URIs [[RFC3986]] and are fully compatible with URIs and URLs. The
            <a href="#rPrefixedName">PrefixedName</a> production designates a prefixed name. The
            mapping from a prefixed name to an IRI is described below. IRI references (relative or
            absolute IRIs) are designated by the <a href="#rIRIREF">IRIREF</a> production, where the
            '&lt;' and '&gt;' delimiters do not form part of the IRI reference. Relative IRIs match the
            <code>irelative-ref</code> reference in section 2.2 ABNF for IRI References and IRIs in
            [[RFC3987]] and are resolved to IRIs as described below.</p>
          <section id="prefNames">
            <h5>Prefixed Names</h5>
            <p>The <code>PREFIX</code> keyword associates a prefix label with an IRI. A prefixed name
              is a prefix label and a local part, separated by a colon "<code>:</code>". A prefixed
              name is mapped to an IRI by concatenating the IRI associated with the prefix and the
              local part. The prefix label or the local part may be empty. 
              Note that <a href="#rPN_LOCAL">SPARQL local names</a> allow leading digits while 
              <a data-cite="XML-NAMES11#NT-LocalPart">XML local names</a> do not. 
              <a href="#rPN_LOCAL">SPARQL local names</a> also allow the non-alphanumeric
              characters allowed in IRIs via backslash
              character escapes (e.g. <code>ns:id\=123</code>). <a href="#rPN_LOCAL">SPARQL local
                names</a> have more syntactic restrictions than 
              <a data-cite="CURIE#">CURIE</a>s.</p>
          </section>
          <section id="relIRIs">
            <h5>Relative IRIs</h5>
            <p>Relative IRIs are combined with base IRIs as per [[[RFC3986]]] [[RFC3986]] using only
              the basic algorithm in section 5.2. Neither Syntax-Based Normalization nor Scheme-Based
              Normalization (described in sections 6.2.2 and 6.2.3 of [[RFC3986]]) are performed.
              Characters additionally allowed in IRI references are treated in the same way that
              unreserved characters are treated in URI references, per section 6.5 of [[[RFC3987]]]
              [[RFC3987]].</p>
            <p>The <code>BASE</code> keyword defines the Base IRI used to resolve relative IRIs per
              [[RFC3986]] section 5.1.1, "Base URI Embedded in Content". Section 5.1.2, "Base URI from
              the Encapsulating Entity" defines how the Base IRI may come from an encapsulating
              document, such as a SOAP envelope with an xml:base directive or a mime multipart document
              with a Content-Location header. The "Retrieval URI" identified in 5.1.3, Base "URI from
              the Retrieval URI", is the URL from which a particular SPARQL query was retrieved. If
              none of the above specifies the Base URI, the default Base URI (section 5.1.4, "Default
              Base URI") is used.</p>
            <p>The following fragments are some of the different ways to write the same IRI:</p>
            <pre class="data nohighlight">&lt;http://example.org/book/book1&gt;</pre>
            <pre class="data nohighlight">BASE &lt;http://example.org/book/&gt;
&lt;book1&gt;</pre>
            <pre class="data nohighlight">PREFIX book: &lt;http://example.org/book/&gt;
book:book1</pre>
          </section>
        </section>
        <section id="QSynLiterals">
          <h4>Syntax for Literals</h4>
          <p>The general syntax for literals is a string (enclosed in either double quotes,
            <code>"..."</code>, or single quotes, <code>'...'</code>), with either an optional language
            tag (introduced by <code>@</code>) or an optional datatype IRI or prefixed name (introduced
            by <code>^^</code>).</p>
          <p>As a convenience, integers can be written directly (without quotation marks and an
            explicit datatype IRI) and are interpreted as literals with datatype
            <code>xsd:integer</code>; decimal numbers for which there is '.' in the number but no
            exponent are interpreted as <code>xsd:decimal</code>; and numbers with exponents are
            interpreted as <code>xsd:double</code>. Values of type <code>xsd:boolean</code> can also be
            written as <code>true</code> or <code>false</code>.</p>
          <p>To facilitate writing literal values which themselves contain quotation marks or which
            are long and contain newline characters, SPARQL provides an additional quoting construct in
            which literals are enclosed in three single- or double-quotation marks.</p>
          <p>Examples of literal syntax in SPARQL include:</p>
          <ul>
            <li><code>"chat"</code></li>
            <li><code>'chat'@fr</code> with language tag "fr"</li>
            <li><code>"xyz"^^&lt;http://example.org/ns/userDatatype&gt;</code></li>
            <li><code>"abc"^^appNS:appDataType</code></li>
            <li><code>'''The librarian said, "Perhaps you would enjoy 'War and
                Peace'."'''</code></li>
            <li><code>1</code>, which is the same as <code>"1"^^xsd:integer</code></li>
            <li><code>1.3</code>, which is the same as <code>"1.3"^^xsd:decimal</code></li>
            <li><code>1.300</code>, which is the same as <code>"1.300"^^xsd:decimal</code></li>
            <li><code>1.0e6</code>, which is the same as <code>"1.0e6"^^xsd:double</code></li>
            <li><code>true</code>, which is the same as <code>"true"^^xsd:boolean</code></li>
            <li><code>false</code>, which is the same as <code>"false"^^xsd:boolean</code></li>
          </ul>
          <p>A token matching one of the productions
            <a href="#rINTEGER">INTEGER</a>,
            <a href="#rDECIMAL">DECIMAL</a>,
            <a href="#rDOUBLE">DOUBLE</a> or 
            <a href="#rBooleanLiteral">BooleanLiteral</a> is equivalent to a literal
            with the lexical value of the token and the corresponding datatype 
            (<code>xsd:integer</code>, <code>xsd:decimal</code>, 
            <code>xsd:double</code>, or <code>xsd:boolean</code>).
          </p>
        </section>
        <section id="QSynVariables">
          <h4>Syntax for Query Variables</h4>
          <p>A query variable is marked by the use of either "?" or "$"; the "?" or "$" is not part
            of the variable name. In a query, <code>$abc</code> and <code>?abc</code> identify the same
            variable. The <a href="#rVARNAME">possible names</a> for variables are given in the
            <a href="#grammar">SPARQL grammar</a>.</p>
        </section>
        <section id="QSynBlankNodes">
          <h4>Syntax for Blank Nodes</h4>
          <p>
            <a data-cite="RDF12-CONCEPTS#dfn-blank-node">Blank nodes</a> in
            graph patterns act as variables, not as references to specific blank
            nodes in the data being queried.  Blank nodes are indicated by
            either the identifier form, such as "<code>_:abc</code>", or an
            abbreviation form using "<code>[]</code>" or "<code>[...]</code>".
          </p>
          <p>
            Blank node identifiers are written as "<code>_:abc</code>" for a
            blank node with identifier "<code>abc</code>".  The same blank node
            identifier cannot be used in two different basic graph patterns in
            the same query.
          </p>
          <p>
            A blank node that is used in only one place in the query syntax can be
            indicated with <code>[]</code>. A unique blank node will be used to
            form the triple pattern. 
          </p>
          <p>
            The <code>[:p :v]</code> construct can be used to create triple
            patterns with a  unique blank node as the subject of contained 
            predicate-object pairs.
          </p>
          <p>The following two forms</p>
          <pre class="query nohighlight">
[ :p "v" ] .
          </pre>
          <pre class="query nohighlight">
[] :p "v" .
          </pre>
          <p>allocate a unique blank node (here, illustrated by
            "<code>_:b57</code>") and both are equivalent to writing:</p>
          <pre class="query nohighlight">
_:b57 :p "v" .
          </pre>
          <p>The allocated blank node can be used as the subject or object of
            further triple patterns. For example, as a subject:</p>
          <pre class="query nohighlight">[ :p "v" ] :q "w" .
          </pre>
          <p>which is equivalent to the two triples:</p>
          <pre class="query nohighlight">
_:b57 :p "v" .
_:b57 :q "w" .
          </pre>
          <p>and as an object:</p>
          <pre class="query nohighlight">
:x :q [ :p "v" ] .
          </pre>
          <p>which is equivalent to the two triples:</p>
          <pre class="query nohighlight">
:x  :q _:b57 .
_:b57 :p "v" .
          </pre>
          <p>Abbreviated blank node syntax can be combined with other
            abbreviations for <a href="#predObjLists">common subjects</a>
            and <a href="#objLists">common predicates</a>.</p>
          <pre class="query nohighlight">
[ foaf:name  ?name ;
  foaf:mbox  &lt;mailto:alice@example.org&gt; ]
          </pre>
          <p>This is the same as writing the following basic graph pattern using
            a blank node identifer instead.</p>
          <pre class="query nohighlight">
_:b18  foaf:name  ?name .
_:b18  foaf:mbox  &lt;mailto:alice@example.org&gt; .
          </pre>
        </section>
      </section>
      <section id="QSynTriples">
        <h3>Syntax for Triple Patterns</h3>
        <p><a href="#defn_TriplePattern">Triple Patterns</a> are written as subject, predicate and
          object; there are abbreviated ways of writing some common triple pattern constructs.</p>
        <p>The following examples express the same query:</p>
        <pre class="query nohighlight">
PREFIX  dc: &lt;http://purl.org/dc/elements/1.1/&gt;
SELECT  ?title
WHERE   { &lt;http://example.org/book/book1&gt; dc:title ?title }  
</pre>
        <pre class="query nohighlight">
PREFIX  dc: &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX  : &lt;http://example.org/book/&gt;

SELECT  $title
WHERE   { :book1  dc:title  $title }
</pre>
        <pre class="query nohighlight">
BASE    &lt;http://example.org/book/&gt;
PREFIX  dc: &lt;http://purl.org/dc/elements/1.1/&gt;

SELECT  $title
WHERE   { &lt;book1&gt;  dc:title  ?title }
</pre>
        <section id="predObjLists">
          <h4>Predicate-Object Lists</h4>
          <p>Triple patterns with a common subject can be written so that the subject is only written
            once and is used for more than one triple pattern by employing the "<code>;</code>"
            notation.</p>
          <pre class="query nohighlight">
?x  foaf:name  ?name ;
foaf:mbox  ?mbox .
          </pre>
          <p>This is the same as writing the triple patterns:</p>
          <pre class="query nohighlight"> 
?x  foaf:name  ?name .
?x  foaf:mbox  ?mbox .
          </pre>
        </section>
        <section id="objLists">
          <h4>Object Lists</h4>
          <p>If triple patterns share both subject and predicate, the objects may be separated by
            "<code>,</code>".</p>
          <pre class="query nohighlight">
?x foaf:nick  "Alice" , "Alice_" .
          </pre>
          <p>is the same as writing the triple patterns:</p>
          <pre class="query nohighlight">
?x  foaf:nick  "Alice" .
?x  foaf:nick  "Alice_" .
          </pre>
          <p>Object lists can be combined with predicate-object lists:</p>
          <pre class="query nohighlight">
?x  foaf:name ?name ; foaf:nick  "Alice" , "Alice_" .
          </pre>
          <p>is equivalent to:</p>
          <pre class="query nohighlight">
?x  foaf:name  ?name .
?x  foaf:nick  "Alice" .
?x  foaf:nick  "Alice_" .
          </pre>
        </section>
        <section id="collections">
          <h4>RDF Collections</h4>
          <p><a data-cite="RDF12-SEMANTICS#collections">RDF collections</a> can be written in triple
            patterns using the syntax "(element1 element2 ...)". The form "<code>()</code>" is an
            alternative for the IRI 
            <code><a href="http://www.w3.org/1999/02/22-rdf-syntax-ns#nil">http://www.w3.org/1999/02/22-rdf-syntax-ns#nil</a></code>.
            When used with collection elements, such as <code>(1 ?x 3 4)</code>, triple patterns with
            blank nodes are allocated for the collection. The blank node at the head of the collection
            can be used as a subject or object in other triple patterns. The blank nodes allocated by
            the collection syntax do not occur elsewhere in the query.</p>
          <pre class="query nohighlight">
(1 ?x 3 4) :p "w" .
          </pre>
          <p>is syntactic sugar for (noting that <code>b0</code>, <code>b1</code>, <code>b2</code>
            and <code>b3</code> do not occur anywhere else in the query):</p>
          <pre class="query nohighlight">
_:b0  rdf:first  1 ;
      rdf:rest   _:b1 .
_:b1  rdf:first  ?x ;
      rdf:rest   _:b2 .
_:b2  rdf:first  3 ;
      rdf:rest   _:b3 .
_:b3  rdf:first  4 ;
      rdf:rest   rdf:nil .
_:b0  :p         "w" . 
          </pre>
          <p>RDF collections can be nested and can involve other syntactic forms:</p>
          <pre class="query nohighlight">(1 [:p :q] ( 2 ) ) .
          </pre>
          <p>is syntactic sugar for:</p>
          <pre class="query nohighlight">
_:b0  rdf:first  1 ;
      rdf:rest   _:b1 .
_:b1  rdf:first  _:b2 .
_:b2  :p         :q .
_:b1  rdf:rest   _:b3 .
_:b3  rdf:first  _:b4 .
_:b4  rdf:first  2 ;
      rdf:rest   rdf:nil .
_:b3  rdf:rest   rdf:nil .
          </pre>
        </section>
        <section id="abbrevRdfType">
          <h4>rdf:type</h4>
          <p>The keyword "<code>a</code>" can be used as a predicate in a triple pattern and is an
            alternative for the IRI&nbsp; 
            <code><a href="http://www.w3.org/1999/02/22-rdf-syntax-ns#type">http://www.w3.org/1999/02/22-rdf-syntax-ns#type</a></code>.
            This keyword is case-sensitive.</p>
          <pre class="query nohighlight">  
?x  a  :Class1 .
[ a :appClass ] :p "v" .
          </pre>
          <p>is syntactic sugar for:</p>
          <pre class="query nohighlight">
?x    rdf:type  :Class1 .
_:b0  rdf:type  :appClass .
_:b0  :p        "v" .
          </pre>
        </section>
      </section>
      <section id="syntaxVersionAnnouncement">
        <h3>Version Announcement</h3>
        <p>To cope with the language evolution of SPARQL,
          the <a href="#rVersionDecl"><code>VERSION</code></a> directive can be used.
          When writing SPARQL queries with new features such as
          <a data-cite="RDF12-CONCEPTS#dfn-triple-term">triple terms</a>
          or <a href="#func-triple-terms">functions on triple terms</a>,
          authors MAY announce the use of the new syntax forms by including this directive.
        </p>
        <pre class="query nohighlight">
              VERSION "1.2"
              PREFIX : &lt;http://example/&gt;
              PREFIX rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;

              SELECT ?s ?date {
                  ?s ?p ?o .
                  BIND( &lt;&lt;( ?s ?p ?o )&gt;&gt; AS ?tt )
                  :myreifier rdf:reifies ?tt .
                  :myreifier :tripleAdded ?date .
              }
</pre>
      </section>
    </section>
    <section id="GraphPattern">
      <h2>Graph Patterns</h2>
      <p>SPARQL is based around graph pattern matching. More complex graph patterns can be formed by
        combining smaller patterns in various ways:</p>
      <ul>
        <li>
          <a href="#BasicGraphPatterns">Basic Graph Patterns</a>, where a set of triple patterns must
          match
        </li>
        <li>
          <a href="#GroupPatterns">Group Graph Pattern</a>, where a set of graph patterns must all
          match
        </li>
        <li>
          <a href="#optionals">Optional Graph patterns</a>, where additional patterns may extend the
          solution
        </li>
        <li>
          <a href="#alternatives">Alternative Graph Pattern</a>, where two or more possible patterns
          are tried
        </li>
        <li>
          <a href="#queryDataset">Patterns on Named Graphs</a>, where patterns are matched against
          named graphs
        </li>
      </ul>
      <p>In this section we describe the two forms that combine patterns by conjunction: basic graph
        patterns, which combine triples patterns, and group graph patterns, which combine all other
        graph patterns.</p>
      <p>The outer-most graph pattern in a query is called the query pattern. It is grammatically
        identified by <code>GroupGraphPattern</code> in</p>
      <div class="grammarExtract">
        <div class="grammarTable">
          <table>
            <tbody>
              <tr style="vertical-align: baseline">
                <td><code>[17]&nbsp;&nbsp;</code></td>
                <td><code><a href="#rWhereClause">WhereClause</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'WHERE'</span>? <a href="#rGroupGraphPattern">GroupGraphPattern</a></code></td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
      <section id="BasicGraphPatterns">
        <h3>Basic Graph Patterns</h3>
        <p>Basic graph patterns are sets of triple patterns. SPARQL graph pattern matching is defined
          in terms of combining the results from matching basic graph patterns.</p>
        <p>A sequence of triple patterns, with optional filters, comprises a single basic graph
          pattern. Any other graph pattern terminates a basic graph pattern.</p>
        <section id="bgpBNodeIdentifiers">
          <h4>Blank Node Identifiers</h4>
          <p>When using blank nodes of the form <code>_:abc</code>, identifiers for blank nodes are
            scoped to the basic graph pattern. A 
            <a data-cite="RDF12-CONCEPTS#dfn-blank-node-identifier">blank node identifier</a>
            can only be used in one basic graph pattern in any query.</p>
        </section>
        <section id="bgpExtend">
          <h4>Extending Basic Graph Pattern Matching</h4>
          <p>SPARQL evaluates basic graph patterns using subgraph matching, which is defined for
            simple entailment. SPARQL can be extended to other forms of entailment given
            <a href="#sparqlBGPExtend">certain conditions</a> as described below. The document
            [[[SPARQL11-ENTAILMENT]]] describes several specific entailment regimes.</p>
        </section>
      </section>
      <section id="GroupPatterns">
        <h3>Group Graph Patterns</h3>
        <p>In a SPARQL query string, a group graph pattern is delimited with braces: <code>{}</code>.
          For example, this query's query pattern is a group graph pattern of one basic graph
          pattern.</p>
        <div class="exampleGroup">
          <div class="queryGroup">
            <pre class="query nohighlight">
PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name ?mbox
WHERE  {
    ?x foaf:name ?name .
    ?x foaf:mbox ?mbox .
}
            </pre>
          </div>
        </div>
        <div class="exampleGroup">
          <div class="queryGroup">
            The same solutions would be obtained from a query that grouped the triple patterns into
            two basic graph patterns. For example, the query below has a different structure but
            would yield the same solutions as the previous query:
            <pre class="query nohighlight">
PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name ?mbox
WHERE  { 
   { ?x foaf:name ?name . }
   { ?x foaf:mbox ?mbox . }
}
</pre>
          </div>
        </div>
        <section id="emptyGroupPattern">
          <h4>Empty Group Pattern</h4>
          <p>The group pattern:</p>
          <pre class="query nohighlight">{ }</pre>
          <p>matches any graph (including the empty graph) with one solution that does not bind any
            variables. For example:</p>
          <pre class="query nohighlight">
SELECT ?x
WHERE {}
          </pre>
          <p>matches with one solution in which variable <code>x</code> is not bound.</p>
        </section>
        <section id="scopeFilters">
          <h4>Scope of Filters</h4>
          <p>A constraint, expressed by the keyword <code>FILTER</code>, is a restriction on
            solutions over the whole group in which the filter appears. The following patterns all have
            the same solutions:</p>
          <div class="exampleGroup">
            <div class="queryGroup">
              <pre class="query nohighlight">
{  ?x foaf:name ?name .
   ?x foaf:mbox ?mbox .
   FILTER regex(?name, "Smith")
}
              </pre>
            </div>
          </div>
          <div class="exampleGroup">
            <div class="queryGroup">
              <pre class="query nohighlight">
{  FILTER regex(?name, "Smith")
   ?x foaf:name ?name .
   ?x foaf:mbox ?mbox .
}
              </pre>
            </div>
          </div>
          <div class="exampleGroup">
            <div class="queryGroup">
              <pre class="query nohighlight">
{  ?x foaf:name ?name .
   FILTER regex(?name, "Smith")
   ?x foaf:mbox ?mbox .
}
              </pre>
            </div>
          </div>
        </section>
        <section id="groupExamples">
          <h4>Group Graph Pattern Examples</h4>
          <div class="exampleGroup">
            <div class="queryGroup">
              <pre class="query nohighlight">
{ ?x foaf:name ?name .
  ?x foaf:mbox ?mbox .
}
</pre>
            </div>
          </div>
          <p>is a group of one basic graph pattern and that basic graph pattern consists of two
            triple patterns.</p>
          <div class="exampleGroup">
            <div class="queryGroup">
              <pre class="query nohighlight">
{
  ?x foaf:name ?name . FILTER regex(?name, "Smith")
  ?x foaf:mbox ?mbox .
}
</pre>
            </div>
          </div>
          <p>is a group of one basic graph pattern and a filter, and that basic graph pattern
            consists of two triple patterns; the filter does not break the basic graph pattern into two
            basic graph patterns.</p>
          <div class="exampleGroup">
            <div class="queryGroup">
              <pre class="query nohighlight">
{
  ?x foaf:name ?name .
  {}
  ?x foaf:mbox ?mbox .
}
</pre>
            </div>
          </div>
          <p>is a group of three elements, a basic graph pattern of one triple pattern, an empty
            group, and another basic graph pattern of one triple pattern.</p>
        </section>
      </section>
    </section>
    <section id="optionals">
      <h2>Including Optional Values</h2>
      <p>Basic graph patterns allow applications to make queries where the entire query pattern must
        match for there to be a solution. For every solution of a query containing only group graph
        patterns with at least one basic graph pattern, every variable is bound to an RDF Term in a
        solution. However, regular, complete structures cannot be assumed in all RDF graphs. It is
        useful to be able to have queries that allow information to be added to the solution where the
        information is available, but do not reject the solution because some part of the query pattern
        does not match. Optional matching provides this facility: if the optional part does not match,
        it creates no bindings but does not eliminate the solution.</p>
      <section id="OptionalMatching">
        <h3>Optional Pattern Matching</h3>
        <p>Optional parts of the graph pattern may be specified syntactically with the OPTIONAL
          keyword applied to a graph pattern:</p>
        <pre class="query nohighlight">
<i>pattern</i> OPTIONAL { <i>pattern</i> }
        </pre>
        <div class="exampleGroup">
          <p>The syntactic form:</p>
          <pre class="query nohighlight">
{ OPTIONAL { <i>pattern</i> } }
          </pre>
          <p>is equivalent to:</p>
          <pre class="query nohighlight">
{ { } OPTIONAL { <i>pattern</i> } }
          </pre>
          <p>The <code>OPTIONAL</code> keyword is left-associative :</p>
          <pre class="query nohighlight">
<i>pattern</i> OPTIONAL { <i>pattern</i> } OPTIONAL { pattern }
          </pre>
          <p>is the same as:</p>
          <pre class="query nohighlight">
{ <i>pattern</i> OPTIONAL { <i>pattern</i> } } OPTIONAL { pattern }
          </pre>
          <p>In an optional match, either the optional graph pattern matches a graph, thereby
            defining and adding bindings to one or more solutions, or it leaves a solution unchanged
            without adding any additional bindings.</p>
          <p>Data:</p>
          <pre class="data nohighlight">
PREFIX foaf:       &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX rdf:        &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;

_:a  rdf:type        foaf:Person .
_:a  foaf:name       "Alice" .
_:a  foaf:mbox       &lt;mailto:alice@example.com&gt; .
_:a  foaf:mbox       &lt;mailto:alice@work.example&gt; .

_:b  rdf:type        foaf:Person .
_:b  foaf:name       "Bob" .
</pre>
          <div class="queryGroup">
            Query:
            <pre class="query nohighlight">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name ?mbox
WHERE  {
    ?x foaf:name  ?name .
    OPTIONAL { ?x  foaf:mbox  ?mbox }
}
            </pre>
            <p>With the data above, the query result is:</p>
            <div class="result">
              <div id="table92"></div>
              <table class="resultTable">
                <tbody>
                  <tr>
                    <th>name</th>
                    <th>mbox</th>
                  </tr>
                  <tr>
                    <td>"Alice"</td>
                    <td>&lt;mailto:alice@example.com&gt;</td>
                  </tr>
                  <tr>
                    <td>"Alice"</td>
                    <td>&lt;mailto:alice@work.example&gt;</td>
                  </tr>
                  <tr>
                    <td>"Bob"</td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>
        <p>There is no value of <code>mbox</code> in the solution where the name is
          <code>"Bob"</code>.</p>
        <p>This query finds the names of people in the data. If there is a triple with predicate
          <code>mbox</code> and the same subject, a solution will contain the object of that triple as
          well. In this example, only a single triple pattern is given in the optional match part of
          the query but, in general, the optional part may be any graph pattern. The entire optional
          graph pattern must match for the optional graph pattern to affect the query solution.</p>
      </section>
      <section id="OptionalAndConstraints">
        <h3>Constraints in Optional Pattern Matching</h3>
        <p>Constraints can be given in an optional graph pattern. For example:</p>
        <div class="exampleGroup">
          <pre class="data nohighlight">
PREFIX dc:   &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX :     &lt;http://example.org/book/&gt;
PREFIX ns:   &lt;http://example.org/ns#&gt;

:book1  dc:title  "SPARQL Tutorial" .
:book1  ns:price  42 .
:book2  dc:title  "The Semantic Web" .
:book2  ns:price  23 .
          </pre>
          <div class="queryGroup">
            <pre class="query nohighlight">
PREFIX  dc:  &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX  ns:  &lt;http://example.org/ns#&gt;
SELECT  ?title ?price
WHERE   { 
    ?x dc:title ?title .
    OPTIONAL { ?x ns:price ?price . FILTER (?price &lt; 30) }
}
            </pre>
            <div class="result">
              <div id="table93"></div>
              <table class="resultTable">
                <tbody>
                  <tr>
                    <th>title</th>
                    <th>price</th>
                  </tr>
                  <tr>
                    <td>"SPARQL Tutorial"</td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>"The Semantic Web"</td>
                    <td>23</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>
        <p>No price appears for the book with title "SPARQL Tutorial" because the optional graph
          pattern did not lead to a solution involving the variable "<code>price</code>".</p>
      </section>
      <section id="MultipleOptionals">
        <h3>Multiple Optional Graph Patterns</h3>
        <p>Graph patterns are defined recursively. A graph pattern may have zero or more optional
          graph patterns, and any part of a query pattern may have an optional part. In this example,
          there are two optional graph patterns.</p>
        <div class="exampleGroup">
          Data:
          <pre class="data nohighlight">
PREFIX foaf:       &lt;http://xmlns.com/foaf/0.1/&gt;

_:a  foaf:name       "Alice" .
_:a  foaf:homepage   &lt;http://work.example.org/alice/&gt; .

_:b  foaf:name       "Bob" .
_:b  foaf:mbox       &lt;mailto:bob@work.example&gt; .
          </pre>
          <div class="queryGroup">
            Query:
            <pre class="query nohighlight">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name ?mbox ?hpage
WHERE  {
    ?x foaf:name  ?name .
    OPTIONAL { ?x foaf:mbox ?mbox } .
    OPTIONAL { ?x foaf:homepage ?hpage }
}
</pre>
            <p>Query result:</p>
            <div class="result">
              <div id="table94"></div>
              <table class="resultTable">
                <tbody>
                  <tr>
                    <th>name</th>
                    <th>mbox</th>
                    <th>hpage</th>
                  </tr>
                  <tr>
                    <td>"Alice"</td>
                    <td></td>
                    <td>&lt;http://work.example.org/alice/&gt;</td>
                  </tr>
                  <tr>
                    <td>"Bob"</td>
                    <td>&lt;mailto:bob@work.example&gt;</td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>
      </section>
    </section>
    <section id="alternatives">
      <h2>Matching Alternatives</h2>
      <p>SPARQL provides a means of combining graph patterns so that one of several alternative graph
        patterns may match. If more than one of the alternatives matches, all the possible pattern
        solutions are found.</p>
      <p>Pattern alternatives are syntactically specified with the <code>UNION</code> keyword.</p>
      <div class="exampleGroup">
        Data:
        <pre class="data nohighlight">
PREFIX dc10:  &lt;http://purl.org/dc/elements/1.0/&gt;
PREFIX dc11:  &lt;http://purl.org/dc/elements/1.1/&gt;

_:a  dc10:title     "SPARQL Query Language Tutorial" .
_:a  dc10:creator   "Alice" .

_:b  dc11:title     "SPARQL Protocol Tutorial" .
_:b  dc11:creator   "Bob" .

_:c  dc10:title     "SPARQL" .
_:c  dc11:title     "SPARQL (updated)" .
        </pre>
        <div class="queryGroup">
          Query:
          <pre class="query nohighlight">
PREFIX dc10:  &lt;http://purl.org/dc/elements/1.0/&gt;
PREFIX dc11:  &lt;http://purl.org/dc/elements/1.1/&gt;

SELECT ?title
WHERE  { { ?book dc10:title  ?title } UNION { ?book dc11:title  ?title } }
          </pre>
          <p>Query result:</p>
          <div class="result">
            <div id="table97"></div>
            <table class="resultTable">
              <tbody>
                <tr>
                  <th>title</th>
                </tr>
                <tr>
                  <td>"SPARQL Protocol Tutorial"</td>
                </tr>
                <tr>
                  <td>"SPARQL"</td>
                </tr>
                <tr>
                  <td>"SPARQL (updated)"</td>
                </tr>
                <tr>
                  <td>"SPARQL Query Language Tutorial"</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
        <p>This query finds titles of the books in the data, whether the title is recorded using
          <a class="inform" href="http://dublincore.org/">Dublin Core</a> properties from version 1.0
          or version 1.1. To determine exactly how the information was recorded, a query could use
          different variables for the two alternatives:</p>
        <div class="queryGroup">
          <pre class="query nohighlight">
PREFIX dc10:  &lt;http://purl.org/dc/elements/1.0/&gt;
PREFIX dc11:  &lt;http://purl.org/dc/elements/1.1/&gt;

SELECT ?x ?y
WHERE  { { ?book dc10:title ?x } UNION { ?book dc11:title  ?y } }
          </pre>
          <div class="result">
            <div id="table98"></div>
            <table class="resultTable">
              <tbody>
                <tr>
                  <th>x</th>
                  <th>y</th>
                </tr>
                <tr>
                  <td></td>
                  <td>"SPARQL (updated)"</td>
                </tr>
                <tr>
                  <td></td>
                  <td>"SPARQL Protocol Tutorial"</td>
                </tr>
                <tr>
                  <td>"SPARQL"</td>
                  <td></td>
                </tr>
                <tr>
                  <td>"SPARQL Query Language Tutorial"</td>
                  <td></td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
        <p>This will return results with the variable <code>x</code> bound for solutions from the
          left branch of the <code>UNION</code>, and <code>y</code> bound for the solutions from the
          right branch. If neither part of the <code>UNION</code> pattern matched, then the graph
          pattern would not match.</p>
        <p>The <code>UNION</code> pattern combines graph patterns; each alternative possibility can
          contain more than one triple pattern:</p>
        <div class="queryGroup">
          <pre class="query nohighlight">
PREFIX dc10:  &lt;http://purl.org/dc/elements/1.0/&gt;
PREFIX dc11:  &lt;http://purl.org/dc/elements/1.1/&gt;

SELECT ?title ?author
WHERE {
    { ?book dc10:title ?title .  ?book dc10:creator ?author }
      UNION
    { ?book dc11:title ?title .  ?book dc11:creator ?author }
}
          </pre>
          <div class="result">
            <div id="table99"></div>
            <table class="resultTable">
              <tbody>
                <tr>
                  <th>title</th>
                  <th>author</th>
                </tr>
                <tr>
                  <td>"SPARQL Query Language Tutorial"</td>
                  <td>"Alice"</td>
                </tr>
                <tr>
                  <td>"SPARQL Protocol Tutorial"</td>
                  <td>"Bob"</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
      </div>
      <p>This query will only match a book if it has both a title and creator predicate from the same
        version of Dublin Core.</p>
    </section>
    <section id="negation">
      <h2>Negation</h2>
      <p>The SPARQL query language incorporates two styles of negation, one based on filtering
        results depending on whether a graph pattern does or does not match in the context of the query
        solution being filtered, and one based on removing solutions related to another pattern.</p>
      <section id="neg-pattern">
        <h3>Filtering Using Graph Patterns</h3>
        <p>Filtering of query solutions is done within a <code>FILTER</code> expression using
          <code>NOT EXISTS</code> and <code>EXISTS</code>. Note that the filter scope rules
          <a href="#scopeFilters">apply to the whole group in which the filter appears</a>.</p>
        <section id="neg-notexists">
          <h4>Testing For the Absence of a Pattern</h4>
          <p>The <code>NOT EXISTS</code> filter expression tests whether a graph pattern does not
            match the dataset, given the values of variables in the group graph pattern in which the
            filter occurs. It does not generate any additional bindings.</p>
          <div class="exampleGroup">
            <p>Data:</p>
            <pre class="data nohighlight">
PREFIX  :       &lt;http://example/&gt;
PREFIX  rdf:    &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;
PREFIX  foaf:   &lt;http://xmlns.com/foaf/0.1/&gt;

:alice  rdf:type   foaf:Person .
:alice  foaf:name  "Alice" .
:bob    rdf:type   foaf:Person .
     </pre>
            <p>Query:</p>
            <div class="queryGroup">
              <pre class="query nohighlight">
PREFIX  rdf:    &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; 
PREFIX  foaf:   &lt;http://xmlns.com/foaf/0.1/&gt; 

SELECT ?person
WHERE 
{
    ?person rdf:type  foaf:Person .
    FILTER NOT EXISTS { ?person foaf:name ?name }
}
</pre>
              <p>Query Result:</p>
              <div class="result">
                <table class="resultTable">
                  <tbody>
                    <tr>
                      <th>person</th>
                    </tr>
                    <tr>
                      <td>&lt;http://example/bob&gt;</td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
          </div>
        </section>
        <section id="neg-exists">
          <h4>Testing For the Presence of a Pattern</h4>
          <p>The filter expression <code>EXISTS</code> is also provided. It tests whether the pattern
            can be found in the data; it does not generate any additional bindings.</p>
          <div class="exampleGroup">
            <p>Query:</p>
            <div class="queryGroup">
              <pre class="query nohighlight">
PREFIX  rdf:    &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; 
PREFIX  foaf:   &lt;http://xmlns.com/foaf/0.1/&gt; 

SELECT ?person
WHERE {
    ?person rdf:type  foaf:Person .
    FILTER EXISTS { ?person foaf:name ?name }
}
</pre>
              <p>Query Result:</p>
              <div class="result">
                <table class="resultTable">
                  <tbody>
                    <tr>
                      <th>person</th>
                    </tr>
                    <tr>
                      <td>&lt;http://example/alice&gt;</td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
          </div>
        </section>
      </section>
      <section id="neg-minus">
        <h3>Removing Possible Solutions</h3>
        <p>The other style of negation provided in SPARQL is <code>MINUS</code> which evaluates both
          its arguments, then calculates solutions in the left-hand side that are not compatible with
          the solutions on the right-hand side.</p>
        <div class="exampleGroup">
          Data:
          <pre class="data nohighlight">
PREFIX :       &lt;http://example/&gt;
PREFIX foaf:   &lt;http://xmlns.com/foaf/0.1/&gt;

:alice  foaf:givenName "Alice" ;
        foaf:familyName "Smith" .

:bob    foaf:givenName "Bob" ;
        foaf:familyName "Jones" .

:carol  foaf:givenName "Carol" ;
        foaf:familyName "Smith" .
</pre>
          <div class="queryGroup">
            Query:
            <pre class="query nohighlight">
PREFIX :       &lt;http://example/&gt;
PREFIX foaf:   &lt;http://xmlns.com/foaf/0.1/&gt;

SELECT DISTINCT ?s
WHERE {
    ?s ?p ?o .
    MINUS {
        ?s foaf:givenName "Bob" .
    }
}</pre>
            <p>Results:</p>
            <div class="result">
              <table class="resultTable">
                <tbody>
                  <tr>
                    <th>s</th>
                  </tr>
                  <tr>
                    <td>&lt;http://example/carol&gt;</td>
                  </tr>
                  <tr>
                    <td>&lt;http://example/alice&gt;</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>
      </section>
      <section id="neg-notexists-minus">
        <h3>Relationship and differences between NOT EXISTS and MINUS</h3>
        <p><code>NOT EXISTS</code> and <code>MINUS</code> represent two ways of thinking about
          negation, one based on testing whether a pattern exists in the data, given the bindings
          already determined by the query pattern, and one based on removing matches based on the
          evaluation of two patterns. In some cases they can produce different answers.</p>
        <section id="neg-example-1">
          <h4>Example: Sharing of variables</h4>
          <pre class="data nohighlight">
PREFIX : &lt;http://example/&gt;
:a :b :c .
</pre>
          <pre class="query nohighlight">
SELECT * { 
    ?s ?p ?o
    FILTER NOT EXISTS { ?x ?y ?z }
}</pre>
          <p>evaluates to a result set with no solutions because <code>{ ?x ?y ?z }</code> matches
            given any <code>?s ?p ?o</code>, so <code>NOT EXISTS { ?x ?y ?z }</code> eliminates any
            solutions.</p>
          <div class="result">
            <table class="resultTable">
              <tbody>
                <tr>
                  <th>s</th>
                  <th>p</th>
                  <th>o</th>
                </tr>
              </tbody>
            </table>
          </div>
          <p>whereas with <code>MINUS</code>, there is no shared variable between the first part
            (<code>?s ?p ?o</code>) and the second (<code>?x ?y ?z</code>) so no bindings are
            eliminated.</p>
          <pre class="query nohighlight">
SELECT * { 
    ?s ?p ?o 
    MINUS 
    { ?x ?y ?z }
}</pre>
          <p>Results:</p>
          <div class="result">
            <table class="resultTable">
              <tbody>
                <tr>
                  <th>s</th>
                  <th>p</th>
                  <th>o</th>
                </tr>
                <tr>
                  <td>&lt;http://example/a&gt;</td>
                  <td>&lt;http://example/b&gt;</td>
                  <td>&lt;http://example/c&gt;</td>
                </tr>
              </tbody>
            </table>
          </div>
        </section>
        <section id="neg-example-2">
          <h4>Example: Fixed pattern</h4>
          <p>Another case is where there is a concrete pattern (no variables) in the example:</p>
          <pre class="query nohighlight">
PREFIX : &lt;http://example/&gt;
SELECT * {  
    ?s ?p ?o 
    FILTER NOT EXISTS { :a :b :c }
}
</pre>
          <p>evaluates to a result set with no query solutions:</p>Results:
          <div class="result">
            <table class="resultTable">
              <tbody>
                <tr>
                  <th>s</th>
                  <th>p</th>
                  <th>o</th>
                </tr>
              </tbody>
            </table>
          </div>
          <p>whereas</p>
          <pre class="query nohighlight">
PREFIX : &lt;http://example/&gt;
SELECT * 
{ 
    ?s ?p ?o 
    MINUS { :a :b :c }
}
</pre>
          <p>evaluates to result set with one query solution:</p>
          <p>Results:</p>
          <div class="result">
            <table class="resultTable">
              <tbody>
                <tr>
                  <th>s</th>
                  <th>p</th>
                  <th>o</th>
                </tr>
                <tr>
                  <td>&lt;http://example/a&gt;</td>
                  <td>&lt;http://example/b&gt;</td>
                  <td>&lt;http://example/c&gt;</td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>because there is no match of bindings and so no solutions are eliminated.</p>
        </section>
        <section id="idp899488">
          <h4>Example: Inner FILTERs</h4>
          <p>Differences also arise because in a filter, variables from the group
            are <a href="#scopeFilters">in scope</a>. 
            In this example, the <code>FILTER</code> inside the 
            <code>NOT EXISTS</code> has access to the value of <code>?n</code> for the solution being considered.</p>
          <pre class="data nohighlight">
PREFIX : &lt;http://example.com/&gt;
:a :p 1 .
:a :q 1 .
:a :q 2 .

:b :p 3.0 .
:b :q 4.0 .
:b :q 5.0 .
</pre>
          <p>When using <code>FILTER NOT EXISTS</code>, the test is on each possible solution to
            <code>?x :p ?n</code>:</p>
          <pre class="query nohighlight">
PREFIX : &lt;http://example.com/&gt;
SELECT * WHERE {
    ?x :p ?n
    FILTER NOT EXISTS {
        ?x :q ?m .
        FILTER(?n = ?m)
    }
}</pre>
          <div class="result">
            <table class="resultTable">
              <tbody>
                <tr>
                  <th>x</th>
                  <th>n</th>
                </tr>
                <tr>
                  <td>&lt;http://example.com/b&gt;</td>
                  <td>3.0</td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>whereas with <code>MINUS</code>, the <code>FILTER</code> inside the pattern does not
            have a value for ?n and it is always unbound:</p>
          <pre class="query nohighlight">
PREFIX : &lt;http://example/&gt;
SELECT * WHERE {
    ?x :p ?n
    MINUS {
        ?x :q ?m .
        FILTER(?n = ?m)
    }
}</pre>
          <div class="result">
            <table class="resultTable">
              <tbody>
                <tr>
                  <th>x</th>
                  <th>n</th>
                </tr>
                <tr>
                  <td>&lt;http://example.com/b&gt;</td>
                  <td>3.0</td>
                </tr>
                <tr>
                  <td>&lt;http://example.com/a&gt;</td>
                  <td>1</td>
                </tr>
              </tbody>
            </table>
          </div>
        </section>
      </section>
    </section>
    <section id="propertypaths">
      <h2>Property Paths</h2>
      <p>A property path is a possible route through a graph between two graph nodes. A trivial case
        is a property path of length exactly 1, which is a triple pattern. The ends of the path may be
        RDF terms or variables. Variables can not be used as part of the path itself, only the
        ends.</p>
      <p>Property paths allow for more concise expressions for some SPARQL basic graph patterns and
        they also add the ability to match connectivity of two resources by an arbitrary length
        path.</p>
      <section id="pp-language">
        <h3>Property Path Syntax</h3>
        <p>In the description below, <i><code>iri</code></i> is either <a href="#QSynIRI">an IRI written
            in full or abbreviated by a prefixed name</a>, or the keyword <code>a</code>. <i><code>elt</code></i>
          is a path element, which may itself be composed of path constructs.</p>
        <table style="border-spacing: 0; border-width: 1px">
          <tbody>
            <tr>
              <th>Syntax Form</th>
              <th>Property Path Expression Name</th>
              <th>Matches</th>
            </tr>
            <tr>
              <td><code><i>iri</i></code></td>
              <td>PredicatePath</td>
              <td>An IRI. A path of length one.</td>
            </tr>
            <tr>
              <td><code>^<i>elt</i></code></td>
              <td>InversePath</td>
              <td>Inverse path (object to subject).</td>
            </tr>
            <tr>
              <td><code><i>elt1</i> / <i>elt2</i></code></td>
              <td>SequencePath</td>
              <td>A sequence path of <code><i>elt1</i></code> followed by <code><i>elt2</i></code>.</td>
            </tr>
            <tr>
              <td><code><i>elt1</i> | <i>elt2</i></code></td>
              <td>AlternativePath</td>
              <td>A alternative path of <code><i>elt1</i></code> or <code><i>elt2</i></code> (all
                possibilities are tried).</td>
            </tr>
            <tr>
              <td><code><i>elt</i>*</code></td>
              <td>ZeroOrMorePath</td>
              <td>A path that connects the subject and object of the path by zero or more matches of
                <code><i>elt</i></code>.</td>
            </tr>
            <tr>
              <td><code><i>elt</i>+</code></td>
              <td>OneOrMorePath</td>
              <td>A path that connects the subject and object of the path by one or more matches of
                <code><i>elt</i></code>.</td>
            </tr>
            <tr>
              <td><code><i>elt</i>?</code></td>
              <td>ZeroOrOnePath</td>
              <td>A path that connects the subject and object of the path by zero or one matches of
                <code><i>elt</i></code>.</td>
            </tr>
            <tr>
              <td><code>!<i>iri</i></code> or <code>!(<i>iri<sub>1</sub></i>|
                  ...|<i>iri<sub>n</sub></i>)</code></td>
              <td>NegatedPropertySet</td>
              <td>Negated property set. An IRI which is not one of <code><i>iri<sub>i</sub></i></code>.
                <code>!<i>iri</i></code> is short for <code>!<i>(iri)</i></code>.</td>
            </tr>
            <tr>
              <td><code>!^<i>iri</i></code> or <code>!(^<i>iri<sub>1</sub></i>|
                  ...|^<i>iri<sub>n</sub></i>)</code></td>
              <td>NegatedPropertySet</td>
              <td>Negated property set where the excluded matches are based on reversed path.<br>
                That is, not one of <i>iri<sub>1</sub></i>...<i>iri<sub>n</sub></i> as reverse paths.
                <code>!^<i>iri</i></code> is short for <code>!(^<i>iri</i>)</code>.</td>
            </tr>
            <tr>
              <td><code>!(<i>iri<sub>1</sub></i>| ...|<i>iri<sub>j</sub></i>|^<i>iri<sub>j+1</sub></i>|
                  ...|^<i>iri<sub>n</sub></i>)</code></td>
              <td>NegatedPropertySet</td>
              <td>A combination of forward and reverse properties in a negated property set.</td>
            </tr>
            <tr>
              <td><code>(<i>elt</i>)</code></td>
              <td>&nbsp;</td>
              <td>A group path <code><i>elt</i></code>, brackets control precedence.</td>
            </tr>
          </tbody>
        </table>
        <p>The order of IRIs, and reverse IRIs, in a negated property set is not significant and they
          can occur in a mixed order.</p>
        <p>The precedence of the syntax forms is, from highest to lowest:</p>
        <ul>
          <li>IRI, prefixed names</li>
          <li>Negated property sets</li>
          <li>Groups</li>
          <li>Unary operators <code>*</code>, <code>?</code> and <code>+</code></li>
          <li>Unary ^ inverse links</li>
          <li>Binary operator <code>/</code></li>
          <li>Binary operator <code>|</code></li>
        </ul>
        <p>Precedence is left-to-right within groups.</p>
      </section>
      <section id="propertypath-examples">
        <h3>Examples</h3>
        <p><i>Alternatives</i>: Match one or both possibilities</p>
        <pre class="query nohighlight">  
{ :book1 dc:title|rdfs:label ?displayString }
</pre>
        <p>which could have written:</p>
        <pre class="query nohighlight">
{ 
   :book1 &lt;http://purl.org/dc/elements/1.1/title&gt; | &lt;http://www.w3.org/2000/01/rdf-schema#label&gt; ?displayString
}
        </pre>
        <p><i>Sequence</i>: Find the name of any people that Alice knows.</p>
        <pre class="query nohighlight">
{
    ?x foaf:mbox &lt;mailto:alice@example&gt; .
    ?x foaf:knows/foaf:name ?name .
}</pre>
        <p><i>Sequence</i>: Find the names of people 2 "<code>foaf:knows</code>" links away.</p>
        <pre class="query nohighlight">
{ 
    ?x foaf:mbox &lt;mailto:alice@example&gt; .
    ?x foaf:knows/foaf:knows/foaf:name ?name .
}</pre>
        <p>This is the same as the SPARQL query:</p>
        <pre class="query nohighlight">  
SELECT ?x ?name {
    ?x  foaf:mbox &lt;mailto:alice@example&gt; .
    ?x  foaf:knows [ foaf:knows [ foaf:name ?name ]]. 
}
</pre>
        <p>or, with explicit variables:</p>
        <pre class="query nohighlight">
SELECT ?x ?name {
    ?x  foaf:mbox &lt;mailto:alice@example&gt; .
    ?x  foaf:knows ?a1 .
    ?a1 foaf:knows ?a2 .
    ?a2 foaf:name ?name .
}
</pre>
        <p><i>Filtering duplicates</i>: Because someone Alice knows may well know Alice, the example
          above may include Alice herself. This could be avoided with:</p>
        <pre class="query nohighlight"> 
 { ?x foaf:mbox &lt;mailto:alice@example&gt; .
   ?x foaf:knows/foaf:knows ?y .
   FILTER ( ?x != ?y )
   ?y foaf:name ?name 
 }</pre>
        <p><i>Inverse Property Paths</i>: These two are the same query: the second is just reversing
          the property direction which swaps the roles of subject and object.</p>
        <pre class="query nohighlight">
{ ?x foaf:mbox &lt;mailto:alice@example&gt; }
        </pre>
        <pre class="query nohighlight">
{ &lt;mailto:alice@example&gt; ^foaf:mbox ?x }
        </pre>
        <p><i>Inverse Path Sequence</i>: Find all the people who know someone <code>?x</code> knows.</p>
        <pre class="query nohighlight">
{
  ?x foaf:knows/^foaf:knows ?y .  
  FILTER(?x != ?y)
}
</pre>
        <p>which is equivalent to (<code>?gen1</code> is a system generated variable):</p>
        <pre class="query nohighlight"> 
{
  ?x foaf:knows ?gen1 .
  ?y foaf:knows ?gen1 .  
  FILTER(?x != ?y)
}
</pre>
        <p><i>Arbitrary length match</i>: Find the names of all the people that can be reached from
          Alice by <code>foaf:knows</code>:</p>
        <pre class="query nohighlight">
{
  ?x foaf:mbox &lt;mailto:alice@example&gt; .
  ?x foaf:knows+/foaf:name ?name .
}
</pre>
        <p><i>Alternatives in an arbitrary length path</i>:</p>
        <pre class="query nohighlight">
{ ?ancestor (ex:motherOf|ex:fatherOf)+ &lt;#me&gt; }
</pre>
        <p><i>Arbitrary length path match</i>: Some forms of limited inference are possible as well.
          For example, for RDFS, all types and supertypes of a resource:</p>
        <pre class="query nohighlight">
{ &lt;http://example/thing&gt; rdf:type/rdfs:subClassOf* ?type }
        </pre>
        <p>All resources and all their inferred types:</p>
        <pre class="query nohighlight">
{ ?x rdf:type/rdfs:subClassOf* ?type }
        </pre>
        <p><i>Subproperty</i>:</p>
        <pre class="query nohighlight">
{ ?x ?p ?v . ?p rdfs:subPropertyOf* :property }
        </pre>
        <p><i>Negated Property Paths</i>: Find nodes connected but not by rdf:type (either way
          round):</p>
        <pre class="query nohighlight"> 
{ ?x !(rdf:type|^rdf:type) ?y }
</pre>
        <p><i>Elements in an RDF collection</i>:</p>
        <pre class="query nohighlight">
{ :list rdf:rest*/rdf:first ?element }
</pre>
        <p><i>Note: This path expression does not guarantee the order of the results.</i></p>
      </section>
      <section id="propertypath-syntaxforms">
        <h3>Property Paths and Equivalent Patterns</h3>
        <p>SPARQL property paths treat the RDF triples as a directed, possibly cyclic, graph with
          named edges. Evaluation of a property path expression can lead to duplicates because any
          variables introduced in the equivalent pattern are not part of the results and are not
          already used elsewhere. They are hidden by implicit projection of the results to just the
          variables given in the query.</p>
        <p>For example, on the data:</p>
        <pre class="data nohighlight">
PREFIX :       &lt;http://example/&gt;

:order  :item :z1 .
:order  :item :z2 .

:z1 :name "Small" .
:z1 :price 5 .

:z2 :name "Large" .
:z2 :price 5 .
        </pre>
        <p>Query:</p>
        <pre class="query nohighlight">
PREFIX :   &lt;http://example/&gt;
SELECT * 
{  ?s :item/:price ?x . }
</pre>
        <p>Results:</p>
        <div class="result">
          <table class="resultTable">
            <tbody>
              <tr>
                <th>s</th>
                <th>x</th>
              </tr>
              <tr>
                <td>&lt;http://example/order&gt;</td>
                <td>5</td>
              </tr>
              <tr>
                <td>&lt;http://example/order&gt;</td>
                <td>5</td>
              </tr>
            </tbody>
          </table>
        </div>
        <p>whereas if the query were written out to include the intermediate variable
          (<code>?_a</code>), no rows in the results are duplicates:</p>
        <pre class="query nohighlight">
PREFIX :   &lt;http://example/&gt;
SELECT * 
{  ?s :item ?_a .
   ?_a :price ?x .
}</pre>
        <p>Results:</p>
        <div class="result">
          <table class="resultTable">
            <tbody>
              <tr>
                <th>s</th>
                <th>_a</th>
                <th>x</th>
              </tr>
              <tr>
                <td>&lt;http://example/order&gt;</td>
                <td>&lt;http://example/z1&gt;</td>
                <td>5</td>
              </tr>
              <tr>
                <td>&lt;http://example/order&gt;</td>
                <td>&lt;http://example/z2&gt;</td>
                <td>5</td>
              </tr>
            </tbody>
          </table>
        </div>
        <p>The equivalence to graphs patterns is particularly significant when query also involves an
          aggregation operation. The total cost of the order can be found with</p>
        <pre class="query nohighlight">
PREFIX :   &lt;http://example/&gt;
SELECT (sum(?x) AS ?total) { 
    :order :item/:price ?x
}
        </pre>
        <div class="result">
          <table class="resultTable">
            <tbody>
              <tr>
                <th>total</th>
              </tr>
              <tr>
                <td>10</td>
              </tr>
            </tbody>
          </table>
        </div>
      </section>
      <section id="propertypath-arbitrary-length">
        <h3>Arbitrary Length Path Matching</h3>
        <p>Connectivity between the subject and object by a property path of arbitrary length can be
          found using the "zero or more" property path operator, <code>*</code>, and the "one or more"
          property path operator, <code>+</code>. There is also a "zero or one" connectivity property
          path operator, <code>?</code>.</p>
        <p>Each of these operators uses the property path expression to try to find a connection
          between subject and object, using the path step a number of times, as restricted by the
          operator.</p>
        <p>For example, finding all the the possible types of a resource, including supertypes of
          resources, can be achieved with:</p>
        <pre class="query nohighlight">
PREFIX  rdfs:   &lt;http://www.w3.org/2000/01/rdf-schema#&gt; . 
PREFIX  rdf:    &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;
SELECT ?x ?type
{ 
    ?x rdf:type/rdfs:subClassOf* ?type
}</pre>
        <p>Similarly, finding all the people <code>:x</code> connects to via the
          <code>foaf:knows</code> relationship,</p>
        <pre class="query nohighlight">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX :     &lt;http://example/&gt;
SELECT ?person
{ 
    :x foaf:knows+ ?person
}
        </pre>
        <p>Such connectivity matching does not introduce duplicates (it does not incorporate any
          count of the number of ways the connection can be made) even if the repeated path itself
          would otherwise result in duplicates.</p>
        <p>The graph matched may include cycles. Connectivity matching is defined so that matching
          cycles does not lead to undefined or infinite results.</p>
      </section>
    </section>
    <section id="assignment">
      <h2>Assignment</h2>
      <p>The value of an expression can be added to a solution mapping by binding a new variable to
        the value of the expression, which is an RDF term. The variable can then be used in the query
        and also can be returned in results.</p>
      <p>Three syntax forms allow this: the <a href="#assignment"><code>BIND</code> keyword</a>,
        <a href="#selectExpressions">expressions in the <code>SELECT</code> clause</a> and
        <a href="#groupby">expressions in the <code>GROUP BY</code> clause</a>. The assignment form is
        <code>(<i>expression</i> AS ?var)</code>.</p>
      <p>If the evaluation of the expression produces an error, the variable remains unbound for that
        solution but the query evaluation continues.</p>
      <p>Data can also be directly included in a query using
        <a href="#inline-data"><code>VALUES</code></a> for inline data.</p>
      <section id="bind">
        <h3>BIND: Assigning to Variables</h3>
        <p>The <code>BIND</code> form allows a value to be assigned to a variable from a basic graph
          pattern or property path expression. Use of <code>BIND</code> ends the preceding basic graph
          pattern. The variable introduced by the <code>BIND</code> clause must not have been used in
          the group graph pattern up to the point of use in <code>BIND</code>.</p>
        <p>Example:</p>
        <div class="exampleGroup">
          <p>Data:</p>
          <pre class="data nohighlight">
PREFIX dc:   &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX :     &lt;http://example.org/book/&gt;
PREFIX ns:   &lt;http://example.org/ns#&gt;

:book1  dc:title     "SPARQL Tutorial" .
:book1  ns:price     42 .
:book1  ns:discount  0.2 .

:book2  dc:title     "The Semantic Web" .
:book2  ns:price     23 .
:book2  ns:discount  0.25 .
</pre>
          <p>Query:</p>
          <pre class="query nohighlight">
PREFIX  dc:  &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX  ns:  &lt;http://example.org/ns#&gt;

SELECT  ?title ?price
{   
    ?x ns:price ?p .
    ?x ns:discount ?discount
    BIND (?p*(1-?discount) AS ?price)
    FILTER(?price &lt; 20)
    ?x dc:title ?title . 
}
</pre>
          <p>Equivalent query (<code>BIND</code> ends the basic graph pattern; the
            <code>FILTER</code> applies to the whole group graph pattern):</p>
          <pre class="query nohighlight">
PREFIX  dc:  &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX  ns:  &lt;http://example.org/ns#&gt;

SELECT  ?title ?price
{  { ?x ns:price ?p .
     ?x ns:discount ?discount
     BIND (?p*(1-?discount) AS ?price)
    }
    {?x dc:title ?title . }
    FILTER(?price &lt; 20)
}</pre>
          <p>Results:</p>
          <div class="result">
            <table class="resultTable">
              <tbody>
                <tr>
                  <th>title</th>
                  <th>price</th>
                </tr>
                <tr>
                  <td>&nbsp;"The Semantic Web"</td>
                  <td>17.25</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
      </section>
      <section id="inline-data">
        <h3>VALUES: Providing inline data</h3>
        <p>Data can be directly written in a graph pattern or added to a query using
          <code>VALUES</code>. <code>VALUES</code> provides inline data as a 
          <a href="#defn_sparqlSolutionSequence">solution sequence</a> which are combined with the results of
          query evaluation by a <a href="#defn_algJoin">join</a> operation. It can be used by an
          application to provide specific requirements on query results and also by SPARQL query engine
          implementations that provide <a href="#basic-federated-query">federated query</a> through the
          <code>SERVICE</code> keyword to send a more constrained query to a remote query service.</p>
        <section id="inline-data-syntax">
          <h4>VALUES syntax</h4>
          <p><code>VALUES</code> allows multiple variables to be specified in the data block; there
            is a special syntax for the common case of specifying just one variable and some
            values.</p>
          <p>In the following example, there is a table of two variables, <code>?x</code> and
            <code>?y</code>. The second row has no value for <code>?y</code>.</p>
          <pre class="data nohighlight">
VALUES (?x ?y) {
    (:uri1 1)
    (:uri2 UNDEF)
}
          </pre>
          <p>Optionally, when there is a single variable and some values:</p>
          <pre class="data nohighlight">
VALUES ?z { "abc" "def" }
          </pre>
          <p>which is the same as using the general form:</p>
          <pre class="data nohighlight">
            VALUES (?z) { ("abc") ("def") }
          </pre>
          <p>Note that the same variable cannot be mentioned multiple times within the variables list of a VALUES clause.</p>
        </section>
        <section id="inline-data-examples">
          <h4>VALUES Examples</h4>
          <p>A <code>VALUES</code> block of data can appear in a query pattern or at the end of a
            <code>SELECT</code> query, including a <a href="#subqueries">subquery</a>.</p>
          <div class="exampleGroup">
            <p>Data:</p>
            <pre class="data nohighlight">
PREFIX dc:   &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX :     &lt;http://example.org/book/&gt;
PREFIX ns:   &lt;http://example.org/ns#&gt;

:book1  dc:title  "SPARQL Tutorial" .
:book1  ns:price  42 .
:book2  dc:title  "The Semantic Web" .
:book2  ns:price  23 .
            </pre>
            <p>Query:</p>
            <pre class="query nohighlight">
PREFIX dc:   &lt;http://purl.org/dc/elements/1.1/&gt; 
PREFIX :     &lt;http://example.org/book/&gt; 
PREFIX ns:   &lt;http://example.org/ns#&gt; 

SELECT ?book ?title ?price
{
    VALUES ?book { :book1 :book3 }
    ?book dc:title ?title ;
          ns:price ?price .
}
            </pre>
            <p>Result:</p>
            <div class="result">
              <div id="table110"></div>
              <table class="resultTable">
                <tbody>
                  <tr>
                    <th>book</th>
                    <th>title</th>
                    <th>price</th>
                  </tr>
                  <tr>
                    <td>&lt;http://example.org/book/book1&gt;</td>
                    <td>"SPARQL Tutorial"</td>
                    <td>42</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
          <p>If a variable has no value for a particular solution in the <code>VALUES</code> clause,
            the keyword <code>UNDEF</code> is used instead of an RDF term.</p>
          <pre class="query nohighlight">
PREFIX dc:   &lt;http://purl.org/dc/elements/1.1/&gt; 
PREFIX :     &lt;http://example.org/book/&gt; 
PREFIX ns:   &lt;http://example.org/ns#&gt; 

SELECT ?book ?title ?price
{
    ?book dc:title ?title ;
          ns:price ?price .
    VALUES (?book ?title) {
        (UNDEF "SPARQL Tutorial")
        (:book2 UNDEF)
    }
}
          </pre>
          <div class="result">
            <div id="table111"></div>
            <table class="resultTable">
              <tbody>
                <tr>
                  <th>book</th>
                  <th>title</th>
                  <th>price</th>
                </tr>
                <tr>
                  <td>&lt;http://example.org/book/book1&gt;</td>
                  <td>"SPARQL Tutorial"</td>
                  <td>42</td>
                </tr>
                <tr>
                  <td>&lt;http://example.org/book/book2&gt;</td>
                  <td>"The Semantic Web"</td>
                  <td>23</td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>In this example, the <code>VALUES</code> might have been specified to execute over the
            results of the <code>SELECT</code> query:</p>
          <pre class="query nohighlight">
PREFIX dc:   &lt;http://purl.org/dc/elements/1.1/&gt; 
PREFIX :     &lt;http://example.org/book/&gt; 
PREFIX ns:   &lt;http://example.org/ns#&gt; 

SELECT ?book ?title ?price {
    ?book dc:title ?title ;
          ns:price ?price .
}
VALUES (?book ?title) {
    (UNDEF "SPARQL Tutorial")
    (:book2 UNDEF)
}
          </pre>
          <p>This is a different query but, in the example situation, has the same results.</p>
        </section>
      </section>
    </section>
    <section id="aggregates">
      <h2>Aggregates</h2>
      <p>Aggregates apply expressions over groups of solutions. By default a solution set consists of
        a single group, containing all solutions.</p>
      <p>Grouping may be specified using the <code>GROUP BY</code> syntax.</p>
      <p>Aggregates defined in version 1.1 of SPARQL are <code>COUNT</code>, <code>SUM</code>,
        <code>MIN</code>, <code>MAX</code>, <code>AVG</code>, <code>GROUP_CONCAT</code>, and
        <code>SAMPLE</code>.</p>
      <p>Aggregates are used where the querier wishes to see a result which is computed over a group
        of solutions, rather than a single solution. For example the maximum value that a particular
        variable takes, rather than each value individually.</p>
      <section id="aggregateExample">
        <h3>Aggregate Example</h3>
        <div class="exampleGroup">
          <p>Data:</p>
          <pre class="data nohighlight">
PREFIX : &lt;http://books.example/&gt;

:org1 :affiliates :auth1, :auth2 .
:auth1 :writesBook :book1, :book2 .
:book1 :price 9 .
:book2 :price 5 .
:auth2 :writesBook :book3 .
:book3 :price 7 .
:org2 :affiliates :auth3 .
:auth3 :writesBook :book4 .
:book4 :price 7 .
</pre>
          <p>Query:</p>
          <pre class="query nohighlight">
PREFIX : &lt;http://books.example/&gt;
SELECT (SUM(?lprice) AS ?totalPrice)
WHERE {
    ?org :affiliates ?auth .
    ?auth :writesBook ?book .
    ?book :price ?lprice .
}
GROUP BY ?org
HAVING (SUM(?lprice) &gt; 10)
          </pre>
          <p>Results:</p>
          <div class="result">
            <table class="resultTable">
              <tbody>
                <tr>
                  <th>totalPrice</th>
                </tr>
                <tr>
                  <td>21</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
        <p>This example demonstrates two features of aggregates: <code>GROUP BY</code>, which groups
          query solutions according to one or more expressions (in this case <code>?org</code>), and
          <code>HAVING</code>, which is analogous to a <code>FILTER</code> expression, but operates
          over groups, rather than individual solutions.</p>
        <p>The example is produced by grouping solutions according to the <code>GROUP BY</code>
          expression (i.e. all solutions where <code>?org</code> takes a particular value appear within
          the same group), and evaluating the Set Function <code>SUM</code> over that group. The groups
          are then filtered by the <code>HAVING</code> expression, which removes all groups where
          <code>SUM(?lprice)</code> is not greater than 10.</p>
        <p>In aggregate queries and sub-queries, variables that appear in the query pattern, but are
          not in the <code>GROUP BY</code> clause, can only be projected or used in select expressions
          if they are aggregated. The <code>SAMPLE</code> aggregate may be used for this purpose. For
          details see the section on <a href="#aggregateRestrictions">Projection Restrictions</a>.</p>
        <p>It should be noted that <a href="#selectExpressions">as per functions</a>, aggregate
          expressions are required to be aliased (again, similar to the <code>BIND</code> clause, using
          the keyword <code>AS</code>) in order to project them from queries or subqueries. In the
          example above this is done using the variable <code>?totalPrice</code>. It is an error for
          aggregates to project variables with a name already used in other aggregate projections, or
          in the <code>WHERE</code> clause.</p>
      </section>
      <section id="groupby">
        <h3>GROUP BY</h3>
        <p>In order to calculate aggregate values for a solution, the solution is first divided into
          one or more groups, and the aggregate value is calculated for each group.</p>
        <p>If aggregates are used in the query level in <code>SELECT</code>, <code>HAVING</code> or
          <code>ORDER BY</code> but the <code>GROUP BY</code> term is not used, then this is taken to
          be a single implicit group, to which all solutions belong.</p>
        <p>Within <code>GROUP BY</code> clauses the binding keyword, <code>AS</code>, may be used,
          such as <code>GROUP BY (?x + ?y AS ?z)</code>. This is equivalent to 
          <code>{ ... BIND (?x + ?y AS ?z) } GROUP BY ?z</code>.</p>
        <p>For example, given a solution sequence <code>S</code>, <code>( {?xâ†’2, ?yâ†’3}, {?xâ†’2, ?yâ†’5}, {?xâ†’6, ?yâ†’7} )</code>, we
          might wish to group the solutions according to the value of <code>?x</code>, and calculate the average of
          the values of <code>?y</code> for each group.</p>
        <p>This could be written as:</p>
        <pre class="query nohighlight">
SELECT (AVG(?y) AS ?avg)
WHERE {
    ?a :x ?x ;
    :y ?y .
}
GROUP BY ?x
        </pre>
      </section>
      <section id="having">
        <h3>HAVING</h3>
        <p><code>HAVING</code> operates over grouped solution sets, in the same way that
          <code>FILTER</code> operates over un-grouped ones.</p>
        <p><code>HAVING</code> expressions have the same evaluation rules as projections from grouped
          queries, as described in the following section.</p>
        <p>An example of the use of <code>HAVING</code> is given below.</p>
        <pre class="query nohighlight">
PREFIX : &lt;http://data.example/&gt;
SELECT (AVG(?size) AS ?asize)
WHERE {
    ?x :size ?size
}
GROUP BY ?x
HAVING(AVG(?size) &gt; 10)
        </pre>
        <p>This will return average sizes, grouped by the subject, but only where the mean size is
          greater than 10.</p>
      </section>
      <section id="aggregateRestrictions">
        <h3>Aggregate Projection Restrictions</h3>
        <p>In a query level which uses aggregates, only expressions consisting of aggregates and
          constants may be projected, with one exception. When <code>GROUP BY</code> is given with one
          or more simple expressions consisting of just a variable, those variables may be projected
          from the level.</p>
        <p>For example, the following query is legal as ?x is given as a <code>GROUP BY</code>
          term.</p>
        <pre class="query nohighlight">
PREFIX : &lt;http://example.com/data/#&gt;
SELECT ?x (MIN(?y) * 2 AS ?min)
WHERE {
    ?x :p ?y .
    ?x :q ?z .
} GROUP BY ?x (STR(?z))
        </pre>
        <p>Note that it would not be legal to project <code>STR(?z)</code> as this is not a simple
          variable expression. However, with <code>GROUP BY (STR(?z) AS ?strZ)</code> it would be
          possible to project <code>?strZ</code>.</p>
        <p>Other expressions, not using <code>GROUP BY</code> variables, or aggregates may have
          non-deterministic values projected from their groups using the <code>SAMPLE</code>
          aggregate.</p>
      </section>
      <section id="aggregateExample2">
        <h3>Aggregate Example (with errors)</h3>
        <p>This section shows an example query using aggregation, which demonstrates how errors are
          handled in results, in the presence of aggregates.</p>
        <p>Data:</p>
        <pre class="data nohighlight">
PREFIX : &lt;http://example.com/data/#&gt;

:x :p 1, 2, 3, 4 .
:y :p 1, _:b2, 3, 4 .
:z :p 1.0, 2.0, 3.0, 4 .
        </pre>
        <p>Query:</p>
        <pre class="query nohighlight">
PREFIX : &lt;http://example.com/data/#&gt;
SELECT ?g (AVG(?p) AS ?avg) ((MIN(?p) + MAX(?p)) / 2 AS ?c)
WHERE {
    ?g :p ?p .
}
GROUP BY ?g</pre>
        <p>Result:</p>
        <div class="result">
          <table class="resultTable">
            <tbody>
              <tr>
                <th>g</th>
                <th>avg</th>
                <th>c</th>
              </tr>
              <tr>
                <td>&lt;http://example.com/data/#x&gt;</td>
                <td>2.5</td>
                <td>2.5</td>
              </tr>
              <tr>
                <td>&lt;http://example.com/data/#y&gt;</td>
                <td></td>
                <td></td>
              </tr>
              <tr>
                <td>&lt;http://example.com/data/#z&gt;</td>
                <td>2.5</td>
                <td>2.5</td>
              </tr>
            </tbody>
          </table>
        </div>
        <p>Note that the bindings for the :y group is not included in the results as the evaluation
          of Avg({1, _:b2, 3, 4}), and (_:b2 + 4) / 2 is an error, removing the bindings from the
          solution.</p>
      </section>
    </section>
    <section id="subqueries">
      <h2>Subqueries</h2>
      <p>Subqueries are a way to embed SPARQL queries within other queries, normally to achieve
        results which cannot otherwise be achieved, such as limiting the number of results from some
        sub-expression within the query.</p>
      <p>Due to the bottom-up nature of SPARQL query evaluation, the subqueries are evaluated
        logically first, and the results are projected up to the outer query.</p>
      <p>Note that only variables projected out of the subquery will be visible, or
        <a href="#variableScope">in scope</a>, to the outer query.</p>
      <h3 id="subquery-example">Example</h3>
      <p>Data:</p>
      <div class="exampleGroup">
        <pre class="data nohighlight">
PREFIX : &lt;http://people.example/&gt;

:alice :name "Alice", "Alice Foo", "A. Foo" .
:alice :knows :bob, :carol .
:bob :name "Bob", "Bob Bar", "B. Bar" .
:carol :name "Carol", "Carol Baz", "C. Baz" .
        </pre>
        <p>Return a name (the one with the lowest sort order) for all the people that know Alice and
          have a name.</p>
        <p>Query:</p>
        <pre class="query nohighlight">
PREFIX : &lt;http://people.example/&gt;
PREFIX : &lt;http://people.example/&gt;

SELECT ?y ?minName
WHERE {
    :alice :knows ?y .
    {
      SELECT ?y (MIN(?name) AS ?minName)
      WHERE {
          ?y :name ?name .
      } GROUP BY ?y
    }
}
        </pre>
      </div>
      <p>Results:</p>
      <div class="result">
        <table class="resultTable">
          <tbody>
            <tr>
              <th>y</th>
              <th>minName</th>
            </tr>
            <tr>
              <td>:bob</td>
              <td>"B. Bar"</td>
            </tr>
            <tr>
              <td>:carol</td>
              <td>"C. Baz"</td>
            </tr>
          </tbody>
        </table>
      </div>
      <p>This result is achieved by first evaluating the inner query:</p>
      <pre class="query nohighlight">
SELECT ?y (MIN(?name) AS ?minName)
WHERE {
    ?y :name ?name .
} GROUP BY ?y
</pre>
      <p>This produces the following solution sequence:</p>
      <div class="result">
        <table class="resultTable">
          <tbody>
            <tr>
              <th>y</th>
              <th>minName</th>
            </tr>
            <tr>
              <td>:alice</td>
              <td>"A. Foo"</td>
            </tr>
            <tr>
              <td>:bob</td>
              <td>"B. Bar"</td>
            </tr>
            <tr>
              <td>:carol</td>
              <td>"C. Baz"</td>
            </tr>
          </tbody>
        </table>
      </div>
      <p>Which is joined with the results of the outer query:</p>
      <div class="result">
        <table class="resultTable">
          <tbody>
            <tr>
              <th>y</th>
            </tr>
            <tr>
              <td>:bob</td>
            </tr>
            <tr>
              <td>:carol</td>
            </tr>
          </tbody>
        </table>
      </div>
    </section>
    <section id="rdfDataset">
      <h2>RDF Dataset</h2>
      <p>The RDF data model expresses information as graphs consisting of triples with subject,
        predicate and object. Many RDF data stores hold multiple RDF graphs and record information
        about each graph, allowing an application to make queries that involve information from more
        than one graph.</p>
      <p>A SPARQL query is executed against an <a data-cite="RDF12-CONCEPTS#dfn-rdf-dataset">RDF Dataset</a> [[RDF12-CONCEPTS]] which represents a collection of
        graphs. An RDF Dataset comprises one graph, the default graph, which does not have a name, and
        zero or more named graphs, where each named graph is identified by an IRI or a blank node. A SPARQL query can
        match different parts of the query pattern against different graphs as described in section
        <a href="#queryDataset">13.3 Querying the Dataset</a>.</p>
      <p>An RDF Dataset may contain zero named graphs; an RDF Dataset always contains one default
        graph. A query does not need to involve matching the default graph; the query can just involve
        matching named graphs.</p>
      <p>The graph that is used for matching a basic graph pattern is the <i>active graph</i>. In the
        previous sections, all queries have been shown executed against a single graph, the default
        graph of an RDF dataset as the active graph. The <code>GRAPH</code> keyword is used to make the
        active graph one of all of the named graphs in the dataset for part of the query.</p>
      <section id="exampleDatasets">
        <h3>Examples of RDF Datasets</h3>
        <p>The <a data-cite="RDF12-CONCEPTS#dfn-rdf-dataset">definition of RDF Dataset</a> [[RDF12-CONCEPTS]] does not restrict the relationships of named and default
          graphs. Information can be repeated in different graphs; relationships between graphs can be
          exposed. Two useful arrangements are:</p>
        <ul>
          <li>to have information in the default graph that includes provenance information about the
            named graphs</li>
          <li>to include the information in the named graphs in the default graph as well.</li>
        </ul>
        <div class="exampleGroup">
          <b>Example 1:</b>
          <pre class="data nohighlight">
PREFIX dc: &lt;http://purl.org/dc/elements/1.1/&gt;

&lt;http://example.org/bob&gt;    dc:publisher  "Bob" .
&lt;http://example.org/alice&gt;  dc:publisher  "Alice" .

GRAPH &lt;http://example.org/bob&gt; {
    _:a foaf:name "Bob" .
    _:a foaf:mbox &lt;mailto:bob@oldcorp.example.org&gt; .
}

GRAPH &lt;http://example.org/alice&gt; {
    _:a foaf:name "Alice" .
    _:a foaf:mbox &lt;mailto:alice@work.example.org&gt; .
}
          </pre>
        </div>
        <p>In this example, the default graph contains the names of the publishers of two named
          graphs. The triples in the named graphs are not visible in the default graph in this
          example.</p>
        <p id="ex_2"><b>Example 2:</b></p>
        <p>RDF data can be combined by the <a data-cite="RDF12-SEMANTICS#dfn-merge">RDF merge</a>
          [[RDF12-SEMANTICS]] of graphs. One possible arrangement of graphs in an RDF Dataset is to have the
          default graph be the RDF merge of some or all of the information in the named graphs.</p>
        <p>
          In this next example, the named graphs contain the same triples as before. The RDF dataset
          includes an <a data-cite="RDF12-SEMANTICS#dfn-merge">RDF merge</a>
          of the named graphs in the default graph, which keeps blank nodes distinct.
        </p>
        <div class="exampleGroup">
          <pre class="data nohighlight">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;

_:x foaf:name "Bob" .
_:x foaf:mbox &lt;mailto:bob@oldcorp.example.org&gt; .

_:y foaf:name "Alice" .
_:y foaf:mbox &lt;mailto:alice@work.example.org&gt; .

GRAPH &lt;http://example.org/bob&gt; {
    _:a foaf:name "Bob" .
    _:a foaf:mbox &lt;mailto:bob@oldcorp.example.org&gt; .
}

GRAPH &lt;http://example.org/alice&gt; {
    _:a foaf:name "Alice" .
    _:a foaf:mbox &lt;mailto:alice@work.example&gt; .
}
          </pre>
          <p>In an RDF merge, blank nodes in the merged graph are not shared with blank nodes from
            the graphs being merged.</p>
        </div>
      </section>
      <section id="specifyingDataset">
        <h3>Specifying RDF Datasets</h3>
        <p>A SPARQL query may specify the dataset to be used for matching by using the
          <code>FROM</code> clause and the <code>FROM NAMED</code> clause to describe the RDF dataset.
          If a query provides such a dataset description, then it is used in place of any dataset that
          the query service would use if no dataset description is provided in a query. The RDF dataset
          may also be <a data-cite="SPARQL11-PROTOCOL#">specified in a SPARQL protocol request</a>, in
          which case the protocol description overrides any description in the query itself. A query
          service may refuse a query request if the dataset description is not acceptable to the
          service.</p>
        <p>The <code>FROM</code> and <code>FROM NAMED</code> keywords allow a query to specify an RDF
          dataset by reference; they indicate that the dataset should include graphs that are obtained
          from representations of the resources identified by the given IRIs (i.e. the absolute form of
          the given IRI references). The dataset resulting from a number of <code>FROM</code> and
          <code>FROM NAMED</code> clauses is:</p>
        <ul>
          <li>a default graph consisting of the RDF merge of the graphs referred to in the
            <code>FROM</code> clauses, and</li>
          <li>a set of (IRI, graph) pairs, one from each <code>FROM NAMED</code> clause.</li>
        </ul>
        <p>If there is no <code>FROM</code> clause, but there is one or more <code>FROM NAMED</code>
          clauses, then the dataset includes an empty graph for the default graph.</p>
        <section id="unnamedGraph">
          <h4>Specifying the Default Graph</h4>
          <p>Each <code>FROM</code> clause contains an IRI that indicates a graph to be used to form
            the default graph. This does not put the graph in as a named graph.</p>
          <p>In this example, the RDF Dataset contains a single default graph and no named
            graphs:</p>
          <div class="exampleGroup">
            <pre class="data nohighlight">
<b># Default graph (located at http://example.org/foaf/aliceFoaf)</b>
PREFIX  foaf:  &lt;http://xmlns.com/foaf/0.1/&gt;

_:a  foaf:name     "Alice" .
_:a  foaf:mbox     &lt;mailto:alice@work.example&gt; .
            </pre>
            <div class="queryGroup">
              <pre class="query nohighlight">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT  ?name
FROM    &lt;http://example.org/foaf/aliceFoaf&gt;
WHERE   { ?x foaf:name ?name }
              </pre>
              <div class="result">
                <div id="table102"></div>
                <table class="resultTable">
                  <tbody>
                    <tr>
                      <th>name</th>
                    </tr>
                    <tr>
                      <td>"Alice"</td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
          </div>
          <p>If a query provides more than one <code>FROM</code> clause, providing more than one IRI
            to indicate the default graph, then the default graph is the 
            <a data-cite="RDF12-SEMANTICS#dfn-merge">RDF merge</a> of the graphs obtained from representations of the
            resources identified by the given IRIs.</p>
        </section>
        <section id="namedGraphs">
          <h4>Specifying Named Graphs</h4>
          <p>A query can supply IRIs for the named graphs in the RDF Dataset using the <code>FROM
              NAMED</code> clause. Each IRI is used to provide one named graph in the RDF Dataset. Using
            the same IRI in two or more <code>FROM NAMED</code> clauses results in one named graph with
            that IRI appearing in the dataset.</p>
          <pre class="data nohighlight">
<b># Graph: http://example.org/bob</b>
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;

_:a foaf:name "Bob" .
_:a foaf:mbox &lt;mailto:bob@oldcorp.example.org&gt; .
          </pre>
          <pre class="data nohighlight">
<b># Graph: http://example.org/alice</b>
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;

_:a foaf:name "Alice" .
_:a foaf:mbox &lt;mailto:alice@work.example&gt; .
          </pre>
          <div class="queryGroup">
            <pre class="query nohighlight">
...
FROM NAMED &lt;http://example.org/alice&gt;
FROM NAMED &lt;http://example.org/bob&gt;
...
            </pre>
          </div>
          <p>
            The <code>FROM NAMED</code> syntax suggests that the IRI identifies the corresponding
            graph, but the relationship between an IRI and a graph in an RDF dataset is indirect. The
            IRI identifies a resource, and the resource is represented by a graph (or, more precisely:
            by a document that serializes a graph). For 
            <a data-cite="?WEBARCH#intro">further details</a> see [[WEBARCH]].
          </p>
        </section>
        <section id="specDataset">
          <h4>Combining FROM and FROM NAMED</h4>
          <p>The <code>FROM</code> clause and <code>FROM NAMED</code> clause can be used in the same
            query.</p>
          <div class="exampleGroup">
            <pre class="data nohighlight">
# <b>Default graph (located at http://example.org/dft.ttl)
</b>PREFIX dc: &lt;http://purl.org/dc/elements/1.1/&gt;

&lt;http://example.org/bob&gt;    dc:publisher  "Bob Hacker" .
&lt;http://example.org/alice&gt;  dc:publisher  "Alice Hacker" .
            </pre>
            <pre class="data nohighlight">
# <b>Named graph: http://example.org/bob</b>
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;

_:a foaf:name "Bob" .
_:a foaf:mbox &lt;mailto:bob@oldcorp.example.org&gt; .
            </pre>
            <pre class="data nohighlight">
# <b>Named graph: http://example.org/alice</b>
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;

_:a foaf:name "Alice" .
_:a foaf:mbox &lt;mailto:alice@work.example.org&gt; .
            </pre>
            <pre class="query nohighlight">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX dc: &lt;http://purl.org/dc/elements/1.1/&gt;

SELECT ?who ?g ?mbox
FROM &lt;http://example.org/dft.ttl&gt;
FROM NAMED &lt;http://example.org/alice&gt;
FROM NAMED &lt;http://example.org/bob&gt;
WHERE
{
    ?g dc:publisher ?who .
    GRAPH ?g { ?x foaf:mbox ?mbox }
}
            </pre>
          </div>
          <p>The RDF Dataset for this query contains a default graph and two named graphs. The
            <code>GRAPH</code> keyword is described below.</p>
          <p>The actions required to construct the dataset are not determined by the dataset
            description alone. If an IRI is given twice in a dataset description, either by using two
            <code>FROM</code> clauses, or a <code>FROM</code> clause and a <code>FROM NAMED</code>
            clause, then it does not assume that exactly one or exactly two attempts are made to obtain
            an RDF graph associated with the IRI. Therefore, no assumptions can be made about blank
            node identity in triples obtained from the two occurrences in the dataset description. In
            general, no assumptions can be made about the equivalence of the graphs.</p>
        </section>
      </section>
      <section id="queryDataset">
        <h3>Querying the Dataset</h3>
        <p>When querying a collection of graphs, the <code>GRAPH</code> keyword is used to match
          patterns against named graphs. <code>GRAPH</code> can provide an IRI to select one graph or
          use a variable which will range over the IRI of all the named graphs in the query's RDF
          dataset.</p>
        <p>The use of <code>GRAPH</code> changes the active graph for matching graph patterns within
          that part of the query. Outside the use of <code>GRAPH</code>, matching is done using the
          default graph.</p>
        <p>The following two graphs will be used in examples:</p>
        <div class="exampleGroup">
          <pre class="data nohighlight">
<b># Named graph: http://example.org/foaf/aliceFoaf
</b>PREFIX  foaf:     &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX  rdf:      &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;
PREFIX  rdfs:     &lt;http://www.w3.org/2000/01/rdf-schema#&gt;

_:a  foaf:name     "Alice" .
_:a  foaf:mbox     &lt;mailto:alice@work.example&gt; .
_:a  foaf:knows    _:b .

_:b  foaf:name     "Bob" .
_:b  foaf:mbox     &lt;mailto:bob@work.example&gt; .
_:b  foaf:nick     "Bobby" .
_:b  rdfs:seeAlso  &lt;http://example.org/foaf/bobFoaf&gt; .

&lt;http://example.org/foaf/bobFoaf&gt;
rdf:type      foaf:PersonalProfileDocument .
          </pre>
          <pre class="data nohighlight">
<b># Named graph: http://example.org/foaf/bobFoaf</b>
PREFIX  foaf:     &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX  rdf:      &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;
PREFIX  rdfs:     &lt;http://www.w3.org/2000/01/rdf-schema#&gt;

_:z  foaf:mbox     &lt;mailto:bob@work.example&gt; .
_:z  rdfs:seeAlso  &lt;http://example.org/foaf/bobFoaf&gt; .
_:z  foaf:nick     "Robert" .

&lt;http://example.org/foaf/bobFoaf&gt;
        rdf:type      foaf:PersonalProfileDocument .
          </pre>
        </div>
        <section id="accessByIdentifier">
          <h4>Accessing Graph Names</h4>
          <p>The query below matches the graph pattern against each of the named graphs in the
            dataset and forms solutions which have the <code>src</code> variable bound to IRIs of the
            graph being matched. The graph pattern is matched with the active graph being each of the
            named graphs in the dataset.</p>
          <div class="queryGroup">
            <pre class="query nohighlight">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;

SELECT ?src ?bobNick
FROM NAMED &lt;http://example.org/foaf/aliceFoaf&gt;
FROM NAMED &lt;http://example.org/foaf/bobFoaf&gt;
WHERE
{
    GRAPH ?src
    { ?x foaf:mbox &lt;mailto:bob@work.example&gt; .
      ?x foaf:nick ?bobNick
    }
}
            </pre>
            <p>The query result gives the name of the graphs where the information was found and the
              value for Bob's nick:</p>
            <div class="result">
              <div id="table105"></div>
              <table class="resultTable">
                <tbody>
                  <tr>
                    <th>src</th>
                    <th>bobNick</th>
                  </tr>
                  <tr>
                    <td>&lt;http://example.org/foaf/aliceFoaf&gt;</td>
                    <td>"Bobby"</td>
                  </tr>
                  <tr>
                    <td>&lt;http://example.org/foaf/bobFoaf&gt;</td>
                    <td>"Robert"</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </section>
        <section id="restrictByIdentifier">
          <h4>Restricting by Graph IRI</h4>
          <p>The query can restrict the matching applied to a specific graph by supplying the graph
            IRI. This sets the active graph to the graph named by the IRI. This query looks for Bob's
            nick as given in the graph <code>http://example.org/foaf/bobFoaf</code>.</p>
          <div class="queryGroup">
            <pre class="query nohighlight">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX data: &lt;http://example.org/foaf/&gt;

SELECT ?nick
FROM NAMED &lt;http://example.org/foaf/aliceFoaf&gt;
FROM NAMED &lt;http://example.org/foaf/bobFoaf&gt;
WHERE
{
    GRAPH data:bobFoaf {
        ?x foaf:mbox &lt;mailto:bob@work.example&gt; .
        ?x foaf:nick ?nick 
    }
}
            </pre>
            <p>which yields a single solution:</p>
            <div class="result">
              <div id="table106"></div>
              <table class="resultTable">
                <tbody>
                  <tr>
                    <th>nick</th>
                  </tr>
                  <tr>
                    <td>"Robert"</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </section>
        <section id="restrictInQuery">
          <h4>Restricting Possible Graph IRIs</h4>
          <p>A variable used in the <code>GRAPH</code> clause may also be used in another
            <code>GRAPH</code> clause or in a graph pattern matched against the default graph in the
            dataset.</p>
          <p>The query below uses the graph with IRI <code>http://example.org/foaf/aliceFoaf</code>
            to find the profile document for Bob; it then matches another pattern against that graph.
            The pattern in the second <code>GRAPH</code> clause finds the blank node (variable
            <code>w</code>) for the person with the same mail box (given by variable <code>mbox</code>)
            as found in the first <code>GRAPH</code> clause (variable <code>whom</code>), because the
            blank node used to match for variable <code>whom</code> from Alice's FOAF file is not the
            same as the blank node in the profile document (they are in different graphs).</p>
          <div class="queryGroup">
            <pre class="query nohighlight">
PREFIX  data:  &lt;http://example.org/foaf/&gt;
PREFIX  foaf:  &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX  rdfs:  &lt;http://www.w3.org/2000/01/rdf-schema#&gt;

SELECT ?mbox ?nick ?ppd
FROM NAMED &lt;http://example.org/foaf/aliceFoaf&gt;
FROM NAMED &lt;http://example.org/foaf/bobFoaf&gt;
WHERE {
    GRAPH data:aliceFoaf {
        ?alice foaf:mbox &lt;mailto:alice@work.example&gt; ;
               foaf:knows ?whom .
        ?whom  foaf:mbox ?mbox ;
               rdfs:seeAlso ?ppd .
        ?ppd  a foaf:PersonalProfileDocument .
    }
    GRAPH ?ppd {
        ?w foaf:mbox ?mbox ;
           foaf:nick ?nick
    }
}
            </pre>
            <div class="result">
              <div id="table107"></div>
              <table class="resultTable">
                <tbody>
                  <tr>
                    <th>mbox</th>
                    <th>nick</th>
                    <th>ppd</th>
                  </tr>
                  <tr>
                    <td>&lt;mailto:bob@work.example&gt;</td>
                    <td>"Robert"</td>
                    <td>&lt;http://example.org/foaf/bobFoaf&gt;</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </section>
        <p>Any triple in Alice's FOAF file giving Bob's <code>nick</code> is not used to provide a
          nick for Bob because the pattern involving variable <code>nick</code> is restricted by
          <code>ppd</code> to a particular Personal Profile Document.</p>
        <section id="namedAndDefaultGraph">
          <h4>Named and Default Graphs</h4>
          <p>Query patterns can involve both the default graph and the named graphs. In this example,
            an aggregator has read in a Web resource on two different occasions. Each time a graph is
            read into the aggregator, it is given an IRI by the local system. The graphs are nearly the
            same but the email address for "Bob" has changed.</p>
          <p>In this example, the default graph is being used to record the provenance information
            and the RDF data actually read is kept in two separate graphs, each of which is given a
            different IRI by the system. The RDF dataset consists of two named graphs and the
            information about them.</p>
          <p>RDF Dataset:</p>
          <div class="exampleGroup">
            <pre class="data nohighlight">
# <b>Default graph</b>
PREFIX dc: &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX g:  &lt;tag:example.org,2005-06-06:&gt;
PREFIX xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt;

g:graph1 dc:publisher "Bob" .
g:graph1 dc:date "2004-12-06"^^xsd:date .

g:graph2 dc:publisher "Bob" .
g:graph2 dc:date "2005-01-10"^^xsd:date .
            </pre>
            <pre class="data nohighlight">
# <b>Graph: locally allocated IRI: tag:example.org,2005-06-06:graph1</b>
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;

_:a foaf:name "Alice" .
_:a foaf:mbox &lt;mailto:alice@work.example&gt; .

_:b foaf:name "Bob" .
_:b foaf:mbox &lt;mailto:bob@oldcorp.example.org&gt; .
            </pre>
            <pre class="data nohighlight">
# <b>Graph: locally allocated IRI: tag:example.org,2005-06-06:graph2</b>
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;

_:a foaf:name "Alice" .
_:a foaf:mbox &lt;mailto:alice@work.example&gt; .

_:b foaf:name "Bob" .
_:b foaf:mbox &lt;mailto:bob@newcorp.example.org&gt; .
            </pre>
            <p>This query finds email addresses, detailing the name of the person and the date the
              information was discovered.</p>
            <div class="queryGroup">
              <pre class="query nohighlight">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX dc:   &lt;http://purl.org/dc/elements/1.1/&gt;

SELECT ?name ?mbox ?date
WHERE {
   ?g dc:publisher ?name ;
      dc:date ?date .
   GRAPH ?g { 
       ?person foaf:name ?name ; foaf:mbox ?mbox
   }
}
              </pre>
              <p>The results show that the email address for "Bob" has changed.</p>
              <div class="result">
                <div id="table108"></div>
                <table class="resultTable">
                  <tbody>
                    <tr>
                      <th>name</th>
                      <th>mbox</th>
                      <th>date</th>
                    </tr>
                    <tr>
                      <td>"Bob"</td>
                      <td>&lt;mailto:bob@oldcorp.example.org&gt;</td>
                      <td>"2004-12-06"^^xsd:date</td>
                    </tr>
                    <tr>
                      <td>"Bob"</td>
                      <td>&lt;mailto:bob@newcorp.example.org&gt;</td>
                      <td>"2005-01-10"^^xsd:date</td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
          </div>
        </section>
      </section>
    </section>
    <section id="basic-federated-query">
      <h2>Basic Federated Query</h2>
      <p>This document incorporates the syntax for SPARQL federation extensions.</p>
      <p>This feature is defined in the document [[[SPARQL11-FEDERATED-QUERY]]].</p>
    </section>
    <section id="solutionModifiers">
      <h2>Solution Sequences and Modifiers</h2>
      <p>Query patterns generate an unordered collection of solutions, each 
        <a href="#defn_sparqlSolutionMapping">solution</a> being a partial function from variables to RDF
        terms. These solutions are then treated as a sequence (a solution sequence), initially in no
        specific order; any sequence modifiers are then applied to create another sequence. Finally,
        this latter sequence is used to generate one of the results of a <a href="#QueryForms">SPARQL
          query form</a>.</p>
      <p>A <span class="definedTerm">solution sequence modifier</span> is one of:</p>
      <ul>
        <li>
          <a href="#modOrderBy">Order</a> modifier: put the solutions in order
        </li>
        <li>
          <a href="#modProjection">Projection</a> modifier: choose certain variables
        </li>
        <li>
          <a href="#modDistinct">Distinct</a> modifier: ensure solutions in the sequence are unique
        </li>
        <li>
          <a href="#modReduced">Reduced</a> modifier: permit elimination of some non-distinct
          solutions
        </li>
        <li>
          <a href="#modOffset">Offset</a> modifier: control where the solutions start from in the
          overall sequence of solutions
        </li>
        <li>
          <a href="#modResultLimit">Limit</a> modifier: restrict the number of solutions
        </li>
      </ul>
      <p>Modifiers are applied in the order given by the list above.</p>
      <section id="modOrderBy">
        <h3>ORDER BY</h3>
        <p>The <code>ORDER BY</code> clause establishes the order of a solution sequence.</p>
        <p>Following the <code>ORDER BY</code> clause is a sequence of order comparators, composed of
          an expression and an optional order modifier (either <code>ASC()</code> or
          <code>DESC()</code>). Each ordering comparator is either ascending (indicated by the
          <code>ASC()</code> modifier or by no modifier) or descending (indicated by the
          <code>DESC()</code> modifier).</p>
        <div class="exampleGroup">
          <div class="queryGroup">
            <pre class="query nohighlight">
PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;

SELECT ?name
WHERE { ?x foaf:name ?name }
ORDER BY ?name
            </pre>
          </div>
        </div>
        <div class="exampleGroup">
          <div class="queryGroup">
            <pre class="query nohighlight">
PREFIX     :    &lt;http://example.org/ns#&gt;
PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;

SELECT ?name
WHERE { ?x foaf:name ?name ; :empId ?emp }
ORDER BY DESC(?emp)
            </pre>
          </div>
        </div>
        <div class="exampleGroup">
          <div class="queryGroup">
            <pre class="query nohighlight">
PREFIX     :    &lt;http://example.org/ns#&gt;
PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;

SELECT ?name
WHERE { ?x foaf:name ?name ; :empId ?emp }
ORDER BY ?name DESC(?emp)
            </pre>
          </div>
        </div>
        <p>The <a href="#op_lt">"&lt;" operator</a> (see the <a href="#OperatorMapping">operator
            mapping</a> and <a href="#operatorExtensibility">operator extensibility</a>) defines
          the relative order of pairs of <code>numerics</code>,
          <code>xsd:strings</code>, <code>xsd:booleans</code> and <code>xsd:dateTimes</code>. Pairs of
          IRIs are ordered by comparing them as literals with datatype <code>xsd:string</code>.</p>
        <p>SPARQL also fixes an order between some kinds of RDF terms that would not otherwise be
          ordered:</p>
        <ol>
          <li>(Lowest) no value assigned to the variable or expression in this solution.</li>
          <li>Blank nodes</li>
          <li>IRIs</li>
          <li>RDF literals</li>
          <li>Triple terms</li>
        </ol>
        <p>SPARQL does not define a total ordering of all possible RDF terms. Implementations may
          define total ordering through <a href="#operatorExtensibility">operator extensibility</a>. Here are a few examples
          of pairs of terms for which the relative order is undefined:</p>
        <ul>
          <li>"a" and "a"@en_gb (a literal with datatype <code>xsd:string</code> and a literal with a language tag)</li>
          <li>"a"@en_gb and "b"@en_gb (two literals with language tags)</li>
          <li>"a" and "1"^^xsd:integer (a literal with datatype <code>xsd:string</code> and a literal with a supported
            datatype)</li>
          <li>"1"^^my:integer and "2"^^my:integer (two unsupported datatypes)</li>
          <li>"1"^^xsd:integer and "2"^^my:integer (a supported datatype and an unsupported
            datatype)</li>
          <li>&lt;&lt; :person1 foaf:name "Bob" &gt;&gt; and &lt;&lt; :person2 foaf:name "Alice" &gt;&gt; (two triple terms)</li>
        </ul>
        <p>This list of variable bindings is in ascending order:</p>
        <div class="result">
          <table class="resultTable">
            <thead>
              <tr>
                <th>RDF Term</th>
                <th>Reason</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td></td>
                <td>Unbound results sort earliest.</td>
              </tr>
              <tr>
                <td><code>_:z</code></td>
                <td>Blank nodes follow unbound.</td>
              </tr>
              <tr>
                <td><code>_:a</code></td>
                <td>There is no relative ordering of blank nodes.</td>
              </tr>
              <tr>
                <td><code>&lt;http://script.example/Latin&gt;</code></td>
                <td>IRIs follow blank nodes.</td>
              </tr>
              <tr>
                <td><code>&lt;http://script.example/ÐšÐ¸Ñ€Ð¸Ð»Ð»Ð¸Ñ†Ð°&gt;</code></td>
                <td>The character in the 23rd position, "Ðš", has a unicode codepoint 0x41A, which is
                  higher than 0x4C ("L").</td>
              </tr>
              <tr>
                <td><code>&lt;http://script.example/æ¼¢å­—&gt;</code></td>
                <td>The character in the 23rd position, "æ¼¢", has a unicode codepoint 0x6F22, which is
                  higher than 0x41A ("Ðš").</td>
              </tr>
              <tr>
                <td><code>"http://script.example/Latin"</code></td>
                <td><code>xsd:strings</code> follow IRIs.</td>
              </tr>
            </tbody>
          </table>
        </div>
        <p>The ascending order of two solutions with respect to an ordering comparator is established
          by substituting the solution bindings into the expressions and comparing them with the
          <a href="#op_lt">"&lt;" operator</a>. The descending order is the reverse of the ascending
          order.</p>
        <p>The relative order of two solutions is the relative order of the two solutions with
          respect to the first ordering comparator in the sequence. For solutions where the
          substitutions of the solution bindings produce the same RDF term, the order is the relative
          order of the two solutions with respect to the next ordering comparator. The relative order
          of two solutions is undefined if no order expression evaluated for the two solutions produces
          distinct RDF terms.</p>
        <p>Ordering a sequence of solutions always results in a sequence with the same number of
          solutions in it.</p>
        <p>Using <code>ORDER BY</code> on a solution sequence for a <code>CONSTRUCT</code> or
          <code>DESCRIBE</code> query has no direct effect because only <code>SELECT</code> returns a
          sequence of results. Used in combination with <code>LIMIT</code> and <code>OFFSET</code>,
          <code>ORDER BY</code> can be used to return results generated from a different slice of the
          solution sequence. An <code>ASK</code> query does not include <code>ORDER BY</code>,
          <code>LIMIT</code> or <code>OFFSET</code>.</p>
      </section>
      <section id="modProjection">
        <h3>Projection</h3>
        <p>The solution sequence can be transformed into one involving only a subset of the
          variables. For each solution in the sequence, a new solution is formed using a specified
          selection of the variables using the SELECT query form.</p>
        <p>The following example shows a query to extract just the names of people described in an
          RDF graph using FOAF properties.</p>
        <div class="exampleGroup">
          <pre class="data nohighlight">
PREFIX foaf:        &lt;http://xmlns.com/foaf/0.1/&gt;

_:a  foaf:name       "Alice" .
_:a  foaf:mbox       &lt;mailto:alice@work.example&gt; .

_:b  foaf:name       "Bob" .
_:b  foaf:mbox       &lt;mailto:bob@work.example&gt; .
          </pre>
          <div class="queryGroup">
            <pre class="query nohighlight">
PREFIX foaf:       &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name
WHERE
{ ?x foaf:name ?name }
            </pre>
            <div class="result">
              <table class="resultTable">
                <tbody>
                  <tr>
                    <th>name</th>
                  </tr>
                  <tr>
                    <td>"Bob"</td>
                  </tr>
                  <tr>
                    <td>"Alice"</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>
      </section>
      <section id="modDuplicates">
        <h3>Duplicate Solutions</h3>
        <p>A solution sequence with no <code>DISTINCT</code> or <code>REDUCED</code> query modifier
          will preserve duplicate solutions.</p>
        <div class="exampleGroup">
          <p>Data:</p>
          <pre class="data nohighlight">
PREFIX  foaf:  &lt;http://xmlns.com/foaf/0.1/&gt;

_:x    foaf:name   "Alice" .
_:x    foaf:mbox   &lt;mailto:alice@example.com&gt; .

_:y    foaf:name   "Alice" .
_:y    foaf:mbox   &lt;mailto:asmith@example.com&gt; .

_:z    foaf:name   "Alice" .
_:z    foaf:mbox   &lt;mailto:alice.smith@example.com&gt; .
          </pre>
          <div class="queryGroup">
            <p>Query:</p>
            <pre class="query nohighlight">
PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name WHERE { ?x foaf:name ?name }
            </pre>
            <div class="result">
              <p>Results:</p>
              <table class="resultTable">
                <tbody>
                  <tr>
                    <th>name</th>
                  </tr>
                  <tr>
                    <td>"Alice"</td>
                  </tr>
                  <tr>
                    <td>"Alice"</td>
                  </tr>
                  <tr>
                    <td>"Alice"</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
          <p>The modifiers <code>DISTINCT</code> and <code>REDUCED</code> affect whether duplicates
            are included in the query results.</p>
          <section id="modDistinct">
            <h4>DISTINCT</h4>
            <p>The <code>DISTINCT</code> solution modifier eliminates duplicate solutions. Only one
              solution solution that binds the same variables to the same RDF terms is returned from
              the query.</p>
            <div class="queryGroup">
              <pre class="query nohighlight">
PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT DISTINCT ?name WHERE { ?x foaf:name ?name }
              </pre>
              <div class="result">
                <table class="resultTable">
                  <tbody>
                    <tr>
                      <th>name</th>
                    </tr>
                    <tr>
                      <td>"Alice"</td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
            <p id="defunSELECT">Note that, per the <a href="#solutionModifiers">order of solution
                sequence modifiers</a>, duplicates are eliminated before either limit or offset is
              applied.</p>
          </section>
          <section id="modReduced">
            <h4>REDUCED</h4>
            <p>While the <code>DISTINCT</code> modifier ensures that duplicate solutions are
              eliminated from the solution set, <code>REDUCED</code> simply permits them to be
              eliminated. The multiplicity of any solution in a <code>REDUCED</code>
              solution set is at least one and not more than the multiplicity of the solution within the solution set with
              no <code>DISTINCT</code> or <code>REDUCED</code> modifier. For example, using the data
              above, the query</p>
            <div class="queryGroup">
              <pre class="query nohighlight">
PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT REDUCED ?name WHERE { ?x foaf:name ?name }
              </pre>
              <p>may have one, two (shown here) or three solutions:</p>
              <div class="result">
                <table class="resultTable">
                  <tbody>
                    <tr>
                      <th>name</th>
                    </tr>
                    <tr>
                      <td>"Alice"</td>
                    </tr>
                    <tr>
                      <td>"Alice"</td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
          </section>
        </div>
      </section>
      <section id="modOffset">
        <h3>OFFSET</h3>
        <p><code>OFFSET</code> causes the solutions generated to start after the specified number of
          solutions. An <code>OFFSET</code> of zero has no effect.</p>
        <p>Using <code>LIMIT</code> and <code>OFFSET</code> to select different subsets of the query
          solutions will not be useful unless the order is made predictable by using <code>ORDER
            BY</code>.</p>
        <div class="exampleGroup">
          <div class="queryGroup">
            <pre class="query nohighlight">
PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;

SELECT  ?name
WHERE   { ?x foaf:name ?name }
ORDER BY ?name
LIMIT   5
OFFSET  10
            </pre>
          </div>
        </div>
      </section>
      <section id="modResultLimit">
        <h3>LIMIT</h3>
        <p>The <code>LIMIT</code> clause puts an upper bound on the number of solutions returned. If
          the number of actual solutions, after <code>OFFSET</code> is applied, is greater than the
          limit, then at most the limit number of solutions will be returned.</p>
        <div class="exampleGroup">
          <div class="queryGroup">
            <pre class="query nohighlight">
PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;

SELECT ?name
WHERE { ?x foaf:name ?name }
LIMIT 20
            </pre>
          </div>
        </div>
        <p>A <code>LIMIT</code> of 0 would cause no results to be returned. A limit may not be
          negative.</p>
      </section>
    </section>
    <section id="QueryForms">
      <h2>Query Forms</h2>
      <p>SPARQL has four query forms. These query forms use the solutions from pattern matching to
        form result sets or RDF graphs. The query forms are:</p>
      <blockquote>
        <dl>
          <dt>
            <a href="#select">SELECT</a>
          </dt>
          <dd>Returns all, or a subset of, the variables bound in a query pattern match.</dd>
          <dt>
            <a href="#construct">CONSTRUCT</a>
          </dt>
          <dd>Returns an RDF graph constructed by substituting variables in a set of triple
            templates.</dd>
          <dt>
            <a href="#ask">ASK</a>
          </dt>
          <dd>Returns a boolean indicating whether a query pattern matches or not.</dd>
          <dt>
            <a href="#describe">DESCRIBE</a>
          </dt>
          <dd>Returns an RDF graph that describes the resources found.</dd>
        </dl>
      </blockquote>
      <p>Formats such as [[[SPARQL11-RESULTS-JSON]]], [[[RDF-SPARQL-XMLRES]]] or
        [[[SPARQL11-RESULTS-CSV-TSV]]] can be used to serialize the result set from a
        <code>SELECT</code> query or the boolean result of an <code>ASK</code> query.</p>
      <section id="select">
        <h3>SELECT</h3>
        <p>The SELECT form of results returns variables and their bindings directly. It combines the
          operations of projecting the required variables with introducing new variable bindings into a
          query solution.</p>
        <section id="selectproject">
          <h4>Projection</h4>
          <p>Specific variables and their bindings are returned when a list of variable names is
            given in the SELECT clause. The syntax <code>SELECT *</code> is an abbreviation that
            selects all of the variables that are <a href="#variableScope">in-scope</a> at that point
            in the query. It excludes variables only used in <code>FILTER</code>, in the right-hand
            side of <code>MINUS</code>, and takes account of subqueries.</p>
          <p>Use of <code>SELECT *</code> is only permitted when the query does not have a
            <code>GROUP BY</code> clause.</p>
          <div class="exampleGroup">
            <pre class="data nohighlight">
PREFIX  foaf:  &lt;http://xmlns.com/foaf/0.1/&gt;

_:a    foaf:name   "Alice" .
_:a    foaf:knows  _:b .
_:a    foaf:knows  _:c .

_:b    foaf:name   "Bob" .

_:c    foaf:name   "Clare" .
_:c    foaf:nick   "CT" .         
            </pre>
            <div class="queryGroup">
              <pre class="query nohighlight">
PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?nameX ?nameY ?nickY
WHERE
{ ?x foaf:knows ?y ;
  foaf:name ?nameX .
  ?y foaf:name ?nameY .
  OPTIONAL { ?y foaf:nick ?nickY }
}</pre>
              <div class="result">
                <div id="table33"></div>
                <table class="resultTable">
                  <tbody>
                    <tr>
                      <th>nameX</th>
                      <th>nameY</th>
                      <th>nickY</th>
                    </tr>
                    <tr>
                      <td>"Alice"</td>
                      <td>"Bob"</td>
                      <td></td>
                    </tr>
                    <tr>
                      <td>"Alice"</td>
                      <td>"Clare"</td>
                      <td>"CT"</td>
                    </tr>
                  </tbody>
                </table>
              </div>
              <p>Result sets can be accessed by a local API but also can be serialized into either
                JSON, XML, CSV or TSV.</p>
              <p>[[[SPARQL11-RESULTS-JSON]]]:</p>
              <div class="result">
                <pre class="resultSet">
{
    "head": {
        "vars": [ "nameX" , "nameY" , "nickY" ]
    } ,
    "results": {
        "bindings": [
          {
            "nameX": { "type": "literal" , "value": "Alice" } ,
            "nameY": { "type": "literal" , "value": "Bob" }
          } ,
          {
            "nameX": { "type": "literal" , "value": "Alice" } ,
            "nameY": { "type": "literal" , "value": "Clare" } ,
            "nickY": { "type": "literal" , "value": "CT" }
          }
        ]
    }
}
                </pre>
              </div>
              <p>[[[RDF-SPARQL-XMLRES]]]:</p>
              <div class="result">
                <pre class="resultSet">
&lt;?xml version="1.0"?&gt;
&lt;sparql xmlns="http://www.w3.org/2005/sparql-results#"&gt;
&lt;head&gt;
&lt;variable name="nameX"/&gt;
&lt;variable name="nameY"/&gt;
&lt;variable name="nickY"/&gt;
&lt;/head&gt;
&lt;results&gt;
&lt;result&gt;
&lt;binding name="nameX"&gt;
&lt;literal&gt;Alice&lt;/literal&gt;
&lt;/binding&gt;
&lt;binding name="nameY"&gt;
&lt;literal&gt;Bob&lt;/literal&gt;
&lt;/binding&gt;
&lt;/result&gt;
&lt;result&gt;
&lt;binding name="nameX"&gt;
&lt;literal&gt;Alice&lt;/literal&gt;
&lt;/binding&gt;
&lt;binding name="nameY"&gt;
&lt;literal&gt;Clare&lt;/literal&gt;
&lt;/binding&gt;
&lt;binding name="nickY"&gt;
&lt;literal&gt;CT&lt;/literal&gt;
&lt;/binding&gt;
&lt;/result&gt;
&lt;/results&gt;
&lt;/sparql&gt;
                </pre>
              </div>
            </div>
          </div>
        </section>
        <section id="selectExpressions">
          <h4>SELECT Expressions</h4>
          <p>As well as choosing which variables from the pattern matching are included in the
            results, the SELECT clause can also introduce new variables. The rules of assignment in
            SELECT expression are the same as for assignment in BIND. The expression combines variable
            bindings already in the query solution, or defined earlier in the SELECT clause, to produce
            a binding in the query solution.</p>
          <p>The scoping for <code>(expr AS v)</code> applies immediately. In <code>SELECT</code>
            expressions, the variable may be used in an expression later in the same
            <code>SELECT</code> clause and may not be be assigned again in the same <code>SELECT</code>
            clause.</p>
          <p>Example:</p>
          <div class="exampleGroup">
            <p>Data:</p>
            <pre class="data nohighlight">
PREFIX dc:   &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX :     &lt;http://example.org/book/&gt;
PREFIX ns:   &lt;http://example.org/ns#&gt;

:book1  dc:title  "SPARQL Tutorial" .
:book1  ns:price  42 .
:book1  ns:discount 0.2 .

:book2  dc:title  "The Semantic Web" .
:book2  ns:price  23 .
:book2  ns:discount 0.25 .</pre>
            <p>Query:</p>
            <div class="queryGroup">
              <pre class="query nohighlight">
PREFIX  dc:  &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX  ns:  &lt;http://example.org/ns#&gt;
SELECT  ?title (?p*(1-?discount) AS ?price)
{ ?x ns:price ?p .
  ?x dc:title ?title . 
  ?x ns:discount ?discount 
}
              </pre>
              <p>Results:</p>
              <div class="result">
                <table class="resultTable">
                  <tbody>
                    <tr>
                      <th>title</th>
                      <th>price</th>
                    </tr>
                    <tr>
                      <td>"The Semantic Web"</td>
                      <td>17.25</td>
                    </tr>
                    <tr>
                      <td>"SPARQL Tutorial"</td>
                      <td>33.6</td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
          </div>
          <p>New variables can also be used in expressions if they are introduced earlier,
            syntactically, in the same SELECT clause:</p>
          <div class="exampleGroup">
            <div class="queryGroup">
              <pre class="query nohighlight">
PREFIX  dc:  &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX  ns:  &lt;http://example.org/ns#&gt;
SELECT  ?title (?p AS ?fullPrice) (?fullPrice*(1-?discount) AS ?customerPrice)
{ ?x ns:price ?p .
  ?x dc:title ?title . 
  ?x ns:discount ?discount 
}
              </pre>
              <p>Results:</p>
              <div class="result">
                <table class="resultTable">
                  <tbody>
                    <tr>
                      <th>title</th>
                      <th>fullPrice</th>
                      <th>customerPrice</th>
                    </tr>
                    <tr>
                      <td>"The Semantic Web"</td>
                      <td>23</td>
                      <td>17.25</td>
                    </tr>
                    <tr>
                      <td>"SPARQL Tutorial"</td>
                      <td>42</td>
                      <td>33.6</td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
          </div>
        </section>
      </section>
      <section id="construct">
        <h3>CONSTRUCT</h3>
        <p>The <code>CONSTRUCT</code> query form returns a single RDF graph specified by a graph
          template. The result is an RDF graph formed by taking each query solution in the solution
          sequence, substituting for the variables in the graph template, and combining the triples
          into a single RDF graph by set union.</p>
        <p>If any such instantiation produces a triple containing an unbound variable or an illegal
          RDF construct, such as a literal in subject or predicate position, then that triple is not
          included in the output RDF graph. The graph template can contain triples with no variables
          (known as ground or explicit triples), and these also appear in the output RDF graph returned
          by the CONSTRUCT query form.</p>
        <p class="note">
          The construction of the result graph by "set union" does not
          enforce whether or not duplicated triples appear in the graph serialization.
          Implementations are allowed to produce duplicate triples or to deduplicate them.
        </p>
        <div class="exampleGroup">
          <pre class="data nohighlight">
PREFIX  foaf:  &lt;http://xmlns.com/foaf/0.1/&gt;

_:a    foaf:name   "Alice" .
_:a    foaf:mbox   &lt;mailto:alice@example.org&gt; .
          </pre>
          <div class="queryGroup">
            <pre class="query nohighlight">
PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX vcard:   &lt;http://www.w3.org/2001/vcard-rdf/3.0#&gt;
CONSTRUCT   { &lt;http://example.org/person#Alice&gt; vcard:FN ?name }
WHERE       { ?x foaf:name ?name }
            </pre>
            <p>creates vcard properties from the FOAF information:</p>
            <div class="result">
              <pre class="resultGraph" style="text-align:left;">
PREFIX vcard: &lt;http://www.w3.org/2001/vcard-rdf/3.0#&gt;

&lt;http://example.org/person#Alice&gt; vcard:FN "Alice" .
              </pre>
            </div>
          </div>
        </div>
        <section id="templatesWithBNodes">
          <h4>Templates with Blank Nodes</h4>
          <p>A template can create an RDF graph containing blank nodes. 
            The blank node identifiers inside the template are scoped to the
            template for each solution, while blank nodes from query solutions
            are not scoped.
            If the same identifier occurs twice in a template, every occurrence
            is replaced by the same blank node which is created for each
            query solution, and there will be different blank nodes for triples
            generated by different query solutions.
          </p>
          <div class="exampleGroup">
            <pre class="data nohighlight">
PREFIX  foaf:  &lt;http://xmlns.com/foaf/0.1/&gt;

_:a    foaf:givenname   "Alice" .
_:a    foaf:family_name "Hacker" .

_:b    foaf:firstname   "Bob" .
_:b    foaf:surname     "Hacker" .
            </pre>
            <div class="queryGroup">
              <pre class="query nohighlight">
PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX vcard:   &lt;http://www.w3.org/2001/vcard-rdf/3.0#&gt;

CONSTRUCT {
     ?x  vcard:N _:v .
    _:v vcard:givenName ?gname .
    _:v vcard:familyName ?fname
} WHERE {
    { ?x foaf:firstname ?gname } UNION  { ?x foaf:givenname   ?gname } .
    { ?x foaf:surname   ?fname } UNION  { ?x foaf:family_name ?fname } .
}
              </pre>
              <p>creates vcard properties corresponding to the FOAF information:</p>
              <div class="result">
                <pre class="resultGraph">
PREFIX vcard: &lt;http://www.w3.org/2001/vcard-rdf/3.0#&gt;

_:a vcard:N         _:v1 .
_:v1 vcard:givenName  "Alice" .
_:v1 vcard:familyName "Hacker" .

_:b vcard:N         _:v2 .
_:v2 vcard:givenName  "Bob" .
_:v2 vcard:familyName "Hacker" .
                </pre>
              </div>
            </div>
          </div>
          <p>
            The blank node with identifier <code>_:v</code> in the template
            will be replaced by a different blank node when the template is applied
            to each of the two query solutions.
            In this example, this will cause the template to generate blank nodes
            with identifier <code>_:v1</code> and <code>_:v2</code> in the
            results graph.
          </p>
          <p>
            The blank nodes in the query solutions, shown with identifiers
            <code>_:a</code> and <code>_:b</code>, originate from the underlying
            RDF dataset and will not be altered.
          </p>
        </section>
        <section id="accessingRdfGraphs">
          <h4>Accessing Graphs in the RDF Dataset</h4>
          <p>Using <code>CONSTRUCT</code>, it is possible to extract parts or the whole of graphs
            from the target RDF dataset. This first example returns the graph (if it is in the dataset)
            with IRI label <code>http://example.org/aGraph</code>; otherwise, it returns an empty
            graph.</p>
          <div class="exampleGroup">
            <div class="queryGroup">
              <pre class="query nohighlight">
CONSTRUCT { ?s ?p ?o } WHERE { GRAPH &lt;http://example.org/aGraph&gt; { ?s ?p ?o } . }
              </pre>
            </div>
          </div>
          <p>The access to the graph can be conditional on other information. For example, if the
            default graph contains metadata about the named graphs in the dataset, then a query like
            the following one can extract one graph based on information about the named graph:</p>
          <div class="exampleGroup">
            <div class="queryGroup">
              <pre class="query nohighlight">
PREFIX  dc: &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX app: &lt;http://example.org/ns#&gt;
PREFIX xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt;

CONSTRUCT { ?s ?p ?o } WHERE
{
    GRAPH ?g { ?s ?p ?o } .
    ?g dc:publisher &lt;http://www.w3.org/&gt; .
    ?g dc:date ?date .
    FILTER ( app:customDate(?date) &gt; "2005-02-28T00:00:00Z"^^xsd:dateTime ) .
}
              </pre>
            </div>
          </div>
          <p>where <code>app:customDate</code> identifies an <a href="#extensionFunctions">extension
              function</a> to turn the date format into an <code>xsd:dateTime</code> RDF term.</p>
        </section>
        <section id="SolModandCONSTRUCT">
          <h4>Solution Modifiers and CONSTRUCT</h4>
          <p>The solution modifiers of a query affect the results of a <code>CONSTRUCT</code> query.
            In this example, the output graph from the <code>CONSTRUCT</code> template is derived from
            just two of the solutions from graph pattern matching. The query outputs a graph with the
            names of the people with the top two sites, rated by hits. The triples in the RDF graph are
            not ordered.</p>
          <div class="exampleGroup">
            <pre class="data nohighlight">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX site: &lt;http://example.org/stats#&gt;

_:a foaf:name "Alice" .
_:a site:hits 2349 .

_:b foaf:name "Bob" .
_:b site:hits 105 .

_:c foaf:name "Eve" .
_:c site:hits 181 .
            </pre>
            <div class="queryGroup">
              <pre class="query nohighlight">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX site: &lt;http://example.org/stats#&gt;

CONSTRUCT { [] foaf:name ?name }
WHERE
{ [] foaf:name ?name ;
  site:hits ?hits .
}
ORDER BY desc(?hits)
LIMIT 2
              </pre>
              <div class="result">
                <pre class="resultGraph">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
_:x foaf:name "Alice" .
_:y foaf:name "Eve" .
                </pre>
              </div>
            </div>
          </div>
        </section>
        <section id="constructWhere">
          <h4>CONSTRUCT WHERE</h4>
          <p>A short form for the CONSTRUCT query form is provided for the case where the template
            and the pattern are the same and the pattern is just a basic graph pattern (no
            <code>FILTER</code>s and no complex graph patterns are allowed in the short form). The
            keyword <code>WHERE</code> is required in the short form.</p>
          <p>The following two queries are the same; the first is a short form of the second.</p>
          <pre class="query nohighlight">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
CONSTRUCT WHERE { ?x foaf:name ?name } 
          </pre>
          <pre class="query nohighlight">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;

CONSTRUCT { ?x foaf:name ?name } 
WHERE
{ ?x foaf:name ?name }
          </pre>
        </section>
      </section>
      <section id="ask">
        <h3>ASK</h3>
        <p>Applications can use the <code>ASK</code> form to test whether or not a query pattern has
          a solution. No information is returned about the possible query solutions, just whether or
          not a solution exists.</p>
        <div class="exampleGroup">
          <pre class="data nohighlight">
PREFIX foaf:       &lt;http://xmlns.com/foaf/0.1/&gt;

_:a  foaf:name       "Alice" .
_:a  foaf:homepage   &lt;http://work.example.org/alice/&gt; .

_:b  foaf:name       "Bob" .
_:b  foaf:mbox       &lt;mailto:bob@work.example&gt; .
          </pre>
          <div class="queryGroup">
            <pre class="query nohighlight">
PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;
ASK  { ?x foaf:name  "Alice" }
            </pre>
            <div class="result">
              <pre class="resultAsk">true</pre>
            </div>
            <p>The [[[RDF-SPARQL-XMLRES]]] form of this result set gives:</p>
            <div class="result">
              <pre class="resultSet">&lt;?xml version="1.0"?&gt;
                &lt;sparql xmlns="http://www.w3.org/2005/sparql-results#"&gt;
                &lt;head&gt;&lt;/head&gt;
                &lt;boolean&gt;true&lt;/boolean&gt;
                &lt;/sparql&gt;
              </pre>
            </div>
          </div>
          <p>On the same data, the following returns no match because Alice's <code>mbox</code> is
            not mentioned.</p>
          <div class="queryGroup">
            <pre class="query nohighlight">
PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;
ASK  {
   ?x foaf:name  "Alice" ;
      foaf:mbox  &lt;mailto:alice@work.example&gt;
}
            </pre>
            <div class="result">
              <pre class="resultAsk">false</pre>
            </div>
          </div>
        </div>
      </section>
      <section id="describe">
        <h3>DESCRIBE (Informative)</h3>
        <p>The <code>DESCRIBE</code> form returns a single result RDF graph containing RDF data about
          resources. This data is not prescribed by a SPARQL query, where the query client would need
          to know the structure of the RDF in the data source, but, instead, is determined by the
          SPARQL query processor. The query pattern is used to create a result set. The
          <code>DESCRIBE</code> form takes each of the resources identified in a solution, together
          with any resources directly named by IRI, and assembles a single RDF graph by taking a
          "description" which can come from any information available including the target RDF Dataset.
          The description is determined by the query service. The syntax <code>DESCRIBE *</code> is an
          abbreviation that describes all of the variables in a query.</p>
        <section id="explicitIRIs">
          <h4>Explicit IRIs</h4>
          <p>The <code>DESCRIBE</code> clause itself can take IRIs to identify the resources. The
            simplest <code>DESCRIBE</code> query is just an IRI in the <code>DESCRIBE</code>
            clause:</p>
          <div class="exampleGroup">
            <div class="queryGroup">
              <pre class="query nohighlight">
DESCRIBE &lt;http://example.org/&gt;
              </pre>
            </div>
          </div>
        </section>
        <section id="identifyingResources">
          <h4>Identifying Resources</h4>
          <p>The resources to be described can also be taken from the bindings to a query variable in
            a result set. This enables description of resources whether they are identified by IRI or
            by blank node in the dataset:</p>
          <div class="exampleGroup">
            <div class="queryGroup">
              <pre class="query nohighlight">
PREFIX foaf:   &lt;http://xmlns.com/foaf/0.1/&gt;
DESCRIBE ?x
WHERE    { ?x foaf:mbox &lt;mailto:alice@org&gt; }
              </pre>
            </div>
          </div>
          <p>The property <code>foaf:mbox</code> is defined as being an inverse functional property
            in the FOAF vocabulary. If treated as such, this query will return information about at
            most one person. If, however, the query pattern has multiple solutions, the RDF data for
            each is the union of all RDF graph descriptions.</p>
          <div class="exampleGroup">
            <div class="queryGroup">
              <pre class="query nohighlight">
PREFIX foaf:   &lt;http://xmlns.com/foaf/0.1/&gt;
DESCRIBE ?x
WHERE    { ?x foaf:name "Alice" }
              </pre>
            </div>
          </div>
          <p>More than one IRI or variable can be given:</p>
          <div class="exampleGroup">
            <div class="queryGroup">
              <pre class="query nohighlight">
PREFIX foaf:   &lt;http://xmlns.com/foaf/0.1/&gt;
DESCRIBE ?x ?y &lt;http://example.org/&gt;
WHERE    {?x foaf:knows ?y}
              </pre>
            </div>
          </div>
        </section>
        <section id="descriptionsOfResources">
          <h4>Descriptions of Resources</h4>
          <p>The RDF returned is determined by the information publisher. It may be information the
            service deems relevant to the resources being described. It may include information about
            other resources: for example, the RDF data for a book may also include details about the
            author.</p>
          <p>A simple query such as</p>
          <div class="exampleGroup">
            <div class="queryGroup">
              <pre class="query nohighlight">
PREFIX ent:  &lt;http://org.example.com/employees#&gt;
DESCRIBE ?x WHERE { ?x ent:employeeId "1234" }
              </pre>
              <p>might return a description of the employee and some other potentially useful
                details:</p>
              <div class="result">
                <pre class="resultGraph">
PREFIX foaf:   &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX vcard:  &lt;http://www.w3.org/2001/vcard-rdf/3.0&gt;
PREFIX exOrg:  &lt;http://org.example.com/employees#&gt;
PREFIX rdf:    &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;
PREFIX owl:    &lt;http://www.w3.org/2002/07/owl#&gt;

_:a     exOrg:employeeId    "1234" ;
        foaf:mbox_sha1sum   "bee135d3af1e418104bc42904596fe148e90f033" ;
        vcard:N
          [ vcard:Family       "Smith" ;
            vcard:Given        "John"  ] .
foaf:mbox_sha1sum  rdf:type  owl:InverseFunctionalProperty .
                </pre>
              </div>
            </div>
          </div>
          <p>which includes the blank node closure for the 
            <a data-cite="vcard-rdf#" class="inform">vCard vocabulary</a> <code>vcard:N</code>.
            Other possible mechanisms for deciding what
            information to return include Concise Bounded Descriptions [[CBD]].</p>
          <p>For a vocabulary such as FOAF, where the resources are typically blank nodes, returning
            sufficient information to identify a node such as the InverseFunctionalProperty
            <code>foaf:mbox_sha1sum</code> as well as information like name and other details recorded
            would be appropriate. In the example, the match to the <code>WHERE</code> clause was
            returned, but this is not required.</p>
        </section>
      </section>
    </section>
    <section id="expressions">
      <h2>Expressions and Testing Values</h2>
      <p>
        SPARQL <code>FILTERs</code> restrict the solutions of a graph pattern match according to a
        given <a href="#rConstraint">constraint</a>. Specifically, <code>FILTERs</code> eliminate any
        solutions that, when substituted into the expression, either result in an effective boolean
        value of <code>false</code> or produce an error. Effective boolean values are defined in
        section <a href="#ebv"> <em>Effective Boolean Value</em></a> and errors are defined in
        <a href="#sparql-error">Evaluation Errors</a>.
      </p>
      <div class="exampleGroup">
        <p><a data-cite="RDF12-CONCEPTS#dfn-literal">RDF Literals</a> have datatypes 
          that determine the value of the literal.</p>
        <pre class="data nohighlight">
PREFIX a:          &lt;http://www.w3.org/2000/10/annotation-ns#&gt;
PREFIX dc:         &lt;http://purl.org/dc/elements/1.1/&gt;

_:a   a:annotates   &lt;http://www.w3.org/TR/rdf-sparql-query/&gt; .
_:a   dc:date       "2004-12-31T19:00:00-05:00" .

_:b   a:annotates   &lt;http://www.w3.org/TR/rdf-sparql-query/&gt; .
_:b   dc:date       "2004-12-31T19:01:00-05:00"^^&lt;http://www.w3.org/2001/XMLSchema#dateTime&gt; .</pre>
        <p>The object of the first <code>dc:date</code> triple is a literal
          that has a datatype of <code>xsd:string</code>.
          The second has the datatype <code>xsd:dateTime</code>.
          They are different <a data-cite="RDF12-CONCEPTS#dfn-rdf-term">RDF terms</a>
          with different values.
        </p>
        <p>SPARQL expressions are constructed according to the grammar and provide access to
          functions (named by IRI) and operator functions (invoked by keywords and symbols in the
          SPARQL grammar). SPARQL operators can be used to compare the values of literals:</p>
        <div class="queryGroup">
          <pre class="query nohighlight">
PREFIX a:      &lt;http://www.w3.org/2000/10/annotation-ns#&gt;
PREFIX dc:     &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX xsd:    &lt;http://www.w3.org/2001/XMLSchema#&gt;

SELECT ?annot
WHERE { ?annot  a:annotates  &lt;http://www.w3.org/TR/rdf-sparql-query/&gt; .
        ?annot  dc:date      ?date .
        FILTER ( ?date &gt; "2005-01-01T00:00:00Z"^^xsd:dateTime ) 
}
          </pre>
        </div>
      </div>
      <p>The SPARQL operators are listed in <a href="#OperatorMapping">section 17.3</a> and are
        associated with their productions in the grammar.</p>
      <p>In addition, SPARQL provides the ability to invoke arbitrary functions, including a subset
        of the XPath casting functions, listed in <a href="#FunctionMapping">section 17.5</a>. These
        functions are invoked by name (an IRI) within a SPARQL query. For example:</p>
      <pre class="query nohighlight">
        ... FILTER ( xsd:dateTime(?date) &lt; xsd:dateTime("2005-01-01T00:00:00Z") ) ...</pre>
      <p>Typographical convention: XPath operators are labeled with the prefix
        <code>op:</code>. XPath operators have no namespace; <code>op:</code> is a labeling
        convention.</p>
      <section id="operandDataTypes">
        <h3>Operand Data Types</h3>
        <p>SPARQL functions and operators operate on RDF terms and SPARQL variables. A subset of
          these functions and operators are taken from the [[[XPATH-FUNCTIONS-31]]] [[XPATH-FUNCTIONS-31]] and have XML Schema
          <a data-cite="XPATH-31#dt-typed-value">typed value</a> arguments and return types. RDF
          <code>literals</code> passed as arguments to these functions and operators are mapped
          to XML Schema typed values with a <a data-cite="XPATH-31#dt-string-value">string value</a> of
          the <code>lexical form</code> and an 
          <a data-cite="XMLSCHEMA11-2#dt-atomic">atomic datatype</a> corresponding to the
          <span class="type datatypeIRI">datatype IRI</span>. The returned typed values are mapped back
          to RDF <code>literals</code> the same way.</p>
        <p>SPARQL has additional operators which operate on specific subsets of RDF terms. When
          referring to a type, the following terms denote a <code>literal</code> with the
          corresponding [[[XMLSCHEMA11-2]]] [[XMLSCHEMA11-2]] <span class="type datatypeIRI">datatype
            IRI</span>:</p>
        <ul>
          <li><code><a data-cite="XMLSCHEMA11-2#dt-integer">xsd:integer</a></code></li>
          <li><code><a data-cite="XMLSCHEMA11-2#dt-decimal">xsd:decimal</a></code></li>
          <li><code><a data-cite="XMLSCHEMA11-2#dt-float">xsd:float</a></code></li>
          <li><code><a data-cite="XMLSCHEMA11-2#dt-double">xsd:double</a></code></li>
          <li><code><a data-cite="XMLSCHEMA11-2#dt-string">xsd:string</a></code></li>
          <li><code><a data-cite="XMLSCHEMA11-2#dt-boolean">xsd:boolean</a></code></li>
          <li><code><a data-cite="XMLSCHEMA11-2#dt-dateTime">xsd:dateTime</a></code></li>
        </ul>
        <p>The following terms identify additional types used in SPARQL value tests:</p>
        <ul>
          <li><span class="type numeric">numeric</span> denotes
            <a data-cite="RDF12-CONCEPTS#dfn-literal">literals</a>
            with datatypes <code>xsd:integer</code>, <code>xsd:decimal</code>, <code>xsd:float</code>, or
            <code>xsd:double</code>.
          </li>
          <li><span class="type RDFterm">RDF term</span> denotes the types
            <a data-cite="RDF12-CONCEPTS#dfn-iri">IRI</a>,
            <a data-cite="RDF12-CONCEPTS#dfn-literal">literal</a>,
            <a data-cite="RDF12-CONCEPTS#dfn-blank-node">blank node</a>, or
            <a data-cite="RDF12-CONCEPTS#dfn-triple-term">triple term</a>.
          </li>
          <li><span class="type variable">variable</span> denotes a SPARQL variable.</li>
        </ul>
        <p>The following types are derived from <span class="type numeric">numeric</span> types and
          are valid arguments to functions and operators taking <span class="type numeric">numeric</span> arguments:</p>
        <ul>
          <li>
            <a data-cite="XMLSCHEMA11-2#dt-nonPositiveInteger"><code>xsd:nonPositiveInteger</code></a>
          </li>
          <li>
            <a data-cite="XMLSCHEMA11-2#dt-negativeInteger"><code>xsd:negativeInteger</code></a>
          </li>
          <li>
            <a data-cite="XMLSCHEMA11-2#dt-long"><code>xsd:long</code></a>
          </li>
          <li>
            <a data-cite="XMLSCHEMA11-2#dt-int"><code>xsd:int</code></a>
          </li>
          <li>
            <a data-cite="XMLSCHEMA11-2#dt-short"><code>xsd:short</code></a>
          </li>
          <li>
            <a data-cite="XMLSCHEMA11-2#dt-byte"><code>xsd:byte</code></a>
          </li>
          <li>
            <a data-cite="XMLSCHEMA11-2#dt-nonNegativeInteger"><code>xsd:nonNegativeInteger</code></a>
          </li>
          <li>
            <a data-cite="XMLSCHEMA11-2#dt-unsignedLong"><code>xsd:unsignedLong</code></a>
          </li>
          <li>
            <a data-cite="XMLSCHEMA11-2#dt-unsignedInt"><code>xsd:unsignedInt</code></a>
          </li>
          <li>
            <a data-cite="XMLSCHEMA11-2#dt-unsignedShort"><code>xsd:unsignedShort</code></a>
          </li>
          <li>
            <a data-cite="XMLSCHEMA11-2#dt-unsignedByte"><code>xsd:unsignedByte</code></a>
          </li>
          <li>
            <a data-cite="XMLSCHEMA11-2#dt-positiveInteger"><code>xsd:positiveInteger</code></a>
          </li>
        </ul>
        <p>SPARQL language extensions may treat additional types as being derived from XML schema
          datatypes.</p>
      </section>

      <section id="expression-evaluation">
        <span id="evaluation"><!-- Legacy name --></span>
        <h3>Expression Evaluation</h3>
        <p>
          A SPARQL expression is evaluated
          with respect to a <a href="#defn_sparqlSolutionMapping">solution mapping</a>
          and in the context of an <a href="#sparqlDataset">RDF dataset</a>
          with an <a href="#defn_ActiveGraph">active graph</a>.
          The result of such an evaluation is either
          an <a data-cite="RDF12-CONCEPTS#dfn-rdf-term">RDF term</a> or
          an [=error=].
        </p>
        <p>
          SPARQL provides a subset of the functions and operators defined by 
          <a data-cite="XPATH-FUNCTIONS-31#">XPath and XQuery Functions and Operators</a>.
          The following rules accommodate the differences in the data and execution
          models between XPath/XQuery and SPARQL:
        </p>
        <ul>
          <li>
            Unlike functions in XPath/XQuery, functions in SPARQL do not
            process node sequences.
          </li>
          <li>
            Functions invoked with an argument of the wrong type will produce an [=error=].
          </li>
          <li>
            Effective boolean value arguments (labeled
            "xsd:boolean (EBV)" in the operator mapping table below), are coerced to
            <code>xsd:boolean</code> using the <a href="#ebv">SPARQL EBV rules</a>.
          </li>
          <li>Apart from the <a href="#func-forms">functional forms</a>
            <a href="#func-bound">BOUND</a>, <a href="#func-coalesce">COALESCE</a>,
            <a href="#func-if">IF</a>, <a href="#func-in">IN</a>, <a href="#func-not-in">NOT IN</a>, 
            <a href="#func-logical-or">logical-or</a> (<code>||</code>),
            <a href="#func-logical-and">logical-and</a> (<code>&amp;&amp</code>),
            <a href="#func-logical-not">logical-not</a> (<code>!</code>),
            <a href="#func-filter-not-exists">NOT EXISTS</a>, 
            <a href="#func-filter-exists">EXISTS</a>, and
            <a href="#func-ebv">EBV</a>,
            all functions operate on RDF Terms.
            Functions produce an [=error=] if any argument is unbound.
          </li>
          <li>Any expression other than <a href="#func-logical-or">logical-or</a> (<code>||</code>)
            or <a href="#func-logical-and">logical-and</a> (<code>&amp;&</code>) that encounters an
            error will produce that error.
          </li>
          <li>A <a href="#func-logical-or">logical-or</a> that encounters an error on only one branch
            will return TRUE if the other branch is TRUE and an error if the other branch is FALSE.
          </li>
          <li>A <a href="#func-logical-and">logical-and</a> that encounters an error on only one
            branch will return an error if the other branch is TRUE and FALSE if the other branch is
            FALSE.
          </li>
          <li>A <a href="#func-logical-or">logical-or</a> or <a href="#func-logical-and">logical-and</a> 
            that encounters errors on both branches will produce <em>either</em> of the [=errors=].
          </li>
        </ul>
        <p>The logical-and and logical-or truth table for true (<span class="truth">T</span>), false
          (<span class="truth">F</span>), and error (<span class="truth error">E</span>) is as
          follows:</p>
        <div id="truthTable"></div>
        <table class="truthTable">
          <thead>
            <tr>
              <th>A</th>
              <th>B</th>
              <th>A || B</th>
              <th>A &amp;& B</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <th>T</th>
              <th>T</th>
              <td>T</td>
              <td>T</td>
            </tr>
            <tr>
              <th>T</th>
              <th>F</th>
              <td>T</td>
              <td>F</td>
            </tr>
            <tr>
              <th>F</th>
              <th>T</th>
              <td>T</td>
              <td>F</td>
            </tr>
            <tr>
              <th>F</th>
              <th>F</th>
              <td>F</td>
              <td>F</td>
            </tr>
          </tbody>
          <tbody>
            <tr>
              <th>T</th>
              <th><span class="error">E</span></th>
              <td>T</td>
              <td><span class="error">E</span></td>
            </tr>
            <tr>
              <th><span class="error">E</span></th>
              <th>T</th>
              <td>T</td>
              <td><span class="error">E</span></td>
            </tr>
            <tr>
              <th>F</th>
              <th><span class="error">E</span></th>
              <td><span class="error">E</span></td>
              <td>F</td>
            </tr>
            <tr>
              <th><span class="error">E</span></th>
              <th>F</th>
              <td><span class="error">E</span></td>
              <td>F</td>
            </tr>
            <tr>
              <th><span class="error">E</span></th>
              <th><span class="error">E</span></th>
              <td><span class="error">E</span></td>
              <td><span class="error">E</span></td>
            </tr>
          </tbody>
        </table>
        <section id="invocation">
          <h4>Invocation</h4>
          <p>SPARQL defines a syntax for invoking functions on a list of arguments. Unless otherwise
            noted, these are invoked as follows:</p>
          <ul>
            <li>Argument expressions are evaluated, producing argument values. The order of argument
              evaluation is not defined.</li>
            <li>Numeric arguments are promoted as necessary to fit the expected types for that
              function or operator.</li>
            <li>The function or operator is invoked on the argument values.</li>
          </ul>
          <p>If any of these steps fails, the invocation generates an error. The effects of errors
            are defined in section <a href="#expression-evaluation" class="sectionRef"></a>.</p>
          <p>There are also "<a href="#func-forms">functional forms</a>" which have different
            evaluation rules to functions, as specified by each such form.</p>
        </section>

        <section id="sparql-error">
          <h4>Evaluation errors</h4>
          <p>Evaluation of an expression can lead to an 
            <dfn data-lt="sparql-eval-error" data-local-lt="error">error</dfn>,
            such as when an argument to a function is a literal of the wrong datatype,
            or an argument being the wrong kind of 
            <a data-cite="RDF12-CONCEPTS#dfn-rdf-term">RDF term</a>.
          </p>
          <p>
            If the evaluation of an expression raises an [=error=], then the 
            evaluation of every function, operator, and expression that contains 
            the expression with the error also raises an [=error=].
            Certain <a href="#func-forms">functional forms</a>
            handle errors as described in their definitions.
          </p>
        </section>

        <section id="ebv">
          <h4>Effective Boolean Value (EBV)</h4>
          <p><dfn data-local-lt="EBV|ebv">Effective boolean value</dfn> is used to calculate the arguments to the logical functions
            <a href="#func-logical-and">logical-and</a>, <a href="#func-logical-or">logical-or</a>,
            and <a href="#func-logical-not">logical-not</a>,
            as well as to evaluate the result of a <code>FILTER</code> expression.</p>

          <div id="func-ebv">
          <pre class="prototype nohighlight"><span class="return">xsd:boolean</span>  <span class="operator">EBV</span> (<span class="type">RDF term</span> <span class="name">term</span>)</pre>
          </div>
          <ul>    
            <li>
              If the argument is a <a data-cite="RDF12-CONCEPTS#dfn-literal">literal</a> 
              with a <a data-cite="RDF12-CONCEPTS#dfn-datatype-iri">datatype IRI</a>
              of <code>xsd:boolean</code>, and it has a
              valid lexical form, the EBV function returns that argument.
            </li>
            <li>
              If the argument is a <a data-cite="RDF12-CONCEPTS#dfn-literal">literal</a>
              with a datatype derived from a <span class="type numeric">numeric</span> type,
              and the argument has a valid lexical form,
              the EBV function returns the literal `"false"^^xsd:boolean`
              if the value of the operand is `NaN` or is numerically equal to zero;
              otherwise the EBV function returns the literal `"true"^^xsd:boolean`.
            </li>
            <li>
              If the argument is a <a data-cite="RDF12-CONCEPTS#dfn-literal">literal</a>
              with a <a data-cite="RDF12-CONCEPTS#dfn-datatype-iri">datatype IRI</a>
              <code>xsd:string</code> and the value is equal to the empty string,
              the EBV function returns the literal `"false"^^xsd:boolean`;
              otherwise the EBV function returns the literal `"true"^^xsd:boolean`.
            </li>
            <li>
              If the argument is a <a data-cite="RDF12-CONCEPTS#dfn-literal">literal</a>
              with an invalid lexical form for the 
              <a data-cite="RDF12-CONCEPTS#dfn-datatype-iri">datatype IRI</a>,
              then raise an error.
            </li>
            <li>
              If the argument is a <a data-cite="RDF12-CONCEPTS#dfn-literal">literal</a>
              with a <a data-cite="RDF12-CONCEPTS#dfn-datatype-iri">datatype IRI</a>
              which is not `xsd:boolean`,
              a <span class="type numeric">numeric</span> datatype, 
              or `xsd:string`, then raise an [=error=].
            </li>
            <li>
              If the argument is not a <a data-cite="RDF12-CONCEPTS#dfn-literal">literal</a>,
              then raise an error.
            </li>
          </ul>

          <div class="result">
            <table>
              <thead>
                <tr>
                  <th>Example</th>
                  <th>EBV Value</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>EBV("true"^^xsd:boolean)</td>
                  <td>`true`</td>
                </tr>
                <tr>
                  <td>EBV("")</td>
                  <td>`false`</td>
                </tr>
                <tr>
                  <td>EBV("1"^^xsd:boolean)</td>
                  <td>`true`</td>
                </tr>
                <tr>
                  <td>EBV(-2e10)</td>
                  <td>`true`</td>
                </tr>
                <tr>
                  <td>EBV(-0)</td>
                  <td>`false`</td>
                </tr>
                <tr>
                  <td>EBV(&lt;http://example/&gt;)</td>
                  <td><i><code>error</code></i></td>
                </tr>
                <tr>
                  <td>EBV("2025-08-18"^^xsd:date)</td>
                  <td><i><code>error</code></i></td>
                </tr>
              </tbody>
            </table>
          </div>
          
          <p>An EBV of <code>true</code> is represented as a 
            <a data-cite="RDF12-CONCEPTS#dfn-literal">literal</a>
            with a datatype IRI of <code>xsd:boolean</code> and a lexical value of "true";
            an EBV of false is represented as a 
            <a data-cite="RDF12-CONCEPTS#dfn-literal">literal</a>
            with a datatype IRI of <code>xsd:boolean</code> and a lexical value of "false".</p>
        </section>
      </section>

      <section id="OperatorMapping">
        <h3>Operator Mapping</h3>
        <p>The SPARQL grammar identifies a set of operators 
          (for instance, <code><span class="token">&amp;&amp;</span></code>, 
          <code><span class="token">*</span></code>, <code><span class="token">isIRI</span></code>) used
          to construct constraints. The following table associates each of these grammatical
          productions with the appropriate operands and an operator function defined by either
          [[[XPATH-FUNCTIONS-31]]] [[XPATH-FUNCTIONS-31]] or the SPARQL operators specified in <a href="#SparqlOps">section
            17.4</a>. When selecting the operator definition for a given set of parameters, the
          definition with the most specific parameters applies. For instance, when evaluating
          <code>xsd:integer = xsd:signedInt</code>, the definition for <code>=</code> with two
          <code>numeric</code> parameters applies, rather than the one with two
          <span class="type RDFterm">RDF terms</span>. The table is arranged so that the upper-most viable
          candidate is the most specific. Operators invoked without appropriate operands
          result in an [=error=].</p>
        <p>SPARQL follows XPath's scheme for numeric type promotions and subtype substitution for
          arguments to numeric operators. The <a data-cite="XPATH-31#mapping">XPath Operator Mapping</a>
          rules for <span class="type numeric">numeric</span> operands (<code>xsd:integer</code>,
          <code>xsd:decimal</code>, <code>xsd:float</code>, <code>xsd:double</code>, and types derived
          from a <span class="type numeric">numeric</span> type) apply to SPARQL operators as well (see
          [[[XPATH-31]]] [[XPATH-31]] for definitions of <a data-cite="XPATH-31#promotion">numeric type
            promotions</a> and <a data-cite="XPATH-31#dt-subtype-substitution">subtype substitution</a>).
          Some of the operators are associated with nested function expressions, e.g.
          <code>fn:not(op:numeric-equal(A, B))</code>. Note that per the XPath definitions,
          <code>fn:not</code> and <code>op:numeric-equal</code> produce an error if their argument is
          an error.</p>
        <p>The collation for <code>fn:compare</code> is <a data-cite="XPATH-FUNCTIONS-31#collations">defined by
            XPath</a> and identified by
          <code>http://www.w3.org/2005/xpath-functions/collation/codepoint</code>. This collation
          allows for string comparison based on code point values. Codepoint string equivalence can be
          tested with <span class="type RDFterm">RDF term</span> equivalence.</p>

        <table title="SPARQL Unary Operators" class="FAndOTable">
          <caption>
            SPARQL Unary Operators
          </caption>
          <tbody>
            <tr>
              <th class="major" scope="col">Operator</th>
              <th class="major" scope="col">Type(A)</th>
              <th class="major" scope="col">Function</th>
              <th class="major" scope="col">Result type</th>
            </tr>
            <tr>
              <th colspan="4" class="subHeading" scope="col">XQuery Unary Operators</th>
            </tr>
            <tr>
              <th scope="row">
                <a href="#rUnaryExpression" title="UnaryExpression"><span class="FAOTtoken">!</span>
                  A</a>
              </th>
              <td>
                xsd:boolean <a href="#ebv-arg">(EBV)</a>
              </td>
              <td class="xpathOp">
                <a href="#func-logical-not" class="SPARQLoperator">logical-not</a>(A)
              </td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row">
                <a href="#rUnaryExpression" title="UnaryExpression"><span class="FAOTtoken">+</span>
                  A</a>
              </th>
              <td><span class="type numeric">numeric</span></td>
              <td class="xpathOp">
                <a data-cite="XPATH-FUNCTIONS-31#func-numeric-unary-plus">op:numeric-unary-plus</a>(A)
              </td>
              <td><span class="type numeric">numeric</span></td>
            </tr>
            <tr>
              <th scope="row">
                <a href="#rUnaryExpression" title="UnaryExpression"><span class="FAOTtoken">-</span>
                  A</a>
              </th>
              <td><span class="type numeric">numeric</span></td>
              <td class="xpathOp">
                <a data-cite="XPATH-FUNCTIONS-31#func-numeric-unary-minus">op:numeric-unary-minus</a>(A)
              </td>
              <td><span class="type numeric">numeric</span></td>
            </tr>
          </tbody>
        </table>
        <table title="SPARQL Binary Operators" class="FAndOTable">
          <caption>
            SPARQL Binary Operators
          </caption>
          <tbody>
            <tr>
              <th class="major" scope="col">Operator</th>
              <th class="major" scope="col">Type(A)</th>
              <th class="major" scope="col">Type(B)</th>
              <th class="major" scope="col">Function</th>
              <th class="major" scope="col">Result type</th>
            </tr>
            <tr>
              <th colspan="5" class="subHeading" scope="col">Logical Connectives</th>
            </tr>
            <tr>
              <th><span id="logical-or-operator"/>
                <a href="#rConditionalOrExpression" title="ConditionalOrExpression">A <span class="FAOTtoken">||</span> B</a>
              </th>
              <td>
                xsd:boolean <a href="#ebv-arg">(EBV)</a>
              </td>
              <td>
                xsd:boolean <a href="#ebv-arg">(EBV)</a>
              </td>
              <td class="sparqlOp"><span id="logical-and-operator"/>
                <a href="#func-logical-or" class="SPARQLoperator">logical-or</a>(A, B)
              </td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th>
                <a href="#rConditionalAndExpression" title="ConditionalAndExpression">A <span class="FAOTtoken">&amp;&</span> B</a>
              </th>
              <td>
                xsd:boolean <a href="#ebv-arg">(EBV)</a>
              </td>
              <td>
                xsd:boolean <a href="#ebv-arg">(EBV)</a>
              </td>
              <td class="sparqlOp">
                <a href="#func-logical-and" class="SPARQLoperator">logical-and</a>(A, B)
              </td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th colspan="5" class="subHeading" scope="col">XPath Tests</th>
            </tr>
            <tr>
              <th scope="row">
                <a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">=</span> B</a>
              </th>
              <td><span class="type numeric">numeric</span></td>
              <td><span class="type numeric">numeric</span></td>
              <td class="xpathOp">
                <a data-cite="XPATH-FUNCTIONS-31#func-numeric-equal">op:numeric-equal</a>(A, B)
              </td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row">
                <a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">=</span> B</a>
              </th>
              <td>xsd:string</td>
              <td>xsd:string</td>
              <td class="xpathOp">
                <a data-cite="XPATH-FUNCTIONS-31#func-numeric-equal">op:numeric-equal</a>(<a data-cite="XPATH-FUNCTIONS-31#func-compare">fn:compare</a>(<a href="#func-str" class="FAOTtoken">STR</a>(A), <a href="#func-str" class="FAOTtoken">STR</a>(B)), 0)
              </td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row">
                <a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">=</span> B</a>
              </th>
              <td>xsd:boolean</td>
              <td>xsd:boolean</td>
              <td class="xpathOp">
                <a data-cite="XPATH-FUNCTIONS-31#func-boolean-equal">op:boolean-equal</a>(A, B)
              </td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row">
                <a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">=</span> B</a>
              </th>
              <td>xsd:dateTime</td>
              <td>xsd:dateTime</td>
              <td class="xpathOp">
                <a data-cite="XPATH-FUNCTIONS-31#func-dateTime-equal">op:dateTime-equal</a>(A, B)
              </td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row">
                <a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">!=</span> B</a>
              </th>
              <td><span class="type numeric">numeric</span></td>
              <td><span class="type numeric">numeric</span></td>
              <td class="xpathOp">
                <a data-cite="XPATH-FUNCTIONS-31#func-not">fn:not</a>(<a data-cite="XPATH-FUNCTIONS-31#func-numeric-equal">op:numeric-equal</a>(A, B))
              </td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row">
                <a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">!=</span> B</a>
              </th>
              <td>xsd:string</td>
              <td>xsd:string</td>
              <td class="xpathOp">
                <a data-cite="XPATH-FUNCTIONS-31#func-not">fn:not</a>(<a data-cite="XPATH-FUNCTIONS-31#func-numeric-equal">op:numeric-equal</a>(<a data-cite="XPATH-FUNCTIONS-31#func-compare">fn:compare</a>(<a href="#func-str" class="FAOTtoken">STR</a>(A), <a href="#func-str" class="FAOTtoken">STR</a>(B)), 0))
              </td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row">
                <a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">!=</span> B</a>
              </th>
              <td>xsd:boolean</td>
              <td>xsd:boolean</td>
              <td class="xpathOp">
                <a data-cite="XPATH-FUNCTIONS-31#func-not">fn:not</a>(<a data-cite="XPATH-FUNCTIONS-31#func-boolean-equal">op:boolean-equal</a>(A, B))
              </td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row">
                <a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">!=</span> B</a>
              </th>
              <td>xsd:dateTime</td>
              <td>xsd:dateTime</td>
              <td class="xpathOp">
                <a data-cite="XPATH-FUNCTIONS-31#func-not">fn:not</a>(<a data-cite="XPATH-FUNCTIONS-31#func-dateTime-equal">op:dateTime-equal</a>(A, B))
              </td>
              <td>xsd:boolean</td>
            </tr>
            <tr id="op_lt">
              <th scope="row">
                <a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&lt;</span> B</a>
              </th>
              <td><span class="type numeric">numeric</span></td>
              <td><span class="type numeric">numeric</span></td>
              <td class="xpathOp">
                <a data-cite="XPATH-FUNCTIONS-31#func-numeric-less-than">op:numeric-less-than</a>(A, B)
              </td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row">
                <a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&lt;</span> B</a>
              </th>
              <td>xsd:string</td>
              <td>xsd:string</td>
              <td class="xpathOp">
                <a data-cite="XPATH-FUNCTIONS-31#func-numeric-equal">op:numeric-equal</a>(<a data-cite="XPATH-FUNCTIONS-31#func-compare">fn:compare</a>(<a href="#func-str" class="FAOTtoken">STR</a>(A), <a href="#func-str" class="FAOTtoken">STR</a>(B)), -1)
              </td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row">
                <a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&lt;</span> B</a>
              </th>
              <td>xsd:boolean</td>
              <td>xsd:boolean</td>
              <td class="xpathOp">
                <a data-cite="XPATH-FUNCTIONS-31#func-boolean-less-than">op:boolean-less-than</a>(A, B)
              </td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row">
                <a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&lt;</span> B</a>
              </th>
              <td>xsd:dateTime</td>
              <td>xsd:dateTime</td>
              <td class="xpathOp">
                <a data-cite="XPATH-FUNCTIONS-31#func-dateTime-less-than">op:dateTime-less-than</a>(A, B)
              </td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row">
                <a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&gt;</span> B</a>
              </th>
              <td><span class="type numeric">numeric</span></td>
              <td><span class="type numeric">numeric</span></td>
              <td class="xpathOp">
                <a data-cite="XPATH-FUNCTIONS-31#func-numeric-greater-than">op:numeric-greater-than</a>(A, B)
              </td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row">
                <a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&gt;</span> B</a>
              </th>
              <td>xsd:string</td>
              <td>xsd:string</td>
              <td class="xpathOp">
                <a data-cite="XPATH-FUNCTIONS-31#func-numeric-equal">op:numeric-equal</a>(<a data-cite="XPATH-FUNCTIONS-31#func-compare">fn:compare</a>(<a href="#func-str" class="FAOTtoken">STR</a>(A), <a href="#func-str" class="FAOTtoken">STR</a>(B)), 1)
              </td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row">
                <a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&gt;</span> B</a>
              </th>
              <td>xsd:boolean</td>
              <td>xsd:boolean</td>
              <td class="xpathOp">
                <a data-cite="XPATH-FUNCTIONS-31#func-boolean-greater-than">op:boolean-greater-than</a>(A, B)
              </td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row">
                <a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&gt;</span> B</a>
              </th>
              <td>xsd:dateTime</td>
              <td>xsd:dateTime</td>
              <td class="xpathOp">
                <a data-cite="XPATH-FUNCTIONS-31#func-dateTime-greater-than">op:dateTime-greater-than</a>(A, B)
              </td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row">
                <a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&lt;=</span> B</a>
              </th>
              <td><span class="type numeric">numeric</span></td>
              <td><span class="type numeric">numeric</span></td>
              <td class="xpathOp">
                <a href="#func-logical-or" class="SPARQLoperator">logical-or</a>(<a data-cite="XPATH-FUNCTIONS-31#func-numeric-less-than">op:numeric-less-than</a>(A, B),
                <a data-cite="XPATH-FUNCTIONS-31#func-numeric-equal">op:numeric-equal</a>(A, B))
              </td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row">
                <a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&lt;=</span> B</a>
              </th>
              <td>xsd:string</td>
              <td>xsd:string</td>
              <td class="xpathOp">
                <a data-cite="XPATH-FUNCTIONS-31#func-not">fn:not</a>(<a data-cite="XPATH-FUNCTIONS-31#func-numeric-equal">op:numeric-equal</a>(<a data-cite="XPATH-FUNCTIONS-31#func-compare">fn:compare</a>(<a href="#func-str" class="FAOTtoken">STR</a>(A), <a href="#func-str" class="FAOTtoken">STR</a>(B)), 1))
              </td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row">
                <a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&lt;=</span> B</a>
              </th>
              <td>xsd:boolean</td>
              <td>xsd:boolean</td>
              <td class="xpathOp">
                <a data-cite="XPATH-FUNCTIONS-31#func-not">fn:not</a>(<a data-cite="XPATH-FUNCTIONS-31#func-boolean-greater-than">op:boolean-greater-than</a>(A, B))
              </td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row">
                <a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&lt;=</span> B</a>
              </th>
              <td>xsd:dateTime</td>
              <td>xsd:dateTime</td>
              <td class="xpathOp">
                <a data-cite="XPATH-FUNCTIONS-31#func-not">fn:not</a>(<a data-cite="XPATH-FUNCTIONS-31#func-dateTime-greater-than">op:dateTime-greater-than</a>(A, B))
              </td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row">
                <a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&gt;=</span> B</a>
              </th>
              <td><span class="type numeric">numeric</span></td>
              <td><span class="type numeric">numeric</span></td>
              <td class="xpathOp">
                <a href="#func-logical-or" class="SPARQLoperator">logical-or</a>(<a data-cite="XPATH-FUNCTIONS-31#func-numeric-greater-than">op:numeric-greater-than</a>(A, B),
                <a data-cite="XPATH-FUNCTIONS-31#func-numeric-equal">op:numeric-equal</a>(A, B))
              </td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row">
                <a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&gt;=</span> B</a>
              </th>
              <td>xsd:string</td>
              <td>xsd:string</td>
              <td class="xpathOp">
                <a data-cite="XPATH-FUNCTIONS-31#func-not">fn:not</a>(<a data-cite="XPATH-FUNCTIONS-31#func-numeric-equal">op:numeric-equal</a>(<a data-cite="XPATH-FUNCTIONS-31#func-compare">fn:compare</a>(<a href="#func-str" class="FAOTtoken">STR</a>(A), <a href="#func-str" class="FAOTtoken">STR</a>(B)), -1))
              </td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row">
                <a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&gt;=</span> B</a>
              </th>
              <td>xsd:boolean</td>
              <td>xsd:boolean</td>
              <td class="xpathOp">
                <a data-cite="XPATH-FUNCTIONS-31#func-not">fn:not</a>(<a data-cite="XPATH-FUNCTIONS-31#func-boolean-less-than">op:boolean-less-than</a>(A, B))
              </td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row">
                <a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&gt;=</span> B</a>
              </th>
              <td>xsd:dateTime</td>
              <td>xsd:dateTime</td>
              <td class="xpathOp">
                <a data-cite="XPATH-FUNCTIONS-31#func-not">fn:not</a>(<a data-cite="XPATH-FUNCTIONS-31#func-dateTime-less-than">op:dateTime-less-than</a>(A, B))
              </td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th colspan="5" class="subHeading" scope="col">XPath Arithmetic</th>
            </tr>
            <tr>
              <th scope="row">
                <a href="#rMultiplicativeExpression" title="MultiplicativeExpression">A <span class="FAOTtoken">*</span> B</a>
              </th>
              <td><span class="type numeric">numeric</span></td>
              <td><span class="type numeric">numeric</span></td>
              <td class="xpathOp">
                <a data-cite="XPATH-FUNCTIONS-31#func-numeric-multiply">op:numeric-multiply</a>(A, B)
              </td>
              <td><span class="type numeric">numeric</span></td>
            </tr>
            <tr>
              <th scope="row">
                <a href="#rMultiplicativeExpression" title="MultiplicativeExpression">A <span class="FAOTtoken">/</span> B</a>
              </th>
              <td><span class="type numeric">numeric</span></td>
              <td><span class="type numeric">numeric</span></td>
              <td class="xpathOp">
                <a data-cite="XPATH-FUNCTIONS-31#func-numeric-divide">op:numeric-divide</a>(A, B)
              </td>
              <td><span class="type numeric">numeric</span>; but xsd:decimal if both operands are
                xsd:integer</td>
            </tr>
            <tr>
              <th scope="row">
                <a href="#rAdditiveExpression" title="AdditiveExpression">A <span class="FAOTtoken">+</span> B</a>
              </th>
              <td><span class="type numeric">numeric</span></td>
              <td><span class="type numeric">numeric</span></td>
              <td class="xpathOp">
                <a data-cite="XPATH-FUNCTIONS-31#func-numeric-add">op:numeric-add</a>(A, B)
              </td>
              <td><span class="type numeric">numeric</span></td>
            </tr>
            <tr>
              <th scope="row">
                <a href="#rAdditiveExpression" title="AdditiveExpression">A <span class="FAOTtoken">-</span> B</a>
              </th>
              <td><span class="type numeric">numeric</span></td>
              <td><span class="type numeric">numeric</span></td>
              <td class="xpathOp">
                <a data-cite="XPATH-FUNCTIONS-31#func-numeric-subtract">op:numeric-subtract</a>(A, B)
              </td>
              <td><span class="type numeric">numeric</span></td>
            </tr>
            <tr>
              <th colspan="5" class="subHeading" scope="col">SPARQL Tests</th>
            </tr>
            <tr>
              <th><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">=</span> B</a></th>
              <td><span class="type RDFterm"><a data-cite="RDF12-CONCEPTS#dfn-iri">IRI</a></span></td>
              <td><span class="type RDFterm"><a data-cite="RDF12-CONCEPTS#dfn-iri">IRI</a></span></td>
              <td>
                <a href="#func-sameTerm">sameTerm</a>(A, B)
              </td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">=</span> B</a></th>
              <td><span class="type RDFterm"><a data-cite="RDF12-CONCEPTS#dfn-blank-node">Blank Node</a></span></td>
              <td><span class="type RDFterm"><a data-cite="RDF12-CONCEPTS#dfn-blank-node">Blank Node</a></span></td>
              <td>
                <a href="#func-sameTerm">sameTerm</a>(A, B)
              </td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">=</span> B</a></th>
              <td><span class="type RDFterm"><a data-cite="RDF12-CONCEPTS#dfn-triple-term">Triple Term</a></span></td>
              <td><span class="type RDFterm"><a data-cite="RDF12-CONCEPTS#dfn-triple-term">Triple Term</a></span></td>
              <td>
                ( A.subject = B.subject ) <a href="#logical-and-operator" class="SPARQLoperator">&amp;&amp;</a><br/>
                ( A.predicate = B.predicate ) <a href="#logical-and-operator" class="SPARQLoperator">&amp;&amp;</a><br/>
                ( A.object = B.object )
              </td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">!=</span> B</a></th>
              <td><span class="type RDFterm"><a data-cite="RDF12-CONCEPTS#dfn-iri">IRI</a></span></td>
              <td><span class="type RDFterm"><a data-cite="RDF12-CONCEPTS#dfn-iri">IRI</a></span></td>
              <td><a data-cite="XPATH-FUNCTIONS-31#func-not">fn:not</a>(<a href="#func-sameTerm">sameTerm</a>(A, B))</td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">!=</span> B</a></th>
              <td><span class="type RDFterm"><a data-cite="RDF12-CONCEPTS#dfn-blank-node">Blank Node</a></span></td>
              <td><span class="type RDFterm"><a data-cite="RDF12-CONCEPTS#dfn-blank-node">Blank Node</a></span></td>
              <td>
                <a data-cite="XPATH-FUNCTIONS-31#func-not">fn:not</a>(<a href="#func-sameTerm">sameTerm</a>(A, B)
              </td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">!=</span> B</a></th>
              <td><span class="type RDFterm"><a data-cite="RDF12-CONCEPTS#dfn-triple-term">Triple Term</a></span></td>
              <td><span class="type RDFterm"><a data-cite="RDF12-CONCEPTS#dfn-triple-term">Triple Term</a></span></td>
              <td>
                ( A.subject != B.subject ) <a href="#logical-or-operator" class="SPARQLoperator">||</a><br/>
                ( A.predicate != B.predicate ) <a href="#logical-or-operator" class="SPARQLoperator">||</a><br/>
                ( A.object != B.object )
              </td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">=</span> B</a></th>
              <td><span class="type RDFterm">RDF term</span></td>
              <td><span class="type RDFterm">RDF term</span></td>
              <td class="xpathOp">
                <a href="#func-sameValue">sameValue</a>(A, B)
              </td> 
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">!=</span> B</a></th>
              <td><span class="type RDFterm">RDF term</span></td>
              <td><span class="type RDFterm">RDF term</span></td>
              <td class="xpathOp">
                <a data-cite="XPATH-FUNCTIONS-31#func-not">fn:not</a>(<a href="#func-sameValue">sameValue</a>(A, B))
              </td>
              <td>xsd:boolean</td>
            </tr>
          </tbody>
        </table>
        <p>
        <span id="ebv-arg"></span>xsd:boolean function arguments marked with "(EBV)" are
        coerced to xsd:boolean by evaluating the <a href="#ebv">effective boolean value of that
          argument.</a>
        </p>
        <p>
          Operators <span class="SPARQLoperator">=</span> and <span class="SPARQLoperator">!=</span> applied to 
          <a data-cite="RDF12-CONCEPTS#dfn-triple-term">triple terms</a>
          apply the operator to each of the components.
        </p>
        <section id="operatorExtensibility">
          <h4>Operator Extensibility</h4>
          <p>SPARQL language extensions may provide additional associations between operators and
            operator functions; this amounts to adding rows to the table above. No additional operator
            may yield a result that replaces any result other than an [=error=].
            The consequence of this rule is that SPARQL <code>FILTER</code>s will
            produce <em>at least</em> the same intermediate bindings after applying a
            <code>FILTER</code> as an unextended implementation.</p>
          <p>Additional mappings of the '&lt;' operator are expected to control the relative ordering
            of the operands, specifically, when used in an <a href="#modOrderBy"><code>ORDER
                BY</code></a> clause.</p>
        </section>
      </section>

      <section id="SparqlOps">
        <h3>Function Definitions</h3>
        <p>This section defines the operators and functions introduced by the SPARQL query language.
          The examples show the behavior of the operators as invoked by the appropriate grammatical
          constructs.</p>
        <section id="func-forms">
          <h4>Functional Forms</h4>
          <section id="func-bound">
            <h5>BOUND</h5>
            <pre class="prototype nohighlight"><span class="return">xsd:boolean</span>  <span class="operator">BOUND</span> (<span class="type">variable</span> <span class="name">var</span>)</pre>
            <p>Returns <code>true</code> if <code>var</code> is bound to a value. Returns false
              otherwise. Variables with the value NaN or INF are considered bound.</p>
            <div class="exampleGroup">
              <p>Data:</p>
              <pre class="data nohighlight">
PREFIX foaf:        &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX dc:          &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX xsd:          &lt;http://www.w3.org/2001/XMLSchema#&gt;

_:a  foaf:givenName  "Alice".

_:b  foaf:givenName  "Bob" .
_:b  dc:date         "2005-04-04T04:04:04Z"^^xsd:dateTime .
              </pre>
              <div class="queryGroup">
                <pre class="query nohighlight">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX dc:   &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX xsd:   &lt;http://www.w3.org/2001/XMLSchema#&gt;
SELECT ?givenName
WHERE {
   ?x foaf:givenName  ?givenName .
   OPTIONAL { ?x dc:date ?date } .
   FILTER ( bound(?date) )
}
                </pre>
                <p>Query result:</p>
                <div class="result">
                  <table class="resultTable">
                    <tbody>
                      <tr>
                        <th>givenName</th>
                      </tr>
                      <tr>
                        <td>"Bob"</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
              <p>One may test whether a graph pattern is <em>not</em> expressed by specifying an
              <code>OPTIONAL</code> graph pattern
              that introduces a variable and testing to see whether the variable is not
                <span class="term">bound</span>
                This is called <em>Negation as Failure</em> in logic programming.</p>
              <div class="queryGroup">
                <p>This query matches the people with a <code>name</code> but <em>no</em> expressed
                  <code>date</code>:</p>
                <pre class="query nohighlight">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX dc:   &lt;http://purl.org/dc/elements/1.1/&gt;
SELECT ?name
WHERE { 
    ?x foaf:givenName  ?name .
    OPTIONAL { ?x dc:date ?date } .
    FILTER (!bound(?date))
 }
                </pre>
                <p>Query result:</p>
                <div class="result">
                  <table class="resultTable">
                    <tbody>
                      <tr>
                        <th>name</th>
                      </tr>
                      <tr>
                        <td>"Alice"</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
            <p>Because Bob's <code>dc:date</code> was known, <code>"Bob"</code> was not a solution to
              the query.</p>
          </section>
          <section id="func-if">
            <h5>IF</h5>
            <pre class="prototype nohighlight"><span class="return">rdfTerm</span>  <span class="operator">IF</span> (<span class="expression">expression1</span>, <span class="expression">expression2</span>, <span class="expression">expression3</span>)</pre>
            <p>The <code>IF</code> function form evaluates the first argument, interprets it as a
              <a href="#ebv">effective boolean value</a>, then returns the value of
              <code>expression2</code> if the EBV is true, otherwise it returns the value of
              <code>expression3</code>. Only one of <code>expression2</code> and
              <code>expression3</code> is evaluated. If evaluating the first argument raises an [=error=],
              then an [=error=] is raised for the evaluation of the <code>IF</code> expression.</p>
            <p>
              Examples: Suppose that `?x` is bound to `2`, `?z` is bound to `0`, 
              and that `?y` is not bound, in some query solution:
            </p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>IF(?x = 2, "yes", "no")</code></td>
                    <td>returns "yes"</td>
                  </tr>
                  <tr>
                    <td><code>IF(bound(?y), "yes", "no")</code></td>
                    <td>returns "no"</td>
                  </tr>
                  <tr>
                    <td><code>IF(?x=2, "yes", 1/?z)</code></td>
                    <td>returns "yes", the expression <code>1/?z</code> is not evaluated</td>
                  </tr>
                  <tr>
                    <td><code>IF(?x=1, "yes", 1/?z)</code></td>
                    <td>raises an error</td>
                  </tr>
                  <tr>
                    <td><code>IF("2" &gt; 1, "yes", "no")</code></td>
                    <td>raises an error</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-coalesce">
            <h5>COALESCE</h5>
            <pre class="prototype nohighlight">
              <span class="return">rdfTerm</span> <span class="operator">COALESCE</span>(<span
class="expression">expression, ....</span>)
            </pre>
            <p>
              The <code>COALESCE</code> function form returns the RDF term value of the first
              expression that evaluates without error.
              In SPARQL, evaluating an unbound variable raises an error.
            </p>
            <p>
              If none of the expressions evaluate without error, an error is raised.
            </p>
            <p>
              If there are zero expressions, an error is raised.
            </p>
            <p>Examples: Suppose ?x = 2 and ?y is not bound in some query solution:</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>COALESCE(?x, 1/0)</code></td>
                    <td>returns 2, the value of <code>x</code></td>
                  </tr>
                  <tr>
                    <td><code>COALESCE(1/0, ?x)</code></td>
                    <td>returns 2</td>
                  </tr>
                  <tr>
                    <td><code>COALESCE(5, ?x)</code></td>
                    <td>returns 5</td>
                  </tr>
                  <tr>
                    <td><code>COALESCE(?y, 3)</code></td>
                    <td>returns 3</td>
                  </tr>
                  <tr>
                    <td><code>COALESCE(?y)</code></td>
                    <td>raises an error because <code>y</code> is not bound.</td>
                  </tr>
                  <tr>
                    <td><code>COALESCE()</code></td>
                    <td>raises an error because there are zero arguments.</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-filter-exists">
            <span id="func-filter-not-exists"></span>
            <h5>NOT EXISTS and EXISTS</h5>
            <p>There is a filter operator <code>EXISTS</code> that takes a graph pattern.
              <code>EXISTS</code> returns <code>true</code>/<code>false</code> depending on whether the
              pattern matches the dataset given the bindings in the current group graph pattern, the
              dataset and the <a href="#defn_ActiveGraph">active graph</a> at this point in the query
              evaluation. No additional binding of variables occurs. The <code>NOT EXISTS</code> form
              translates into <code>fn:not(EXISTS{...})</code>.</p>
            <pre class="prototype nohighlight"> 
<span class="return">xsd:boolean</span>  <span class="operator">NOT EXISTS</span> { <span class="pattern">pattern</span> }
            </pre>
            <p>Returns <code>false</code> if <code>pattern</code> matches. Returns true
              otherwise.</p>
            <p><code>NOT EXISTS { pattern }</code> is equivalent to <code>fn:not(EXISTS { pattern
                })</code>.</p>
            <pre class="prototype nohighlight"> 
<span class="return">xsd:boolean</span> EXISTS { <span class="pattern">pattern</span> }
            </pre>
            <p>Returns <code>true</code> if <code>pattern</code> matches. Returns false
              otherwise.</p>
            <p>Variables in the <code>pattern</code> that are bound in the current 
              <a data-cite="SPARQL11-QUERY#defn_sparqlSolutionMapping">solution mapping</a> take the value that they
              have from the solution mapping. Variables in the pattern <code>pattern</code> that are
              not bound in the current solution mapping take part in pattern matching.</p>
            <p>To facilitate this, we introduce a function <a href="#defn_exists">Exists</a> that
              evaluates a SPARQL Algebra expression and returns true or false, depending on whether
              there are any solutions to the pattern, given the solution mapping being tested by the
              filter operation.</p>
          </section>
          <section id="func-logical-or">
            <h5>logical-or</h5>
            <pre class="prototype nohighlight">
              <span class="return">xsd:boolean</span> <span class="operator" style="text-transform: none;">logical-or</span> (<span class="type">xsd:boolean</span> <span class="name">left</span>, <span class="type">xsd:boolean</span> <span class="name">right</span>)
            </pre>
            <p>This function cannot be used directly in expressions. 
              The purpose of this function is to define the semantics of the "<code>||</code>" operator.</p>
            <p>The function returns a logical <code>OR</code> of <code>left</code> and <code>right</code>. 
              Note that <span class="SPARQLoperator">logical-or</span> operates on the 
              <a href="#ebv">effective boolean value</a> of each of its arguments.</p>
            <p>Note: see section <a href="#expression-evaluation" class="sectionRef"></a>, for the
              <code>||</code> operator's treatment of errors.</p>
          </section>
          <section id="func-logical-and">
            <h5>logical-and</h5>
            <pre class="prototype nohighlight">
              <span class="return">xsd:boolean</span> <span class="operator" style="text-transform: none;">logical-and</span> (<span class="type">xsd:boolean</span> <span class="name">left</span>, <span class="type">xsd:boolean</span> <span class="name">right</span>)
            </pre>
            <p>This function cannot be used directly in expressions. 
              The purpose of this function is to define the semantics of the "<code>&amp;&amp;</code>" operator.</p>
            <p>The function returns a logical <code>AND</code> of <code>left</code> and <code>right</code>.
              Note that <span class="SPARQLoperator">logical-and</span> operates on the 
              <a href="#ebv">effective boolean value</a> of each of its arguments.</p>
            <p>Note: see section <a href="#expression-evaluation" class="sectionRef"></a>, for the
              <code>&amp;&amp;</code> operator's treatment of errors.</p>
          </section>
          <section id="func-logical-not">
            <h5>logical-not</h5>
            <pre class="prototype nohighlight">
              <span class="return">xsd:boolean</span> <span class="operator" style="text-transform: none;">logical-not</span> (<span class="type">xsd:boolean</span> <span class="name">arg</span>)
            </pre>
            <p>This function cannot be used directly in expressions.  The purpose of this
              function is to define the semantics of the "<code>!</code>" operator.</p>
            <p>The function returns a logical <code>NOT</code> of <code>arg</code>.
              Note that <span class="SPARQLoperator">logical-not</span> operates on the 
              <a href="#ebv">effective boolean value</a> of its argument.
            </p>
          </section>
          <section id="func-in">
            <h5>IN</h5>
            <pre class="prototype nohighlight">
<span class="return">boolean</span>  rdfTerm <span class="operator">IN</span> (<span class="expression">expression</span>, <span class="expression">...</span>)
            </pre>
            <p>
              The <code>IN</code> operator tests whether the RDF term on the
              left-hand side is found in the list of values of the expressions
              on the right-hand side. The test is done with the "=" operator,
              which tests for the same value, as determined by the
              <a href="#OperatorMapping">operator mapping</a>.
            </p>
            <p>
              A list of zero terms on the right-hand side is legal and evaluates
              to <code>false</code>.
            </p>
            <p>
              Errors in comparisons cause the <code>IN</code> expression to
              raise an error if the RDF term being tested is not found elsewhere
              in the list of terms.
            </p>
            <p>
              If <code>IN</code> is used with an expression to produce the
              <code>rdfTerm</code>, then that expression is evaluated only once, 
              before evaluating the <code>IN</code> expression.
            </p>
            <p>
              The <code>IN</code> operator is equivalent to the 
              SPARQL expression:
            </p>
            <pre>(rdfTerm = value of expression1) || (rdfTerm = value of expression2) || ...</pre>
            <p>Examples:</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>2 IN (1, 2, 3)</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>2 IN ()</code></td>
                    <td>false</td>
                  </tr>
                  <tr>
                    <td><code>2 IN (&lt;http://example/iri&gt;, "str", 2.0)</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>2 IN (1/0, 2)</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>2 IN (2, 1/0)</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>2 IN (3, 1/0)</code></td>
                    <td>raises an error</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-not-in">
            <h5>NOT IN</h5>
            <pre class="prototype nohighlight">
<span class="return">boolean</span>  rdfTerm <span class="operator">NOT IN</span> (<span class="expression">expression</span>, <span class="expression">...</span>)
</pre>
            <p>
              The <code>NOT IN</code> operator tests whether the RDF term on
              the left-hand side is not found in the values of list of the
              expressions on the right-hand side. The test is done with the "!="
              operator, which tests that two values are not the same value, as
              determined by the
              <a href="#OperatorMapping">operator mapping</a>.
            </p>
            <p>
              A list of zero terms on the right-hand side is legal and evaluates
              to <code>true</code>.
            </p>
            <p>
              If <code>NOT IN</code> is used with an expression to produce the
              <code>rdfTerm</code>, then that expression is evaluated only once, 
              before evaluating the <code>NOT IN</code> expression.
            </p>
            <p>Errors in comparisons cause the <code>NOT IN</code> expression to raise an error if
              the RDF term being tested is not found elsewhere in the list of
              terms.</p>
            <p>
              The <code>NOT IN</code> operator is equivalent to the
              SPARQL expression: 
            </p>
            <pre>(rdfTerm != value of expression1) &amp;&amp; (rdfTerm != value of expression2) &amp;&amp; ...</pre>
            <p><code>NOT IN (...)</code> is equivalent to <code>!(IN (...))</code>.</p>

            <p>Examples:</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>2 NOT IN (1, 2, 3)</code></td>
                    <td>false</td>
                  </tr>
                  <tr>
                    <td><code>2 NOT IN ()</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>2 NOT IN (&lt;http://example/iri&gt;, "str", 2.0)</code></td>
                    <td>false</td>
                  </tr>
                  <tr>
                    <td><code>2 NOT IN (1/0, 2)</code></td>
                    <td>false</td>
                  </tr>
                  <tr>
                    <td><code>2 NOT IN (2, 1/0)</code></td>
                    <td>false</td>
                  </tr>
                  <tr>
                    <td><code>2 NOT IN (3, 1/0)</code></td>
                    <td>raises an error</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
        </section>
        <section id="func-rdfTerms">
          <h4>Functions on RDF Terms</h4>

          <section id="func-sameTerm">
            <h5>sameTerm</h5>
            <pre class="prototype nohighlight"> <span class="return">xsd:boolean</span>  <span class="operator">sameTerm</span> (<span class="type"><span class="type RDFterm">RDF term</span></span> <span class="name">term1</span>, <span class="type"><span class="type RDFterm">RDF term</span></span> <span class="name">term2</span>)</pre>
            <p>Returns TRUE if <code>term1</code> and <code>term2</code> are the same RDF term as
              defined in [[[RDF12-CONCEPTS]]] [[RDF12-CONCEPTS]]; returns FALSE otherwise.</p>
            <p>
              |term1| and |term2| are the
              <a data-cite="RDF12-CONCEPTS#dfn-rdf-term-equality">same RDF term</a>
              if one of the following is true:
            </p>
            <ul>
              <li><code>term1</code> and <code>term2</code> are 
                <a data-cite="RDF12-CONCEPTS#iri">IRIs</a> that are the
                <a data-cite="RDF12-CONCEPTS#dfn-iri-equality">same as IRIs</a>.
              </li>
              <li><code>term1</code> and <code>term2</code> are 
                <a data-cite="RDF12-CONCEPTS#dfn-literal">literals</a> that are 
                <a data-cite="RDF12-CONCEPTS#dfn-literal-term-equality">equal as literal terms</a>.
              </li>
              <li><code>term1</code> and <code>term2</code> are 
                <a data-cite="RDF12-CONCEPTS#dfn-blank-node">blank nodes</a> that are 
                <a data-cite="RDF12-CONCEPTS#dfn-blank-node-equality">equal as blank nodes</a>.
              </li>
              <li><code>term1</code> and <code>term2</code> are 
                <a data-cite="RDF12-CONCEPTS#dfn-triple-term">triple terms</a> that are 
                <a data-cite="RDF12-CONCEPTS#dfn-triple-term-equality">equal as triple terms</a>; that
                is, the
                <a data-cite="RDF12-CONCEPTS#dfn-subject">subject</a>,
                <a data-cite="RDF12-CONCEPTS#dfn-predicate">predicate</a>, and
                <a data-cite="RDF12-CONCEPTS#dfn-object">object</a> components are pair-wise
                the same term.
              </li>
            </ul>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>sameTerm(&lt;http://example/&gt;, &lt;http://example/&gt;)</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>sameTerm(&lt;http://example/&gt;, &lt;https://example/&gt;)</code></td>
                    <td>false</td>
                  </tr>
                  <tr>
                    <td><code>sameTerm("abc", "abc")</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>sameTerm("abc"@en, "abc")</code></td>
                    <td>false</td>
                  </tr>
                  <tr>
                    <td><code>sameTerm("abc"@en, "abc"@EN)</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>sameTerm("abc"@en--rtl, "abc"@en)</code></td>
                    <td>false</td>
                  </tr>
                  <tr>
                    <td><code>sameTerm(2, 2.0)</code></td>
                    <td>false</td>
                  </tr>
                  <tr>
                    <td><code>sameTerm(2, "2"^^xsd:integer)</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>sameTerm(2, "02"^^xsd:integer)</code></td>
                    <td>false</td>
                  </tr>
              </table>
            </div>

          </section>
          <section id="func-sameValue">
            <span id="func-RDFterm-equal"><!-- obsolete id --></span>
            <h5>sameValue</h5>
            <pre class="prototype nohighlight">
              <span class="return">xsd:boolean</span> <span class="operator" style="text-transform: none;">sameValue</span> (<span class="type"><span class="type RDFterm">RDF term</span></span> <span class="name">term1</span>, <span class="type"><span class="type RDFterm">RDF term</span></span> <span class="name">term2</span>)
            </pre>

            <p>This function cannot be used directly in expressions. The purpose
              of this function is to define the semantics of the "=" operator when applied to
              two RDF terms that do not fall into the concrete cases
              covered in the operator mapping table in Section
              <a href="#OperatorMapping" class="sectionRef"></a>.
            </p>

            <p>The result of this function is determined by going through the following steps.</p>

            <ol>
              <li>If <code>term1</code> and <code>term2</code> are
                <a data-cite="RDF12-CONCEPTS#dfn-rdf-term-equality">equal RDF terms</a>,
                then return TRUE.
              </li>
              <li>If <code>term1</code> or <code>term2</code> is an
                <a data-cite="RDF12-CONCEPTS#dfn-iri">IRI</a> or a
                <a data-cite="RDF12-CONCEPTS#dfn-blank-node">blank node</a>
                then return FALSE.
              <li>If <code>term1</code> and <code>term2</code> are both
                <a data-cite="RDF12-CONCEPTS#dfn-literal">literals</a>
                and one or both of these literals has a datatype that is
                not handled by the SPARQL processor,
                then produce an [=error=].
              </li>
              <li>If <code>term1</code> and <code>term2</code> are both
                <a data-cite="RDF12-CONCEPTS#dfn-literal">literals</a>
                and one or both of these literals are known to be
                <a data-cite="RDF12-CONCEPTS#dfn-ill-typed">ill-typed</a>,
                then produce an [=error=].
              </li>
              <li>
                `"NaN"^^xsd:double` and `"NaN"^^xsd:float` are considered to 
                represent the same value.
                If <code>term1</code> and <code>term2</code> are
                both "NaN" for either xsd:double or xsd:float, then 
                return TRUE.
              </li>
              <li>If <code>term1</code> and <code>term2</code> are both 
                <a data-cite="RDF12-CONCEPTS#dfn-literal">literals</a>
                and the SPARQL processor can determine that their the values are equal,
                then return TRUE.
              </li>
              <li>If <code>term1</code> and <code>term2</code> are both 
                <a data-cite="RDF12-CONCEPTS#dfn-literal">literals</a>
                and the SPARQL processor can determine the values can not be equal,
                then return FALSE.
              </li>
              <li>
                If <code>term1</code> and <code>term2</code> are both 
                <a data-cite="RDF12-CONCEPTS#dfn-triple-term">triple terms</a>,
                apply the function `sameValue` pair-wise to each of the components.
                Return TRUE if each component pair returns TRUE;
                produce an [=error=] if any component pair produces an [=error=];
                otherwise return FALSE.
              </li>
              <li>Otherwise, return FALSE.</li>
            </ol>
            <div id="sameValue-ill-typed" class="note">
              <p>A literal is 
                <a data-cite="RDF12-CONCEPTS#dfn-ill-typed">ill-typed</a>
                if its datatype is handled by the SPARQL processor and
                its lexical form is not in the
                <a data-cite="RDF12-CONCEPTS#dfn-lexical-space">lexical space</a>
                of the datatype.
              </p>
              <p>
                If the two arguments are literals, the function `sameValue` 
                returns `true` or `false` in cases where the SPARQL processor
                can determine that the values of these literals are equal or are not equal. 
                If the SPARQL processor can not be sure, it returns `error`.
              </p>
            </div>
            <div id="sameValue-NaN" class="note">
              <p>
                The <a href="#OperatorMapping">Operator Mapping</a> for "`=`"
                is the function
                <a data-cite="XPATH-FUNCTIONS-31#func-numeric-equal">`op:numeric-equal`</a>
                which is defined to return `false` when comparing arguments involving `NaN`.
                However, `sameTerm("NaN"^^xsd:double, "NaN"^^xsd:double)` is true.
                The function `sameValue` defines `sameValue("NaN"^^xsd:double, "NaN"^^xsd:double)`
                to be true because the arguments are the same element of the value space.
              </p>
              <p>
                `sameValue` treats the values of `"NaN"^^xsd:double` and `"NaN"^^xsd:float` as being
                the same. `sameValue("NaN"^^xsd:double, "NaN"^^xsd:float)` is `true`.
              </p>
            </div>
            <p id="sameValue-zeros" class="note">
              For xsd:double and xsd:float, `+0`, `-0` and `0` are same value.
            </p>
            <p id="func-sameValue-note1" class="note">
              An extended implementation may support additional datatypes for literals. An
              implementation processing a query that tests for equivalence of literals with non-recognized datatypes
              (and non-identical lexical form and datatype IRI) returns an error, indicating that it
              is unable to determine whether or not the values of the compared literals are equivalent. For example, an
              unextended implementation will produce an error when testing either <span class="queryExcerpt"><code>"iiii"^^my:romanNumeral =
                  "iv"^^my:romanNumeral</code></span> or <span class="queryExcerpt"><code>"iiii"^^my:romanNumeral !=
                  "iv"^^my:romanNumeral</code></span>.
            </p>

            <p>Examples:</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <th>sameValue</th>
                    <th>Results</th>
                  </tr>
                  <tr>
                    <td><code>sameValue(1e10, "NaN"^^xsd:double)</code></td>
                    <td>false</td>
                  </tr>
                  <tr>
                    <td><code>sameValue("NaN"^^xsd:double, "NaN"^^xsd:double)</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>sameValue("NaN"^^xsd:double, "NaN"^^xsd:float)</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>sameValue( &lt;&lt(:s :p 123)&gt;&gt , &lt;&lt(:s :p 123.0)&gt;&gt )</td>
                    <td>true</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <p id="sameValue-old-name" class="note">
              This function was called `RDFterm-equal` up until SPARQL 1.1.
            </p>
          </section>

          <section id="func-isIRI">
            <span id="func-isURI"></span>
            <h5>isIRI</h5>
            <pre class="prototype nohighlight">
<span class="return">xsd:boolean</span>  <span class="operator">isIRI</span> (<span class="type">RDF term</span> <span class="name">term</span>)
<span class="return">xsd:boolean</span>  <span class="operator">isURI</span> (<span class="type">RDF term</span> <span class="name">term</span>)
            </pre>
            <p>Returns <code>true</code> if <code>term</code> is an 
              <span class="type IRI">IRI</span>. 
              Returns <code>false</code> otherwise. 
              <span class="operator">isURI</span> is an alternate spelling for the 
              <span class="operator">isIRI</span> operator.
            </p>
            <div class="exampleGroup">
              <pre class="data nohighlight">
PREFIX foaf:       &lt;http://xmlns.com/foaf/0.1/&gt;

_:a  foaf:name       "Alice".
_:a  foaf:mbox       &lt;mailto:alice@work.example&gt; .

_:b  foaf:name       "Bob" .
_:b  foaf:mbox       "bob@work.example" .
              </pre>
              <div class="queryGroup">
                <p>This query matches the people with a <code>name</code> and an <code>mbox</code>
                  which is an IRI:</p>
                <pre class="query nohighlight">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name ?mbox
WHERE {
    ?x foaf:name  ?name ;
       foaf:mbox  ?mbox .
    FILTER isIRI(?mbox) 
}
                </pre>
                <p>Query result:</p>
                <div class="result">
                  <table class="resultTable">
                    <tbody>
                      <tr>
                        <th>name</th>
                        <th>mbox</th>
                      </tr>
                      <tr>
                        <td>"Alice"</td>
                        <td>&lt;mailto:alice@work.example&gt;</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
          </section>

          <section id="func-isBlank">
            <h5>isBLANK</h5>
            <pre class="prototype nohighlight"> <span class="return">xsd:boolean</span>  <span class="operator">isBLANK</span> (<span class="type"><span class="type">RDF term</span></span> <span class="name">term</span>)</pre>
            <p>Returns <code>true</code> if <code>term</code> is a <span class="type bNode">blank
                node</span>. Returns <code>false</code> otherwise.</p>
            <div class="exampleGroup">
              <pre class="data nohighlight">
PREFIX a:          &lt;http://www.w3.org/2000/10/annotation-ns#&gt;
PREFIX dc:         &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX foaf:       &lt;http://xmlns.com/foaf/0.1/&gt;

_:a   a:annotates   &lt;http://www.w3.org/TR/rdf-sparql-query/&gt; .
_:a   dc:creator    "Alice B. Toeclips" .

_:b   a:annotates   &lt;http://www.w3.org/TR/rdf-sparql-query/&gt; .
_:b   dc:creator    _:c .
_:c   foaf:given    "Bob".
_:c   foaf:family   "Smith".
              </pre>
              <div class="queryGroup">
                <p>This query matches the people with a <code>dc:creator</code> which uses predicates
                  from the FOAF vocabulary to express the name.</p>
                <pre class="query nohighlight">
PREFIX a:      &lt;http://www.w3.org/2000/10/annotation-ns#&gt;
PREFIX dc:     &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX foaf:   &lt;http://xmlns.com/foaf/0.1/&gt;

SELECT ?given ?family
WHERE { 
    ?annot  a:annotates  &lt;http://www.w3.org/TR/rdf-sparql-query/&gt; .
    ?annot  dc:creator   ?c .
    OPTIONAL { ?c  foaf:given   ?given ; foaf:family  ?family } .
    FILTER isBLANK(?c)
}</pre>
                <p>Query result:</p>
                <div class="result">
                  <table class="resultTable">
                    <tbody>
                      <tr>
                        <th>given</th>
                        <th>family</th>
                      </tr>
                      <tr>
                        <td>"Bob"</td>
                        <td>"Smith"</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
            <p>In this example, there were two objects of <code>dc:creator</code> predicates, but
              only one (<code>_:c</code>) was a blank node.</p>
          </section>
          <section id="func-isLiteral">
            <h5>isLITERAL</h5>
            <pre class="prototype nohighlight"> <span class="return">xsd:boolean</span>  <span class="operator">isLITERAL</span> (<span class="type"><span class="type">RDF term</span></span> <span class="name">term</span>)</pre>
            <p>Returns <code>true</code> if <code>term</code> is a <span class="type literal">literal</span>. Returns <code>false</code> otherwise.</p>
            <div class="exampleGroup">
              <pre class="data nohighlight">
PREFIX foaf:       &lt;http://xmlns.com/foaf/0.1/&gt;
                
_:a  foaf:name       "Alice".
_:a  foaf:mbox       &lt;mailto:alice@work.example&gt; .

_:b  foaf:name       "Bob" .
_:b  foaf:mbox       "bob@work.example" .
              </pre>
              <div class="queryGroup">
                <p>This query is similar to the one in <a href="#func-isIRI">17.4.2.1</a> except that
                  is matches the people with a <code>name</code> and an <code>mbox</code> which is a
                  literal. This could be used to look for erroneous data (<code>foaf:mbox</code> should
                  only have an IRI as its object).</p>
                <pre class="query nohighlight">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name ?mbox
WHERE {
    ?x foaf:name  ?name ;
       foaf:mbox  ?mbox .
    FILTER isLiteral(?mbox)
}
                </pre>
                <p>Query result:</p>
                <div class="result">
                  <table class="resultTable">
                    <tbody>
                      <tr>
                        <th>name</th>
                        <th>mbox</th>
                      </tr>
                      <tr>
                        <td>"Bob"</td>
                        <td>"bob@work.example"</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
          </section>
          <section id="func-isNumeric">
            <h5>isNUMERIC</h5>
            <pre class="prototype nohighlight"> <span class="return">xsd:boolean</span>  <span class="operator">isNUMERIC</span> (<span class="type"><span class="type">RDF term</span></span> <span class="name">term</span>)</pre>
            <p>Returns <code>true</code> if <code>term</code> is a numeric value. Returns
              <code>false</code> otherwise. <code>term</code> is numeric if it has an appropriate
              datatype (see the section <a href="#operandDataTypes">Operand Data Types</a>) and has a
              valid lexical form, making it a valid argument to functions and operators taking numeric
              arguments.</p>
            <p>Examples:</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>isNUMERIC(12)</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>isNUMERIC("12")</code></td>
                    <td>false</td>
                  </tr>
                  <tr>
                    <td><code>isNUMERIC("12"^^xsd:nonNegativeInteger)</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>isNUMERIC("1200"^^xsd:byte)</code></td>
                    <td>false</td>
                  </tr>
                  <tr>
                    <td><code>isNUMERIC(&lt;http://example/&gt;)</code></td>
                    <td>false</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-str">
            <h5>STR</h5>
            <pre class="prototype nohighlight">
<span class="return">xsd:string</span>  <span class="operator">STR</span> (<span class="type"><span class="type literal">literal</span></span> <span class="name">literal</span>)
<span class="return">xsd:string</span>  <span class="operator">STR</span> (<span class="type"><span class="type IRI">IRI</span></span> <span class="name">rsrc</span>)
            </pre>
            <p>Returns the <span class="type lexicalForm">lexical form</span> of <code>literal</code> (a
              <span class="type literal">literal</span>); returns the codepoint representation of
              <code>rsrc</code> (an <span class="type IRI">IRI</span>). This is useful for examining
              parts of an IRI, for instance, the host-name.</p>
            <div class="exampleGroup">
              <pre class="data nohighlight">
PREFIX foaf:       &lt;http://xmlns.com/foaf/0.1/&gt;

_:a  foaf:name       "Alice".
_:a  foaf:mbox       &lt;mailto:alice@work.example&gt; .

_:b  foaf:name       "Bob" .
_:b  foaf:mbox       &lt;mailto:bob@home.example&gt; .
              </pre>
              <div class="queryGroup">
                <p>This query selects the set of people who use their <code>work.example</code>
                  address in their foaf profile:</p>
                <pre class="query nohighlight">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name ?mbox
WHERE {
    ?x foaf:name  ?name ;
      foaf:mbox  ?mbox .
    FILTER regex(str(?mbox), "@work\\.example$")
}
                </pre>
                <p>Query result:</p>
                <div class="result">
                  <table class="resultTable">
                    <tbody>
                      <tr>
                        <th>name</th>
                        <th>mbox</th>
                      </tr>
                      <tr>
                        <td>"Alice"</td>
                        <td>&lt;mailto:alice@work.example&gt;</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
          </section>
          <section id="func-lang">
            <h5>LANG</h5>
            <pre class="prototype nohighlight"> <span class="return">xsd:string</span>  <span class="operator">LANG</span> (<span class="type"><span class="type literal">literal</span></span> <span class="name">ltrl</span>)
            </pre>
            <p>
              Returns the <a data-cite="RDF12-CONCEPTS#dfn-language-tag">language tag</a>
              of `ltrl`, if it has one. 
              It returns an empty string if `ltrl` has no 
              <a data-cite="RDF12-CONCEPTS#dfn-language-tag">language tag</a>.
              Note that the RDF data model does not include literals with an empty 
              <a data-cite="RDF12-CONCEPTS#dfn-language-tag">language tag</a>.
            </p>
            <div class="exampleGroup">
              <pre class="data nohighlight">
PREFIX foaf:       &lt;http://xmlns.com/foaf/0.1/&gt;

_:a  foaf:name       "Robert"@en.
_:a  foaf:name       "Roberto"@es.
_:a  foaf:mbox       &lt;mailto:bob@work.example&gt; .
              </pre>
              <div class="queryGroup">
                <p>This query finds the Spanish `foaf:name` and `foaf:mbox`:</p>
                <pre class="query nohighlight">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name ?mbox
WHERE {
    ?x foaf:name  ?name ;
       foaf:mbox  ?mbox .
    FILTER ( lang(?name) = "es" )
}
                </pre>
                <p>Query result:</p>
                <div class="result">
                  <table class="resultTable">
                    <tbody>
                      <tr>
                        <th>name</th>
                        <th>mbox</th>
                      </tr>
                      <tr>
                        <td>"Roberto"@es</td>
                        <td>&lt;mailto:bob@work.example&gt;</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
            </div>

            <p>
              Function examples:
            </p>
            <div class="result">
              <table>
                <thead>
                  <tr>
                    <th>Expression</th>
                    <th>Result</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><code>LANG("abc"@en)</code></td>
                    <td><code>"en"</code></td>
                  </tr>
                  <tr>
                    <td><code>LANG("abc"@en--ltr)</code></td>
                    <td><code>"en"</code></td>
                  </tr>
                  <tr>
                    <td><code>LANG("abc")</code></td>
                    <td><code>""</code></td>
                  </tr>
                  <tr>
                    <td><code>LANG(1)</code></td>
                    <td><code>""</code></td>
                  </tr>
                  <tr>
                    <td><code>LANG(&lt;http://example/&gt;)</code></td>
                    <td><code>error</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>

          <section id="func-langdir">
            <h5>LANGDIR</h5>
            <pre class="prototype nohighlight"> <span class="return">xsd:string</span>  <span class="operator">LANGDIR</span> (<span class="type"><span class="type literal">literal</span></span> <span class="name">ltrl</span>)
            </pre>
            <p>
              Returns the <a data-cite="RDF12-CONCEPTS#dfn-base-direction">base direction</a>
              of `ltrl`, if it has one. 
              It returns an empty string if `ltrl` has no
              <a data-cite="RDF12-CONCEPTS#dfn-base-direction">base direction</a>.
              Note that the RDF data model does not include literals with an empty 
              <a data-cite="RDF12-CONCEPTS#dfn-base-direction">base direction</a>.
            </p>
            <div class="result">
              <table>
                <thead>
                  <tr>
                    <th>Expression</th>
                    <th>Result</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><code>LANGDIR("abc"@en--ltr)</code></td>
                    <td><code>"ltr"</code></td>
                  </tr>
                  <tr>
                    <td><code>LANGDIR("abc"@en)</code></td>
                    <td><code>""</code></td>
                  </tr>
                  <tr>
                    <td><code>LANGDIR("abc")</code></td>
                    <td><code>""</code></td>
                  </tr>
                  <tr>
                    <td><code>LANGDIR(1)</code></td>
                    <td><code>""</code></td>
                  </tr>
                  <tr>
                    <td><code>LANGDIR(&lt;http://example/&gt;)</code></td>
                    <td><code>error</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>

          <section id="func-haslang">
            <h5>hasLANG</h5>
            <pre class="prototype nohighlight"> <span class="return">xsd:string</span>  <span class="operator">hasLANG</span> (<span class="type">RDF term</span> <span class="name">term</span>)
            </pre>
            <p>
              Returns `true` if the RDF term argument is a literal with a 
              <a data-cite="RDF12-CONCEPTS#dfn-language-tag">language tag</a>.
              Otherwise, the function returns `false`.
            </p>
            <p>If the argument is a literal, the function is equivalent to
              testing for the datatype of the literal being either
              `rdf:langString` or `rdf:dirLangString`.
            </p>
             <div class="result">
               <table>
                 <thead>
                   <tr>
                     <th>Expression</th>
                     <th>Result</th>
                   </tr>
                 </thead>
                 <tbody>
                   <tr>
                     <td><code>hasLANG("abc"@en)</code></td>
                     <td><code>true</code></td>
                   </tr>
                   <tr>
                     <td><code>hasLANG("abc@"en--ltr)</code></td>
                     <td><code>true</code></td>
                   </tr>
                   <tr>
                     <td><code>hasLANG("ØªØµÙ…ÙŠÙ… Ø§Ù„Ù…ÙˆØ§Ù‚Ø¹"@ar--rtl)</code></td>
                     <td><code>true</code></td>
                   </tr>
                   <tr>
                     <td><code>hasLANG(1)</code></td>
                     <td><code>false</code></td>
                   </tr>
                   <tr>
                     <td><code>hasLANG(&lt;http://example/&gt;)</code></td>
                     <td><code>false</code></td>
                   </tr>
                 </tbody>
               </table>
             </div>
          </section>

          <section id="func-haslangdir">
            <h5>hasLANGDIR</h5>
            <pre class="prototype nohighlight"> <span class="return">xsd:string</span>  <span class="operator">hasLANGDIR</span> (<span class="type">RDF term</span> <span class="name">term</span>)
            </pre>
            <p>
              Returns `true` if the RDF term argument is a literal with a 
              <a data-cite="RDF12-CONCEPTS#dfn-base-direction">base direction</a>.
              Otherwise, the function returns `false`.
            </p>
            <p>If the argument is a literal, the function is equivalent to
              testing for the datatype of the literal being
              `rdf:dirLangString`.
            </p>
             <div class="result">
               <table>
                 <thead>
                   <tr>
                     <th>Expression</th>
                     <th>Result</th>
                   </tr>
                 </thead>
                 <tbody>
                   <tr>
                     <td><code>hasLANGDIR("abc"@en)</code></td>
                     <td><code>false</code></td>
                   </tr>
                   <tr>
                     <td><code>hasLANGDIR("abc@"en--ltr)</code></td>
                     <td><code>true</code></td>
                   </tr>
                   <tr>
                     <td><code>hasLANGDIR("ØªØµÙ…ÙŠÙ… Ø§Ù„Ù…ÙˆØ§Ù‚Ø¹"@ar--rtl)</code></td>
                     <td><code>true</code></td>
                   </tr>
                   <tr>
                     <td><code>hasLANGDIR(1)</code></td>
                     <td><code>false</code></td>
                   </tr>
                   <tr>
                     <td><code>hasLANGDIR(&lt;http://example/&gt;)</code></td>
                     <td><code>false</code></td>
                   </tr>
                 </tbody>
               </table>
             </div>
          </section>

          <section id="func-datatype">
            <h5>DATATYPE</h5>
            <pre class="prototype nohighlight"> <span class="return"><span class="type IRI">iri</span></span>  <span class="operator">DATATYPE</span> (<span class="type"><span class="type">literal</span></span> <span class="name">literal</span>)
            </pre>
            <p>
              Returns the <a data-cite="RDF12-CONCEPTS#dfn-datatype-iri">datatype IRI</a> of the given literal.
            </p>
            <div class="note">
              <p>
                The <a data-cite="RDF12-CONCEPTS#dfn-datatype-iri">datatype IRI</a>
                of a literal with a
                <a data-cite="RDF12-CONCEPTS#dfn-language-tag">language tag</a>
                and <em>no</em> <a data-cite="RDF12-CONCEPTS#dfn-base-direction">base direction</a>
                is <code>rdf:langString</code>.
              </p>
              <p>
                 The <a data-cite="RDF12-CONCEPTS#dfn-datatype-iri">datatype IRI</a>
                of a literal with a
                <a data-cite="RDF12-CONCEPTS#dfn-language-tag">language tag</a> 
                and a
                <a data-cite="RDF12-CONCEPTS#dfn-base-direction">base direction</a>
                is <code>rdf:dirLangString</code>.
              </p>
            </div>
            <div class="exampleGroup">
              <pre class="data nohighlight">
PREFIX foaf:       &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX eg:         &lt;http://biometrics.example/ns#&gt;
PREFIX xsd:        &lt;http://www.w3.org/2001/XMLSchema#&gt;

_:a  foaf:name       "Alice".
_:a  eg:shoeSize     "9.5"^^xsd:float .

_:b  foaf:name       "Bob".
_:b  eg:shoeSize     "42"^^xsd:integer .
              </pre>
              <div class="queryGroup">
                <p>This query finds the <code>foaf:name</code> and <code>foaf:shoeSize</code> of
                  everyone with a shoeSize that is an integer:</p>
                <pre class="query nohighlight">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX xsd:  &lt;http://www.w3.org/2001/XMLSchema#&gt;
PREFIX eg:   &lt;http://biometrics.example/ns#&gt;
SELECT ?name ?shoeSize
WHERE { 
    ?x foaf:name  ?name ;
       eg:shoeSize  ?shoeSize .
    FILTER ( datatype(?shoeSize) = xsd:integer )
}</pre>
                <p>Query result:</p>
                <div class="result">
                  <table class="resultTable">
                    <tbody>
                      <tr>
                        <th>name</th>
                        <th>shoeSize</th>
                      </tr>
                      <tr>
                        <td>"Bob"</td>
                        <td>42</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
          </section>
          <section id="func-iri">
            <span id="func-uri"></span>
            <h5>IRI</h5>
            <pre class="prototype nohighlight">
              <span class="return">iri</span>  <span class="operator">IRI</span>(<span class="type">xsd:string</span>)
              <span class="return">iri</span>  <span class="operator">IRI</span>(<span class="type">iri</span>)
              <span class="return">iri</span>  <span class="operator">URI</span>(<span class="type">xsd:string</span>)
              <span class="return">iri</span>  <span class="operator">URI</span>(<span class="type">iri</span>)</pre>
            <p>The <code>IRI</code> function constructs an IRI by resolving the string argument (see
              [[RFC3986]] and [[RFC3987]] or any later RFC that superceeds RFC 3986 or RFC 3987). The
              IRI is resolved against the base IRI of the query and must result in an absolute IRI.</p>
            <p>The <code>URI</code> function is a synonym for <a href="#func-iri"><code>IRI</code></a>.</p>
            <p>If the function is passed an IRI, it returns the IRI unchanged.</p>
            <p>Passing any RDF term other than a literal with datatype <code>xsd:string</code> or an IRI is an
              error.</p>
            <p>An implementation MAY normalize the IRI.</p>
            <p>Examples:</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>IRI("http://example/")</code></td>
                    <td>&lt;http://example/&gt;</td>
                  </tr>
                  <tr>
                    <td><code>IRI(&lt;http://example/&gt;)</code></td>
                    <td>&lt;http://example/&gt;</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-bnode">
            <h5>BNODE</h5>
            <pre class="prototype nohighlight"><span class="return">blank node</span>  <span class="operator">BNODE</span>()</pre>
            <pre class="prototype nohighlight"><span class="return">blank node</span>  <span class="operator">BNODE</span>(<span class="type">xsd:string</span>)</pre>
            <p>The <code>BNODE</code> function constructs a blank node that is distinct from all
              blank nodes in the dataset being queried and distinct from all blank nodes created by
              calls to this constructor for other query solutions. If the no argument form is used,
              every call results in a distinct blank node. If the form with an <code>xsd:string</code> literal is used,
              every call results in distinct blank nodes for different <code>xsd:string</code> literals, and the same
              blank node for calls with the same <code>xsd:string</code> literal within expressions for one <a href="#defn_sparqlSolutionMapping">solution mapping</a>.
            </p>
            <p>This functionality is compatible with the <a href="#templatesWithBNodes">treatment of
                blank nodes in SPARQL CONSTRUCT templates</a>.</p>
          </section>

          <section id="func-strdt">
            <h5>STRDT</h5>
            <pre class="prototype nohighlight"><span class="return">literal</span>  <span class="operator">STRDT</span>(<span class="type">xsd:string</span> lexicalForm, <span class="type">IRI</span> datatypeIRI)</pre>
            <p>The <code>STRDT</code> function constructs a literal with
              <a data-cite="RDF12-CONCEPTS#dfn-lexical-form">lexical form</a>
              and 
              <a data-cite="RDF12-CONCEPTS#dfn-datatype-iri">datatype IRI</a>
              as specified by the arguments.
            </p>
            <div class="result">
              <table>
                <thead>
                  <tr>
                    <th>Expression</th>
                    <th>Result</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><code>STRDT("123", xsd:integer)</code></td>
                    <td>"123"^^&lt;http://www.w3.org/2001/XMLSchema#integer&gt;</td>
                  </tr>
                  <tr>
                    <td><code>STRDT("iiii", &lt;http://example/romanNumeral&gt;)</code></td>
                    <td>"iiii"^^&lt;http://example/romanNumeral&gt;</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="note">
                `STRDT` should not be called with `datatypeIRI` argument
                `rdf:langString` or `rdf:dirLangString`. To create literals with
                these IRIs as datatype IRI, function `STRLANG`
                or `STRLANGDIR` should be used.
            </div>
          </section>

          <section id="func-strlang">
            <h5>STRLANG</h5>
            <pre class="prototype nohighlight"><span class="return">literal</span>  <span class="operator">STRLANG</span>(<span class="type">xsd:string</span> lexicalForm, <span class="type">xsd:string</span> langTag)</pre>
            <p>The <code>STRLANG</code> function constructs a literal with
              <a data-cite="RDF12-CONCEPTS#dfn-lexical-form">lexical form</a>
              and
              <a data-cite="RDF12-CONCEPTS#dfn-language-tag">language tag</a>,
              as specified by the arguments, 
              and a datatype IRI of `rdf:langString`.
            </p>
            <p>
              The argument `langTag` MUST not be an empty string and SHOULD be a
              valid <a data-cite="RDF12-CONCEPTS#dfn-language-tag">language tag</a>.
            </p>
            <div class="result">
              <table>
                <thead>
                  <tr>
                    <th>Expression</th>
                    <th>Result</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><code>STRLANG("chat", "fr")</code></td>
                    <td>"chat"@fr</td>
                  </tr>
                  <tr>
                    <td><code>STRLANG("abc", "")</code></td>
                    <td style="text-align: center"><em>error</em></td>
                </tr>
                <tr>
                  <td><code>STRLANG(123, "en")</code></td>
                  <td style="text-align: center"><em>error</em></td>
                </tr>
              </tbody>
            </table>
          </section>

          <section id="func-strlangdir">
            <h5>STRLANGDIR</h5>
            <pre class="prototype nohighlight"><span class="return">literal</span>  <span class="operator">STRLANGDIR</span>(<span class="type">xsd:string</span> lexicalForm, <span class="type">xsd:string</span> langTag, <span class="type">xsd:string</span> baseDirection)</pre>
            <p>
              The <code>STRLANGDIR</code> function constructs a literal with 
               <a data-cite="RDF12-CONCEPTS#dfn-lexical-form">lexical form</a>, 
              <a data-cite="RDF12-CONCEPTS#dfn-language-tag">language tag</a> and
              <a data-cite="RDF12-CONCEPTS#dfn-base-direction">base direction</a>, 
              as specified by the arguments, and a  datatype IRI of `rdf:dirLangString`.
            </p>
            <p>
              The argument `langTag` MUST NOT be an empty string and SHOULD be a
              valid <a data-cite="RDF12-CONCEPTS#dfn-language-tag">language tag</a>.
              The argument `baseDirection` MUST be either `"ltr"` or `"rtl"`.
            </p>
            <div class="result">
              <table>
                <thead>
                  <tr>
                    <th>Expression</th>
                    <th>Result</th>
                  </tr>
                </thead> 
                <tbody>
                <tr>
                  <td><code>STRLANGDIR("abc", "en", "ltr")</code></td>
                  <td><code>"abc"@en--ltr</code></td>
                </tr>
                <tr>
                  <td><code>STRLANGDIR("abc", "en", "LTR")</code></td>
                  <td style="text-align: center"><em>error</em></td>
                </tr>
                  <tr>
                    <td><code>STRLANGDIR("Ù‚Ø·Ø©", "ar", "rtl")</code></td>
                    <td>"Ù‚Ø·Ø©"@ar--rlt</td>
                  </tr>
                <tr>
                  <td><code>STRLANGDIR("abc", "en", "")</code></td>
                  <td style="text-align: center"><em>error</em></td>
                </tr>
                <tr>
                  <td><code>STRLANGDIR("abc", "", "ltr")</code></td>
                  <td style="text-align: center"><em>error</em></td>
                </tr>
                <tr>
                  <td><code>STRLANGDIR(123, "", "ltr")</code></td>
                  <td style="text-align: center"><em>error</em></td>
                </tr>
                <tr>
                  <td><code>STRLANGDIR(&lt;x:uri&gt;, "en", "ltr")</code></td>
                  <td style="text-align: center"><em>error</em></td>
                </tr>
              </tbody>
            </table>
          </section>

          <section id="func-uuid">
            <h5>UUID</h5>
            <pre class="prototype nohighlight"><span class="return">iri</span>  <span class="operator">UUID</span>()</pre>
            <p>Returns a fresh IRI from the [[[RFC4122]]]. Each call of <code>UUID()</code> returns a
              different UUID. It must not be the "nil" UUID (all zeroes). The variant and version of
              the UUID is implementation dependent.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>UUID()</code></td>
                    <td><code>&lt;urn:uuid:b9302fb5-642e-4d3b-af19-29a8f6d894c9&gt;</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-struuid">
            <h5>STRUUID</h5>
            <pre class="prototype nohighlight"><span class="return">xsd:string</span>  <span class="operator">STRUUID</span>()</pre>
            <p>Returns a string that is the scheme-specific part of UUID. That is, as a literal with datatype <code>xsd:string</code>,
              the result of generating a UUID, converting to a literal with datatype <code>xsd:string</code> and removing the
              initial <code>urn:uuid:</code>.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>STRUUID()</code></td>
                    <td><code>"73cd4307-8a99-4691-a608-b5bda64fb6c1"</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
        </section>

        <section id="func-string">
          <h4>Functions on Strings</h4>
          <p>Certain functions (e.g., <a href="#func-regex">REGEX</a>, <a href="#func-strlen">STRLEN</a>, <a href="#func-contains">CONTAINS</a>)
            take a <dfn>string literal</dfn> 
            as an argument. A string literal is one of
          </p>
          <ul>
            <li>a literal with datatype <code>xsd:string</code></li>
            <li>a literal with datatype <code>rdf:langString</code> and
              with <a data-cite="RDF12-CONCEPTS#dfn-language-tag">language tag</a></li>
            <li>a literal with datatype <code>rdf:dirLangString</code> and 
              with both a <a data-cite="RDF12-CONCEPTS#dfn-language-tag">language tag</a>
              and a <a data-cite="RDF12-CONCEPTS#dfn-base-direction">base direction</a></li>
          </ul>
          <p>Use of any other RDF term will cause a call to the function to raise an error.</p>
          <p class="note">
            <code>"abc"</code> is a                 
            <a data-cite="RDF12-CONCEPTS#dfn-simple-literal">simple literal</a>
            syntactic shorthand for <code>"abc"^^xsd:string</code>.
          </p>

          <span id="string-literal-return-type"></span>
          <p>The functions <a href="#func-substr">SUBSTR</a>, 
            <a href="#func-strbefore">STRBEFORE</a>,
            <a href="#func-strafter">STRAFTER</a>,
            and <a href="#func-replace">REPLACE</a> return a <a>string literal</a> of the same
            kind as their first argument.
          </p>

          <span id="func-arg-compatibility"></span>
          <p>The functions <a href="#func-strstarts">STRSTARTS</a>, 
            <a href="#func-strends">STRENDS</a>,
            <a href="#func-contains">CONTAINS</a>, 
            <a href="#func-strbefore">STRBEFORE</a>,
            <a href="#func-strafter">STRAFTER</a> and 
            <a href="#func-concat">CONCAT</a>
            take two or more arguments. These arguments must be <dfn>argument compatible</dfn>; otherwise, invocation of the
            function raises an error.</p>

          <p>Two <a>string literal</a> arguments are <a>argument compatible</a> if:
          <ul>
            <li>
              The arguments are literals with datatype <code>xsd:string</code>
            </li>
            <li>
              The arguments are literals with datatype <code>rdf:langString</code>
              and have the same <a data-cite="RDF12-CONCEPTS#dfn-language-tag">language tag</a>
            </li>
            <li>
              The arguments are literals with datatype <code>rdf:dirLangString</code>
              and have the same 
              <a data-cite="RDF12-CONCEPTS#dfn-language-tag">language tag</a>
              and the same <a data-cite="RDF12-CONCEPTS#dfn-base-direction">base direction</a>
            </li>
            <li>
              The first argument is a literal with datatype <code>rdf:langString</code> 
              and the second argument is a literal with datatype <code>xsd:string</code>
            </li>
            <li>
              The first argument is a literal with datatype <code>rdf:dirLangString</code>,
              and the second argument has datatype <code>xsd:string</code>
            </li>
          </ul>
          <div class="result">
            <table>
              <tbody>
                <tr>
                  <th>Argument1</th>
                  <th>Argument2</th>
                  <th>Compatible?</th>
                </tr>
                <tr>
                  <td>"abc"</td>
                  <td>"b"</td>
                  <td>yes</td>
                </tr>
                <tr>
                  <td>"abc"@en</td>
                  <td>"b"</td>
                  <td>yes</td>
                </tr>
                <tr>
                  <td>"abc"@en</td>
                  <td>"b"@en</td>
                  <td>yes</td>
                </tr>
                <tr>
                  <td>"abc"@fr</td>
                  <td>"b"@ja</td>
                  <td>no</td>
                </tr>
                <tr>
                  <td>"abc"</td>
                  <td>"b"@ja</td>
                  <td>no</td>
                </tr>
                <tr>
                  <td>"abc"</td>
                  <td>"b"@en--ltr</td>
                  <td>no</td>
                </tr>
                <tr>
                  <td>"abc"@en--ltr</td>
                  <td>"b"@en--ltr</td>
                  <td>yes</td>
                </tr>
                <tr>
                  <td>"abc"@en--ltr</td>
                  <td>"b"@en</td>
                  <td>no</td>
                </tr>
                <tr>
                  <td>"abc"@en--ltr</td>
                  <td>"z"</td>
                  <td>yes</td>
                </tr>
              </tbody>
            </table>
          </div>
          
          <section id="func-strlen">
            <h5>STRLEN</h5>
            <pre class="prototype nohighlight"><span class="return">xsd:integer</span>  <span class="operator">STRLEN</span>(<span class="type">string literal</span> str)</pre>
            <p>The <code>strlen</code> function corresponds to the XPath
              <a data-cite="XPATH-FUNCTIONS-31#func-string-length">fn:string-length</a>
              function and returns an
              <code>xsd:integer</code> equal to the length in characters of the 
              <a data-cite="RDF12-CONCEPTS#dfn-lexical-form">lexical form</a> of the
              literal.
            </p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>strlen("chat")</code></td>
                    <td>4</td>
                  </tr>
                  <tr>
                    <td><code>strlen("chat"@en)</code></td>
                    <td>4</td>
                  </tr>
                  <tr>
                    <td><code>strlen("chat"@en--ltr)</code></td>
                    <td>4</td>
                  </tr>
                  <tr>
                    <td><code>strlen("chat"^^xsd:string)</code></td>
                    <td>4</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-substr">
            <h5>SUBSTR</h5>
            <pre class="prototype nohighlight">
<span class="return">string literal</span>  <span class="operator">SUBSTR</span>(<span class="type">string literal</span> source, <span class="type">xsd:integer</span> startingLoc)
<span class="return">string literal</span>  <span class="operator">SUBSTR</span>(<span class="type">string literal</span> source, <span class="type">xsd:integer</span> startingLoc, <span class="type">xsd:integer</span> length)
            </pre>
            <p>The <code>substr</code> function corresponds to the XPath 
              <a data-cite="XPATH-FUNCTIONS-31#func-substring">fn:substring</a> function and returns a literal of the
              same kind (literal with datatype <code>xsd:string</code>, literal with the same language tag,
              literal with the same language tag and base direction)
              as the <code>source</code> input parameter but with a 
              <a data-cite="RDF12-CONCEPTS#dfn-lexical-form">lexical form</a> 
              derived from the substring of the lexical form of the source.
            </p>
            <p>The arguments <code>startingLoc</code> and <code>length</code> may be derived types of
              xsd:integer.
            </p>
            <p>The index of the first character in a string is 1.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>substr("foobar", 4)</code></td>
                    <td>"bar"</td>
                  </tr>
                  <tr>
                    <td><code>substr("foobar"@en, 4)</code></td>
                    <td>"bar"@en</td>
                  </tr>
                  <tr>
                    <td><code>substr("foobar"^^xsd:string, 4)</code></td>
                    <td>"bar"^^xsd:string</td>
                  </tr>
                  <tr>
                    <td><code>substr("foobar", 4, 1)</code></td>
                    <td>"b"</td>
                  </tr>
                  <tr>
                    <td><code>substr("foobar"@en, 4, 1)</code></td>
                    <td>"b"@en</td>
                  </tr>
                  <tr>
                    <td><code>substr("foobar"^^xsd:string, 4, 1)</code></td>
                    <td>"b"^^xsd:string</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-ucase">
            <h5>UCASE</h5>
            <pre class="prototype nohighlight"><span class="return">string literal</span>  <span class="operator">UCASE</span>(<span class="type">string literal</span> str)</pre>
            <p>The <code>UCASE</code> function corresponds to the XPath 
              <a data-cite="XPATH-FUNCTIONS-31#func-upper-case">fn:upper-case</a>
              function. It returns a <a>string literal</a>
              whose lexical form is the upper case of the lexical form of the argument.
            </p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>ucase("foo")</code></td>
                    <td>"FOO"</td>
                  </tr>
                  <tr>
                    <td><code>ucase("Foo"@en)</code></td>
                    <td>"FOO"@en</td>
                  </tr>
                  <tr>
                    <td><code>ucase("foo"@en--ltr)</code></td>
                    <td>"FOO"@en--ltr</td>
                  </tr>
                  <tr>
                    <td><code>ucase("foo"^^xsd:string)</code></td>
                    <td>"FOO"^^xsd:string</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-lcase">
            <h5>LCASE</h5>
            <pre class="prototype nohighlight"><span class="return">string literal</span>  <span class="operator">LCASE</span>(<span class="type">string literal</span> str)</pre>
            <p>The <code>LCASE</code> function corresponds to the XPath 
              <a data-cite="XPATH-FUNCTIONS-31#func-lower-case">fn:lower-case</a> function.
              It returns a string literal whose lexical form is the lower case of the lexical form of the argument.
            </p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>lcase("BAR")</code></td>
                    <td>"bar"</td>
                  </tr>
                  <tr>
                    <td><code>lcase("Bar"@en)</code></td>
                    <td>"bar"@en</td>
                  </tr>
                    <td><code>lcase("BAR"@en--ltr)</code></td>
                    <td>"bar"@en--ltr</td>
                  </tr>
                  <tr>
                    <td><code>lcase("BAR"^^xsd:string)</code></td>
                    <td>"bar"^^xsd:string</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-strstarts">
            <h5>STRSTARTS</h5>
            <pre class="prototype nohighlight"><span class="return">xsd:boolean</span>  <span class="operator">STRSTARTS</span>(<span class="type">string literal</span> arg1, <span class="type">string literal</span> arg2)</pre>
            <p>The <code>STRSTARTS</code> function corresponds to the XPath <a data-cite="XPATH-FUNCTIONS-31#func-starts-with">fn:starts-with</a> function.
              The arguments must be <a>argument compatible</a>,
              otherwise an error is raised.
            </p>
            <p>For such input pairs, the function returns true if the lexical form of
              <code>arg1</code> starts with the lexical form of <code>arg2</code>, otherwise it returns
              false.
            </p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>strStarts("foobar", "foo")</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>strStarts("foobar", "abc")</code></td>
                    <td>false</td>
                  </tr>
                  <tr>
                    <td><code>strStarts("foobar"@en, "foo"@en)</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>strStarts("foobar"^^xsd:string, "foo"^^xsd:string)</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>strStarts("foobar"^^xsd:string, "foo")</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>strStarts("foobar", "foo"^^xsd:string)</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>strStarts("foobar"@en, "foo")</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>strStarts("foobar"@en, "foo"^^xsd:string)</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>strStarts("foobar", "foo"@en)</code></td>
                    <td><i>error</i></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-strends">
            <h5>STRENDS</h5>
            <pre class="prototype nohighlight"><span class="return">xsd:boolean</span>  <span class="operator">STRENDS</span>(<span class="type">string literal</span> arg1, <span class="type">string literal</span> arg2)</pre>
            <p>The <code>STRENDS</code> function corresponds to the XPath <a data-cite="XPATH-FUNCTIONS-31#func-ends-with">fn:ends-with</a> function.
              The arguments must be <a>argument compatible</a>,
              otherwise an error is raised.
            </p>
            <p>For such input pairs, the function returns true if the lexical form of
              <code>arg1</code> ends with the lexical form of <code>arg2</code>, otherwise it returns
              false.
            </p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>strEnds("foobar", "bar")</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>strEnds("foobar", "abc")</code></td>
                    <td>false</td>
                  </tr>
                  <tr>
                    <td><code>strEnds("foobar"@en, "bar"@en)</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>strEnds("foobar"^^xsd:string, "bar"^^xsd:string)</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>strEnds("foobar"^^xsd:string, "bar")</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>strEnds("foobar", "bar"^^xsd:string)</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>strEnds("foobar"@en, "bar")</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>strEnds("foobar"@en, "bar"^^xsd:string)</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>strEnds("foobar"@en, "bar"@en)</code></td>
                    <td><i>error</i></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-contains">
            <h5>CONTAINS</h5>
            <pre class="prototype nohighlight"><span class="return">xsd:boolean</span>  <span class="operator">CONTAINS</span>(<span class="type">string literal</span> arg1, <span class="type">string literal</span> arg2)</pre>
            <p>The <code>CONTAINS</code> function corresponds to the XPath <a data-cite="XPATH-FUNCTIONS-31#func-contains">fn:contains</a>.
              The arguments must be <a>argument compatible</a>,
              otherwise an error is raised.
            </p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>contains("foobar", "bar")</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>contains("foobar"@en, "foo"@en)</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>contains("foobar"^^xsd:string, "bar"^^xsd:string)</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>contains("foobar"^^xsd:string, "foo")</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>contains("foobar", "bar"^^xsd:string)</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>contains("foobar"@en, "foo")</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>contains("foobar"@en, "bar"^^xsd:string)</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>contains("foobar", "bar"@en)</code></td>
                    <td><i>error</i></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-strbefore">
            <h5>STRBEFORE</h5>
            <pre class="prototype nohighlight"><span class="return">literal</span>  <span class="operator">STRBEFORE</span>(<span class="type">string literal</span> arg1, <span class="type">string literal</span> arg2)</pre>
            <p>The <code>STRBEFORE</code> function corresponds to the XPath <a data-cite="XPATH-FUNCTIONS-31#func-substring-before">fn:substring-before</a> function.
              The arguments must be <a>argument compatible</a>,
              otherwise an error is raised.
            </p>
            <p>For compatible arguments, if the lexical part of the second argument occurs as a
              substring of the lexical part of the first argument, the function returns a literal of
              the same kind as the first argument <code>arg1</code> (literal with datatype <code>xsd:string</code>, literal with the same
              language tag). The lexical form of the result is the substring of the lexical
              form of <code>arg1</code> that precedes the first occurrence of the lexical form of
              <code>arg2</code>. If the lexical form of <code>arg2</code> is the empty string, this is
              considered to be a match and the lexical form of the result is the empty string.</p>
            <p>If there is no such occurrence, an empty literal with datatype <code>xsd:string</code> is returned.
            </p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td>`strBefore("abc","b")`</td>
                    <td>`"a"`</td>
                  </tr>
                  <tr>
                    <td>`strBefore("abc"@en,"bc")`</td>
                    <td>`"a"@en`</td>
                  </tr>
                  <tr>
                    <td>`strBefore("abc"@en,"b"@cy)`</td>
                    <td><i>error</i></td>
                  </tr>
                  <tr>
                    <td>`strBefore("abc"^^xsd:string,"")`</td>
                    <td>`""^^xsd:string`</td>
                  </tr>
                  <tr>
                    <td>`strBefore("abc","xyz")`</td>
                    <td>`""`</td>
                  </tr>
                  <tr>
                    <td>`strBefore("abc"@en, "z"@en)`</td>
                    <td>`""`</td>
                  </tr>
                  <tr>
                    <td>`strBefore("abc"@en, "z")`</td>
                    <td>`""`</td>
                  </tr>
                  <tr>
                    <td>`strBefore("abc"@en, ""@en)`</td>
                    <td>`""@en`</td>
                  </tr>
                  <tr>
                    <td>`strBefore("abc"@en, "")`</td>
                    <td>`""@en`</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-strafter">
            <h5>STRAFTER</h5>
            <pre class="prototype nohighlight"><span class="return">literal</span>  <span class="operator">STRAFTER</span>(<span class="type">string literal</span> arg1, <span class="type">string literal</span> arg2)</pre>
            <p>The <code>STRAFTER</code> function corresponds to the XPath <a data-cite="XPATH-FUNCTIONS-31#func-substring-after">fn:substring-after</a> function.
              The arguments must be <a>argument compatible</a>,
              otherwise an error is raised.
            </p>
            <p>For compatible arguments, if the lexical part of the second argument occurs as a
              substring of the lexical part of the first argument, the function returns a literal of
              the same kind as the first argument <code>arg1</code> (literal with datatype <code>xsd:string</code>, literal with the same
              language tag). The lexical form of the result is the substring of the lexical
              form of <code>arg1</code> that follows the first occurrence of the lexical form of
              <code>arg2</code>. If the lexical form of <code>arg2</code> is the empty string, this is
              considered to be a match and the lexical form of the result is the lexical form of
              <code>arg1</code>.</p>
            <p>If there is no such occurrence, an empty literal with datatype <code>xsd:string</code> is returned.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td>`strAfter("abc","b")`</td>
                    <td>`"c"</td>
                  </tr>
                  <tr>
                    <td>`strAfter("abc"@en,"ab")`</td>
                    <td>`"c"@en`</td>
                  </tr>
                  <tr>
                    <td>`strAfter("abc"@en,"b"@cy)`</td>
                    <td><i>error</i></td>
                  </tr>
                  <tr>
                    <td>`strAfter("abc"^^xsd:string,"")`</td>
                    <td>`"abc"^^xsd:string`</td>
                  </tr>
                  <tr>
                    <td>`strAfter("abc","xyz")`</td>
                    <td>`""`</td>
                  </tr>
                  <tr>
                    <td>`strAfter("abc"@en, "z"@en)`</td>
                    <td>`""`</td>
                  </tr>
                  <tr>
                    <td>`strAfter("abc"@en, "z")`</td>
                    <td>`""`</td>
                  </tr>
                  <tr>
                    <td>`strAfter("abc"@en, ""@en)`</td>
                    <td>`"abc"@en`</td>
                  </tr>
                  <tr>
                    <td>`strAfter("abc"@en, "")`</td>
                    <td>`"abc"@en`</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-concat">
            <h5>CONCAT</h5>
            <pre class="prototype nohighlight"><span class="return">string literal</span>  <span class="operator">CONCAT</span>(<span class="type">string literal</span>, ..., <span class="type">string literal</span>)</pre>
            <p>The <code>CONCAT</code> function takes zero or more arguments.
              The arguments must be pair-wise <a>argument compatible</a>,
              otherwise an error is raised.
            </p>
            <p>
              If zero arguments are given, the result is an empty string of datatype `xsd:string`.
            </p>
            <p>
              If one argument is given, the result is that argument value.
            </p>
            <p>
              If two or more arguments are given, the function returns a
              <a>string literal</a> such that the
              <a data-cite="RDF12-CONCEPTS#dfn-lexical-form">lexical form</a> 
              of the resulting string literal is obtained by concatenating the
              lexical forms of the arguments of the function using the
              <a data-cite="XPATH-FUNCTIONS-31#func-concat">fn:concat</a> function.
              If all input literals are literals with the same 
              <a data-cite="RDF12-CONCEPTS#dfn-language-tag">language tag</a>
              and the same
              <a data-cite="RDF12-CONCEPTS#dfn-base-direction">base direction</a>,
              then the returned string literal is a literal with that language
              tag and base direction.
              If  all input literals are literals with the same 
              <a data-cite="RDF12-CONCEPTS#dfn-language-tag">language tag</a>,
              but not all the same 
              <a data-cite="RDF12-CONCEPTS#dfn-base-direction">base direction</a>,
              the returned literal is a literal with that language tag and no
              base direction.
            </p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>concat("foo", "bar")</code></td>
                    <td>"foobar"</td>
                  </tr>
                  <tr>
                    <td><code>concat("foo"@en, "bar"@en)</code></td>
                    <td>"foobar"@en</td>
                  </tr>
                  <tr>
                    <td><code>concat("foo", "bar")</code></td>
                    <td>"foobar"</td>
                  </tr>
                  <tr>
                    <td><code>concat("foo"@en, "bar")</code></td>
                    <td>"foobar"</td>
                  </tr>
                  <tr>
                    <td><code>concat("foo"@en, "bar"@es)</code></td>
                    <td>"foobar"</td>
                  </tr>
                  <tr>
                    <td><code>concat("abc")</code></td>
                    <td>"abc"</td>
                  </tr>
                  <tr>
                    <td><code>concat("abc"@en)</code></td>
                    <td>"abc"@en</td>
                  </tr>
                  <tr>
                    <td><code>concat()</code></td>
                    <td>""</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-langMatches">
            <h5>langMATCHES</h5>
            <pre class="prototype nohighlight"> <span class="return">xsd:boolean</span>  <span class="operator">langMatches</span> (<span class="type"><span class="type">xsd:string</span></span> <span class="name">language-tag</span>, <span class="type"><span class="type">xsd:string</span></span> <span class="name">language-range</span>)
            </pre>

            <p>Returns `true` if the argument <code>language-tag</code> (a <a data-cite="RDF12-CONCEPTS#dfn-language-tag">language tag</a>)
               matches the argument <code>language-range</code> (a [basic language range](https://www.rfc-editor.org/rfc/rfc4647#section-2.1) per [[[RFC4647]]] [[RFC4647]] section 2.1)
              according to the basic filtering scheme defined in
              [[RFC4647]] section 3.3.1. Otherwise, the function returns `false`.
            </p>
              
            <p>If <code>language-tag</code>, <code>language-range</code>, or both are empty
              (and thus not a valid language tag or language range, respectively),
              the function returns `false`.
            </p>
              
            <p>A <code>language-range</code> of "*" matches any non-empty <code>language-tag</code> string.</p>
            <div class="exampleGroup">
              <pre class="data nohighlight">
PREFIX dc:       &lt;http://purl.org/dc/elements/1.1/&gt;

_:a  dc:title         "That Seventies Show"@en .
_:a  dc:title         "Cette SÃ©rie des AnnÃ©es Soixante-dix"@fr .
_:a  dc:title         "Cette SÃ©rie des AnnÃ©es Septante"@fr-BE .
_:b  dc:title         "Il Buono, il Bruto, il Cattivo" .
              </pre>
              <div class="queryGroup">
                <p>This query uses <a href="#func-langMatches"><code>langMatches</code></a> and
                  <a href="#func-lang"><code>lang</code></a> to find the French titles for the show
                  known in English as "That Seventies Show":</p>
                <pre class="query nohighlight">
PREFIX dc: &lt;http://purl.org/dc/elements/1.1/&gt;
SELECT ?title
WHERE {
    ?x dc:title  "That Seventies Show"@en ;
       dc:title  ?title .
    FILTER langMatches( lang(?title), "FR" )
}
                </pre>
                <p>Query result:</p>
                <div class="result">
                  <table class="resultTable">
                    <tbody>
                      <tr>
                        <th>title</th>
                      </tr>
                      <tr>
                        <td>"Cette SÃ©rie des AnnÃ©es Soixante-dix"@fr</td>
                      </tr>
                      <tr>
                        <td>"Cette SÃ©rie des AnnÃ©es Septante"@fr-BE</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
              <div class="queryGroup">
                <p>The idiom <code>langMatches( lang( ?v ), "*" )</code> will not match literals
                  without a language tag as <code>lang( ?v )</code> will return an empty string, so</p>
                <pre class="query nohighlight add">
PREFIX dc: &lt;http://purl.org/dc/elements/1.1/&gt;
SELECT ?title
WHERE {
    ?x dc:title  ?title .
    FILTER langMatches( lang(?title), "*" )
}
                </pre>
                <p>will report all of the titles with a language tag:</p>
                <div class="result add">
                  <table class="resultTable">
                    <tbody>
                      <tr>
                        <th>title</th>
                      </tr>
                      <tr>
                        <td>"That Seventies Show"@en</td>
                      </tr>
                      <tr>
                        <td>"Cette SÃ©rie des AnnÃ©es Soixante-dix"@fr</td>
                      </tr>
                      <tr>
                        <td>"Cette SÃ©rie des AnnÃ©es Septante"@fr-BE</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
          </section>
          <section id="func-regex">
            <h5>REGEX</h5>
            <pre class="prototype nohighlight">
<span class="return">xsd:boolean</span>  <span class="operator">REGEX</span> (<span class="type"><span class="type">string literal</span></span> <span class="name">text</span>, <span class="type"><span class="type">xsd:string</span></span> <span class="name">pattern</span>)
<span class="return">xsd:boolean</span>  <span class="operator">REGEX</span> (<span class="type"><span class="type">string literal</span></span> <span class="name">text</span>, <span class="type"><span class="type">xsd:string</span></span> <span class="name">pattern</span>, <span class="type"><span class="type">xsd:string</span></span> <span class="name">flags</span>)
</pre>
            <p>Invokes the XPath <a data-cite="XPATH-FUNCTIONS-31#func-matches">fn:matches</a> function to match
              <code>text</code> against a regular expression <code>pattern</code>. The regular
              expression language is defined in XQuery 1.0 and XPath 2.0 Functions and Operators
              section <a data-cite="XPATH-FUNCTIONS-31#regex-syntax">7.6.1 Regular Expression Syntax</a>
              [[XPATH-FUNCTIONS-31]].</p>
            <div class="exampleGroup">
              <pre class="data nohighlight">
PREFIX foaf:       &lt;http://xmlns.com/foaf/0.1/&gt;

_:a  foaf:name       "Alice".
_:b  foaf:name       "Bob" .
              </pre>
              <div class="queryGroup">
                <pre class="query nohighlight">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name
WHERE { 
    ?x foaf:name  ?name
    FILTER regex(?name, "^ali", "i")
}
                </pre>
                <p>Query result:</p>
                <div class="result">
                  <table class="resultTable">
                    <tbody>
                      <tr>
                        <th>name</th>
                      </tr>
                      <tr>
                        <td>"Alice"</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
          </section>
          <section id="func-replace">
            <h5>REPLACE</h5>
            <pre class="prototype nohighlight">
<span class="return"><span class="type">string literal</span></span>  <span class="operator">REPLACE</span> (<span class="type"><span class="type">string literal</span></span> arg, <span class="type"><span class="type">xsd:string</span></span> pattern, <span class="type"><span class="type">xsd:string</span></span> replacement )
<span class="return"><span class="type">string literal</span></span>  <span class="operator">REPLACE</span> (<span class="type"><span class="type">string literal</span></span> arg, <span class="type"><span class="type">xsd:string</span></span> pattern, <span class="type"><span class="type">xsd:string</span></span> replacement,  <span class="type"><span class="type">xsd:string</span></span> flags)
            </pre>
            <p>The <code>REPLACE</code> function corresponds to the XPath <a data-cite="XPATH-FUNCTIONS-31#func-replace">fn:replace</a> function. It replaces each non-overlapping
              occurrence of the regular expression <code>pattern</code> with the replacement string.
              Regular expession matching may involve modifier flags. See <a href="#func-regex">REGEX</a>.
            </p>
            <div class="result">
              <table class="resultTable">
                <tbody>
                  <tr>
                    <td>replace("abcd", "b", "Z")</td>
                    <td>"aZcd"</td>
                  </tr>
                  <tr>
                    <td>replace("abab", "B", "Z","i")</td>
                    <td>"aZaZ"</td>
                  </tr>
                  <tr>
                    <td>replace("abab", "B.", "Z","i")</td>
                    <td>"aZb"</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-encode">
            <h5>ENCODE_FOR_URI</h5>
            <pre class="prototype nohighlight"><span class="return">xsd:string</span>  <span class="operator">ENCODE_FOR_URI</span>(<span class="type">string literal</span> ltrl)</pre>
            <p>The <code>ENCODE_FOR_URI</code> function corresponds to the XPath <a data-cite="XPATH-FUNCTIONS-31#func-encode-for-uri">fn:encode-for-uri</a> function. It returns a
              literal with datatype <code>xsd:string</code> with the lexical form obtained from the lexical form of its input after
              translating reserved characters according to the <a data-cite="XPATH-FUNCTIONS-31#func-encode-for-uri">fn:encode-for-uri</a>
              function.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>encode_for_uri("Los Angeles")</code></td>
                    <td><code>"Los%20Angeles"</code></td>
                  </tr>
                  <tr>
                    <td><code>encode_for_uri("Los Angeles"@en)</code></td>
                    <td><code>"Los%20Angeles"</code></td>
                  </tr>
                  <tr>
                    <td><code>encode_for_uri("Los Angeles"^^xsd:string)</code></td>
                    <td><code>"Los%20Angeles"</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
        </section>
        <section id="func-numerics">
          <h4>Functions on Numerics</h4>
          <section id="func-abs">
            <h5>ABS</h5>
            <pre class="prototype nohighlight"> <span class="return">numeric</span>  <span class="operator">ABS</span> (<span class="type"><span class="type numeric">numeric</span></span> <span class="name">term</span>)</pre>
            <p>Returns the absolute value of <code>arg</code>. An error is raised if <code>arg</code>
              is not a numeric value.</p>
            <p>This function is the same as 
              <a data-cite="XPATH-FUNCTIONS-31#func-abs">fn:abs</a>
              for terms with a datatype from <a data-cite="XPATH-DATAMODEL-31#">XDM</a>.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>ABS(1)</code></td>
                    <td><code>1</code></td>
                  </tr>
                  <tr>
                    <td><code>ABS(-1.5)</code></td>
                    <td><code>1.5</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-round">
            <h5>ROUND</h5>
            <pre class="prototype nohighlight"> <span class="return">numeric</span>  <span class="operator">ROUND</span> (<span class="type"><span class="type numeric">numeric</span></span> <span class="name">term</span>)</pre>
            <p>Returns the number with no fractional part that is closest to the argument. If there
              are two such numbers, then the one that is closest to positive infinity is returned. An
              error is raised if <code>arg</code> is not a numeric value.</p>
            <p>This function is the same as <a data-cite="XPATH-FUNCTIONS-31#func-round">fn:round</a> for terms with a datatype from <a data-cite="XPATH-DATAMODEL-31#">XDM</a>.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>ROUND(2.4999)</code></td>
                    <td><code>2.0</code></td>
                  </tr>
                  <tr>
                    <td><code>ROUND(2.5)</code></td>
                    <td><code>3.0</code></td>
                  </tr>
                  <tr>
                    <td><code>ROUND(-2.5)</code></td>
                    <td><code>-2.0</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-ceil">
            <h5>CEIL</h5>
            <pre class="prototype nohighlight"> <span class="return">numeric</span>  <span class="operator">CEIL</span> (<span class="type"><span class="type numeric">numeric</span></span> <span class="name">term</span>)</pre>
            <p>Returns the smallest (closest to negative infinity) number with no fractional part
              that is not less than the value of <code>arg</code>. An error is raised if
              <code>arg</code> is not a numeric value.</p>
            <p>This function is the same as 
              <a data-cite="XPATH-FUNCTIONS-31#func-ceiling">fn:ceiling</a>
              for terms with a datatype from <a data-cite="XPATH-DATAMODEL-31#">XDM</a>.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>CEIL(10.5)</code></td>
                    <td><code>11.0</code></td>
                  </tr>
                  <tr>
                    <td><code>CEIL(-10.5)</code></td>
                    <td><code>-10.0</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-floor">
            <h5>FLOOR</h5>
            <pre class="prototype nohighlight"> <span class="return">numeric</span>  <span class="operator">FLOOR</span> (<span class="type"><span class="type numeric">numeric</span></span> <span class="name">term</span>)</pre>
            <p>Returns the largest (closest to positive infinity) number with no fractional part that
              is not greater than the value of <code>arg</code>. An error is raised if <code>arg</code>
              is not a numeric value.</p>
            <p>This function is the same as
              <a data-cite="XPATH-FUNCTIONS-31#func-floor">fn:floor</a>
              for terms with a datatype from <a data-cite="XPATH-DATAMODEL-31#">XDM</a>.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>FLOOR(10.5)</code></td>
                    <td><code>10.0</code></td>
                  </tr>
                  <tr>
                    <td><code>FLOOR(-10.5)</code></td>
                    <td><code>-11.0</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-rand">
            <h5>RAND</h5>
            <pre class="prototype nohighlight"> <span class="return">xsd:double</span>  <span class="operator">RAND</span> ( )</pre>
            <p>Returns a pseudo-random number between 0 (inclusive) and 1.0e0 (exclusive). Different
              numbers can be produced every time this function is invoked. Numbers should be produced
              with approximately equal probability.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>rand()</code></td>
                    <td><code>"0.31221030831984886"^^xsd:double</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
        </section>
        <section id="func-date-time">
          <h4>Functions on Dates and Times</h4>
          <section id="func-now">
            <h5>NOW</h5>
            <pre class="prototype nohighlight"> <span class="return">xsd:dateTime</span>  <span class="operator">NOW</span> ()</pre>
            <p>Returns an XSD dateTime value for the current query execution. All calls to this
              function in any one query execution must return the same value. The exact moment returned
              is not specified.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>NOW()</code></td>
                    <td><code>"2011-01-10T14:45:13.815-05:00"^^xsd:dateTime</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-year">
            <h5>YEAR</h5>
            <pre class="prototype nohighlight"> <span class="return">xsd:integer</span>  <span class="operator">YEAR</span> (<span class="type"><span class="type">xsd:dateTime</span></span> <span class="parm">arg</span>)</pre>
            <p>Returns the year part of <code>arg</code> as an integer.</p>
            <p>This function corresponds to <a data-cite="XPATH-FUNCTIONS-31#func-year-from-dateTime">fn:year-from-dateTime</a>.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>YEAR("2011-01-10T14:45:13.815-05:00"^^xsd:dateTime)</code></td>
                    <td><code>2011</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-month">
            <h5>MONTH</h5>
            <pre class="prototype nohighlight"> <span class="return">xsd:integer</span>  <span class="operator">MONTH</span> (<span class="type"><span class="type">xsd:dateTime</span></span> <span class="parm">arg</span>)</pre>
            <p>Returns the month part of <code>arg</code> as an integer.</p>
            <p>This function corresponds to <a data-cite="XPATH-FUNCTIONS-31#func-month-from-dateTime">fn:month-from-dateTime</a>.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>MONTH("2011-01-10T14:45:13.815-05:00"^^xsd:dateTime)</code></td>
                    <td><code>1</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-day">
            <h5>DAY</h5>
            <pre class="prototype nohighlight"> <span class="return">xsd:integer</span>  <span class="operator">DAY</span> (<span class="type"><span class="type">xsd:dateTime</span></span> <span class="parm">arg</span>)</pre>
            <p>Returns the day part of <code>arg</code> as an integer.</p>
            <p>This function corresponds to <a data-cite="XPATH-FUNCTIONS-31#func-day-from-dateTime">fn:day-from-dateTime</a>.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>day("2011-01-10T14:45:13.815-05:00"^^xsd:dateTime)</code></td>
                    <td><code>10</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-hours">
            <h5>HOURS</h5>
            <pre class="prototype nohighlight"> <span class="return">xsd:integer</span>  <span class="operator">HOURS</span> (<span class="type"><span class="type">xsd:dateTime</span></span> <span class="parm">arg</span>)</pre>
            <p>Returns the hours part of <code>arg</code> as an integer. The value is as given in the
              lexical form of the XSD dateTime.</p>
            <p>This function corresponds to <a data-cite="XPATH-FUNCTIONS-31#func-hours-from-dateTime">fn:hours-from-dateTime</a>.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>HOURS("2011-01-10T14:45:13.815-05:00"^^xsd:dateTime)</code></td>
                    <td><code>14</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-minutes">
            <h5>MINUTES</h5>
            <pre class="prototype nohighlight"> <span class="return">xsd:integer</span>  <span class="operator">MINUTES</span> (<span class="type"><span class="type">xsd:dateTime</span></span> <span class="parm">arg</span>)</pre>
            <p>Returns the minutes part of the lexical form of <code>arg</code>. The value is as
              given in the lexical form of the XSD dateTime.</p>
            <p>This function corresponds to <a data-cite="XPATH-FUNCTIONS-31#func-minutes-from-dateTime">fn:minutes-from-dateTime</a>.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>MINUTES("2011-01-10T14:45:13.815-05:00"^^xsd:dateTime)</code></td>
                    <td><code>45</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-seconds">
            <h5>SECONDS</h5>
            <pre class="prototype nohighlight"> <span class="return">xsd:decimal</span>  <span class="operator">SECONDS</span> (<span class="type"><span class="type">xsd:dateTime</span></span> <span class="parm">arg</span>)</pre>
              <p>Returns the seconds part of the lexical form of <code>arg</code>.</p>
              <p>This function corresponds to <a data-cite="XPATH-FUNCTIONS-31#func-seconds-from-dateTime">fn:seconds-from-dateTime</a>.</p>
              <div class="result">
                <table>
                  <tbody>
                    <tr>
                      <td><code>SECONDS("2011-01-10T14:45:13.815-05:00"^^xsd:dateTime)</code></td>
                    <td><code>13.815</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-timezone">
            <h5>TIMEZONE</h5>
            <pre class="prototype nohighlight"> <span class="return">xsd:dayTimeDuration</span>  <span class="operator">TIMEZONE</span> (<span class="type"><span class="type">xsd:dateTime</span></span> <span class="parm">arg</span>)</pre>
            <p>Returns the timezone part of <code>arg</code> as an xsd:dayTimeDuration.
              Raises an error if there is no timezone.</p>
            <p>This function corresponds to 
              <a data-cite="XPATH-FUNCTIONS-31#func-timezone-from-dateTime">fn:timezone-from-dateTime</a>
              except for the treatment of literals with no timezone.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>TIMEZONE("2011-01-10T14:45:13.815-05:00"^^xsd:dateTime)</code></td>
                    <td><code>"-PT5H"^^xsd:dayTimeDuration</code></td>
                  </tr>
                  <tr>
                    <td><code>TIMEZONE("2011-01-10T14:45:13.815Z"^^xsd:dateTime)</code></td>
                    <td><code>"PT0S"^^xsd:dayTimeDuration</code></td>
                  </tr>
                  <tr>
                    <td><code>TIMEZONE("2011-01-10T14:45:13.815"^^xsd:dateTime)</code></td>
                    <td>error</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-tz">
            <h5>TZ</h5>
            <pre class="prototype nohighlight"> <span class="return">xsd:string</span>  <span class="operator">TZ</span> (<span class="type"><span class="type">xsd:dateTime</span></span> <span class="parm">arg</span>)</pre>
            <p>Returns the timezone part of <code>arg</code> as a literal with datatype <code>xsd:string</code>. Returns the empty
              string if there is no timezone.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>TZ("2011-01-10T14:45:13.815-05:00"^^xsd:dateTime)</code></td>
                    <td><code>"-05:00"</code></td>
                  </tr>
                  <tr>
                    <td><code>TZ("2011-01-10T14:45:13.815Z"^^xsd:dateTime)</code></td>
                    <td><code>"Z"</code></td>
                  </tr>
                  <tr>
                    <td><code>TZ("2011-01-10T14:45:13.815"^^xsd:dateTime)</code></td>
                    <td><code>""</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
        </section>

        <section id="func-triple-terms">
          <h4>Functions on Triple Terms</h4>
          <section id="func-triple">
            <h5>TRIPLE</h5>
            <pre class="prototype nohighlight">
              <span class="return">triple term</span>  <span class="operator">TRIPLE</span> (<span class="type RDFterm">RDF term</span> <span class="name">subj</span>, <span class="type RDFterm">RDF term</span> <span class="name">pred</span>, <span class="type RDFterm">RDF term</span> <span
class="name">obj</span>)
            </pre>
            <pre class="query nohighlight">
                  <span class="operator">&lt;&lt;(</span> subj pred obj <span class="operator">)&gt;&gt;</span>
            </pre>
            <p>
              If the 3-tuple (<code style="color:black">subj</code>, 
              <code style="color:black">pred</code>, 
              <code style="color:black">obj</code>)
              is an <a data-cite="RDF12-CONCEPTS#dfn-rdf-triple">RDF triple</a>
              (that is, <code style="color:black">subj</code> is an
              <a data-cite="RDF12-CONCEPTS#dfn-iri">IRI</a> or
              <a data-cite="RDF12-CONCEPTS#dfn-blank-node">blank node</a>;
              <code style="color:black">pred</code> is an
              <a data-cite="RDF12-CONCEPTS#dfn-iri">IRI</a>;
              and <code style="color:black">obj</code> is an
              <a data-cite="RDF12-CONCEPTS#dfn-iri">IRI</a>,
              <a data-cite="RDF12-CONCEPTS#dfn-triple-term">triple term</a>,
              <a data-cite="RDF12-CONCEPTS#dfn-blank-node">blank node</a> or
              <a data-cite="RDF12-CONCEPTS#dfn-literal">literal</a>)
              the function returns a triple term with these three elements.
              Otherwise, the function raises an error.
            </p>
            <p>
              As a shorthand notation, the <code>TRIPLE</code> function 
              can also be written in the form of a
              <a href="#rExprTripleTerm">triple term expression</a>
              using <code>&lt;&lt;(</code> and <code>)&gt;&gt;</code>.  There are
              syntax limitations to this shorthand form:
            </p>
            <ul>
              <li>each of the three elements of the triple term expression can only be
                a <a href="#defn_QueryVariable">variable</a>
                or a directly written [=RDF term=], not an arbitrary expression.
              </li>
              <li>
                the syntax of the subject and predicate positions is limited to an
                <a data-cite="RDF12-CONCEPTS#dfn-iri">IRI</a> or a
                <a href="#defn_QueryVariable">variable</a>.
              </li>
            </ul>
            <p>
              The function form, <code>TRIPLE</code>, can be used with arbitrary expressions.
            </p>
            <pre class="query nohighlight">
              VERSION "1.2"
              PREFIX : &lt;http://example/&gt;
              PREFIX rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;

              SELECT ?s ?date {
                  ?s ?p ?o .
                  BIND( &lt;&lt;( ?s ?p ?o )&gt;&gt; AS ?tt )
                  :myreifier rdf:reifies ?tt .
                  :myreifier :tripleAdded ?date .
              }
            </pre>
            <pre class="query nohighlight">
              VERSION "1.2"
              PREFIX : &lt;http://example/&gt;
              PREFIX rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;

              SELECT ?s ?date {
                  ?s ?p ?o .
                  BIND( TRIPLE(?s, ?p, ?o) AS ?tt )
                  :myreifier rdf:reifies ?tt .
                  :myreifier :tripleAdded ?date .
              }
            </pre>
          </section>

          <section id="func-subject">
            <h5>SUBJECT</h5>
            <pre class="prototype nohighlight"><span class="return">RDF term</span>  <span class="operator">SUBJECT</span> (<span class="type RDFterm">triple term</span> <span class="name">triple-term</span>)</pre>
            <p>
	            If the argument is a
              <a data-cite="RDF12-CONCEPTS#dfn-triple-term">triple term</a>, 
              the function returns the 
              <a data-cite="RDF12-CONCEPTS#dfn-subject">subject</a>
              of the triple term. 
              If the argument is not a 
              <a data-cite="RDF12-CONCEPTS#dfn-triple-term">triple term</a>,
              an error is raised.
            </p>
          </section>
          
          <section id="func-predicate">
            <h5>PREDICATE</h5>
            <pre class="prototype nohighlight"><span class="return">RDF term</span>  <span class="operator">PREDICATE</span> (<span class="type RDFterm">triple term</span> <span class="name">triple-term</span>)</pre>
            <p>
              If the argument is a
              <a data-cite="RDF12-CONCEPTS#dfn-triple-term">triple term</a>,
              the function returns the 
              <a data-cite="RDF12-CONCEPTS#dfn-predicate">predicate</a>
              of the triple term.
              If the argument is not a 
              <a data-cite="RDF12-CONCEPTS#dfn-triple-term">triple term</a>,
              an error is raised.
            </p>
          </section>

          <section id="func-object">
            <h5>OBJECT</h5>
            <pre class="prototype nohighlight"><span class="return">RDF term</span>  <span class="operator">OBJECT</span> (<span class="type RDFterm">triple term</span> <span class="name">triple-term</span>)</pre>
            <p>
              If the argument is a
              <a data-cite="RDF12-CONCEPTS#dfn-triple-term">triple term</a>,
              the function returns the 
              <a data-cite="RDF12-CONCEPTS#dfn-object">object</a>
              of the triple term.
              If the argument is not a 
              <a data-cite="RDF12-CONCEPTS#dfn-triple-term">triple term</a>,
              an error is raised.
            </p>
          </section>

          <section id="func-isTriple">
            <h5>isTRIPLE</h5>
            <pre class="prototype nohighlight"><span class="return">xsd:boolean</span>  <span class="operator">isTRIPLE</span> (<span class="type RDFterm">RDF term</span> <span class="name">term</span>)</pre>
            <p>
              If the argument is a <a data-cite="RDF12-CONCEPTS#dfn-triple-term">triple term</a>, 
              the function returns true.
              If the argument is any other kind of 
              <a data-cite="RDF12-CONCEPTS#dfn-rdf-term">RDF term</a>, 
              the function returns false.
            </p>
          </section>
        </section>

        <section id="func-hash">
          <h4>Hash Functions</h4>
          <section id="func-md5">
            <h5>MD5</h5>
            <pre class="prototype nohighlight"> <span class="return">xsd:string</span>  <span class="operator">MD5</span> (<span class="type"><span class="type">xsd:string</span></span> <span class="name">arg</span>)</pre>
            <p>Returns the MD5 checksum, as a hex digit string, calculated on the lexical form of the <code>xsd:string</code>. Hex digits SHOULD be in lower case.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>MD5("abc")</code></td>
                    <td><code>"900150983cd24fb0d6963f7d28e17f72"</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-sha1">
            <h5>SHA1</h5>
            <pre class="prototype nohighlight"> <span class="return">xsd:string</span>  <span class="operator">SHA1</span> (<span class="type"><span class="type">xsd:string</span></span> <span class="name">arg</span>)</pre>
            <p>Returns the SHA1 checksum, as a hex digit string, calculated on the lexical form of the <code>xsd:string</code>. Hex digits SHOULD be in lower case.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>SHA1("abc")</code></td>
                    <td><code>"a9993e364706816aba3e25717850c26c9cd0d89d"</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-sha256">
            <h5>SHA256</h5>
            <pre class="prototype nohighlight"> <span class="return">xsd:string</span>  <span class="operator">SHA256</span> (<span class="type"><span class="type">xsd:string</span></span> <span class="name">arg</span>)</pre>
            <p>Returns the SHA256 checksum, as a hex digit string, calculated on the lexical form of the <code>xsd:string</code>. Hex digits SHOULD be in lower case.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>SHA256("abc")</code></td>
                    <td>
                      <code>"ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad"</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-sha384">
            <h5>SHA384</h5>
            <pre class="prototype nohighlight"> <span class="return">xsd:string</span>  <span class="operator">SHA384</span> (<span class="type"><span class="type">xsd:string</span></span> <span class="name">arg</span>)</pre>
            <p>Returns the SHA384 checksum, as a hex digit string, calculated on the lexical form of the <code>xsd:string</code>. Hex digits SHOULD be in lower case.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>SHA384("abc")</code></td>
                    <td>
                      <code>"cb00753f45a35e8bb5a03d699ac65007272c32ab0eded1631a8b605a43ff5bed8086072ba1e7cc2358baeca134c825a7"</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
          <section id="func-sha512">
            <h5>SHA512</h5>
            <pre class="prototype nohighlight"> <span class="return">xsd:string</span>  <span class="operator">SHA512</span> (<span class="type"><span class="type">xsd:string</span></span> <span class="name">arg</span>)</pre>
            <p>Returns the SHA512 checksum, as a hex digit string, calculated on the lexical form of the <code>xsd:string</code>. Hex digits SHOULD be in lower case.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>SHA512("abc")</code></td>
                    <td>
                      <code>"ddaf35a193617abacc417349ae20413112e6fa4e89a97ea20a9eeee64b55d39a2192992a274fc1a836ba3c23a3feebbd454d4423643ce80e2a9ac94fa54ca49f"</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </section>
        </section>
      </section>
      <section id="FunctionMapping">
        <h3>XPath Constructor Functions</h3>
        <p>
          SPARQL imports a subset of the XPath constructor functions defined in
          [[[XPATH-FUNCTIONS-31]]] [[XPATH-FUNCTIONS-31]] in
          section 
          <a data-cite="XPATH-FUNCTIONS-31#casting-from-primitive-to-primitive"
          >19.1 Casting from primitive types to primitive types</a>.
          SPARQL constructors include all of the XPath constructors for
          the <a href="#operandDataTypes">SPARQL operand datatypes</a> plus
          the <a href="#operandDataTypes">additional datatypes</a> imposed by
          the RDF data model. Casting in SPARQL is performed by calling a
          constructor function for the target type on an operand of the source
          type.
        </p>
        <p>
          XPath defines only the casts from one XML Schema datatype to another. The remaining cast
          is defined as follows:
        </p>
        <ul>
          <li>Casting an <span class="IRI type">IRI</span> to an <code>xsd:string</code> produces a
            <span class="IRI literal">literal</span> with a lexical value of the codepoints
            comprising the IRI, and a datatype of <code>xsd:string</code>.</li>
        </ul>
        <p>The table below summarizes the casting operations that are always allowed 
          (<span class="castY">Y</span>), never allowed (<span class="castN">N</span>)
          and dependent on the lexical
          value (<span class="castM">M</span>). For example, a casting operation from an
          <code>xsd:string</code> (the first row) to an <code>xsd:float</code> (the second column) is
          dependent on the lexical value (<span class="castM">M</span>).</p>
        <blockquote>
          <p>bool = <a data-cite="XMLSCHEMA11-2#dt-boolean">xsd:boolean</a><br>
            dbl = <a data-cite="XMLSCHEMA11-2#dt-double">xsd:double</a><br>
            flt = <a data-cite="XMLSCHEMA11-2#dt-float">xsd:float</a><br>
            dec = <a data-cite="XMLSCHEMA11-2#dt-decimal">xsd:decimal</a><br>
            int = <a data-cite="XMLSCHEMA11-2#dt-integer">xsd:integer</a><br>
            dT = <a data-cite="XMLSCHEMA11-2#dt-dateTime">xsd:dateTime</a><br>
            str = <a data-cite="XMLSCHEMA11-2#dt-string">xsd:string</a><br>
            IRI = <a data-cite="RDF12-CONCEPTS#iri">IRI</a>
        </blockquote>
        <table title="Casting table" class="casting" 
               style="border-spacing: 1px; border-width:1px">
          <colgroup>
            <col style="width: 13%">
            <col style="width: 11%">
            <col style="width: 11%">
            <col style="width: 11%">
            <col style="width: 11%">
            <col style="width: 11%">
            <col style="width: 11%">
            <col style="width: 11%">
          </colgroup>
          <thead>
            <tr>
              <th><span class="cancast" title="From\To">From \ To</span></th>
              <th><span class="cancast" title="string">str</span></th>
              <th><span class="cancast" title="float">flt</span></th>
              <th><span class="cancast" title="double">dbl</span></th>
              <th><span class="cancast" title="decimal">dec</span></th>
              <th><span class="cancast" title="integer">int</span></th>
              <th><span class="cancast" title="dateTime">dT</span></th>
              <th><span class="cancast" title="boolean">bool</span></th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <th><span class="cancast" title="string">str</span></th>
              <td class="castY" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast string to string? Yes">Y</span></td>
              <td class="castM" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast string to float? Maybe">M</span></td>
              <td class="castM" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast string to double? Maybe">M</span></td>
              <td class="castM" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast string to decimal? Maybe">M</span></td>
              <td class="castM" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast string to integer? Maybe">M</span></td>
              <td class="castM" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast string to dateTime? Maybe">M</span></td>
              <td class="castM" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast string to boolean? Maybe">M</span></td>
            </tr>
            <tr>
              <th><span class="cancast" title="float">flt</span></th>
              <td class="castY" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast float to string? Yes">Y</span></td>
              <td class="castY" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast float to float? Yes">Y</span></td>
              <td class="castY" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast float to double? Yes">Y</span></td>
              <td class="castM" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast float to decimal? Maybe">M</span></td>
              <td class="castM" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast float to integer? Maybe">M</span></td>
              <td class="castN" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast float to dateTime? No">N</span></td>
              <td class="castY" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast float to boolean? Yes">Y</span></td>
            </tr>
            <tr>
              <th><span class="cancast" title="double">dbl</span></th>
              <td class="castY" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast double to string? Yes">Y</span></td>
              <td class="castY" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast double to float? Yes">Y</span></td>
              <td class="castY" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast double to double? Yes">Y</span></td>
              <td class="castM" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast double to decimal? Maybe">M</span></td>
              <td class="castM" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast double to integer? Maybe">M</span></td>
              <td class="castN" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast double to dateTime? No">N</span></td>
              <td class="castY" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast double to boolean? Yes">Y</span></td>
            </tr>
            <tr>
              <th><span class="cancast" title="decimal">dec</span></th>
              <td class="castY" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast decimal to string? Yes">Y</span></td>
              <td class="castY" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast decimal to float? Yes">Y</span></td>
              <td class="castY" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast decimal to double? Yes">Y</span></td>
              <td class="castY" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast decimal to decimal? Yes">Y</span></td>
              <td class="castY" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast decimal to integer? Yes">Y</span></td>
              <td class="castN" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast decimal to dateTime? No">N</span></td>
              <td class="castY" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast decimal to boolean? Yes">Y</span></td>
            </tr>
            <tr>
              <th><span class="cancast" title="integer">int</span></th>
              <td class="castY" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast integer to string? Yes">Y</span></td>
              <td class="castY" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast integer to float? Yes">Y</span></td>
              <td class="castY" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast integer to double? Yes">Y</span></td>
              <td class="castY" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast integer to decimal? Yes">Y</span></td>
              <td class="castY" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast integer to integer? Yes">Y</span></td>
              <td class="castN" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast integer to dateTime? No">N</span></td>
              <td class="castY" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast integer to boolean? Yes">Y</span></td>
            </tr>
            <tr>
              <th><span class="cancast" title="dateTime">dT</span></th>
              <td class="castY" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast dateTime to string? Yes">Y</span></td>
              <td class="castN" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast dateTime to float? No">N</span></td>
              <td class="castN" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast dateTime to double? No">N</span></td>
              <td class="castN" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast dateTime to decimal? No">N</span></td>
              <td class="castN" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast dateTime to integer? No">N</span></td>
              <td class="castY" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast dateTime to dateTime? Yes">Y</span></td>
              <td class="castN" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast dateTime to boolean? No">N</span></td>
            </tr>
            <tr>
              <th><span class="cancast" title="boolean">bool</span></th>
              <td class="castY" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast boolean to string? Yes">Y</span></td>
              <td class="castY" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast boolean to float? Yes">Y</span></td>
              <td class="castY" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast boolean to double? Yes">Y</span></td>
              <td class="castY" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast boolean to decimal? Yes">Y</span></td>
              <td class="castY" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast boolean to integer? Yes">Y</span></td>
              <td class="castN" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast boolean to dateTime? No">N</span></td>
              <td class="castY" style="vertical-align: middle; text-align: center;"><span class="cancast" title=
                                                                                        "Cast boolean to boolean? Yes">Y</span></td>
            </tr>
            <tr>
              <th><span class="cancast" title="IRI">IRI</span></th>
              <td class="castY" style="vertical-align: middle; text-align: center;"><span class="cancast rdfDM" title=
                                                                                        "Cast IRI to string? Yes">Y</span></td>
              <td class="castN" style="vertical-align: middle; text-align: center;"><span class="cancast rdfDM" title=
                                                                                        "Cast IRI to float? No">N</span></td>
              <td class="castN" style="vertical-align: middle; text-align: center;"><span class="cancast rdfDM" title=
                                                                                        "Cast IRI to double? No">N</span></td>
              <td class="castN" style="vertical-align: middle; text-align: center;"><span class="cancast rdfDM" title=
                                                                                        "Cast IRI to decimal? No">N</span></td>
              <td class="castN" style="vertical-align: middle; text-align: center;"><span class="cancast rdfDM" title=
                                                                                        "Cast IRI to integer? No">N</span></td>
              <td class="castN" style="vertical-align: middle; text-align: center;"><span class="cancast rdfDM" title=
                                                                                        "Cast IRI to dateTime? No">N</span></td>
              <td class="castN" style="vertical-align: middle; text-align: center;"><span class="cancast rdfDM" title=
                                                                                        "Cast IRI to boolean? No">N</span></td>
            </tr>
          </tbody>
        </table>
      </section>
      <section id="extensionFunctions">
        <h3>Extensible Value Testing</h3>
        <p>It should be noted that any function or operator that is specified to return an error
          under some conditions is a valid extension point. That is, an implementation may return a
          non-error value in these error cases, and still be conformant with this recommendation.</p>
        <p>A <a href="#rPrimaryExpression">PrimaryExpression</a> grammar rule can be a call to an
          extension function named by an IRI. An extension function takes some number of RDF terms as
          arguments and returns an RDF term. The semantics of these functions are identified by the IRI
          that identifies the function.</p>
        <p>SPARQL queries using extension functions are likely to have limited interoperability.</p>
        <p>As an example, consider a function called <code>func:even</code>:</p>
        <pre class="prototype nohighlight"> <code>xsd:boolean</code>   <code>func:even</code> (<code><span class="type numeric">numeric</span></code> <code>value</code>)
        </pre>
        <div class="exampleGroup">
          <div class="queryGroup">
            <p>This function would be invoked in a FILTER as such:</p>
            <pre class="query nohighlight">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX func: &lt;http://example.org/functions#&gt;
SELECT ?name ?id
WHERE { 
    ?x foaf:name  ?name ;
       func:empId   ?id .
    FILTER (func:even(?id))
}
</pre>
          </div>
        </div>
        <p>For a second example, consider a function <code>aGeo:distance</code> that calculates the
          distance between two points, which is used here to find the places near Grenoble:</p>
        <pre class="prototype nohighlight">
          <code>xsd:double</code>   <code>aGeo:distance</code> (<code><span class="type numeric">numeric</span></code> <code>x1</code>, <code><span class="type numeric">numeric</span></code> <code>y1</code>, <code><span class="type numeric">numeric</span></code> <code>x2</code>, <code><span class="type numeric">numeric</span></code> <code>y2</code>)
        </pre>
        <div class="exampleGroup">
          <div class="queryGroup">
            <pre class="query nohighlight">
PREFIX aGeo: &lt;http://example.org/geo#&gt;

SELECT ?neighbor
WHERE {
    ?a aGeo:placeName "Grenoble" .
    ?a aGeo:locationX ?axLoc .
    ?a aGeo:locationY ?ayLoc .

    ?b aGeo:placeName ?neighbor .
    ?b aGeo:locationX ?bxLoc .
    ?b aGeo:locationY ?byLoc .

    FILTER ( aGeo:distance(?axLoc, ?ayLoc, ?bxLoc, ?byLoc) &lt; 10 ) .
}
            </pre>
          </div>
        </div>
        <p>An extension function might be used to test some application datatype not supported by the
          core SPARQL specification, it might be a transformation between datatype formats, for example
          into an XSD dateTime RDF term from another date format.</p>
      </section>
    </section>
    <section id="sparqlDefinition">
      <h2>Definition of SPARQL</h2>
      <p>This section defines the correct behavior for evaluation of graph patterns and solution
        modifiers, given a query string and an RDF dataset. It does not imply a SPARQL implementation
        must use the process defined here.</p>
      <p>The outcome of executing a SPARQL query is defined by a series of steps, starting from the
        SPARQL query as a string, turning that string into an abstract syntax form, then turning the
        abstract syntax into a SPARQL abstract query comprising operators from the SPARQL algebra. This
        abstract query is then evaluated on an RDF dataset.</p>
      <section id="initDefinitions">
        <h3>Initial Definitions</h3>
        <section id="sparqlDataset">
          <h4>RDF Dataset</h4>
          <p>The concept of an <a data-cite="RDF12-CONCEPTS#dfn-rdf-dataset">RDF Dataset</a> is defined in [[RDF12-CONCEPTS]].</p>
          <p>For the following definitions, we capture each RDF dataset as a set:</p>
          <div class="defn">
            <p>
            { G, (&lt;u<sub>1</sub>&gt;, G<sub>1</sub>), (&lt;u<sub>2</sub>&gt;, G<sub>2</sub>),
              ... (&lt;u<sub>n</sub>&gt;, G<sub>n</sub>) }
            
              where G and each G<sub>i</sub> are graphs, and each &lt;u<sub>i</sub>&gt; is an IRI or blank node. Each
              &lt;u<sub>i</sub>&gt; is distinct.</p>
            <p>G is called the default graph. (&lt;u<sub>i</sub>&gt;, G<sub>i</sub>) are called named
              graphs.</p>
          </div>
          <div class="defn">
            <p><b>Definition: <span id="defn_ActiveGraph">Active Graph</span></b></p>
            <p>The <b>active graph</b> is the graph from the dataset used for basic graph pattern
              matching.</p>
          </div>
        </section>
        <section id="sparqlQueryVariables">
          <h4>Query Variables</h4>
          <div class="defn">
            <p><b>Definition: <span id="defn_QueryVariable">Query Variable</span></b></p>
            <p>We assume a countably infinite set <var>V</var> that is disjoint
              from the set of all <a data-cite="RDF12-CONCEPTS#dfn-rdf-terms">RDF terms</a>.
              Every member of this set <var>V</var> is a <span class="definedTerm">query variable</span>.</p>
          </div>
        </section>
        <section id="sparqlTriplePatterns">
          <h4>Triple Patterns</h4>
          <div class="defn">
            <p><b>Definition: <span id="defn_TriplePattern">Triple Pattern</span></b></p>
            <p>A <span class="definedTerm">triple pattern</span> is a 3-tuple
              (|s|, |p|, |o|) where:</p>
            <ul>
              <li>|s| is an <a data-cite="RDF12-CONCEPTS#dfn-rdf-terms">RDF term</a>
                or a <a href="#defn_QueryVariable">variable</a>,</li>
              <li>|p| is an <a data-cite="RDF12-CONCEPTS#dfn-iri">IRI</a>
                or a <a href="#defn_QueryVariable">variable</a>, and</li>
              <li>|o| is an <a data-cite="RDF12-CONCEPTS#dfn-rdf-terms">RDF term</a>
                or a <a href="#defn_QueryVariable">variable</a>.</li>
            </ul>
          </div>
          <p>This definition of Triple Pattern includes literal subjects. 
            <a href="http://www.w3.org/2000/03/rdf-tracking/#rdfms-literalsubjects">
              This has been noted by RDF-core</a>.
          </p>
          <pre>"[The RDF core Working Group] noted that it is aware of no reason why literals should
            not be subjects and a future WG with a less restrictive charter may
            extend the syntaxes to allow literals as the subjects of statements."</pre>
          <p>Because RDF graphs may not contain literal subjects, any SPARQL triple pattern with a
            literal as subject will fail to match on any RDF graph.</p>
        </section>
        <section id="sparqlBasicGraphPatterns">
          <h4>Basic Graph Patterns</h4>
          <div class="defn">
            <p><b>Definition: <span id="defn_BasicGraphPattern">Basic Graph Pattern</span></b></p>
            <p>A <span class="definedTerm">Basic Graph Pattern</span> is a set of
              <a href="#defn_TriplePattern">Triple Patterns</a>.</p>
          </div>
          <p>The empty graph pattern is a basic graph pattern which is the empty set.</p>
        </section>
        <section id="sparqlPropertyPaths">
          <h4>Property Path Patterns</h4>
          <div class="defn">
            <p><b>Definition: <span id="defn_PropertyPath">Property Path</span></b></p>
            <p>A Property Path is a sequence of triples, t<sub>i</sub> in sequence ST, with n =
              length(ST)-1, such that, for i=0 to n, the object of t<sub>i</sub> is the same term as
              the subject of t<sub>i+1</sub>.</p>
            <p>We call the subject of t<sub>0</sub> the start of the path.</p>
            <p>We call the object of t<sub>n</sub> the end of the path.</p>
            <p>A Property Path is a path in graph G if each t<sub>i</sub> is a triple of G.</p>
          </div>
          <p>A property path does not span multiple graphs in a dataset.</p>
          <div class="defn">
            <p><b>Definition: <span id="defn_PropertyPathExpr">Property Path Expression</span></b></p>
            <p>
              A property path expression is an expression using the property path forms described
              above.
            </p>
          </div>
          <div class="defn">
            <p><b>Definition: <span id="defn_PropertyPathPattern">Property Path Pattern</span></b></p>
            <p>A property path pattern is a 3-tuple (|s|, |p|, |o|) where:</p>
            <ul>
              <li>|s| is an <a data-cite="RDF12-CONCEPTS#dfn-rdf-terms">RDF term</a>
                or a <a href="#defn_QueryVariable">variable</a>,</li>
              <li>|p| is a <a href="#defn_PropertyPathExpr">property path expression</a>, and</li>
              <li>|o| is an <a data-cite="RDF12-CONCEPTS#dfn-rdf-terms">RDF term</a>
                or a <a href="#defn_QueryVariable">variable</a>.</li>
            </ul>
          </div>
          <p>A Property Path Pattern is a generalization of a <a href="#defn_TriplePattern">Triple
              Pattern</a> to include a property path expression in the predicate position.</p>
        </section>
        <section id="sparqlSolutions">
          <h4>Solution Mapping</h4>
          <p>A solution mapping is a mapping from a set of variables to a set of RDF terms. We use
            the term 'solution' where it is clear.</p>
          <div class="defn">
            <p><b>Definition: <span id="defn_sparqlSolutionMapping">Solution Mapping</span></b></p>
            <p>A <b>solution mapping</b>, <var>Î¼</var>, is a partial function
              <var>Î¼</var> : <var>V</var> â†’ <var>T</var>, where
              <var>V</var> is the set of all <a href="#defn_QueryVariable">variables</a> and
              <var>T</var> is the set of all <a data-cite="RDF12-CONCEPTS#dfn-rdf-terms">RDF terms</a>.</p>
            <p>The domain of <var>Î¼</var>, denoted by dom(<var>Î¼</var>), is the
              subset of <var>V</var> for which <var>Î¼</var> is defined.</p>
          </div>
          <div class="defn">
            <p><b>Definition: <span id="defn_sparqlSolutionSequence">Solution Sequence</span></b></p>
            <p>A <b>solution sequence</b> is a list of solutions, possibly unordered.</p>
          </div>
          <p>Write expr(Î¼) for the value of the expression expr, using the terms for variables given
            by Î¼. Evaluation may result in an error.</p>
        </section>
        <section id="sparqlSolMod">
          <h4>Solution Sequence Modifiers</h4>
          <div class="defn">
            <p><b>Definition: <span id="defn_SolutionModifier">Solution Sequence Modifier</span></b></p>
            <p>A <span class="definedTerm">solution sequence modifier</span> is one of:</p>
            <ul>
              <li>
                <a href="#defn_algOrderBy">Order By</a> modifier: put the solutions in order
              </li>
              <li>
                <a href="#defn_algProject">Projection</a> modifier: choose certain variables
              </li>
              <li>
                <a href="#defn_algDistinct">Distinct</a> modifier: ensure solutions in the sequence
                are unique
              </li>
              <li>
                <a href="#defn_algReduced">Reduced</a> modifier: permit any non-distinct solutions to
                be eliminated
              </li>
              <li>
                <a href="#defn_algSlice">Offset</a> modifier: control where the solutions start from
                in the overall sequence of solutions
              </li>
              <li>
                <a href="#defn_algSlice">Limit</a> modifier: restrict the number of solutions
              </li>
            </ul>
          </div>
        </section>
        <section id="idp2427544">
          <h4>SPARQL Query</h4>
          <div class="defn">
            <p><b>Definition: <dfn data-lt="SPARQLQuery">SPARQL Query</dfn></b></p>
            <p>A <span class="definedTerm">SPARQL Abstract Query</span> is a tuple (E, DS, QF)
              where:</p>
            <ul>
              <li>E is a <a href="#sparqlAlgebra">SPARQL algebra</a> expression
              </li>
              <li>DS is an <a data-cite="RDF12-CONCEPTS#dfn-rdf-dataset">RDF Dataset</a> [[RDF12-CONCEPTS]]
              </li>
              <li>QF is a <a href="#QueryForms">query form</a>
              </li>
            </ul>
          </div>
          <div class="defn">
            <p><b>Definition: <span id="defn_QueryUnit">Query Level</span></b></p>
            <p>A query level is a graph pattern, a set of group and aggregation, and a set of
              solution modifiers.</p>
          </div>
          <p>A query is a tree of "query levels", where each <a href="#subqueries">subquery</a> forms
            one query level in the tree.</p>
        </section>
      </section>
      <section id="algebraicSyntax">
        <h3>Algebraic Syntax</h3>
        <p>To define the evaluation semantics of a SPARQL query,
          the abstract syntax tree of the SPARQL query string
          (as defined by the <a href="#sparqlGrammar">SPARQL grammar</a>)
          is first translated into a syntax that resembles the
          <a href="#sparqlAlgebra">SPARQL algebra</a>.
          This section defines the expressions that can be formed in this algebraic syntax,
          and the translation of SPARQL query strings into this algebraic syntax is then defined
          in Section&nbsp;<a href="#translation" class="sectionRef"></a>.</p>
        <p id="defn_AlgebraicQueryExpression">An
          <a href="#defn_AlgebraicQueryExpression">algebraic query expression</a>
          is defined recursively as follows:</p>
        <ul>
          <li>
            A <a href="#defn_BasicGraphPattern">basic graph pattern</a>
            is an algebraic query expression.</li>
          <li>
            A multiset of <a href="#defn_sparqlSolutionMapping">solution mappings</a>
            is an algebraic query expression.</li>
          <li>
            A sequence of <a href="#defn_sparqlSolutionMapping">solution mappings</a>
            is an algebraic query expression.
<div class="issue" data-number="231">Do we really need both of the previous two points?</div>
            </li>
          <li id="defn_absContextSolution">
            <a href="#defn_absContextSolution" class="absOp">ContextSolution</a>
            is an algebraic query expression.</li>
          <li id="defn_absPath">
            <a href="#defn_absPath" class="absOp">Path</a>(|x|, |ppe|, |y|)
            is an algebraic query expression if
            |ppe| is an <a href="#defn_AlgebraicPropertyPathExpression">algebraic property path expression</a>,
            |x| is an <a data-cite="RDF12-CONCEPTS#dfn-rdf-term">RDF term</a> or a <a href="#defn_QueryVariable">variable</a>, and
            |y| is an <a data-cite="RDF12-CONCEPTS#dfn-rdf-term">RDF term</a> or a <a href="#defn_QueryVariable">variable</a>.</li>
          <li id="defn_absUnion">
            <a href="#defn_absUnion" class="absOp">Union</a>(<var>A<sub>1</sub></var>, <var>A<sub>2</sub></var>)
            is an algebraic query expression if
            <var>A<sub>1</sub></var> and <var>A<sub>2</sub></var> are algebraic query expressions.</li>
          <li id="defn_absJoin">
            <a href="#defn_absJoin" class="absOp">Join</a>(<var>A<sub>1</sub></var>, <var>A<sub>2</sub></var>)
            is an algebraic query expression if
            <var>A<sub>1</sub></var> and <var>A<sub>2</sub></var> are algebraic query expressions.</li>
          <li id="defn_absMinus">
            <a href="#defn_absMinus" class="absOp">Minus</a>(<var>A<sub>1</sub></var>, <var>A<sub>2</sub></var>)
            is an algebraic query expression if
            <var>A<sub>1</sub></var> and <var>A<sub>2</sub></var> are algebraic query expressions.</li>
          <li id="defn_absLeftJoin">
            <a href="#defn_absLeftJoin" class="absOp">LeftJoin</a>(<var>A<sub>1</sub></var>, <var>A<sub>2</sub></var>, |expr|)
            is an algebraic query expression if
            <var>A<sub>1</sub></var> and <var>A<sub>2</sub></var> are algebraic query expressions and
            |expr| is an <a href="#expressions">expression</a>.</li>
          <li id="defn_absFilter">
            <a href="#defn_absFilter" class="absOp">Filter</a>(|expr|, |A|)
            is an algebraic query expression if
            |expr| is an <a href="#expressions">expression</a> and
            |A| is an algebraic query expression.</li>
          <li id="defn_absExtend">
            <a href="#defn_absExtend" class="absOp">Extend</a>(|A|, |var|, |expr|)
            is an algebraic query expression if
            |A| is an algebraic query expression,
            |var| is a <a href="#defn_QueryVariable">variable</a>, and
            |expr| is an <a href="#expressions">expression</a>.</li>
          <li id="defn_absGraph">
            <a href="#defn_absGraph" class="absOp">Graph</a>(|x|, |A|)
            is an algebraic query expression if
            |x| is an <a data-cite="RDF12-CONCEPTS#dfn-iri">IRI</a> or a <a href="#defn_QueryVariable">variable</a> and
            |A| is an algebraic query expression.</li>
          <li id="defn_absToMultiset">
            <a href="#defn_absToMultiset" class="absOp">ToMultiset</a>(|A|)
            is an algebraic query expression if
            |A| is an algebraic query expression.</li>
          <li id="defn_absToList">
            <a href="#defn_absToList" class="absOp">ToList</a>(|A|)
            is an algebraic query expression if
            |A| is an algebraic query expression.</li>
          <li id="defn_absGroup">
            <a href="#defn_absGroup" class="absOp">Group</a>(|exprlist|, |A|)
            is an algebraic query expression if
            |exprlist| is a nonempty sequence of <a href="#expressions">expressions</a> and
            |A| is an algebraic query expression.</li>
          <li id="defn_absAggregation">
            <a href="#defn_absAggregation" class="absOp">Aggregation</a>(|exprlist|, |func|, |scalarvals|, |grp|)
            is an algebraic query expression if
            |exprlist| is a nonempty sequence of <a href="#expressions">expressions</a> or the asterisk character (*),
            |func| is a <a href="#setFunctions">set function</a>,
            |scalarvals| is a partial function (which may be the empty function, i.e., with an empty domain), and
            |grp| is an algebraic query expression of the form <a href="#defn_absGroup" class="absOp">Group</a>(<var>exprlist'</var>, |A|) where
            <var>exprlist'</var> is a sequence of <a href="#expressions">expressions</a> and
            |A| is an algebraic query expression.
<div class="issue" data-number="230">
  <a href="#defn_absGroup" class="absOp">Group</a> and <a href="#defn_absAggregation" class="absOp">Aggregation</a>
  should not be independent operators but, instead, should be integrated into the definition of
  <a href="#defn_absAggregateJoin" class="absOp">AggregateJoin</a>.</div>
            </li>
          <li id="defn_absAggregateJoin">
            <a href="#defn_absAggregateJoin" class="absOp">AggregateJoin</a>(<var>A<sub>1</sub></var>, ..., <var>A<sub>|n|</sub></var>)
            is an algebraic query expression if
            <var>A<sub>1</sub></var>, ..., <var>A<sub>|n|</sub></var> is
            a non-empty sequence of algebraic query expressions (i.e., |n| &geq; 1)
            such that every expression <var>A<sub>|i|</sub></var> in this sequence
            is of the form <a href="#defn_absAggregation" class="absOp">Aggregation</a>(<var>exprlist<sub>|i|</sub></var>, <var>func<sub>|i|</sub></var>, <var>scalarvals<sub>|i|</sub></var>, <var>grp<sub>|i|</sub></var>)
            that is captured by <a href="#defn_absAggregation">the previous point</a>.</li>
          <li id="defn_absOrderBy">
            <a href="#defn_absOrderBy" class="absOp">OrderBy</a>(|A|, |condition|)
            is an algebraic query expression if
            |A| is an algebraic query expression and
            |condition| is an ordering condition.
<div class="issue" data-number="229">The term "ordering condition" should link to some definition of this notion.</div>
            </li>
          <li id="defn_absProject">
            <a href="#defn_absProject" class="absOp">Project</a>(|A|, |PV|)
            is an algebraic query expression if
            |A| is an algebraic query expression and
            |PV| is a set of <a href="#defn_QueryVariable">variables</a>.</li>
          <li id="defn_absDistinct">
            <a href="#defn_absDistinct" class="absOp">Distinct</a>(|A|)
            is an algebraic query expression if
            |A| is an algebraic query expression.</li>
          <li id="defn_absReduced">
            <a href="#defn_absReduced" class="absOp">Reduced</a>(|A|)
            is an algebraic query expression if
            |A| is an algebraic query expression.</li>
          <li id="defn_absSlice">
            <a href="#defn_absSlice" class="absOp">Slice</a>(|A|, |offset|)
            and
            <a href="#defn_absSlice" class="absOp">Slice</a>(|A|, |offset|, |limit|)
            are algebraic query expressions if
            |A| is an algebraic query expression and
            |offset| and |limit| are non-negative integers.</li>
        </ul>
        <p id="defn_AlgebraicPropertyPathExpression">The notion of an
          <a href="#defn_AlgebraicPropertyPathExpression">algebraic property path expression</a>,
          as used in the previous definition,
          is defined recursively as follows:</p>
        <ul>
          <li id="defn_ppeLink">
            <a href="#defn_ppeLink" class="ppeOp">Link</a>(|iri|)
            is an algebraic property path expression if
            |iri| is an <a data-cite="RDF12-CONCEPTS#dfn-iri">IRI</a>.</li>
          <li id="defn_ppeNPS">
            <a href="#defn_ppeNPS" class="ppeOp">NPS</a>(|I|)
            is an algebraic property path expression if
            |I| is a nonempty set of <a data-cite="RDF12-CONCEPTS#dfn-iri">IRIs</a>.
            NPS is an acronym for <em>negated property set</em>.</i>
          <li id="defn_ppeSeq">
            <a href="#defn_ppeSeq" class="ppeOp">Seq</a>(<var>ppe<sub>1</sub></var>, <var>ppe<sub>2</sub></var>)
            is an algebraic property path expression if
            <var>ppe<sub>1</sub></var> and <var>ppe<sub>2</sub></var> are algebraic property path expressions.</li>
          <li id="defn_ppeAlt">
            <a href="#defn_ppeAlt" class="ppeOp">Alt</a>(<var>ppe<sub>1</sub></var>, <var>ppe<sub>2</sub></var>)
            is an algebraic property path expression if
            <var>ppe<sub>1</sub></var> and <var>ppe<sub>2</sub></var> are algebraic property path expressions.</li>
          <li id="defn_ppeInv">
            <a href="#defn_ppeInv" class="ppeOp">Inv</a>(|ppe|)
            is an algebraic property path expression if
            |ppe| is an algebraic property path expression.</li>
          <li id="defn_ppeZeroOrOnePath">
            <a href="#defn_ppeZeroOrOnePath" class="ppeOp">ZeroOrOnePath</a>(|ppe|)
            is an algebraic property path expression if
            |ppe| is an algebraic property path expression.</li>
          <li id="defn_ppeZeroOrMorePath">
            <a href="#defn_ppeZeroOrMorePath" class="ppeOp">ZeroOrMorePath</a>(|ppe|)
            is an algebraic property path expression if
            |ppe| is an algebraic property path expression.</li>
          <li id="defn_ppeOneOrMorePath">
            <a href="#defn_ppeOneOrMorePath" class="ppeOp">OneOrMorePath</a>(|ppe|)
            is an algebraic property path expression if
            |ppe| is an algebraic property path expression.</li>
        </ul>
      </section>
      <section id="translation">
        <span id="sparqlQuery"><!-- obsolete id --></span>
        <h3>Translation to the Algebraic Syntax</h3>
        <p>This section defines the process of converting graph patterns and solution modifiers in a
          SPARQL query string into an <a href="#defn_AlgebraicQueryExpression">algebraic
          query expression</a>. The process described converts one
          level of query nesting as formed by subqueries using the nested <code>SELECT</code> syntax, and
          is applied recursively on subqueries. Each level consists of graph pattern matching and
          filtering, followed by the application of solution modifiers.</p>
        <p>The SPARQL query string is parsed and the abbreviations for IRIs and triple patterns given
          in Section&nbsp;<a href="#sparqlSyntax" class="sectionRef"></a> are applied.
          At this point, the abstract syntax tree is composed of the following:</p>
        <table class="plain">
          <tbody>
            <tr>
              <th>Patterns</th>
              <th>Modifiers</th>
              <th>Query Forms</th>
              <th>Other</th>
            </tr>
            <tr>
              <td>RDF terms</td>
              <td>DISTINCT</td>
              <td>SELECT</td>
              <td>VALUES</td>
            </tr>
            <tr>
              <td>Property path expression</td>
              <td>REDUCED</td>
              <td>CONSTRUCT</td>
              <td>SERVICE</td>
            </tr>
            <tr>
              <td>Property path patterns</td>
              <td>Projection</td>
              <td>DESCRIBE</td>
              <td>&nbsp;</td>
            </tr>
            <tr>
              <td>Groups</td>
              <td>ORDER BY</td>
              <td>ASK</td>
              <td>&nbsp;</td>
            </tr>
            <tr>
              <td>OPTIONAL</td>
              <td>LIMIT</td>
              <td>&nbsp;</td>
              <td>&nbsp;</td>
            </tr>
            <tr>
              <td>UNION</td>
              <td>OFFSET</td>
              <td>&nbsp;</td>
              <td>&nbsp;</td>
            </tr>
            <tr>
              <td>GRAPH</td>
              <td>Select expressions</td>
              <td>&nbsp;</td>
              <td>&nbsp;</td>
            </tr>
            <tr>
              <td>BIND</td>
              <td>&nbsp;</td>
              <td>&nbsp;</td>
              <td>&nbsp;</td>
            </tr>
            <tr>
              <td>GROUP BY</td>
              <td>&nbsp;</td>
              <td>&nbsp;</td>
              <td>&nbsp;</td>
            </tr>
            <tr>
              <td>HAVING</td>
              <td>&nbsp;</td>
              <td>&nbsp;</td>
              <td>&nbsp;</td>
            </tr>
            <tr>
              <td>MINUS</td>
              <td>&nbsp;</td>
              <td>&nbsp;</td>
              <td>&nbsp;</td>
            </tr>
            <tr>
              <td>FILTER</td>
              <td>&nbsp;</td>
              <td>&nbsp;</td>
              <td>&nbsp;</td>
            </tr>
          </tbody>
        </table>
        <section id="variableScope">
          <h4>Variable Scope</h4>
          <p>We define a variable to be <i>in-scope</i> if there is a way for the variable to be in the
            domain of a solution mapping at that point in the evaluation of the
            <a href="#defn_AlgebraicQueryExpression">algebraic expression</a> of the
            query. The definition below provides a way of determining this from the
            abstract syntax tree of a query.</p>
          <p>Note that a subquery with a projection can hide variables; use of a variable in
            <code>FILTER</code> or in <code>MINUS</code> does not cause the variable to be in-scope
            outside of those forms.</p>
          <p>Let <b>P</b>, <b>P1</b>, and <b>P2</b> be graph patterns, and <b>E</b>,
            <b>E1</b>,..., through <b>En</b> be expressions. A variable <code>v</code> is in-scope if:</p>
          <table style="border-collapse: collapse; border-color: #000000; border-spacing:5px; border-width: 1px">
            <tbody>
              <tr>
                <th>Syntax Form</th>
                <th>In-scope variables</th>
              </tr>
              <tr>
                <td>Basic Graph Pattern (BGP)</td>
                <td><code>v</code> occurs in the BGP</td>
              </tr>
              <tr>
                <td>Path</td>
                <td><code>v</code> occurs in the path</td>
              </tr>
              <tr>
                <td>Group <code>{ P1 P2 ... }</code></td>
                <td><code>v</code> is in-scope if it is in-scope in one or more of P1, P2, ...</td>
              </tr>
              <tr>
                <td><code>GRAPH term { P }</code></td>
                <td><code>v</code> is <code>term</code> or <code>v</code> is in-scope in P</td>
              </tr>
              <tr>
                <td><code>{ P1 } UNION { P2 }</code></td>
                <td><code>v</code> is in-scope in P1 or in-scope in P2</td>
              </tr>
              <tr>
                <td><code>OPTIONAL {P}</code></td>
                <td><code>v</code> is in-scope in P</td>
              </tr>
              <tr>
                <td><code>SERVICE term {P}</code></td>
                <td><code>v</code> is <code>term</code> or <code>v</code> is in-scope in P</td>
              </tr>
              <tr>
                <td><code>BIND (expr AS v)</code></td>
                <td><code>v</code> is in-scope</td>
              </tr>
              <tr>
                <td><code>SELECT .. v .. { P }</code></td>
                <td><code>v</code> is in-scope</td>
              </tr>
              <tr>
                <td><code>SELECT ... (expr AS v)</code></td>
                <td><code>v</code> is in-scope</td>
              </tr>
              <tr>
                <td><code>GROUP BY (expr AS v)</code></td>
                <td><code>v</code> is in-scope</td>
              </tr>
              <tr>
                <td><code>SELECT * { P }</code></td>
                <td><code>v</code> is in-scope in <code>P</code></td>
              </tr>
              <tr>
                <td><code>VALUES v { values }</code></td>
                <td><code>v</code> is in-scope</td>
              </tr>
              <tr>
                <td><code>VALUES varlist { values }</code></td>
                <td><code>v</code> is in-scope if <code>v</code> is in <code>varlist</code></td>
              </tr>
            </tbody>
          </table>
          <p>The variable <code>v</code> must not be in-scope at the point of the <code>(expr AS
              v)</code> form. The scoping for <code>(expr AS v)</code> applies immediately in
            <code>SELECT</code> expressions.</p>
          <p>In <code>BIND (expr AS v)</code> requires that the variable <code>v</code> is not
            in-scope from the preceeding elements in the group graph pattern in which it is used.</p>
          <p>In <code>SELECT</code>, the variable <code>v</code> must not be in-scope in the graph
            pattern of the <code>SELECT</code> clause, nor used in another select expression earlier in
            the clause.</p>
        </section>
        <section id="convertGraphPattern">
          <h4>Converting Graph Patterns</h4>
          <p>This section describes the process for translating a SPARQL graph pattern into an
            <a href="#defn_AlgebraicQueryExpression">algebraic query expression</a>. This
            process is applied to the group graph pattern (the unit between brace
            ("<code>{&nbsp}</code>") delimiters) forming the <code>WHERE</code> clause of a
            query, and recursively to each syntactic element within the group graph pattern.
            The result of the
            translation is an <a href="#defn_AlgebraicQueryExpression">algebraic query expression</a>.</p>
          <p>In summary, the steps are applied as follows:</p>
          <ul>
            <li>
              <a href="#sparqlExpandForms">Expand syntax forms</a> for IRIs, literals and triple
              patterns.
            </li>
            <li>
              <a href="#sparqlTranslatePathExpressions">Translate property path expressions</a>
            </li>
            <li>
              <a href="#sparqlTranslatePathPatterns">Convert some property path patterns to
                triples</a>
            </li>
            <li>
              <a href="#sparqlCollectFilters">Collect the <code>FILTER</code>s in the group</a>
            </li>
            <li>
              <a href="#sparqlTranslateBasicGraphPatterns">Translate Basic Graph Patterns</a>
            </li>
            <li>
              <a href="#sparqlTranslateGraphPatterns">Translate the remaining graph patterns in the
                group</a>
            </li>
            <li>
              <a href="#sparqlAddFilters">Add in Filters</a>
            </li>
            <li>
              <a href="#sparqlSimplification">Simplify the resulting expression</a>
            </li>
          </ul>
          <p>We write</p>
          <blockquote>
            translate(graph pattern)
          </blockquote>
          <p>for the algorithm described here to translate graph patterns.</p>
          <div class="wgNote">
            The working group notes that in SPARQL 1.0, the point at which the simplification step is
            applied leads to ambiguous transformation of queries involving a doubly nested filter and
            pattern in an optional:
            <pre><code>OPTIONAL { { ... FILTER ( ... ?x ... ) } }.</code>.</pre>
            <p>This is illustrated by two non-normative test cases:</p>
            <ul>
              <li>
                <a href="http://www.w3.org/2001/sw/DataAccess/tests/data-r2/optional-filter/manifest#dawg-optional-filter-005-not-simplified">
                  Simplification applied after all transformations</a> or not at all.
              </li>
              <li>
                <a href="http://www.w3.org/2001/sw/DataAccess/tests/data-r2/optional-filter/manifest#dawg-optional-filter-005-simplified">
                  Simplification applied during transformation</a>.
              </li>
            </ul>
          </div>
          <p>Applying the simpification step after all the translation of graph patterns is the
            preferred reading.</p>
          <section id="sparqlExpandForms">
            <h5>Expand Syntax Forms</h5>
            <p>Expand abbreviations for IRIs and triple patterns given in
              Section&nbsp;<a href="#sparqlSyntax" class="sectionRef"></a>.</p>
          </section>
          <section id="sparqlCollectFilters">
            <h5>Collect <code>FILTER</code> Elements</h5>
            <p><code>FILTER</code> expressions apply to the whole group graph pattern in which they
              appear. The algebra operators to perform filtering are added to the group after
              translation of each group element. We collect the filters together here and remove them
              from group, then <a href="#sparqlAddFilters">apply them to the whole translated group
                graph pattern</a>.</p>
            <p>In this step, we also translate graph patterns within <code>FILTER</code> expressions
              <a href="#func-filter-exists"><code>EXISTS</code></a> and 
              <a href="#func-filter-not-exists"><code>NOT EXISTS</code></a>.</p>

            <pre class="code nohighlightBlock">
Let FS := empty set
For each form FILTER(expr) in the group graph pattern
    In expr, replace NOT EXISTS{P} with fn:not(<a href="#defn_evalExists">exists(translate(P)))</a> 
    In expr, replace EXISTS{P} with <a href="#defn_evalExists">exists(translate(P))</a>
    FS := FS âˆª {expr}
    End
</pre>
            <p>The set of filter expressions <code>FS</code> is <a href="#sparqlAddFilters">used
                later</a>.</p>
          </section>
          <section id="sparqlTranslatePathExpressions">
            <h5>Translate Property Path Expressions</h5>
            <p>The following table gives the translation
              of <a href="#defn_PropertyPathExpr">property path expressions</a> in SPARQL query strings
              into <a href="#defn_AlgebraicPropertyPathExpression">algebraic property path expressions</a>.
              This applies to all elements of a <a href="#defn_PropertyPathExpr">property path expression</a> recursively.</p>
            <p>The <a href="#sparqlTranslatePathPatterns">next step after this one</a> translates
              certain forms to triple patterns, and these are converted later to basic graph patterns
              by adjacency (without intervening group pattern delimiters 
              <code>{</code> and <code>})</code> or
              other syntax forms. Overall, SPARQL syntax property paths of just an IRI become triple
              patterns and these are aggregated into basic graph patterns.</p>
            <p>Notes:</p>
            <ul>
              <li>The order of forms IRI and ^IRI in a negated property set (NPS) is not relevant.</li>
            </ul>
            <table style="border-collapse: collapse; border-color: #000000; border-spacing: 5px; border-width: 1px">
              <tbody>
                <tr>
                  <th><a href="#defn_PropertyPathExpr">Syntax Form</a> (path)</th>
                  <th><a href="#defn_AlgebraicPropertyPathExpression">Algebraic Form</a> (path)</th>
                </tr>
                <tr>
                  <td><code>iri</code></td>
                  <td><code><a href="#defn_ppeLink" class="ppeOp">Link</a>(iri)</code></td>
                </tr>
                <tr>
                  <td><code>^path</code></td>
                  <td><code><a href="#defn_ppeInv" class="ppeOp">Inv</a>(path)</code></td>
                </tr>
                <tr>
                  <td><code>!(:iri<sub>1</sub>|...|:iri<sub>n</sub>)</code></td>
                  <td><code><a href="#defn_ppeNPS" class="ppeOp">NPS</a>({:iri<sub>1</sub> ... :iri<sub>n</sub>})</code></td>
                </tr>
                <tr>
                  <td><code>!(^:iri<sub>1</sub>|...|^:iri<sub>n</sub>)</code></td>
                  <td><code><a href="#defn_ppeInv" class="ppeOp">Inv</a>( <a href="#defn_ppeNPS" class="ppeOp">NPS</a>({:iri<sub>1</sub> ... :iri<sub>n</sub>}) )</code></td>
                </tr>
                <tr>
                  <td>
                    <code>!(:iri<sub>1</sub>|...|:iri<sub>i</sub>|^:iri<sub>i+1</sub>|...|^:iri<sub>m</sub>)</code>&nbsp;</td>
                  <td><code><a href="#defn_ppeAlt" class="ppeOp">Alt</a>( <a href="#defn_ppeNPS" class="ppeOp">NPS</a>({:iri<sub>1</sub> ...:iri<sub>i</sub>}),<br>
                      &nbsp;&nbsp;&nbsp;&nbsp;<a href="#defn_ppeInv" class="ppeOp">Inv</a>(<a href="#defn_ppeNPS" class="ppeOp">NPS</a>({:iri<sub>i+1</sub>, ..., :iri<sub>m</sub>}))
                      )</code></td>
                </tr>
                <tr>
                  <td><code>path1 / path2</code></td>
                  <td><code><a href="#defn_ppeSeq" class="ppeOp">Seq</a>(path1, path2)</code></td>
                </tr>
                <tr>
                  <td><code>path1 | path2</code></td>
                  <td><code><a href="#defn_ppeAlt" class="ppeOp">Alt</a>(path1, path2)</code></td>
                </tr>
                <tr>
                  <td><code>path*</code></td>
                  <td><code><a href="#defn_ppeZeroOrMorePath" class="ppeOp">ZeroOrMorePath</a>(path)</code></td>
                </tr>
                <tr>
                  <td><code>path+</code></td>
                  <td><code><a href="#defn_ppeOneOrMorePath" class="ppeOp">OneOrMorePath</a>(path)</code></td>
                </tr>
                <tr>
                  <td><code>path?</code></td>
                  <td><code><a href="#defn_ppeZeroOrOnePath" class="ppeOp">ZeroOrOnePath</a>(path)</code></td>
                </tr>
              </tbody>
            </table>
          </section>
          <section id="sparqlTranslatePathPatterns">
            <h5>Translate Property Path Patterns</h5>
            <p>The previous step translated <a href="#defn_PropertyPathExpr">property path expressions</a>.
              This step translates <a href="#defn_PropertyPathPattern">property path patterns</a>,
              which are a subject end point, a property path expression, and an object end
              point.
              This step assumes that the property path expression
              of the property path pattern is already given in the form of an
              <a href="#defn_AlgebraicPropertyPathExpression">algebraic property path expression</a>.
              The result of this step may be triple patterns and
              <a href="#defn_AlgebraicQueryExpression">algebraic query expressions</a>
              of the form <a href="#defn_absPath" class="absOp">Path</a>(...).</p>
            <p>Notes:</p>
            <ul>
              <li>|x| and |y| are <a data-cite="RDF12-CONCEPTS#dfn-rdf-terms">RDF terms</a> or <a href="#defn_QueryVariable">variables</a>.</li>
              <li>|var| is a fresh <a href="#defn_QueryVariable">variable</a>.</li>
              <li>|ppe|, <var>ppe<sub>1</sub></var>, and <var>ppe<sub>2</sub></var> are <a href="#defn_AlgebraicPropertyPathExpression">algebraic property path expressions</a>.</li>
              <li>These are only applied to property path patterns, not within property path
                expressions.</li>
              <li>Translations earlier in the table are applied in preference to the last
                translation.</li>
              <li>The final translation simply wraps any remaining property path expression to use a
                common form <a href="#defn_absPath" class="absOp">Path</a>(...).</li>
            </ul>
            <table style="border-collapse: collapse; border-color: #000000; border-spacing: 5px; border-width: 1px">
              <tbody>
                <tr>
                  <th><a href="#defn_AlgebraicPropertyPathExpression">Algebraic Form</a> (path)</th>
                  <th>Translation</th>
                </tr>
                <tr>
                  <td>|x| <a href="#defn_ppeLink" class="ppeOp">Link</a>(|iri|) |y|</td>
                  <td>|x| |iri| |y|</td>
                </tr>
                <tr>
                  <td>|x| <a href="#defn_ppeInv" class="ppeOp">Inv</a>(|iri|) |y|</td>
                  <td>|y| |iri| |x|</td>
                </tr>
                <tr>
                  <td>|x| <a href="#defn_ppeSeq" class="ppeOp">Seq</a>(<var>ppe<sub>1</sub></var>, <var>ppe<sub>2</sub></var>) |y|</td>
                  <td>|x| <var>ppe<sub>1</sub></var> |var| . |var| <var>ppe<sub>2</sub></var> |y|</td>
                </tr>
                <tr>
                  <td>|x| |ppe| |y|</td>
                  <td><a href="#defn_absPath" class="absOp">Path</a>(|x|, |ppe|, |y|)</td>
                </tr>
              </tbody>
            </table>
<div class="issue" data-number="226">
  I assume that the translation rules in this table are meant to be applied recursively,
  but the section doesn't say anything about that. In particular, for the
  "|x| <a href="#defn_ppeSeq" class="ppeOp">Seq</a>(<var>ppe<sub>1</sub></var>, <var>ppe<sub>2</sub></var>) |y|"
  case: <var>ppe<sub>1</sub></var> and <var>ppe<sub>2</sub></var> in the resulting translation
  may still be arbitrary algebraic property path expressions and, thus,
  the translation should be applied again for each of the two resulting property path patterns
  (i.e., for "|x| <var>ppe<sub>1</sub></var> |var|" and for "|var| <var>ppe<sub>2</sub></var> |y|").</div>
            <p>Examples of the whole path translation process (<code>?_V</code> is a fresh
              variable):</p>
            <div class="algExample">
              <div class="algExample1">
                ?s :p/:q ?o
              </div>
              <div class="algExample2">
                ?s :p ?_V .<br>
                ?_V :q ?o
              </div>
            </div>
            <div class="algExample">
              <div class="algExample1">
                ?s :p* ?o
              </div>
              <div class="algExample2">
                <a href="#defn_absPath" class="absOp">Path</a>(?s, <a href="#defn_ppeZeroOrMorePath" class="ppeOp">ZeroOrMorePath</a>(<a href="#defn_ppeLink" class="ppeOp">Link</a>(:p)), ?o)
              </div>
            </div>
            <div class="algExample">
              <div class="algExample1">
                :list rdf:rest*/rdf:first ?member
              </div>
              <div class="algExample2">
                <a href="#defn_absPath" class="absOp">Path</a>(:list, <a href="#defn_ppeZeroOrMorePath" class="ppeOp">ZeroOrMorePath</a>(<a href="#defn_ppeLink" class="ppeOp">Link</a>(rdf:rest)), ?_V) .<br>
                ?_V rdf:first ?member
              </div>
            </div>
          </section>
          <section id="sparqlTranslateBasicGraphPatterns">
            <h5>Translate Basic Graph Patterns</h5>
            <p>After translating property paths, any adjacent triple patterns are collected together
              to form a basic graph pattern <code>BGP(triples)</code>.</p>
          </section>
          <section id="sparqlTranslateGraphPatterns">
            <h5>Translate Graph Patterns</h5>
            <p>Next, we translate each remaining graph pattern form, recursively applying the
              translation process.</p>
            <blockquote>
              <p>If the form is <code><a href="#rGroupOrUnionGraphPattern">GroupOrUnionGraphPattern</a></code></p>
            </blockquote>

<pre class="code nohighlight">Let <var>A</var> := undefined
          
For each element <var>G</var> in the GroupOrUnionGraphPattern
    If <var>A</var> is undefined
        <var>A</var> := Translate(<var>G</var>)
    Else
        <var>A</var> := <a href="#defn_absUnion" class="absOp">Union</a>(<var>A</var>, Translate(<var>G</var>))
    End

The result is <var>A</var>
            </pre>

            <blockquote>
              <p>If the form is <code><a href="#rGraphGraphPattern">GraphGraphPattern</a></code></p>
            </blockquote>

            <pre class="code nohighlight">
If the form is GRAPH IRI GroupGraphPattern
    The result is <a href="#defn_absGraph" class="absOp">Graph</a>(IRI, Translate(GroupGraphPattern))
</pre>

            <pre class="code nohighlight">
If the form is GRAPH Var GroupGraphPattern
    The result is <a href="#defn_absGraph" class="absOp">Graph</a>(Var, Translate(GroupGraphPattern))
</pre>

            <blockquote>
              <p>If the form is <code><a href="#rGroupGraphPattern">GroupGraphPattern</a></code>:</p>
            </blockquote>
<pre class="code nohighlight">
Let FS := the empty set
Let <var>G</var> := <a href="#defn_absContextSolution" class="absOp">ContextSolution</a>

For each element <var>E</var> in the sequence of elements in the GroupGraphPattern

    If <var>E</var> is of the form OPTIONAL{<var>P</var>} 
        Let <var>A</var> := Translate(<var>P</var>)
        If <var>A</var> is of the form <a href="#defn_absFilter" class="absOp">Filter</a>(<var>F</var>, <var>A2</var>)
            <var>G</var> := <a href="#defn_absLeftJoin" class="absOp">LeftJoin</a>(<var>G</var>, <var>A2</var>, <var>F</var>)
        Else 
            <var>G</var> := <a href="#defn_absLeftJoin" class="absOp">LeftJoin</a>(<var>G</var>, <var>A</var>, true)
            End
        End

    If <var>E</var> is of the form MINUS{<var>P</var>}
        <var>G</var> := <a href="#defn_absMinus" class="absOp">Minus</a>(<var>G</var>, Translate(<var>P</var>))
        End

    If <var>E</var> is of the form BIND(<var>expr</var> AS <var>var</var>)
        <var>G</var> := <a href="#defn_absExtend" class="absOp">Extend</a>(<var>G</var>, <var>var</var>, <var>expr</var>)
        End

    If <var>E</var> is any other form 
        Let <var>A</var> := Translate(<var>E</var>)
        <var>G</var> := <a href="#defn_absJoin" class="absOp">Join</a>(<var>G</var>, <var>A</var>)
        End

   End
   
The result is <var>G</var>.
            </pre>
            <blockquote>
              <p>If the form is <a href="#rInlineData">InlineData</a></p>
            </blockquote>
            <pre class="code nohighlight">The result is a multiset <var>data</var> of solution mappings.</pre>
            <div id="data-block">
              <blockquote>
                <var>data</var> is formed by forming a solution mapping from the variable in the
                corresponding position in list of variables (or single variable), omitting a binding
                if the <a href="#rDataBlockValue">DataBlockValue</a>
                is the word <code>UNDEF</code>.
              </blockquote>
            </div>
            <blockquote>
              <p>If the form is <a href="#rSubSelect">SubSelect</a></p>
            </blockquote>
            <pre class="code nohighlight">The result is <a href="#defn_absToMultiset" class="absOp">ToMultiset</a>(Translate(SubSelect))</pre>
          </section>
          <section id="sparqlAddFilters">
            <h5>Filters of Group</h5>
            <p>After the group has been translated, the filter expressions are added so they wil
              apply to the whole of the rest of the group:</p>
            <pre class="code nohighlight">
If <var>FS</var> is not empty
    Let <var>G</var> := output of preceding step
    Let <var>X</var> := Conjunction of expressions in <var>FS</var>
    <var>G</var> := <a href="#defn_absFilter" class="absOp">Filter</a>(<var>X</var>, <var>G</var>)
End</pre>
          </section>
          <section id="sparqlSimplification">
            <h5>Simplification step</h5>
            <p>Some groups of one graph pattern become <a href="#defn_absJoin"
              class="absOp">Join</a>(|Z|, |A|), where |Z| is the empty basic graph
              pattern (which is the empty set). These are replaced by |A|. The empty
              graph pattern |Z| is the identity for join:</p>
            <pre class="code nohighlight">
Replace <a href="#defn_absJoin" class="absOp">Join</a>(<var>Z</var>, <var>A</var>) by <var>A</var>
Replace <a href="#defn_absJoin" class="absOp">Join</a>(<var>A</var>, <var>Z</var>) by <var>A</var>
</pre>
          </section>
        </section>
        <section id="sparqlAlgebraExamples">
          <h4>Examples of Mapped Graph Patterns</h4>
          <p>The second form of a rewrite example is the first with empty group joins removed by the
            simplification step.
            |Z| is the empty basic graph pattern.</p>
          <p>Example: group with a basic graph pattern consisting of a single triple pattern:</p>
          <div class="algExample">
            <div class="algExample1">
              { ?s ?p ?o }
            </div>
            <div class="algExample2">
              <a href="#defn_absJoin" class="absOp">Join</a>(|Z|, BGP(?s ?p ?o) )
            </div>
            <div class="algExample2">
              BGP(?s ?p ?o)
            </div>
          </div>
          <p>Example: group with a basic graph pattern consisting of two triple patterns:</p>
          <div class="algExample">
            <div class="algExample1">
              { ?s :p1 ?v1 ; :p2 ?v2 }
            </div>
            <div class="algExample2">
              BGP( ?s :p1 ?v1 . ?s :p2 ?v2 )
            </div>
          </div>
<div class="issue" data-number="246">
  The example above does not include the version of the resulting expression
  before the simplification step. The same is true for several other examples
  below. The examples should be consistent in this regard.</div>
          <p>Example: group consisting of a union of two basic graph patterns:</p>
          <div class="algExample">
            <div class="algExample1">
              { { ?s :p1 ?v1 } UNION {?s :p2 ?v2 } }
            </div>
            <div class="algExample2">
              <a href="#defn_absUnion" class="absOp">Union</a>(<a href="#defn_absJoin" class="absOp">Join</a>(|Z|, BGP(?s :p1 ?v1)),<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#defn_absJoin" class="absOp">Join</a>(|Z|, BGP(?s :p2 ?v2)) )
            </div>
            <div class="algExample2">
              <a href="#defn_absUnion" class="absOp">Union</a>( BGP(?s :p1 ?v1) , BGP(?s :p2 ?v2) )
            </div>
          </div>
          <p>Example: group consisting of a union of a union and a basic graph pattern:</p>
          <div class="algExample">
            <div class="algExample1">
              { { ?s :p1 ?v1 } UNION {?s :p2 ?v2 } UNION {?s :p3 ?v3 } }
            </div>
            <div class="algExample2">
              <a href="#defn_absUnion" class="absOp">Union</a>(<br>
              &nbsp;&nbsp;&nbsp; <a href="#defn_absUnion" class="absOp">Union</a>( <a href="#defn_absJoin" class="absOp">Join</a>(|Z|, BGP(?s :p1 ?v1)),<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#defn_absJoin" class="absOp">Join</a>(|Z|, BGP(?s :p2 ?v2)))
              ,<br>
              &nbsp;&nbsp;&nbsp; <a href="#defn_absJoin" class="absOp">Join</a>(|Z|, BGP(?s :p3 ?v3)) )
            </div>
            <div class="algExample2">
              <a href="#defn_absUnion" class="absOp">Union</a>(<br>
              &nbsp;&nbsp;&nbsp; <a href="#defn_absUnion" class="absOp">Union</a>( BGP(?s :p1 ?v1) ,<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BGP(?s :p2 ?v2),<br>
              &nbsp;&nbsp;&nbsp; BGP(?s :p3 ?v3))
            </div>
          </div>
          <p>Example: group consisting of a basic graph pattern and an optional graph pattern:</p>
          <div class="algExample">
            <div class="algExample1">
              { ?s :p1 ?v1 OPTIONAL {?s :p2 ?v2 } }
            </div>
            <div class="algExample2">
              <a href="#defn_absLeftJoin" class="absOp">LeftJoin</a>(<br>
              &nbsp;&nbsp;&nbsp; <a href="#defn_absJoin" class="absOp">Join</a>(|Z|, BGP(?s :p1 ?v1)),<br>
              &nbsp;&nbsp;&nbsp; <a href="#defn_absJoin" class="absOp">Join</a>(|Z|, BGP(?s :p2 ?v2)),<br>
              &nbsp;&nbsp;&nbsp; true)
            </div>
            <div class="algExample2">
              <a href="#defn_absLeftJoin" class="absOp">LeftJoin</a>(BGP(?s :p1 ?v1), BGP(?s :p2 ?v2), true)
            </div>
          </div>
          <p>Example: group consisting of a basic graph pattern and two optional graph patterns:</p>
          <div class="algExample">
            <div class="algExample1">
              { ?s :p1 ?v1 OPTIONAL {?s :p2 ?v2 } OPTIONAL { ?s :p3 ?v3 } }
            </div>
            <div class="algExample2">
              <a href="#defn_absLeftJoin" class="absOp">LeftJoin</a>(<br>
              &nbsp;&nbsp;&nbsp; <a href="#defn_absLeftJoin" class="absOp">LeftJoin</a>(<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BGP(?s :p1 ?v1),<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BGP(?s :p2 ?v2),<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; true) ,<br>
              &nbsp;&nbsp;&nbsp; BGP(?s :p3 ?v3),<br>
              &nbsp;&nbsp;&nbsp; true)
            </div>
          </div>
          <p>Example: group consisting of a basic graph pattern and an optional graph pattern with a
            filter:</p>
          <div class="algExample">
            <div class="algExample1">
              { ?s :p1 ?v1 OPTIONAL {?s :p2 ?v2 FILTER(?v1&lt;3) } }
            </div>
            <div class="algExample2">
              <a href="#defn_absLeftJoin" class="absOp">LeftJoin</a>(<br>
              &nbsp;&nbsp;&nbsp;&nbsp; <a href="#defn_absJoin" class="absOp">Join</a>(|Z|, BGP(?s :p1 ?v1)),<br>
              &nbsp;&nbsp;&nbsp;&nbsp; <a href="#defn_absJoin" class="absOp">Join</a>(|Z|, BGP(?s :p2 ?v2)),<br>
              &nbsp;&nbsp;&nbsp;&nbsp; (?v1&lt;3) )
            </div>
            <div class="algExample2">
              <a href="#defn_absLeftJoin" class="absOp">LeftJoin</a>(<br>
              &nbsp;&nbsp;&nbsp; BGP(?s :p1 ?v1) ,<br>
              &nbsp;&nbsp;&nbsp; BGP(?s :p2 ?v2) ,<br>
              &nbsp;&nbsp; (?v1&lt;3) )
            </div>
          </div>
          <p>Example: group consisting of a union graph pattern and an optional graph pattern:</p>
          <div class="algExample">
            <div class="algExample1">
              { {?s :p1 ?v1} UNION {?s :p2 ?v2} OPTIONAL {?s :p3 ?v3} }
            </div>
            <div class="algExample2">
              <a href="#defn_absLeftJoin" class="absOp">LeftJoin</a>(<br>
              &nbsp; <a href="#defn_absUnion" class="absOp">Union</a>(BGP(?s :p1 ?v1),<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BGP(?s :p2 ?v2)) ,<br>
              &nbsp; BGP(?s :p3 ?v3) ,<br>
              &nbsp; true )
            </div>
          </div>
          <p>Example: group consisting of a basic graph pattern, a filter and an optional graph
            pattern:</p>
          <div class="algExample">
            <div class="algExample1">
              { ?s :p1 ?v1 FILTER (?v1 &lt; 3 ) OPTIONAL {?s :p2 ?v2} }
            </div>
            <div class="algExample2">
              <a href="#defn_absFilter" class="absOp">Filter</a>( ?v1 &lt; 3 ,<br>
              &nbsp; <a href="#defn_absLeftJoin" class="absOp">LeftJoin</a>( BGP(?s :p1 ?v1), BGP(?s :p2 ?v2), true) ,<br>
              &nbsp; )
            </div>
          </div>
          <p>Example: Pattern involving BIND:</p>
          <div class="algExample">
            <div class="algExample1">
              { ?s :p ?v . BIND (2*?v AS ?v2) ?s :p1 ?v2 }
            </div>
            <div class="algExample2">
              <a href="#defn_absJoin" class="absOp">Join</a>(<br>
              &nbsp;&nbsp; <a href="#defn_absExtend" class="absOp">Extend</a>( BGP(?s :p ?v), ?v2, 2*?v) ,<br>
              &nbsp;&nbsp; BGP(?s :p1 ?v2) )
            </div>
          </div>
          <p>Example: Pattern involving BIND, with a 
            <a href="#sparqlSimplification">simplification</a> step:</p>
<div class="issue" data-number="246">
  The following example uses <code>{}</code> to represent the empty BGP in the
  first version of the resulting expression (the one before the simplification
  step), whereas the previous examples above are using |Z| instead. The
  examples should be consistent in this regard.</div>
          <div class="algExample">
            <div class="algExample1">
              { ?s :p ?v . {} BIND (2*?v AS ?v2) }
            </div>
            <div class="algExample2">
              <a href="#defn_absExtend" class="absOp">Extend</a>(<br>
              &nbsp;&nbsp; <a href="#defn_absJoin" class="absOp">Join</a>( <br>
              &nbsp;&nbsp;&nbsp;&nbsp; <a href="#defn_absJoin" class="absOp">Join</a>( {}, BGP(?s :p ?v)),<br>
              &nbsp;&nbsp;&nbsp;&nbsp; {}),<br>
              &nbsp;&nbsp; ?v2, 2*?v<br>
              )
            </div>
            <div class="algExample2">
              <a href="#defn_absExtend" class="absOp">Extend</a>(<br>
              &nbsp;&nbsp; BGP(?s :p ?v) ,<br>
              &nbsp;&nbsp; ?v2, 2*?v<br>
            )
            </div>
          </div>
          <p>Example: Pattern involving MINUS:</p>
          <div class="algExample">
            <div class="algExample1">
              { ?s :p ?v . MINUS {?s :p1 ?v2 } }
            </div>
            <div class="algExample2">
              <a href="#defn_absMinus" class="absOp">Minus</a>(<br>
              &nbsp;&nbsp; BGP(?s :p ?v) ,<br>
              &nbsp;&nbsp; BGP(?s :p1 ?v2)<br>
              )
            </div>
          </div>
          <p>Example: Pattern involving a subquery:</p>
          <div class="algExample">
            <div class="algExample1">
              { ?s :p ?o . {SELECT DISTINCT ?o {?o ?p ?z} } }
            </div>
            <div class="algExample2">
              <a href="#defn_absJoin" class="absOp">Join</a>(<br>
              &nbsp;&nbsp; BGP(?s :p ?o) ,<br>
              &nbsp;&nbsp; <a href="#defn_absToMultiset" class="absOp">ToMultiset</a>(<br>
              &nbsp;&nbsp;&nbsp;&nbsp; <a href="#defn_absDistinct" class="absOp">Distinct</a>( <br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="#defn_absProject" class="absOp">Project</a>( <a href="#defn_absToList" class="absOp">ToList</a>(BGP(?o ?p ?z)), {?o} ) <br>
              &nbsp;&nbsp;&nbsp;&nbsp; ) <br>
              &nbsp;&nbsp; ) <br>
              )
            </div>
          </div>
        </section>
        <section id="convertGroupAggSelectExpressions">
          <h4>Converting Groups, Aggregates, HAVING, final VALUES clause and SELECT Expressions</h4>
          <p>In this step, we process clauses on the query level in the following order:</p>
          <ul>
            <li>Grouping</li>
            <li>Aggregates</li>
            <li>HAVING</li>
            <li>VALUES</li>
            <li>Select expressions</li>
          </ul>
          <section id="sparqlGroupAggregate">
            <h5>Grouping and Aggregation</h5>
            <p>Step: GROUP BY</p>
            <p>If the <code>GROUP BY</code> keyword is used, or there is implicit grouping due to the
              use of aggregates in <code>HAVING</code> or <code>ORDER BY</code> clauses, or in the
              projection, then grouping is performed by the <a href="#defn_algGroup">Group</a> function.
              In this case, before grouping, the solution set is converted into a solution
              sequence by applying the <a href="#defn_algToList">ToList</a> function.
              Next, the <a href="#defn_algGroup">Group</a> function
              divides this solution sequence into groups of one or
              more solutions, with the same overall cardinality. In case of implicit grouping, a fixed
              constant (1) is used to group all solutions into a single group.</p>
            <p>Step: Aggregates</p>
            <p>
              The aggregation step is applied as a transformation on the query level, replacing
              aggregate expressions in the query level with <a href="#defn_absAggregation" class="absOp">Aggregation</a>() algebraic
              expressions.
            </p>
            <p>
              The transformation for query levels that use any aggregates is given
              below:
            </p>
<div class="issue" data-number="247">
  There are a few minor issues in the following algorithm.</div>

<pre class="code nohighlight">Let <var>A</var> := the empty sequence
Let <var>Q</var> := the query level being evaluated
Let <var>P</var> := algebraic query expression <a href="#convertGraphPattern">produced</a> for the GroupGraphPattern of the query level
Let <var>E</var> := [], a list of pairs of the form (variable, expression)

If <var>Q</var> contains GROUP BY <var>exprlist</var>
   Let <var>Grp</var> := <a href="#defn_absGroup" class="absOp">Group</a>(<var>exprlist</var>, <a href="#defn_absToList" class="absOp">ToList</a>(<var>P</var>))
Else If <var>Q</var> contains an aggregate in SELECT, HAVING, ORDER BY
   Let <var>Grp</var> := <a href="#defn_absGroup" class="absOp">Group</a>((1), <a href="#defn_absToList" class="absOp">ToList</a>(<var>P</var>))
Else
   skip the rest of the Aggregates step
   End

Global <var>i</var> := 1   # Initially 1 for each query processed

For each (<var>X</var> AS <var>Var</var>) in SELECT, each HAVING(<var>X</var>), and each ORDER BY <var>X</var> in <var>Q</var>
  For each unaggregated variable <var>V</var> in <var>X</var>
      Replace <var>V</var> with SAMPLE(<var>V</var>)
      End
  For each aggregate <var>R</var>(<var>args</var> ; <var>scalarvals</var>) now in <var>X</var>
      # note: <var>scalarvals</var> may be omitted; if so, it is equivalent to the empty function
      <var>A</var><sub><var>i</var></sub> := <a href="#defn_absAggregation" class="absOp">Aggregation</a>(<var>args</var>, <var>R</var>, <var>scalarvals</var>, <var>Grp</var>)
      Replace <var>R</var>(...) with agg<sub><var>i</var></sub> in <var>Q</var>
      <var>i</var> := <var>i</var> + 1
      End
  End

For each variable <var>V</var> appearing outside of an aggregate
   <var>A</var><sub><var>i</var></sub> := <a href="#defn_absAggregation" class="absOp">Aggregation</a>(<var>V</var>, <a href="#defn_aggSample" class="aggFct">Sample</a>, {}, <var>Grp</var>)
   <var>E</var> := <var>E</var> append (<var>V</var>, agg<sub><var>i</var></sub>)
   <var>i</var> := <var>i</var> + 1
   End

<var>A</var> := <var>A</var><sub><var>i</var></sub>, ..., <var>A</var><sub><var>i</var>-1</sub>
<var>P</var> := <a href="#defn_absAggregateJoin" class="absOp">AggregateJoin</a>(<var>A</var>)
</pre>
            <p>
              The list <var>E</var> will be used when translating SELECT expressions in
              Section&nbsp;<a href="#sparqlSelectExpressions" class="sectionRef"></a>.
            </p>
          </section>
          <section id="sparqlHavingClause">
            <h5>HAVING</h5>
            <p>The HAVING expression is evaluated using the same rules as FILTER().
              Note that, due to the logic position in which the HAVING clause is
              evaluated, expressions projected by the
              SELECT clause are not visible to the HAVING clause.</p>
            <pre class="code nohighlight">
Let <var>Q</var> := the query level being evaluated
Let <var>P</var> := the algebraic query expression produced for the query level so far

For each HAVING(<var>E</var>) in <var>Q</var>
    <var>P</var> := <a href="#defn_absFilter" class="absOp">Filter</a>(<var>E</var>, <var>P</var>)
    End
</pre>

          </section>
          <section id="sparqlAlgebraFinalValues">
            <h5>VALUES</h5>
            <p>If the query has a trailing VALUES clause:</p>

<pre class="code nohighlight">
Let <var>P</var> := the algebraic query expression produced for the query level so far
<var>P</var> := <a href="#defn_absJoin" class="absOp">Join</a>(<var>P</var>, <a href="#defn_absToMultiset" class="absOp">ToMultiset</a>(<var>data</var>))
  where <var>data</var> is a solution sequence derived from the VALUES clause
</pre>

            <p>The translation of the data is the same as for <a href="#data-block">inline
                data</a>.</p>
          </section>
          <section id="sparqlSelectExpressions">
            <h5>SELECT Expressions</h5>
            <p>Step: Select expressions</p>
            <p>We have two forms of the abstract syntax to consider:</p>

<pre class="code nohighlightBlock">
  SELECT selItem ... { pattern }
  SELECT * { pattern }
</pre>

<pre class="code nohighlight">
Let <var>X</var> := algebraic query expression from earlier steps
Let <var>VS</var> := set of all variables visible in the pattern,
           so restricted by sub-SELECT projected variables and GROUP BY variables.
           Not visible: only in filter, exists/not exists, masked by a subselect, 
                        non-projected GROUP variables, only in the right hand side of MINUS

Let <var>PV</var> := {}, a set of variable names
Let <var>E</var> := a list of pairs of the form (variable, expression), populated in Section&nbsp;<a href="#sparqlGroupAggregate" class="sectionRef"></a>
  
If "SELECT *"
    <var>PV</var> := <var>VS</var>

If  "SELECT selItem ..."
    For each selItem
        If selItem is a variable
            <var>PV</var> := <var>PV</var> âˆª { variable }
        End
        If selItem is (<var>expr</var> AS <var>var</var>)
            <var>var</var> must not appear in <var>VS</var> nor in <var>PV</var>; if it does then generate a syntax error and stop
            <var>PV</var> := <var>PV</var> âˆª { <var>var</var> }
            <var>E</var> := <var>E</var> append (<var>var</var>, <var>expr</var>) 
        End
    End

For each pair (<var>var</var>, <var>expr</var>) in <var>E</var>
    <var>X</var> := <a href="#defn_absExtend" class="absOp">Extend</a>(<var>X</var>, <var>var</var>, <var>expr</var>)
    End
  
Result is <var>X</var>  
The set <var>PV</var> is used later for projection (see Section&nbsp;<a href="#sparqlProjection" class="sectionRef"></a>).
            </pre>

            <p>The syntax error arises for use of a variable as the named target of AS (e.g. ... AS
              ?x) when the variable is used inside the WHERE clause of the SELECT or if already used as
              the target of AS in this SELECT expression.</p>
          </section>
        </section>
        <section id="convertSolMod">
          <h4>Converting Solution Modifiers</h4>
          <p>Solution modifiers apply to the processing of a SPARQL query after pattern matching.</p>
          <p>Since the solution modifiers operate on sequences
            of solution mappings, the query result produced up to this
            point is first turned from a multiset of solution mappings
            into such a sequence. While there is no implied ordering to
            this sequence, and duplicates need not be adjacent, the sequence
            is identical to the multiset in terms of the elements that it
            contains, and their multiplicities. To apply this conversion
            from a multiset into a sequence, the algorithm for translating
            the solution modifiers into
            <a href="#defn_AlgebraicQueryExpression">algebraic query expressions</a>
            begins with the following step, where |A| is the
            <a href="#defn_AlgebraicQueryExpression">algebraic query expression</a>
            produced by the algorithm in the previous section.</p>
          <blockquote>
            <p>Let |M| := <a href="#defn_absToList" class="absOp">ToList</a>(|A|)</p>
          </blockquote>
          <p>Now, the solution modifiers are applied in the following order:</p>
          <ul>
            <li>Order by</li>
            <li>Projection</li>
            <li>Distinct</li>
            <li>Reduced</li>
            <li>Offset</li>
            <li>Limit</li>
          </ul>
          <section id="sparqlOrderBy">
            <h5>ORDER BY</h5>
            <p>If the query string has an ORDER BY clause</p>
            <blockquote>
              <p>|M| := <a href="#defn_absOrderBy" class="absOp">OrderBy</a>(|M|, list of order comparators)</p>
            </blockquote>
          </section>
          <section id="sparqlProjection">
            <h5>Projection</h5>
            <p>The set |PV| of projection variables was calculated in the
              <a href="#sparqlSelectExpressions">processing of SELECT expressions</a>.</p>
            <blockquote>
              <p>|M| := <a href="#defn_absProject" class="absOp">Project</a>(|M|, |PV|)</p>
            </blockquote>
          </section>
          <section id="sparqlDistinct">
            <h5>DISTINCT</h5>
            <p>If the query contains DISTINCT,</p>
            <blockquote>
              <p>|M| := <a href="#defn_absDistinct" class="absOp">Distinct</a>(|M|)</p>
            </blockquote>
          </section>
          <section id="sparqlReduced">
            <h5>REDUCED</h5>
            <p>If the query contains REDUCED,</p>
            <blockquote>
              <p>|M| := <a href="#defn_absReduced" class="absOp">Reduced</a>(|M|)</p>
            </blockquote>
          </section>
          <section id="sparqlOffsetLimit">
            <h5>OFFSET and LIMIT</h5>
            <p>If the query contains "OFFSET |offset|" and "LIMIT |limit|"</p>
            <blockquote>
              <p>|M| := <a href="#defn_absSlice" class="absOp">Slice</a>(|M|, |offset|, |limit|)</p>
            </blockquote>
            <p>If the query contains "OFFSET |offset|" but the query does not contain "LIMIT |limit|"</p>
            <blockquote>
              <p>|M| := <a href="#defn_absSlice" class="absOp">Slice</a>(|M|, |offset|)</p>
            </blockquote>
            <p>If the query contains "LIMIT |limit|" but the query does not contain "OFFSET |offset|"</p>
            <blockquote>
              <p>|M| := <a href="#defn_absSlice" class="absOp">Slice</a>(|M|, 0, |limit|)</p>
            </blockquote>
          </section>
          <section id="sparqlAlgebraOutcome">
            <h5>Final Algebraic Query Expression</h5>
            <blockquote>
              The overall algebraic query expression is |M|.
            </blockquote>
          </section>
        </section>
      </section>
      <section id="BasicGraphPattern">
        <h3>Basic Graph Patterns</h3>
        <p>When matching graph patterns, the possible solutions form a 
          <a href="https://en.wikipedia.org/w/index.php?title=Multiset">multiset</a>, 
          also known as a <i>bag</i>. A multiset is an
          unordered collection of elements in which each element may appear more than once. It is
          described by a set of elements and a function giving the multiplicity of each of these
          elements (i.e., the number of times the element is contained in the multiset).</p>
        <p>Write <var>Î¼</var> for solution mappings.</p>
        <p>Write <var>Î¼<sub>0</sub></var> for the mapping such that <var>dom</var>(<var>Î¼<sub>0</sub></var>) is the empty set.</p>
        <p>Write <var>Î©<sub>0</sub></var> for the multiset consisting of exactly the empty mapping
          <var>Î¼<sub>0</sub></var>, with multiplicity 1. This is the join identity.</p>
        <p>Write <var>Î¼</var>(<var>x</var>) for the solution mapping variable <var>x</var> to RDF term <var>t</var> : { (<var>x</var>, <var>t</var>) }.</p>
        <div class="defn">
          <p><b>Definition: <span id="defn_algCompatibleMapping">Compatible Mappings</span></b></p>
          <p>Two solution mappings Î¼<sub>1</sub> and Î¼<sub>2</sub> are compatible if, for every
            variable v in dom(Î¼<sub>1</sub>) and in dom(Î¼<sub>2</sub>), Î¼<sub>1</sub>(v) =
            Î¼<sub>2</sub>(v).</p>
        </div>
        <p>Here, Î¼<sub>1</sub>(v) = Î¼<sub>2</sub>(v) means that Î¼<sub>1</sub>(v) and Î¼<sub>2</sub>(v)
          are the same RDF term.</p>
        <p>If Î¼<sub>1</sub> and Î¼<sub>2</sub> are compatible then Î¼<sub>1</sub> âˆª Î¼<sub>2</sub> is
          also a mapping. Write merge(Î¼<sub>1</sub>, Î¼<sub>2</sub>) for Î¼<sub>1</sub> âˆª
          Î¼<sub>2</sub></p>
        <div class="defn">
          <p><b>Definition: <span id="defn_Multiplicity">Multiplicity</span></b></p>
          <p>Given a multiset&nbsp;<var>Î©</var> of solution mappings and a solution
            mapping&nbsp;<var>Î¼</var>, we write <var>multiplicity</var>(<var>Î¼</var>&nbsp;|&nbsp;<var>Î©</var>)
            to denote the number of times <var>Î¼</var> appears in <var>Î©</var>.</p>
          <p>Similarly, given a solution sequence&nbsp;<var>Î¨</var> and a solution
            mapping&nbsp;<var>Î¼</var>, we write <var>multiplicity</var>(<var>Î¼</var>&nbsp;|&nbsp;<var>Î¨</var>)
            to denote the number of times <var>Î¼</var> appears in <var>Î¨</var>.</p>
        </div>
        <section id="BGPsparql">
          <h4>SPARQL Basic Graph Pattern Matching</h4>
          <p>A basic graph pattern is matched against the active graph for that part of the query.
            Basic graph patterns can be instantiated by replacing both variables and blank nodes by
            terms, giving two notions of instance. Blank nodes are replaced using an
            <a data-cite="RDF12-SEMANTICS#dfn-instance">RDF instance mapping</a>, &nbsp;Ïƒ, from blank nodes to RDF terms;
            variables are replaced by a solution mapping from query variables to RDF terms.</p>
          <div class="defn">
            <p><b>Definition: <span id="defn_PatternInstanceMapping">Pattern Instance Mapping</span></b></p>
            <p>A <b>Pattern Instance Mapping</b>, P, is the combination of an RDF instance mapping,
              Ïƒ, and solution mapping, Î¼. P(x) = Î¼(Ïƒ(x))</p>
          </div>
          <p>For a BGP 'x', P(x) denotes the result of replacing blank nodes b in x for which Ïƒ is
            defined with Ïƒ(b) and all variables v in x for which Î¼ is defined with Î¼(v).</p>
          <p>Any pattern instance mapping defines a unique solution mapping and a unique RDF instance
            mapping obtained by restricting it to query variables and blank nodes respectively.</p>
          <div class="defn">
            <b>Definition: Basic Graph Pattern Matching</b>
            <p>Let BGP be a basic graph pattern and let G be an RDF graph.</p>
            <p>Î¼ is a <b>solution</b> for BGP from G when there is a pattern instance mapping P such
              that P(BGP) is a subgraph of G and Î¼ is the restriction of P to the query variables in
              BGP.</p>
            <p><a href="#defn_Multiplicity">multiplicity</a>( Î¼ | Î© ) =
              number of distinct RDF instance mappings, Ïƒ, such that P = Î¼(Ïƒ)
              is a pattern instance mapping and P(BGP) is a subgraph of G.</p>
          </div>
          <p>If a basic graph pattern is the empty set, then the solution is Î©<sub>0</sub>.</p>
        </section>
        <section id="BGPsparqlBNodes">
          <h4>Treatment of Blank Nodes</h4>
          <p>This definition allows the solution mapping to bind a variable in a basic graph pattern,
            BGP, to a blank node in G. Since SPARQL treats blank node identifiers in a results format
            document ([[[RDF-SPARQL-XMLRES]]], [[[SPARQL11-RESULTS-JSON]]] and
            [[[SPARQL11-RESULTS-CSV-TSV]]]) as scoped to the document, they cannot be understood as
            identifying nodes in the active graph of the dataset. If DS is the dataset of a query,
            pattern solutions are therefore understood to be not from the active graph of DS itself,
            but from an RDF graph, called the <i>scoping graph,</i> which is graph-equivalent to the
            active graph of DS but shares no blank nodes with DS or with BGP. The same scoping graph is
            used for all solutions to a single query. The scoping graph is purely a theoretical
            construct; in practice, the effect is obtained simply by the document scope conventions for
            blank node identifiers.</p>
          <p>Since RDF blank nodes allow infinitely many redundant solutions for many patterns, there
            can be infinitely many pattern solutions (obtained by replacing blank nodes by different
            blank nodes). It is necessary, therefore, to somehow delimit the solutions for a basic
            graph pattern. SPARQL uses the subgraph match criterion to determine the solutions of a
            basic graph pattern. There is one solution for each distinct pattern instance mapping from
            the basic graph pattern to a subset of the active graph.</p>
          <p>This is optimized for ease of computation rather than redundancy elimination. It allows
            query results to contain redundancies even when the active graph of the dataset is
            <a data-cite="RDF12-SEMANTICS#dfn-lean">lean</a>, and it allows logically equivalent datasets to
            yield different query results.</p>
        </section>
      </section>
      <section id="PropertyPathPatterns">
        <h3>Property Path Patterns</h3>
        <p>This section defines the evaluation of <a href="#defn_PropertyPathPattern">property path
            patterns</a>. A property path pattern consists of a subject endpoint (an RDF term or a variable), a
          <a href="#defn_PropertyPathExpr">property path expression</a>, and an object endpoint.</p>
        <p>The <a href="#sparqlTranslatePathExpressions">translation of property path expressions</a>
          converts every <a href="#defn_PropertyPathExpr">property path expression</a>
          into an <a href="#defn_AlgebraicPropertyPathExpression">algebraic property path expression</a>.
          For example, the property path expression <code>(:p/:q)*</code>
          is a ZeroOrMorePath expression involving a sequence property path,
          and is translated into the algebraic property path expression
          <a href="#defn_ppeZeroOrMorePath" class="ppeOp">ZeroOrMorePath</a>( <a href="#defn_ppeSeq" class="ppeOp">Seq</a>(<a href="#defn_ppeLink" class="ppeOp">Link</a>(:p), <a href="#defn_ppeLink" class="ppeOp">Link</a>(:q)) ).</p>
        <p>Thereafter, the <a href="#sparqlTranslatePathPatterns">translation of property path patterns</a>
          converts some of these algebraic property path expressions
          to other SPARQL graph patterns, such as converting property paths of length one to triple
          patterns, which in turn are combined into basic graph patterns.
          This leaves algebraic property path expressions with the operators
          <a href="#defn_ppeAlt" class="ppeOp">Alt</a>,
          <a href="#defn_ppeZeroOrOnePath" class="ppeOp">ZeroOrOnePath</a>,
          <a href="#defn_ppeZeroOrMorePath" class="ppeOp">ZeroOrMorePath</a>,
          <a href="#defn_ppeOneOrMorePath" class="ppeOp">OneOrMorePath</a>,
          and <a href="#defn_ppeNPS" class="ppeOp">NPS</a>,
          as well as algebraic property path
          expressions contained within these operators.</p>
        <p>The property path patterns with these remaining algebraic property path expressions
          are present in the <a href="#algebraicSyntax">algebraic syntax</a> in the form
          <a href="#defn_absPath" class="absOp">Path</a>(|X|, |ppe|, |X|) for endpoints |X| and |Y|.</p>
        <div class="defn">
          <div id="pp-eval-notation">
            <b>Notation</b>
          </div>
          <p>To denote the evaluation of the property path pattern, for every
          <a href="#defn_AlgebraicQueryExpression">algebraic query expression</a>
          of the form
            <a href="#defn_absPath" class="absOp">Path</a>(|X|, |ppe|, |Y|), we write the following:</p>
          <pre class="nohighlight">ppeval(<var>X</var>, <var>ppe</var>, <var>Y</var>)</pre>
          <p>This produces a multiset of solution
            mappings, each solution mapping having a binding for variables used (each of |X| and |Y| can
            be a variable). Some operators only produce a set of solution mappings.</p>
          <table style="border-collapse: collapse; border-color: #000000; border-spacing: 10px ; border-width: 1px">
            <tbody>
              <tr>
                <th>Write</th>
                <th>When <code>|x|</code> is</th>
              </tr>
              <tr>
                <td><code>|x|:term</code></td>
                <td>an RDF term</td>
              </tr>
              <tr>
                <td><code>|x|:var</code></td>
                <td>a variable</td>
              </tr>
            </tbody>
          </table>
        </div>
        <p>All evaluation is carried out by matching the <a href="#defn_ActiveGraph">active graph</a>
          at that point in the overall query evaluation. We omit explicitly including the active graph
          in each definition for clarity.</p>
        <div class="defn">
          <p><b>Definition: <span id="defn_evalPP_predicate">Evaluation of Predicate Property Path</span></b></p>
          <p>Let |iri| be an IRI.</p>
            <pre class="nohighlight">
ppeval(<var>X</var>, <a href="#defn_ppeLink" class="ppeOp">Link</a>(<var>iri</var>), <var>Y</var>) = <a href="#BasicGraphPattern">evaluation of basic graph pattern</a> {<var>X</var> <var>iri</var> <var>Y</var>}
            </pre>
        </div>
        <p>If both |X| and |Y| are variables, this is the same as:</p>
        <pre class="nohighlight">
ppeval(<var>X</var>:var, <a href="#defn_ppeLink" class="ppeOp">Link</a>(<var>iri</var>), <var>Y</var>:var) =
    { (<var>X</var>, <var>xn</var>:term) (<var>Y</var>, <var>yn</var>:term) | triple (<var>xn</var>, <var>iri</var>, <var>yn</var>) is in the active graph }</pre>
        <p>If |X| is a variable and |Y| an RDF term:</p>
        <pre class="nohighlight">
ppeval(<var>X</var>:var, <a href="#defn_ppeLink" class="ppeOp">Link</a>(<var>iri</var>), <var>Y</var>:term) =
    { (<var>X</var>, <var>xn</var>:term) | triple (<var>xn</var>, <var>iri</var>, <var>Y</var>) is in the active graph }</pre>
        <p>If |X| is an RDF term and |Y| is a variable:</p>
        <pre class="nohighlight">
ppeval(<var>X</var>:term, <a href="#defn_ppeLink" class="ppeOp">Link</a>(<var>iri</var>), <var>Y</var>:var) =
    { (<var>Y</var>, <var>yn</var>:term) | triple (<var>X</var>, <var>iri</var>, <var>yn</var>) is in the active graph }</pre>
        <p>If both |X| and |Y| are RDF terms:</p>
        <pre class="nohighlight">
ppeval(<var>X</var>:term, <a href="#defn_ppeLink" class="ppeOp">Link</a>(<var>iri</var>), <var>Y</var>:term)
    = { Î¼<sub>0</sub> } if triple (<var>X</var>, <var>iri</var>, <var>Y</var>) is in the active graph
    = { { } } = Î©<sub>0</sub> 

ppeval(<var>X</var>:term, <a href="#defn_ppeLink" class="ppeOp">Link</a>(<var>iri</var>), <var>Y</var>:term) =
     { } if triple (<var>X</var>, <var>iri</var>, <var>Y</var>) is not in the active graph
        </pre>
        <p>Informally, evaluating a Predicate Property Path is the same as executing a subquery
          <code>SELECT&nbsp;*&nbsp;{&nbsp;|X|&nbsp;|iri|&nbsp;|Y|&nbsp;}</code> at that point in the query evaluation.</p>
        <div class="defn">
          <p><b>Definition: <span id="defn_evalPP_inverse">Evaluation of Inverse Property Path</span></b></p>
          <p>Let |ppe| be an <a href="#defn_AlgebraicPropertyPathExpression">algebraic property path expression</a>, then:</p>
          <pre class="nohighlight">ppeval(<var>X</var>, <a href="#defn_ppeInv" class="ppeOp">Inv</a>(<var>ppe</var>), <var>Y</var>) = ppeval(<var>Y</var>, <var>ppe</var>, <var>X</var>)</pre>
        </div>
        <div class="defn">
          <p><b>Definition: <span id="defn_evalPP_sequence">Evaluation of Sequence Property Path</span></b></p>
          <p>Let <var>ppe<sub>1</sub></var> and <var>ppe<sub>2</sub></var> be <a href="#defn_AlgebraicPropertyPathExpression">algebraic property path expressions</a>. Let |V| be a fresh variable.</p>
          <pre class="nohighlight"><var>A</var> = <a href="#defn_algJoin" class="algFct">Join</a>( ppeval(<var>X</var>, <var>ppe<sub>1</sub></var>, <var>V</var>), ppeval(<var>V</var>, <var>ppe<sub>2</sub></var>, <var>Y</var>) )</pre>
          <pre class="nohighlight">ppeval(<var>X</var>, <a href="#defn_ppeSeq" class="ppeOp">Seq</a>(<var>ppe<sub>1</sub></var>, <var>ppe<sub>2</sub></var>), <var>Y</var>) = <a href="#defn_algProject" class="algFct">Project</a>(<var>A</var>, <var>PV</var>)</pre>
          <p>where |PV| = { |v| âˆˆ {|X|,|Y|} | |v| is a variable}.</p>
<div class="issue" data-number="266"><a href="#defn_algJoin" class="algFct">Join</a> produces a multiset of solution mappings but <a href="#defn_algProject" class="algFct">Project</a> expects a sequence as its first argument. Moreover, <a href="#defn_algProject" class="algFct">Project</a> produces a sequence but ppeval(..) should be a multiset.</div>
        </div>
        <p>Informally, this is the same as:</p>
        <pre class="nohighlight">SELECT * { <var>X</var> <var>P<sub>1</sub></var> _:a . _:a <var>P<sub>2</sub></var> <var>Y</var> }</pre>
        <p>where <var>P<sub>1</sub></var> is a
          <a href="#defn_AlgebraicPropertyPathExpression">property path expression</a>
          that can be <a href="#sparqlTranslatePathExpressions">translated</a> into the
          <a href="#defn_AlgebraicPropertyPathExpression">algebraic property path expression</a> <var>ppe<sub>1</sub></var>,
          and <var>P<sub>2</sub></var> can be translated into <var>ppe<sub>2</sub></var>.
          This observation is based on the fact that a blank node <code>_:a</code> acts like a variable (under simple
          entailment) except it does not appear in the results from <code>SELECT *</code>.</p>
        <div class="defn">
          <p><b>Definition: <span id="defn_evalPP_alternative">Evaluation of Alternative Property Path</span></b></p>
          <p>Let <var>ppe<sub>1</sub></var> and <var>ppe<sub>2</sub></var> be <a href="#defn_AlgebraicPropertyPathExpression">algebraic property path expressions</a>.
          <pre class="nohighlight">
ppeval(<var>X</var>, <a href="#defn_ppeAlt" class="ppeOp">Alt</a>(<var>ppe<sub>1</sub></var>, <var>ppe<sub>2</sub></var>), <var>Y</var>) =
    <a href="#defn_algUnion" class="algFct">Union</a>( ppeval(<var>X</var>, <var>ppe<sub>1</sub></var>, <var>Y</var>), ppeval(<var>X</var>, <var>ppe<sub>2</sub></var>, <var>Y</var>) )
          </pre>
        </div>
        <p>Informally, this is the same as:</p>
        <pre class="nohighlight">SELECT * { { <var>X</var> <var>P<sub>1</sub></var> <var>Y</var> } UNION { <var>X</var> <var>P<sub>2</sub></var> <var>Y</var> } }</pre>
        <p>where <var>P<sub>1</sub></var> is a
          <a href="#defn_AlgebraicPropertyPathExpression">property path expression</a>
          that can be <a href="#sparqlTranslatePathExpressions">translated</a> into the
          <a href="#defn_AlgebraicPropertyPathExpression">algebraic property path expression</a> <var>ppe<sub>1</sub></var>,
          and <var>P<sub>2</sub></var> can be translated into <var>ppe<sub>2</sub></var>.</p>
        <div class="defn">
          <p><b>Definition: <span id="defn_nodeSet">Node set of a graph</span></b></p>
          <p>The node set of a graph |G|, <a href="#defn_nodeSet">nodes</a>(|G|), is:</p>
          <p><a href="#defn_nodeSet">nodes</a>(|G|) = { |n| | |n| is an RDF term that is used as a subject or object of an asserted triple of
            |G|}</p>
        </div>
        <div class="defn">
          <p><b>Definition: <span id="defn_evalPP_ZeroOrOnePath">Evaluation of ZeroOrOnePath</span></b></p>
          <p>Let |ppe| be an <a href="#defn_AlgebraicPropertyPathExpression">algebraic property path expression</a>.
            Let <var>G</var> be the <a href="#defn_ActiveGraph">active graph</a>.</p>
          <pre class="nohighlight">
ppeval(<var>X</var>:term, <a href="#defn_ppeZeroOrOnePath" class="ppeOp">ZeroOrOnePath</a>(<var>ppe</var>), <var>Y</var>:var) = 
    { (<var>Y</var>, <var>yn</var>) | <var>yn</var> = <var>X</var> or {(<var>Y</var>, <var>yn</var>)} in ppeval(<var>X</var>, <var>ppe</var>, <var>Y</var>) }
</pre>
          <pre class="nohighlight">
ppeval(<var>X</var>:var, <a href="#defn_ppeZeroOrOnePath" class="ppeOp">ZeroOrOnePath</a>(<var>ppe</var>), <var>Y</var>:term) =
    { (<var>X</var>, <var>xn</var>) | <var>xn</var> = <var>Y</var> or {(<var>X</var>, <var>xn</var>)} in ppeval(<var>X</var>, <var>ppe</var>, <var>Y</var>) }
          </pre>
          <pre class="nohighlight">
ppeval(<var>X</var>:term, <a href="#defn_ppeZeroOrOnePath" class="ppeOp">ZeroOrOnePath</a>(<var>ppe</var>), <var>Y</var>:term) = 
    { {} } if <var>X</var> = <var>Y</var> or ppeval(<var>X</var>,<var>ppe</var>,<var>X</var>) is not empty
    { } otherwise</pre>
          <pre class="nohighlight">
ppeval(<var>X</var>:var, <a href="#defn_ppeZeroOrOnePath" class="ppeOp">ZeroOrOnePath</a>(<var>ppe</var>), <var>Y</var>:var) = 
    { (<var>X</var>, <var>xn</var>) (<var>Y</var>, <var>yn</var>) | 
        either (<var>yn</var> in <a href="#defn_nodeSet">nodes</a>(<var>G</var>) and <var>xn</var> = <var>yn</var>)
        or {(<var>X</var>, <var>xn</var>), (<var>Y</var>, <var>yn</var>)} in ppeval(<var>X</var>, <var>ppe</var>, <var>Y</var>) }</pre>
        </div>
        <p>We define an auxiliary function, <a href="#defn_evalALP">ALP</a>, used in the definitions of <a href="#defn_evalZeroOrMorePath">ZeroOrMorePath</a> and
          <a href="#defn_evalOneOrMorePath">OneOrMorePath</a>. Note that the algorithm given here serves to specify the feature. An
          implementor is free to implement evaluation by any method that produces the same results
          for the query overall. The <a href="#defn_ppeZeroOrMorePath" class="ppeOp">ZeroOrMorePath</a> and <a href="#defn_ppeOneOrMorePath" class="ppeOp">OneOrMorePath</a> forms return matches based on
          distinct nodes connected by the path.</p>
        <p>The matching algorithm is based on following all paths, and detecting when a graph node
          (subject or object), has been already visited on the path.</p>
        <p>Informally, this algorithm attempts to extend the multiset of results by one application
          of the given <a href="#defn_AlgebraicPropertyPathExpression">algebraic property path expression</a> |ppe| at each step, noting which nodes it has visited for this particular path. If
          a node has been visited for the path under consideration, it is not a candidate for another
          step.</p>
        <div class="defn">
          <p><b>Definition: <span id="defn_evalALP">Function ALP</span><span id="defn_evalALP_1"><!-- obsolete id --></span></b></p>
          <pre class="nohighlight">
Let <var>ppe</var> be an <a href="#defn_AlgebraicPropertyPathExpression">algebraic property path expression</a>.
Let <span id="defn_reachableTerms"><var>reachableTerms</var></span>(<var>x</var>:term, <var>ppe</var>) be the set of RDF terms
 reached by repeated matches of <var>ppe</var>,
 when starting at RDF term <var>x</var>.

  <a href="#defn_evalALP">ALP</a>(<var>x</var>:term, <var>ppe</var>) =
      Let <var>V</var> = empty set of terms
      <a href="#defn_evalALP_recurse">ALP_recurse</a>(<var>x</var>:term, <var>ppe</var>, <var>V</var>)
      return is <var>V</var>

  <a id="defn_evalALP_recurse" href="#defn_evalALP_recurse">ALP_recurse</a>(<var>x</var>:term, <var>ppe</var>, <var>V</var>:set of RDF terms) =
      if ( <var>x</var> in <var>V</var> ) return 
      add <var>x</var> to <var>V</var>
      <var>X</var> = <a href="#defn_reachableTerms"><var>reachableTerms</var></a>(<var>x</var>, <var>ppe</var>)
      For <var>n</var>:term in <var>X</var>
          <a href="#defn_evalALP_recurse">ALP_recurse</a>(<var>n</var>, <var>ppe</var>, <var>V</var>)
          End
</pre>
        </div>
        <div class="defn">
          <p><b>Definition: <span id="defn_evalZeroOrMorePath">Evaluation of ZeroOrMorePath</span></b></p>
          <p>Let <var>ppe</var> be an <a href="#defn_AlgebraicPropertyPathExpression">algebraic property path expression</a>.
            Let <var>G</var> be the <a href="#defn_ActiveGraph">active graph</a>.</p>
          <pre class="nohighlight">
ppeval(<var>X</var>:term, <a href="#defn_ppeZeroOrMorePath" class="ppeOp">ZeroOrMorePath</a>(<var>ppe</var>), <var>vy</var>:var) =
    { { (<var>vy</var>, <var>n</var>) } | <var>n</var> in <a href="#defn_evalALP">ALP</a>(<var>X</var>, <var>ppe</var>) }

ppeval(<var>vx</var>:var, <a href="#defn_ppeZeroOrMorePath" class="ppeOp">ZeroOrMorePath</a>(<var>ppe</var>), <var>vy</var>:var) =
    { { (<var>vx</var>, <var>t</var>), (<var>vy</var>, <var>n</var>) } |  
      <var>t</var> in <a href="#defn_nodeSet">nodes</a>(<var>G</var>), (<var>vy</var>, <var>n</var>) in ppeval(<var>t</var>, <a href="#defn_ppeZeroOrMorePath" class="ppeOp">ZeroOrMorePath</a>(<var>ppe</var>), <var>vy</var>) }

ppeval(<var>vx</var>:var, <a href="#defn_ppeZeroOrMorePath" class="ppeOp">ZeroOrMorePath</a>(<var>ppe</var>), <var>y</var>:term) = 
    ppeval(<var>y</var>:term, <a href="#defn_ppeZeroOrMorePath" class="ppeOp">ZeroOrMorePath</a>(<a href="#defn_ppeInv" class="ppeOp">Inv</a>(<var>ppe</var>)), <var>vx</var>:var)

ppeval(<var>x</var>:term, <a href="#defn_ppeZeroOrMorePath" class="ppeOp">ZeroOrMorePath</a>(<var>ppe</var>), <var>y</var>:term) = 
    { { } } if { (<var>vy</var>:var,<var>y</var>) } in ppeval(<var>x</var>, <a href="#defn_ppeZeroOrMorePath" class="ppeOp">ZeroOrMorePath</a>(<var>ppe</var>), <var>vy</var>)
    { } otherwise
          </pre>
        </div>
        <div class="defn">
          <p><b>Definition: <span id="defn_evalOneOrMorePath">Evaluation of OneOrMorePath</span></b></p>
          <p>Let <var>ppe</var> be an <a href="#defn_AlgebraicPropertyPathExpression">algebraic property path expression</a>.
            Let <var>G</var> be the <a href="#defn_ActiveGraph">active graph</a>.</p>
          <pre class="nohighlight">
# For <a href="#defn_ppeOneOrMorePath" class="ppeOp">OneOrMorePath</a>, we take one step of the path then start
# recording nodes for results.

ppeval(<var>x</var>:term, <a href="#defn_ppeOneOrMorePath" class="ppeOp">OneOrMorePath</a>(<var>ppe</var>), <var>vy</var>:var) =
    Let <var>X</var> = <a href="#defn_reachableTerms"><var>reachableTerms</var></a>(<var>x</var>, <var>ppe</var>)
    Let <var>V</var> = the empty multiset
    For <var>n</var> in <var>X</var>
        <a href="#defn_evalALP_recurse">ALP_recurse</a>(<var>n</var>, <var>ppe</var>, <var>V</var>)
    End
    result is <var>V</var>

ppeval(<var>vx</var>:var, <a href="#defn_ppeOneOrMorePath" class="ppeOp">OneOrMorePath</a>(<var>ppe</var>), <var>vy</var>:var) =
     { { (<var>vx</var>, <var>t</var>), (<var>vy</var>, <var>n</var>) } |
         <var>t</var> in <a href="#defn_nodeSet">nodes</a>(<var>G</var>), (<var>vy</var>, <var>n</var>) in ppeval(<var>t</var>, <a href="#defn_ppeOneOrMorePath" class="ppeOp">OneOrMorePath</a>(<var>ppe</var>), <var>vy</var>) }

ppeval(<var>vx</var>:var, <a href="#defn_ppeOneOrMorePath" class="ppeOp">OneOrMorePath</a>(<var>ppe</var>), <var>y</var>:term) =
    ppeval(<var>y</var>:term, <a href="#defn_ppeOneOrMorePath" class="ppeOp">OneOrMorePath</a>(<a href="#defn_ppeInv" class="ppeOp">Inv</a>(<var>ppe</var>)), <var>vx</var>)

ppeval(<var>x</var>:term, <a href="#defn_ppeOneOrMorePath" class="ppeOp">OneOrMorePath</a>(<var>ppe</var>), <var>y</var>:term) =
    { { } } if { (<var>vy</var>:var, <var>y</var>) } in ppeval(<var>x</var>, <a href="#defn_ppeOneOrMorePath" class="ppeOp">OneOrMorePath</a>(<var>ppe</var>), <var>vy</var>)
    { } otherwise
</pre>
<div class="issue" data-number="267"><var>V</var> is not a multiset of solution mappings but a set of RDF terms.</div>
        </div>
        <div class="defn">
          <p><b>Definition: <span id="eval_negatedPropertySet">Evaluation of NegatedPropertySet</span></b></p>
          <pre class="nohighlight">
Write <var>Î¼'</var> as the extension of a solution mapping:
<var>Î¼'</var>(<var>Î¼</var>, <var>x</var>) = <var>Î¼</var>(<var>x</var>)   if <var>x</var> is a variable
<var>Î¼'</var>(<var>Î¼</var>, <var>t</var>) = <var>t</var>      if <var>t</var> is an RDF term
          </pre>
          <pre class="nohighlight">
Let <var>x</var> and <var>y</var> be variables or RDF terms, <var>S</var> a set of IRIs,
and <var>G</var> the <a href="#defn_ActiveGraph">active graph</a>.

   ppeval(<var>x</var>, <a href="#defn_ppeNPS" class="ppeOp">NPS</a>(<var>S</var>), <var>y</var>) =
       { <var>Î¼</var> | âˆƒ triple(<var>Î¼'</var>(<var>Î¼</var>, <var>x</var>), <var>p</var>, <var>Î¼'</var>(<var>Î¼</var>, <var>y</var>)) in <var>G</var>, such that the IRI of <var>p</var> âˆ‰ <var>S</var> }
          </pre>
        </div>
      </section>
      <section id="sparqlAlgebra">
        <h3>SPARQL Algebra</h3>
        <p>For each remaining symbol in a SPARQL abstract query, we define an operator for
          evaluation. The SPARQL algebra operators of the same name are used to evaluate SPARQL
          abstract query nodes as described in the section "<a href="#sparqlAlgebraEval">Evaluation
            Semantics</a>". Evaluation of basic graph patterns and property path patterns has been
          described above.</p>
        <div class="defn">
          <p><b>Definition: <span id="defn_algFilter">Filter</span></b></p>
          <p>Let <var>Î©</var> be a multiset of solution mappings,
            <var>expr</var> be an <a href="#expressions">expression</a>,
            |D| be a <a href="#sparqlDataset">dataset</a>,
            and |G| be the <a href="#defn_ActiveGraph">active graph</a>.
            We define:</p>
          <p><a href="#defn_algFilter" class="algFct">Filter</a>(<var>expr</var>, <var>Î©</var>, |D|, |G|) =
            { <var>Î¼</var> in <var>Î©</var>  |
            |expr|(<var>Î¼</var>, |D|, |G|) is an RDF term |t|
            such that <a href="#func-ebv">EBV</a>(|t|) is `"true"^^xsd:boolean` }</p>
          <p><a href="#defn_Multiplicity">multiplicity</a>( <var>Î¼</var> | <a href="#defn_algFilter" class="algFct">Filter</a>(<var>expr</var>, <var>Î©</var>, |D|, |G|) )
            = <a href="#defn_Multiplicity">multiplicity</a>( <var>Î¼</var> | <var>Î©</var> )</p>
          <p>
            where, for every solution mapping <var>Î¼</var>,
            |expr|(<var>Î¼</var>, |D|, |G|) is the result of
            <a href="#expression-evaluation">evaluating</a> expression |expr|
            with respect to <var>Î¼</var>, in the context of dataset |D| with active graph |G|.
          </p>
        </div>
        <div class="defn">
          <p><b>Definition: <span id="defn_algJoin">Join</span></b></p>
          <p>Let <var>Î©<sub>1</sub></var> and <var>Î©<sub>2</sub></var> be multisets of solution mappings. We define:</p>
          <p><a href="#defn_algJoin" class="algFct">Join</a>(<var>Î©<sub>1</sub></var>, <var>Î©<sub>2</sub></var>) = { merge(<var>Î¼<sub>1</sub></var>, <var>Î¼<sub>2</sub></var>) |
            <var>Î¼<sub>1</sub></var> in <var>Î©<sub>1</sub></var> and <var>Î¼<sub>2</sub></var> in <var>Î©<sub>2</sub></var>, and <var>Î¼<sub>1</sub></var> and
            <var>Î¼<sub>2</sub></var> are <a href="#defn_algCompatibleMapping">compatible</a> }</p>
          <p><a href="#defn_Multiplicity">multiplicity</a>( <var>Î¼</var> | <a href="#defn_algJoin" class="algFct">Join</a>(<var>Î©<sub>1</sub></var>, <var>Î©<sub>2</sub></var>) ) =<br>
            &nbsp;&nbsp;&nbsp; for each merge(<var>Î¼<sub>1</sub></var>, <var>Î¼<sub>2</sub></var>), <var>Î¼<sub>1</sub></var> in
            <var>Î©<sub>1</sub></var> and <var>Î¼<sub>2</sub></var> in <var>Î©<sub>2</sub></var> such that <var>Î¼</var> = merge(<var>Î¼<sub>1</sub></var>,
            <var>Î¼<sub>2</sub></var>),<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sum over (<var>Î¼<sub>1</sub></var>, <var>Î¼<sub>2</sub></var>),
            <a href="#defn_Multiplicity">multiplicity</a>( <var>Î¼<sub>1</sub></var> | <var>Î©<sub>1</sub></var> ) * <a href="#defn_Multiplicity">multiplicity</a>( <var>Î¼<sub>2</sub></var> | <var>Î©<sub>2</sub></var> )</p>
        </div>
        <p>It is possible that a solution mapping <var>Î¼</var> in a Join can arise in different solution
          mappings, <var>Î¼<sub>1</sub></var> and <var>Î¼<sub>2</sub></var> in the multisets being joined. The multiplicity
          of <var>Î¼</var> is the sum of the multiplicities from all possibilities.</p>
        <div class="defn">
          <p><b>Definition: <span id="defn_algDiff">Diff</span></b></p>
          <p>Let <var>Î©<sub>1</sub></var> and <var>Î©<sub>2</sub></var> be multisets of solution mappings,
            <var>expr</var> be an <a href="#expressions">expression</a>,
            |D| be a <a href="#sparqlDataset">dataset</a>,
            and |G| be the <a href="#defn_ActiveGraph">active graph</a>.
            We define:</p>
          <p><a href="#defn_algDiff" class="algFct">Diff</a>(<var>Î©<sub>1</sub></var>, <var>Î©<sub>2</sub></var>, <var>expr</var>, |D|, |G|)
            = { <var>Î¼</var> in <var>Î©<sub>1</sub></var> | for every <var>Î¼'</var> in <var>Î©<sub>2</sub></var>,
            any of the following conditions holds:</p>
          <ul>
            <li><var>Î¼</var> and <var>Î¼'</var> are not <a href="#defn_algCompatibleMapping">compatible</a>,</li>
            <li><var>Î¼</var> and <var>Î¼'</var> are <a href="#defn_algCompatibleMapping">compatible</a>
              and |expr|(merge(<var>Î¼</var>, <var>Î¼'</var>), |D|, |G|) is an [=error=], or</li>
            <li><var>Î¼</var> and <var>Î¼'</var> are <a href="#defn_algCompatibleMapping">compatible</a>
              and |expr|(merge(<var>Î¼</var>, <var>Î¼'</var>), |D|, |G|) is an RDF term |t|
              for which <a href="#func-ebv">EBV</a>(|t|) is not `"true"^^xsd:boolean`.</li>
          </ul>
          <p>}</p>
          <p><a href="#defn_Multiplicity">multiplicity</a>( <var>Î¼</var> | <a href="#defn_algDiff" class="algFct">Diff</a>(<var>Î©<sub>1</sub></var>, <var>Î©<sub>2</sub></var>, <var>expr</var>, |D|, |G|) ) =
            <a href="#defn_Multiplicity">multiplicity</a>( <var>Î¼</var> | <var>Î©<sub>1</sub></var> )</p>
          <p>
            where, for every solution mapping <var>Î¼</var>,
            |expr|(<var>Î¼</var>, |D|, |G|) is the result of
            <a href="#expression-evaluation">evaluating</a> expression |expr|
            with respect to <var>Î¼</var>, in the context of dataset |D| with active graph |G|.
          </p>
        </div>
        <p><a href="#defn_algDiff" class="algFct">Diff</a> is used internally for the definition of <a href="#defn_algLeftJoin" class="algFct">LeftJoin</a>.</p>
        <div class="defn">
          <p><b>Definition: <span id="defn_algLeftJoin">LeftJoin</span></b></p>
          <p>Let <var>Î©<sub>1</sub></var> and <var>Î©<sub>2</sub></var> be multisets of solution mappings,
            <var>expr</var> be an <a href="#expressions">expression</a>,
            |D| be a <a href="#sparqlDataset">dataset</a>,
            and |G| be the <a href="#defn_ActiveGraph">active graph</a>.
            We define:</p>
          <p><a href="#defn_algLeftJoin" class="algFct">LeftJoin</a>(<var>Î©<sub>1</sub></var>, <var>Î©<sub>2</sub></var>, <var>expr</var>, |D|, |G|) = <a href="#defn_algFilter" class="algFct">Filter</a>(<var>expr</var>, <a href="#defn_algJoin" class="algFct">Join</a>(<var>Î©<sub>1</sub></var>,
            <var>Î©<sub>2</sub></var>), |D|, |G|) âˆª <a href="#defn_algDiff" class="algFct">Diff</a>(<var>Î©<sub>1</sub></var>, <var>Î©<sub>2</sub></var>, <var>expr</var>, |D|, |G|)</p>
          <p><a href="#defn_Multiplicity">multiplicity</a>( <var>Î¼</var> | <a href="#defn_algLeftJoin" class="algFct">LeftJoin</a>(<var>Î©<sub>1</sub></var>, <var>Î©<sub>2</sub></var>, <var>expr</var>, |D|, |G|) ) =
            <a href="#defn_Multiplicity">multiplicity</a>( <var>Î¼</var> | <a href="#defn_algFilter" class="algFct">Filter</a>(<var>expr</var>, <a href="#defn_algJoin" class="algFct">Join</a>(<var>Î©<sub>1</sub></var>, <var>Î©<sub>2</sub></var>), |D|, |G|) ) +
            <a href="#defn_Multiplicity">multiplicity</a>( <var>Î¼</var> | <a href="#defn_algDiff" class="algFct">Diff</a>(<var>Î©<sub>1</sub></var>, <var>Î©<sub>2</sub></var>,
            <var>expr</var>, |D|, |G|) )</p>
        </div>

        <div class="defn">
          <p><b>Definition: <span id="defn_algUnion">Union</span></b></p>
          <p>Let <var>Î©<sub>1</sub></var> and <var>Î©<sub>2</sub></var> be multisets of solution mappings. We define:</p>
          <p><a href="#defn_algUnion" class="algFct">Union</a>(<var>Î©<sub>1</sub></var>, <var>Î©<sub>2</sub></var>) = { <var>Î¼</var> | <var>Î¼</var> in <var>Î©<sub>1</sub></var> or <var>Î¼</var> in <var>Î©<sub>2</sub></var>
            }</p>
          <p><a href="#defn_Multiplicity">multiplicity</a>( <var>Î¼</var> | <a href="#defn_algUnion" class="algFct">Union</a>(<var>Î©<sub>1</sub></var>, <var>Î©<sub>2</sub></var>) ) =
            <a href="#defn_Multiplicity">multiplicity</a>( <var>Î¼</var> | <var>Î©<sub>1</sub></var> ) +
            <a href="#defn_Multiplicity">multiplicity</a>( <var>Î¼</var> | <var>Î©<sub>2</sub></var> )</p>
        </div>
        <div class="defn">
          <p><b>Definition: <span id="defn_algMinus">Minus</span></b></p>
          <p>Let <var>Î©<sub>1</sub></var> and <var>Î©<sub>2</sub></var> be multisets of solution mappings. We define:</p>
          <p><a href="#defn_algMinus" class="algFct">Minus</a>(<var>Î©<sub>1</sub></var>, <var>Î©<sub>2</sub></var>) = { <var>Î¼</var> | <var>Î¼</var> in <var>Î©<sub>1</sub></var> . âˆ€ <var>Î¼'</var> in
            <var>Î©<sub>2</sub></var>, either <var>Î¼</var> and <var>Î¼'</var> are not <a href="#defn_algCompatibleMapping">compatible</a> or dom(<var>Î¼</var>) and dom(<var>Î¼'</var>) are disjoint
            }</p>
          <p><a href="#defn_Multiplicity">multiplicity</a>( <var>Î¼</var> | <a href="#defn_algMinus" class="algFct">Minus</a>(<var>Î©<sub>1</sub></var>, <var>Î©<sub>2</sub></var>) ) =
            <a href="#defn_Multiplicity">multiplicity</a>( <var>Î¼</var> | <var>Î©<sub>1</sub></var> )</p>
        </div>
        <p>The additional restriction on dom(<var>Î¼</var>) and dom(<var>Î¼'</var>) is added because otherwise if there is
          a solution mapping in <var>Î©<sub>2</sub></var> that has no variables in common with the solution
          mappings of <var>Î©<sub>1</sub></var>, then <a href="#defn_algMinus" class="algFct">Minus</a>(<var>Î©<sub>1</sub></var>, <var>Î©<sub>2</sub></var>) would be empty,
          regardless of the rest of <var>Î©<sub>2</sub></var>. The empty solution mapping is compatible with
          every other solution mapping so <code>P MINUS {}</code> would otherwise be empty for any
          pattern <code>P</code>.</p>
        <div class="defn">
          <p><b>Definition: <span id="defn_algExtend">Extend</span><span id="defn_extend"><!-- obsolete id --></span></b></p>
          <p>Let <var>Î¼</var> be a solution mapping, <var>Î©</var> a multiset of solution mappings,
            <var>var</var> be a variable,
            <var>expr</var> be an <a href="#expressions">expression</a>,
            |D| be a <a href="#sparqlDataset">dataset</a>,
            and |G| be the <a href="#defn_ActiveGraph">active graph</a>.
            We define:</p>
          <p><a href="#defn_algExtend" class="algFct">Extend</a>(<var>Î©</var>, <var>var</var>, <var>expr</var>, |D|, |G|) = { |Extend|(<var>Î¼</var>, <var>var</var>, <var>expr</var>, |D|, |G|) | <var>Î¼</var> in <var>Î©</var> },</p>
          <p>where, for every solution mapping <var>Î¼</var>,</p>
          <p>|Extend|(<var>Î¼</var>, <var>var</var>, <var>expr</var>, |D|, |G|) = <var>Î¼</var> âˆª { (<var>var</var>, |expr|(<var>Î¼</var>, |D|, |G|)) }
            if <var>var</var> not in dom(<var>Î¼</var>) and
            |expr|(<var>Î¼</var>, |D|, |G|) is an RDF term,</p>
          <p>|Extend|(<var>Î¼</var>, <var>var</var>, <var>expr</var>, |D|, |G|) = <var>Î¼</var>
            if <var>var</var> not in dom(<var>Î¼</var>) and
            |expr|(<var>Î¼</var>, |D|, |G|) is an [=error=],</p>
          <p>|Extend|(<var>Î¼</var>, <var>var</var>, <var>expr</var>, |D|, |G|) is undefined
            if <var>var</var> in dom(<var>Î¼</var>), and</p>
          <p>|expr|(<var>Î¼</var>, |D|, |G|) is the result of
            <a href="#expression-evaluation">evaluating</a> expression |expr|
            with respect to <var>Î¼</var>, in the context of dataset |D| with active graph |G|.
          </p>
<div class="issue" data-number="290">
  We need to define <a href="#defn_Multiplicity">multiplicity</a>( <var>Î¼</var> | <a href="#defn_algExtend" class="algFct">Extend</a>(<var>Î©</var>, <var>var</var>, <var>expr</var>, |D|, |G|) )</div>
        </div>
        <p>Write [ <var>x</var> | <var>C</var> ] for a sequence of elements where <var>C</var> is a condition on <var>x</var>.</p>
        <div class="defn">
          <p><b>Definition: <span id="defn_algToList">ToList</span></b></p>
          <p>Let <var>Î©</var> be a multiset of solution mappings. We define:</p>
          <p><a href="#defn_algToList" class="algFct">ToList</a>(<var>Î©</var>) = a sequence of mappings <var>Î¼</var> in <var>Î©</var> in any order, with
            <a href="#defn_Multiplicity">multiplicity</a>( <var>Î¼</var> | <var>Î©</var> ) occurrences of
            <var>Î¼</var></p>
          <p><a href="#defn_Multiplicity">multiplicity</a>( <var>Î¼</var> | <a href="#defn_algToList" class="algFct">ToList</a>(<var>Î©</var>) ) =
            <a href="#defn_Multiplicity">multiplicity</a>( <var>Î¼</var> | <var>Î©</var> )</p>
        </div>
        <div class="defn">
          <p><b>Definition: <span id="defn_algOrderBy">OrderBy</span><span id="defn_algOrdered"><!-- obsolete id --></span></b></p>
          <p>Let <var>Î¨</var> be a sequence of solution mappings. We define:</p>
          <p><a href="#defn_algOrderBy" class="algFct">OrderBy</a>(<var>Î¨</var>, condition) = [ <var>Î¼</var> | <var>Î¼</var> in <var>Î¨</var> and the sequence satisfies the ordering condition]</p>
          <p><a href="#defn_Multiplicity">multiplicity</a>( <var>Î¼</var> | <a href="#defn_algOrderBy" class="algFct">OrderBy</a>(<var>Î¨</var>, condition) ) =
            <a href="#defn_Multiplicity">multiplicity</a>( <var>Î¼</var> | <var>Î¨</var> )</p>
        </div>
        <div class="defn">
          <p><b>Definition: <span id="defn_algProject">Project</span><span id="defn_algProjection"><!-- obsolete id --></span></b></p>
          <p>Let <var>Î¨</var> be a sequence of solution mappings and <var>PV</var> a set of variables.</p>
          <p>For mapping <var>Î¼</var>, write Proj(<var>Î¼</var>, <var>PV</var>) to be the restriction of <var>Î¼</var> to variables in <var>PV</var>.</p>
          <p><a href="#defn_algProject" class="algFct">Project</a>(<var>Î¨</var>, <var>PV</var>) = [ Proj(<var>Î¼</var>, <var>PV</var>) | <var>Î¼</var> in <var>Î¨</var> ]</p>
          <p><a href="#defn_Multiplicity">multiplicity</a>( <var>Î¼</var> | <a href="#defn_algProject" class="algFct">Project</a>(<var>Î¨</var>, <var>PV</var>) ) =
            sum( <a href="#defn_Multiplicity">multiplicity</a>( <var>Î¼'</var> | <var>Î¨</var> ) | <var>Î¼'</var> in <var>Î¨</var> such that <var>Î¼'</var> = Proj(<var>Î¼</var>, <var>PV</var>) )</p>
          <p>The order of <a href="#defn_algProject" class="algFct">Project</a>(<var>Î¨</var>, <var>PV</var>) must preserve any ordering given by <a href="#defn_algOrderBy" class="algFct">OrderBy</a>.</p>
        </div>
        <div class="defn">
          <p><b>Definition: <span id="defn_algDistinct">Distinct</span></b></p>
          <p>Let <var>Î¨</var> be a sequence of solution mappings. We define:</p>
          <p><a href="#defn_algDistinct" class="algFct">Distinct</a>(<var>Î¨</var>) = [ <var>Î¼</var> | <var>Î¼</var> in <var>Î¨</var> ]</p>
          <p><a href="#defn_Multiplicity">multiplicity</a>( <var>Î¼</var> | <a href="#defn_algDistinct" class="algFct">Distinct</a>(<var>Î¨</var>) ) = 1
            for every <var>Î¼</var> âˆˆ <a href="#defn_algDistinct" class="algFct">Distinct</a>(<var>Î¨</var>)</p>
          <p><a href="#defn_Multiplicity">multiplicity</a>( <var>Î¼</var> | <a href="#defn_algDistinct" class="algFct">Distinct</a>(<var>Î¨</var>) ) = 0
            for every <var>Î¼</var> âˆ‰ <a href="#defn_algDistinct" class="algFct">Distinct</a>(<var>Î¨</var>)</p>
          <p>The order of <a href="#defn_algDistinct" class="algFct">Distinct</a>(<var>Î¨</var>) must preserve any ordering given by <a href="#defn_algOrderBy" class="algFct">OrderBy</a>.</p>
        </div>
        <div class="defn">
          <p><b>Definition: <span id="defn_algReduced">Reduced</span></b></p>
          <p>Let <var>Î¨</var> be a sequence of solution mappings. We define:</p>
          <p><a href="#defn_algReduced" class="algFct">Reduced</a>(<var>Î¨</var>) = [ <var>Î¼</var> | <var>Î¼</var> in <var>Î¨</var> ]</p>
          <p><a href="#defn_Multiplicity">multiplicity</a>( <var>Î¼</var> | <a href="#defn_algReduced" class="algFct">Reduced</a>(<var>Î¨</var>) ) is
            between 1 and <a href="#defn_Multiplicity">multiplicity</a>( <var>Î¼</var> | <var>Î¨</var> )
            for every <var>Î¼</var> âˆˆ <a href="#defn_algReduced" class="algFct">Reduced</a>(<var>Î¨</var>)</p>
          <p><a href="#defn_Multiplicity">multiplicity</a>( <var>Î¼</var> | <a href="#defn_algReduced" class="algFct">Reduced</a>(<var>Î¨</var>) ) = 0
            for every <var>Î¼</var> âˆ‰ <a href="#defn_algReduced" class="algFct">Reduced</a>(<var>Î¨</var>)</p>
          <p>The order of <a href="#defn_algReduced" class="algFct">Reduced</a>(<var>Î¨</var>) must preserve any ordering given by <a href="#defn_algOrderBy" class="algFct">OrderBy</a>.</p>
        </div>
        <p>The <a href="#defn_algReduced" class="algFct">Reduced</a> solution sequence modifier does not guarantee a defined multiplicity.</p>
        <div class="defn">
          <p><b>Definition: <span id="defn_algSlice">Slice</span></b></p>
          <p>Let <var>Î¨</var> be a sequence of solution mappings, and |offset| and |limit| be non-negative integers. We define:</p>
          <p><a href="#defn_algSlice" class="algFct">Slice</a>(<var>Î¨</var>, |offset|)
            = <var>Î¨<sub>0</sub></var>
            &nbsp; if |offset| &geq; <a href="#defn_Card">Card</a>(<var>Î¨</var>)</p>
          <p><a href="#defn_algSlice" class="algFct">Slice</a>(<var>Î¨</var>, |offset|)
            = subseq(<var>Î¨</var>, |offset|+1, <a href="#defn_Card">Card</a>(<var>Î¨</var>))
            &nbsp; if 0 &leq; |offset| &lt; <a href="#defn_Card">Card</a>(<var>Î¨</var>)</p>
          <p><a href="#defn_algSlice" class="algFct">Slice</a>(<var>Î¨</var>, |offset|, |limit|)
            = <var>Î¨<sub>0</sub></var>
            &nbsp; if |offset| &geq; <a href="#defn_Card">Card</a>(<var>Î¨</var>)
            or |limit| = 0</p>
          <p><a href="#defn_algSlice" class="algFct">Slice</a>(<var>Î¨</var>, |offset|, |limit|)
            = subseq(<var>Î¨</var>, |offset|+1, <a href="#defn_Card">Card</a>(<var>Î¨</var>))
            &nbsp; if 0 &leq; |offset| &lt; <a href="#defn_Card">Card</a>(<var>Î¨</var>)
            and |limit| &geq; <a href="#defn_Card">Card</a>(<var>Î¨</var>)&minus;|offset|</p>
          <p><a href="#defn_algSlice" class="algFct">Slice</a>(<var>Î¨</var>, |offset|, |limit|)
            = subseq(<var>Î¨</var>, |offset|+1, |offset|+|limit|)
            &nbsp; if 0 &leq; |offset| &lt; <a href="#defn_Card">Card</a>(<var>Î¨</var>)
            and 0 &lt; |limit| &lt; <a href="#defn_Card">Card</a>(<var>Î¨</var>)&minus;|offset|</p>
          <p>where <var>Î¨<sub>0</sub></var> is the empty sequence of solution mappings
            and, for every two integers |i| and |j|,
            subseq(<var>Î¨</var>, |i|, |j|) is the subsequence of <var>Î¨</var>
            that starts with the |i|-th element of <var>Î¨</var>
            and ends with the |j|-th element of <var>Î¨</var>.</p>
            <p>Notice that this definition assumes that sequences are 1-based
            and subsequences are inclusive at both ends
            (i.e., ending with |j|-th element means that
            the subsequence contains the |j|-th element of <var>Î¨</var> as its last element).
            </p>
        </div>
        <div class="defn">
          <p><b>Definition: <span id="defn_algToMultiSet">ToMultiSet</span></b></p>
          <p>Let <var>Î¨</var> be a solution sequence. We define:</p>
          <p><a href="#defn_algToMultiSet" class="algFct">ToMultiSet</a>(<var>Î¨</var>) = { <var>Î¼</var> | <var>Î¼</var> in <var>Î¨</var> }</p>
          <p><a href="#defn_Multiplicity">multiplicity</a>( <var>Î¼</var> | <a href="#defn_algToMultiSet" class="algFct">ToMultiSet</a>(<var>Î¨</var>) ) =
            <a href="#defn_Multiplicity">multiplicity</a>( <var>Î¼</var> | <var>Î¨</var> )</p>
        </div>
        <div class="defn">
          <p><b>Definition: <span id="defn_exists">Exists</span></b></p>
          <p>exists(pattern) is a function that returns true if the pattern
            <a href="#defn_evalExists">evaluates</a> to a non-empty solution sequence, given the current
            solution mapping and active graph at the time of evaluation; otherwise it returns
            false.</p>
        </div>
        <section id="aggregateAlgebra">
          <h4>Aggregate Algebra</h4>
          <p><a href="#defn_algGroup" class="algFct">Group</a> is a function which groups a solution sequence into multiple solutions, based on
            some attribute of the solutions.</p>
          <div class="defn">
            <div id="defn_algGroup">
              <b>Definition: Group</b>
            </div>
            <p><a href="#defn_algGroup" class="algFct">Group</a> evaluates a list of expressions against a solution sequence <var>Î¨</var>, producing a
              partial function from keys to solution sequences.</p>
            <p><a href="#defn_algGroup" class="algFct">Group</a>(<var>exprlist</var>, <var>Î¨</var>) = {
              <a href="#defn_ListEval">ListEval</a>(<var>exprlist</var>, <var>Î¼</var>)
              â†’ [ <var>Î¼'</var> | <var>Î¼'</var> in <var>Î¨</var> such that
              <a href="#defn_ListEval">ListEval</a>(<var>exprlist</var>, <var>Î¼'</var>) and
              <a href="#defn_ListEval">ListEval</a>(<var>exprlist</var>, <var>Î¼</var>)
              are the same ] | <var>Î¼</var> in <var>Î¨</var> },</p>
            <p>where two lists <var>L</var> and <var>L'</var> (as produced by
              the <a href="#defn_ListEval">ListEval</a> function) are considered
              the same iff they have the same number of elements and, for every
              position&nbsp;<var>k</var> within the two lists, either of the
              following two conditions is true:</p>
            <ul>
              <li>the element at the <var>k</var>-th position of
                <var>L</var> is an RDF term; the element at the <var>k</var>-th
                position of <var>L'</var> is also an RDF term; and these two
                RDF terms are the <a href="#func-sameTerm">same term</a></li>
              <li>the element at the <var>k</var>-th position of <var>L</var>
                is an error, and the element at the <var>k</var>-th position of
                <var>L'</var> is also an error</li>
            </ul>
          </div>
          <div class="defn">
            <p><b>Definition: <span id="defn_ListEval">ListEval</span></b></p>
            <p><a href="#defn_ListEval">ListEval</a>((<var>expr<sub>1</sub></var>, ..., <var>expr<sub><var>n</var></sub></var>), <var>Î¼</var>) returns a list
              (<var>e<sub>1</sub></var>, ..., <var>e<sub><var>n</var></sub></var>), where <var>e<sub><var>i</var></sub></var> = <var>expr<sub><var>i</var></sub></var>(<var>Î¼</var>) or
              error.</p>
            <p><a href="#defn_ListEval">ListEval</a> retains errors resulting from the evaluation of the list elements.</p>
          </div>
          <p>Note that, although the result of <a href="#defn_ListEval">ListEval</a>
            may contain errors, and errors may be used
            to group, solutions containing error values are removed at the
            end of evaluating the group and any aggregation functions.</p>
          <p>Note also that the result of <a href="#defn_ListEval">ListEval</a>((unbound), <var>Î¼</var>)
            is the list (error), as the evaluation of an unbound expression is an
            error.</p>
          <p><a href="#defn_algAggregation" class="algFct">Aggregation</a>, a function which calculates a scalar value as an output of the aggregate
            expression. It is used in the SELECT clause, the HAVING evaluation process, and in ORDER
            BY (where required). <a href="#defn_algAggregation" class="algFct">Aggregation</a> calculates aggregated values over groups of solutions,
            using set functions.</p>
          <div class="defn">
            <div id="defn_algAggregation">
              <b>Definition: Aggregation</b>
            </div>
            <p>Let <var>exprlist</var> be a list of expressions or `*`; <var>func</var>, a set function;
              <var>scalarvals</var>, a partial function (possibly with an empty domain) passed from the aggregate
              in the query; and { <var>key<sub>1</sub></var>â†’<var>Î¨<sub>1</sub></var>, ...,
              <var>key<sub><var>m</var></sub></var>â†’<var>Î¨<sub><var>m</var></sub></var> }, a partial function from keys to
              solution sequences as produced by the grouping step.</p>
            <p><a href="#defn_algAggregation" class="algFct">Aggregation</a> applies the set function <var>func</var> to the given set and produces a
              single value for each key and a group of solutions for that key.</p>
            <p><a href="#defn_algAggregation" class="algFct">Aggregation</a>(<var>exprlist</var>, <var>func</var>, <var>scalarvals</var>, { <var>key<sub>1</sub></var>â†’<var>Î¨<sub>1</sub></var>, ...,
              <var>key<sub><var>m</var></sub></var>â†’<var>Î¨<sub><var>m</var></sub></var> } )<br>
              &nbsp;&nbsp;&nbsp;= { (<var>key</var>, <var>F</var>(<var>Î¨</var>)) | <var>key</var> â†’ <var>Î¨</var> in { <var>key<sub>1</sub></var>â†’<var>Î¨<sub>1</sub></var>, ...,
              <var>key<sub><var>m</var></sub></var>â†’<var>Î¨<sub><var>m</var></sub></var> } }</p>
            <p>where<br>
              &nbsp;&nbsp;M(<var>Î¨</var>) = [ <a href="#defn_ListEval">ListEval</a>(<var>exprlist</var>, <var>Î¼</var>) | <var>Î¼</var> in <var>Î¨</var> ]<br>
              &nbsp;&nbsp;F(<var>Î¨</var>) = <var>func</var>(M(<var>Î¨</var>), <var>scalarvals</var>), for non-<code>DISTINCT</code><br>
              &nbsp;&nbsp;F(<var>Î¨</var>) = <var>func</var>(Dedup(M(<var>Î¨</var>)), <var>scalarvals</var>), for <code>DISTINCT</code></p>
            <p>with Dedup(M(<var>Î¨</var>)) being an order-preserving, duplicate-free version of the sequence M(<var>Î¨</var>); that is, Dedup(M(<var>Î¨</var>)) is a sequence of lists that has the following four properties
              (where each such list in this sequence may contain RDF terms and
              errors, as it is produced by the <a href="#defn_ListEval">ListEval</a> function).</p>
            <ol>
              <li>For every list&nbsp;<var>L</var> in M(<var>Î¨</var>) there exists a
                list&nbsp;<var>L'</var> in Dedup(M(<var>Î¨</var>)) such that <var>L</var>
                and <var>L'</var> are the same,
                where two lists <var>L</var> and <var>L'</var> from M(<var>Î¨</var>) are
                considered the same as specified in the definition of the
                <a href="#defn_algGroup">Group operator</a>.</li>
              <li>For every list&nbsp;<var>L</var> in Dedup(M(<var>Î¨</var>)) there exists
                a list&nbsp;<var>L'</var> in M(<var>Î¨</var>) such that <var>L</var> and
                <var>L'</var> are the same.</li>
              <li>Dedup(M(<var>Î¨</var>)) is free of duplicates. That is, the list at the |i|-th position in Dedup(M(<var>Î¨</var>)) is not the same list as the list at the |j|-th position in Dedup(M(<var>Î¨</var>)) for every two natural numbers |i| and |j| such that |i| &ne; |j|.</li>
              <li>For any two lists <var>L<sub>1</sub></var> and <var>L<sub>2</sub></var> in Dedup(M(<var>Î¨</var>)), the relative order of their first occurrences in M(<var>Î¨</var>) is preserved in Dedup(M(<var>Î¨</var>)). That is, if <var>i<sub>1</sub></var>&nbsp;&lt;&nbsp;<var>i<sub>2</sub></var>, then <var>j<sub>1</sub></var>&nbsp;&lt;&nbsp;<var>j<sub>2</sub></var>, where
                <ul>
                  <li><var>i<sub>1</sub></var> is the smallest natural number such that <var>L<sub>1</sub></var> is at the <var>i<sub>1</sub></var>-th position in M(<var>Î¨</var>),</li>
                  <li><var>i<sub>2</sub></var> is the smallest natural number such that <var>L<sub>2</sub></var> is at the <var>i<sub>2</sub></var>-th position in M(<var>Î¨</var>),</li>
                  <li><var>j<sub>1</sub></var> is the position of <var>L<sub>1</sub></var> in Dedup(M(<var>Î¨</var>)), and</li>
                  <li><var>j<sub>2</sub></var> is the position of <var>L<sub>2</sub></var> in Dedup(M(<var>Î¨</var>)).</li>
                </ul>
              </li>
            </ol>

            <p><b>Special Case:</b> when <code>COUNT</code> is used with the expression
              <code>*</code>, then F(<var>Î¨</var>) is the cardinality of the group solution sequence,
              i.e., F(<var>Î¨</var>)&nbsp;=&nbsp;<a href="#defn_Card">Card</a>(<var>Î¨</var>),
              or F(<var>Î¨</var>)&nbsp;=&nbsp;<a href="#defn_Card">Card</a>(<a href="#defn_algDistinct">Distinct</a>(<var>Î¨</var>))
              if the <code>DISTINCT</code> keyword is present.</p>
          </div>
          <p><var>scalarvals</var> are used to pass values to the underlying set function, bypassing
            the mechanics of the grouping. For example, the aggregate expression
            <code>GROUP_CONCAT(?x ; separator="|")</code> has a <var>scalarvals</var> argument of { "separator"
            â†’ "|" }.</p>
          <p>All aggregates may have the <code>DISTINCT</code> keyword as the first token in their
            argument list. If this keyword is present, then first argument to |func| is Dedup(M(<var>Î¨</var>)).</p>
          <p>Example</p>
          <p>Given a solution sequence <var>Î¨</var> with the following values:</p>
          <table>
            <tbody>
              <tr>
                <td>solution</td>
                <td>?x</td>
                <td>?y</td>
                <td>?z</td>
              </tr>
              <tr>
                <td><var>Î¼<sub>1</sub></var></td>
                <td>1</td>
                <td>2</td>
                <td>3</td>
              </tr>
              <tr>
                <td><var>Î¼<sub>2</sub></var></td>
                <td>1</td>
                <td>3</td>
                <td>4</td>
              </tr>
              <tr>
                <td><var>Î¼<sub>3</sub></var></td>
                <td>2</td>
                <td>5</td>
                <td>6</td>
              </tr>
            </tbody>
          </table>
          <p>And the query expression SELECT (ex:agg(?y, ?z) AS ?agg) WHERE { ?x ?y ?z } GROUP BY
            ?x.</p>
          <p>We produce <var>G</var> = <a href="#defn_algGroup" class="algFct">Group</a>((?x), <var>Î¨</var>) = { (1) â†’ [<var>Î¼<sub>1</sub></var>, <var>Î¼<sub>2</sub></var>], (2) â†’
          [<var>Î¼<sub>3</sub></var>] }</p>
          <p>And so <a href="#defn_algAggregation" class="algFct">Aggregation</a>((?y, ?z), ex:agg, {}, <var>G</var>) =<br>
            { ((1), eg:agg([(2, 3), (3, 4)], {})), ((2), eg:agg([(5, 6)], {})) }.</p>
          <div class="defn">
            <div id="defn_algAggregateJoin">
              <b>Definition: AggregateJoin</b>
            </div>
            <p>Let <var>S<sub>1</sub></var>, ..., <var>S<sub>|n|</sub></var> be a list of sets, where each set
              <var>S<sub>i</sub></var> contains key to (aggregated) value maps as produced by <a href="#defn_algAggregation" class="algFct">Aggregation</a>.</p>
            <p>Let |K| = { |key| | |key| in dom(<var>S<sub>|j|</sub></var>) for some 1 &le; |j| &le; |n| } be the set of
              keys, then<br>
              <a href="#defn_algAggregateJoin" class="algFct">AggregateJoin</a>(<var>S<sub>1</sub></var>, ..., <var>S<sub>|n|</sub></var>) = { <var>agg<sub>1</sub></var>â†’<var>val<sub>1</sub></var>,
              ..., <var>agg<sub>|n|</sub></var>â†’<var>val<sub>|n|</sub></var> | |key| in |K| and |key|â†’<var>val<sub>|i|</sub></var> in
              <var>S<sub>|i|</sub><var> for each 1 &le; |i| &le; |n| }</p>
          </div>
          <section id="setFunctions">
            <h5>Set Functions</h5>
            <p>The set functions which underlie SPARQL aggregates all have a common signature:
              SetFunc(|S|), or SetFunc(|S|, |scalarvals|) where |S| is a sequence of lists, and |scalarvals| is
              one or more scalar values that are passed to the set function indirectly via the ( ...
              ; key=value ) syntax for aggregates in the SPARQL grammar. The only use of this that is
              supported by the built-in aggregates in SPARQL Query 1.1 is <code>GROUP_CONCAT</code>,
              as in <code>GROUP_CONCAT(?x ; separator=", ")</code>.</p>
            <p>Note that the name "Set Function" is somewhat historical â€” the arguments to set
              functions are in fact sequences. The name is retained due to the commonality with SQL
              Set Functions, which operate over multisets.</p>
            <p>The set functions defined in this document are
              <a href="#defn_aggCount" class="aggFct">Count</a>,
              <a href="#defn_aggSum" class="aggFct">Sum</a>,
              <a href="#defn_aggMin" class="aggFct">Min</a>,
              <a href="#defn_aggMax" class="aggFct">Max</a>,
              <a href="#defn_aggAvg" class="aggFct">Avg</a>,
              <a href="#defn_aggGroupConcat" class="aggFct">GroupConcat</a>, and
              <a href="#defn_aggSample" class="aggFct">Sample</a>
              â€” corresponding to the aggregates <code>COUNT</code>,
              <code>SUM</code>, <code>MIN</code>, <code>MAX</code>, <code>AVG</code>,
              <code>GROUP_CONCAT</code>, and <code>SAMPLE</code>. Definitions may be found in the
              following sections. Systems may choose to expand this set using local extensions, using
              the same notation as for functions and casts. Note that, unless the ; separator is used
              this requires the parser to know whether some IRI refers to a function, cast, or
              aggregate before it can determine if there are any errors in a query where aggregates
              are used.</p>
            <p>The definitions of the set functions in the following sections
              are based on two functions, <a href="#defn_Flatten">Flatten</a>
              and <a href="#defn_Card">Card</a>, which are defined as follows.</p>
            <p><a href="#defn_Flatten">Flatten</a> is a function which is
              used to collapse a sequence of lists into a single list.
              For example, [(1,&nbsp;2), (3,&nbsp;4)] becomes (1,&nbsp;2,&nbsp;3,&nbsp;4).</p>
            <div class="defn">
              <p><b>Definition: <span id="defn_Flatten">Flatten</span></b></p>
              <p>Let <var>S</var> be a sequence of lists,
                i.e., <var>S</var> =
                [<var>L<sub>1</sub></var>,
                <var>L<sub>2</sub></var>, ...,
                <var>L<sub><var>m</var></sub></var>]
                where, for every <var>i</var> &in; {1, ..., <var>m</var>},
                <var>L<sub><var>i</var></sub></var> is a list.</p>
              <p><a href="#defn_Flatten">Flatten</a>(<var>S</var>) is the list
                ( <var>x</var> | <var>L</var> in <var>S</var> and
                <var>x</var> in <var>L</var> ).</p>
            </div>
            <p><a href="#defn_Card">Card</a> is a function that returns the
              cardinality of a sequence or a list of elements (which may be
              solution mappings or other types of elements, depending on the
              context).
            <div class="defn">
              <p><b>Definition: <span id="defn_Card">Card</span></b></p>
              <p>Given a sequence or a list |L|, <a href="#defn_Card">Card</a>(|L|) is the cardinality of |L|.</p>
            </div>
          </section>

          <section id="aggCount">
            <h5>Count</h5>
            <p><a href="#defn_aggCount" class="aggFct">Count</a> is a SPARQL set function which counts the number of times a given expression
              has a bound, non-error value within the aggregate group.</p>
            <div class="defn">
              <p><b>Definition: <span id="defn_aggCount">Count</span></b></p>
              <pre class="code nohighlight">xsd:integer <a href="#defn_aggCount" class="aggFct">Count</a>(sequence <var>S</var>)</pre>
              <p><a href="#defn_aggCount" class="aggFct">Count</a>(<var>S</var>) = <a href="#defn_Card">Card</a>(<var>L'</var>),</p>
              <p>where <var>L'</var> is the list <var>L</var> = <a href="#defn_Flatten">Flatten</a>(<var>S</var>)
                with all error elements removed.</p>
            </div>
          </section>
          <section id="aggSum">
            <h5>Sum</h5>
            <p><a href="#defn_aggSum" class="aggFct">Sum</a> is a SPARQL set function that returns the numeric value obtained by summing
              the values within the aggregate group. Type promotion happens as per the op:numeric-add
              function, applied transitively, (see definition below) so the value of SUM(?x), in an
              aggregate group where ?x has values 1 (integer), 2.0e0 (float), and 3.0 (decimal) will
              be 6.0 (float).</p>
            <div class="defn">
              <p><b>Definition: <span id="defn_aggSum">Sum</span></b></p>
              <pre class="code nohighlight">numeric <a href="#defn_aggSum" class="aggFct">Sum</a>(sequence <var>S</var>)</pre>
              <p><a href="#defn_aggSum" class="aggFct">Sum</a>(<var>S</var>) = <var>SumList</var>(<var>L</var>),</p>
              <p>where <var>L</var> = <a href="#defn_Flatten">Flatten</a>(<var>S</var>) and
                <var>SumList</var>(<var>L</var>) is defined recursively as follows.</p>
              <ul>
                <li>If <a href="#defn_Card">Card</a>(<var>L</var>) = 0, then
                  <var>SumList</var>(<var>L</var>) = "0"^^<code>xsd:integer</code>.</li>
                <li>If <a href="#defn_Card">Card</a>(<var>L</var>) = 1, then
                  <var>SumList</var>(<var>L</var>) = <a data-cite="XPATH-FUNCTIONS-31#func-numeric-add">op:numeric-add</a>(<var>L</var><sub>1</sub>, 0).</li>
                <li>If <a href="#defn_Card">Card</a>(<var>L</var>) > 1, then
                  <var>SumList</var>(<var>L</var>) = <a data-cite="XPATH-FUNCTIONS-31#func-numeric-add">op:numeric-add</a>(<var>L</var><sub>1</sub>,
                  <var>SumList</var>(<var>L</var><sub>2..n</sub>)).</li>
              </ul>
              <p>Note that <var>L</var><sub>1</sub> is the first element in
                <var>L</var>, and <var>L</var><sub>2..n</sub> is <var>L</var>
                without its first element.</p>
            </div>
            <p>In this way, <a href="#defn_aggSum" class="aggFct">Sum</a>( [(1), (2), (3)] ) = <var>SumList</var>( (1, 2, 3) ) =
              op:numeric-add(1, op:numeric-add(2, op:numeric-add(3, 0))).</p>
          </section>
          <section id="aggAvg">
            <h5>Avg</h5>
            <div id="defn_algAvg"></div>The <a href="#defn_aggAvg" class="aggFct">Avg</a> set function calculates the
            average value for an expression over a group. It is defined in terms of Sum and Count.
            <div class="defn">
              <p><b>Definition: <span id="defn_aggAvg">Avg</span></b></p>
              <pre class="code nohighlight">numeric <a href="#defn_aggAvg" class="aggFct">Avg</a>(sequence <var>S</var>)</pre>
              <p>If <var><a href="#defn_aggCount">Count</a></var>(<var>S</var>) = 0,
                then <a href="#defn_aggAvg" class="aggFct">Avg</a>(<var>S</var>) = "0"^^<code>xsd:integer</code>.</p>
              <p>If <var><a href="#defn_aggCount">Count</a></var>(<var>S</var>) &gt; 0,
                then <a href="#defn_aggAvg" class="aggFct">Avg</a>(<var>S</var>) =
                <var><a href="#defn_aggSum" class="aggFct">Sum</a></var>(<var>S</var>) /
                <var><a href="#defn_aggCount" class="aggFct">Count</a></var>(<var>S</var>).</p>
            </div>
            <p>For example, <a href="#defn_aggAvg" class="aggFct">Avg</a>([(1), (2), (3)]) =
              <a href="#defn_aggSum">Sum</a>([(1), (2), (3)])/<a href="#defn_aggCount">Count</a>([(1), (2), (3)])
              = 6/3 = 2.</p>
          </section>
          <section id="aggMin">
            <h5>Min</h5>
            <p><a href="#defn_aggMin" class="aggFct">Min</a> is a SPARQL set function that returns the minimum value from a group
              respectively.</p>
            <p>It makes use of the SPARQL ORDER BY ordering definition, to allow ordering over
              arbitrarily typed expressions.</p>
            <div class="defn">
              <p><b>Definition: <span id="defn_aggMin">Min</span></b></p>
              <pre class="code nohighlight">term <a href="#defn_aggMin" class="aggFct">Min</a>(sequence <var>S</var>)</pre>
              <p><a href="#defn_aggMin" class="aggFct">Min</a>(<var>S</var>) = <var>MinList</var>(<var>L</var>),</p>
              <p>where <var>L</var> is the list of values obtained by
                <a href="#defn_Flatten">Flatten</a>(<var>S</var>)
                and then ordered as per the <code>ORDER BY ASC</code> clause,
                and <var>MinList</var>(<var>L</var>) is defined as follows.</p>
              <ul>
                <li>If <a href="#defn_Card">Card</a>(<var>L</var>) = 0, then
                  <var>MinList</var>(<var>L</var>) = error.</li>
                <li>If <a href="#defn_Card">Card</a>(<var>L</var>) > 0, then
                  <var>MinList</var>(<var>L</var>) = <var>L</var><sub>1</sub>,
                  where <var>L</var><sub>1</sub> is the first element in
                  <var>L</var>.</li>
              </ul>
            </div>
          </section>
          <section id="aggMax">
            <h5>Max</h5>
            <p><a href="#defn_aggMax" class="aggFct">Max</a> is a SPARQL set function that returns the maximum value from a group
              respectively.</p>
            <p>It makes use of the SPARQL ORDER BY ordering definition, to allow ordering over
              arbitrarily typed expressions.</p>
            <div class="defn">
              <p><b>Definition: <span id="defn_aggMax">Max</span></b></p>
              <pre class="code nohighlight">term <a href="#defn_aggMax" class="aggFct">Max</a>(sequence <var>S</var>)</pre>
              <p><a href="#defn_aggMax" class="aggFct">Max</a>(<var>S</var>) = <var>MaxList</var>(<var>L</var>),</p>
              <p>where <var>L</var> is the list of values obtained by
                <a href="#defn_Flatten">Flatten</a>(<var>S</var>)
                and then ordered as per the <code>ORDER BY DESC</code> clause,
                and <var>MaxList</var>(<var>L</var>) is defined as follows.</p>
              <ul>
                <li>If <a href="#defn_Card">Card</a>(<var>L</var>) = 0, then
                  <var>MaxList</var>(<var>L</var>) = error.</li>
                <li>If <a href="#defn_Card">Card</a>(<var>L</var>) > 0, then
                 <var>MaxList</var>(<var>L</var>) = <var>L</var><sub>1</sub>,
                 where <var>L</var><sub>1</sub> is the first element in
                 <var>L</var>.</li>
              </ul>
            </div>
          </section>
          <section id="aggGroupConcat">
            <h5>GroupConcat</h5>
            <p><a href="#defn_aggGroupConcat" class="aggFct">GroupConcat</a> is a set function which performs a string concatenation across the
              values of an expression with a group. The order of the strings is not specified. The
              separator character used in the concatenation may be given with the scalar argument
              SEPARATOR.</p>
            <div class="defn">
              <p><b>Definition: <span id="defn_aggGroupConcat">GroupConcat</span></b></p>
              <pre class="code nohighlight">literal <a href="#defn_aggGroupConcat" class="aggFct">GroupConcat</a>(sequence <var>S</var>, function <var>scalarvals</var>)</pre>
              <p>If the <var>scalarvals</var> argument is absent from <code>GROUP_CONCAT</code>,
                then <var>scalarvals</var> is taken to be the empty function.</p>
              <p>Let <var>sep</var> be a string that is defined as follows.</p>
              <ul>
                <li>If <var>scalarvals</var> is defined for the argument "separator",
                  then <var>sep</var> = <var>scalarvals</var>("separator").</li>
                <li>If <var>scalarvals</var> is undefined for the argument "separator",
                  then <var>sep</var> is the "space" character (i.e., unicode codepoint U+0020).</li>
              </ul>
              <p><a href="#defn_aggGroupConcat" class="aggFct">GroupConcat</a>(<var>S</var>, <var>scalarvals</var>) =
                <var>GCList</var>(<var>L</var>, <var>sep</var>),</p>
              <p>where <var>L</var> = <a href="#defn_Flatten">Flatten</a>(<var>S</var>)
                and <var>GCList</var>(<var>L</var>, <var>sep</var>)
                is defined recursively as follows.</p>
              <ul>
                <li>If <a href="#defn_Card">Card</a>(<var>L</var>) = 0, then
                  <var>GCList</var>(<var>L</var>, <var>sep</var>) = "".</li>
                <li>If <a href="#defn_Card">Card</a>(<var>L</var>) = 1, then
                  <var>GCList</var>(<var>L</var>, <var>sep</var>) =
                  <a href="#func-concat"><code>CONCAT</code></a>("", <var>L</var><sub>1</sub>).</li>
                <li>If <a href="#defn_Card">Card</a>(<var>L</var>) > 1, then
                  <var>GCList</var>(<var>L</var>, <var>sep</var>) =
                  <a href="#func-concat"><code>CONCAT</code></a>(<var>L</var><sub>1</sub>, <var>sep</var>, <var>GCList</var>(<var>L</var><sub>2..n</sub>, <var>sep</var>)).</li>
              </ul>
              <p>Note that <var>L</var><sub>1</sub> is the first element in
                <var>L</var>, and <var>L</var><sub>2..n</sub> is <var>L</var>
                without its first element.</p>
            </div>
            <p>For example, <a href="#defn_aggGroupConcat" class="aggFct">GroupConcat</a>([("a"), ("b"), ("c")], {"separator" â†’ "."})
              = <var>GCList</var>( ("a", "b", "c"), "." )
              = "a.b.c".</p>
          </section>
          <section id="aggSample">
            <h5>Sample</h5>
            <p><a href="#defn_aggSample" class="aggFct">Sample</a> is a set function which returns an arbitrary value from the sequence passed
              to it.</p>
            <div class="defn">
              <p><b>Definition: <span id="defn_aggSample">Sample</span></b></p>
              <pre class="code nohighlight">RDFTerm <a href="#defn_aggSample" class="aggFct">Sample</a>(sequence <var>S</var>)</pre>
              <p>If <a href="#defn_Card">Card</a>(<var>S</var>) = 0, then
                <a href="#defn_aggSample" class="aggFct">Sample</a>(<var>S</var>) = error.</p>
              <p>If <a href="#defn_Card">Card</a>(<var>S</var>) &gt; 0, then
                <a href="#defn_aggSample" class="aggFct">Sample</a>(<var>S</var>) = <var>v</var>, where <var>v</var>
                in <a href="#defn_Flatten">Flatten</a>(<var>S</var>).</p>
            </div>
            <p>For example, given <a href="#defn_aggSample" class="aggFct">Sample</a>([("a"), ("b"), ("c")]), "a", "b", and "c" are all valid return
              values. Note that the <a href="#defn_aggSample" class="aggFct">Sample</a> function is not required to be deterministic for a given input. The
              only restriction is that the output value must be present in the input sequence.</p>
          </section>
        </section>
        <section id="sparqlAlgebraEval">
          <h3>Evaluation Semantics</h3>
          <p id="defn_eval">We define <a href="#defn_eval" class="evalFct">eval</a>(|D|(|G|), |A|, <var>Î¼<sub>ctx</sub></var>) as the evaluation of an <a href="#defn_AlgebraicQueryExpression">algebraic query expression</a> |A| with
            respect to a <a href="#sparqlDataset">dataset</a> |D| having <a href="#defn_ActiveGraph">active graph</a> |G|
            in correlation with solution mapping <var>Î¼<sub>ctx</sub></var>.</p>
          <p>The active graph is initially the default graph of |D| and
            <var>Î¼<sub>ctx</sub></var> is initially the empty solution mapping <var>Î¼<sub>0</sub></var>.</p>
          <p>Further symbols used in the following definitions are:</p>
          <ul>
            <li>|P|, <var>P<sub>1</sub></var>, <var>P<sub>2</sub></var> : graph patterns</li>
            <li>|L| : a solution sequence</li>
            <li>|F| : an <a href="#expressions">expression</a></li>
          </ul>
<div class="issue" data-number="308">
  |L| should not be a solution sequence but an <a href="#defn_AlgebraicQueryExpression">algebraic query expression</a>.</div>
<div class="issue" data-number="225">
  The definitions in this section do not cover the cases in which
  |A| is a sequence or a multiset of solution mappings.</div>
          <div class="defn">
            <p><b>Definition: <span id="defn_evalBasicGraphPattern">Evaluation of a Basic Graph Pattern</span></b></p>
            <p><a href="#defn_eval" class="evalFct">eval</a>( |D|(|G|), |BGP|, <var>Î¼<sub>ctx</sub></var> ) = multiset of solution mappings</p>
            <p>See section <a href="#BasicGraphPattern">Basic Graph Patterns</a></p>
          </div>
          <div class="defn">
            <p><b>Definition: <span id="defn_evalPropertyPathPattern">Evaluation of a Property Path Pattern</span></b></p>
            <p><a href="#defn_eval" class="evalFct">eval</a>( |D|(|G|), <a href="#defn_absPath" class="absOp">Path</a>(|X|, |path|, |Y|), <var>Î¼<sub>ctx</sub></var> ) = multiset of solution mappings</p>
            <p>See section <a href="#PropertyPathPatterns">Property Path Patterns</a></p>
          </div>
          <div class="defn">
            <p><b>Definition: <span id="defn_evalContextSolution">Evaluation of ContextSolution</span></b></p>
            <p><a href="#defn_eval" class="evalFct">eval</a>( |D|(|G|), <a href="#defn_absContextSolution" class="absOp">ContextSolution</a>, <var>Î¼<sub>ctx</sub></var> ) = multiset that contains only <var>Î¼<sub>ctx</sub></var>, with a multiplicity of 1</p>
          </div>
          <div class="defn">
            <p><b>Definition: <span id="defn_evalFilter">Evaluation of Filter</span></b></p>
            <p><a href="#defn_eval" class="evalFct">eval</a>( |D|(|G|), <a href="#defn_absFilter" class="absOp">Filter</a>(|F|, |P|), <var>Î¼<sub>ctx</sub></var> ) = <a href="#defn_algFilter" class="algFct">Filter</a>( |F|, <a href="#defn_eval" class="evalFct">eval</a>(|D|(|G|), |P|, <var>Î¼<sub>ctx</sub></var>), |D|, |G| )</p>
          </div>
          <p>'substitute' is a filter function in support of the evaluation of 
            <a href="#func-filter-exists"><code>EXISTS</code>
              and <code>NOT EXISTS</code></a> forms which were translated to <code>exists</code>.</p>
<div class="issue" data-number="302">
  The sentence above and the next two definitions will be removed in the context of fixing the definition of EXISTS.</div>
          <div class="defn">
            <p><b>Definition: <span id="defn_substitute">Substitute</span></b></p>
            <p>Let <var>Î¼</var> be a solution mapping.</p>
            <blockquote>
              <p>substitute(|pattern|, <var>Î¼</var>) = the pattern formed by replacing every occurrence of
                a variable |v| in |pattern| by <var>Î¼</var>(|v|) for each |v| in dom(<var>Î¼</var>)</p>
            </blockquote>
          </div>
          <div class="defn">
            <p><b>Definition: <span id="defn_evalExists">Evaluation of Exists</span></b></p>
            <p>Let <var>Î¼</var> be the current solution mapping for a filter and |P| a graph pattern:</p>
            <blockquote>
              The value exists(|P|), given |D|(|G|) is true if and only if <a href="#defn_eval" class="evalFct">eval</a>( |D|(|G|), substitute(|P|, <var>Î¼</var>)) is
              a non-empty sequence.
            </blockquote>
          </div>
          <div class="defn">
            <p><b>Definition: <span id="defn_evalJoin">Evaluation of Join</span></b></p>
            <p><a href="#defn_eval" class="evalFct">eval</a>( |D|(|G|), <a href="#defn_absJoin" class="absOp">Join</a>(<var>P<sub>1</sub></var>, <var>P<sub>2</sub></var>), <var>Î¼<sub>ctx</sub></var> ) = <a href="#defn_algJoin" class="algFct">Join</a>( <a href="#defn_eval" class="evalFct">eval</a>(|D|(|G|), <var>P<sub>1</sub></var>, <var>Î¼<sub>ctx</sub></var>), <a href="#defn_eval" class="evalFct">eval</a>(|D|(|G|), <var>P<sub>2</sub></var>, <var>Î¼<sub>ctx</sub></var>) )</p>
          </div>
          <div class="defn">
            <p><b>Definition: <span id="defn_evalLeftJoin">Evaluation of LeftJoin</span></b></p>
            <p>
<a href="#defn_eval" class="evalFct">eval</a>( |D|(|G|), <a href="#defn_absLeftJoin" class="absOp">LeftJoin</a>(<var>P<sub>1</sub></var>, <var>P<sub>2</sub></var>, |F|), <var>Î¼<sub>ctx</sub></var> ) = <a href="#defn_algLeftJoin" class="algFct">LeftJoin</a>( <a href="#defn_eval" class="evalFct">eval</a>(|D|(|G|), <var>P<sub>1</sub></var>, <var>Î¼<sub>ctx</sub></var>), <a href="#defn_eval" class="evalFct">eval</a>(|D|(|G|), <var>P<sub>2</sub></var>, <var>Î¼<sub>ctx</sub></var>), |F|, |D|, |G| )
            </p>
          </div>
          <div class="defn">
            <p><b>Definition: <span id="defn_evalUnion">Evaluation of Union</span></b></p>
            <p><a href="#defn_eval" class="evalFct">eval</a>( |D|(|G|), <a href="#defn_absUnion" class="absOp">Union</a>(<var>P<sub>1</sub></var>, <var>P<sub>2</sub></var>), <var>Î¼<sub>ctx</sub></var> ) = <a href="#defn_algUnion" class="algFct">Union</a>( <a href="#defn_eval" class="evalFct">eval</a>(|D|(|G|), <var>P<sub>1</sub></var>, <var>Î¼<sub>ctx</sub></var>), <a href="#defn_eval" class="evalFct">eval</a>(|D|(|G|), <var>P<sub>2</sub></var>, <var>Î¼<sub>ctx</sub></var>) )</p>
          </div>
          <div class="defn">
            <p><b>Definition: <span id="defn_evalGraph">Evaluation of Graph</span></b></p>
            <p>For every |x| that is
              an <a data-cite="RDF12-CONCEPTS#dfn-IRI">IRI</a> or
              a <a href="#defn_QueryVariable">variable</a>,
              <a href="#defn_eval" class="evalFct">eval</a>( |D|(|G|), <a href="#defn_absGraph" class="absOp">Graph</a>(|x|, |P|), <var>Î¼<sub>ctx</sub></var> )
              is defined as follows:</p>
            <ul>
              <li>If |x| is an IRI
                that is a <a data-cite="RDF12-CONCEPTS#dfn-graph-name">graph name</a> in |D|,
                <div class="indentedFormula">
                  <a href="#defn_eval" class="evalFct">eval</a>( |D|(|G|), <a href="#defn_absGraph" class="absOp">Graph</a>(|x|, |P|), <var>Î¼<sub>ctx</sub></var> )
                  =
                  <a href="#defn_eval" class="evalFct">eval</a>( |D|(<var>G<sub>|x|</sub></var>), |P|, <var>Î¼<sub>ctx</sub></var> ),
                </div>
                where <var>G<sub>|x|</sub></var> is the RDF graph of the named graph with name |x| in |D|.
              </li>
              <li>If |x| is an IRI
                that is not a <a data-cite="RDF12-CONCEPTS#dfn-graph-name">graph name</a> in |D|,
                <div class="indentedFormula">
                  <a href="#defn_eval" class="evalFct">eval</a>( |D|(|G|), <a href="#defn_absGraph" class="absOp">Graph</a>(|x|, |P|), <var>Î¼<sub>ctx</sub></var> )
                  is the empty multiset.
                </div>
              </li>
              <li>If |x| is a variable,
                <div class="indentedFormula">
                  <a href="#defn_eval" class="evalFct">eval</a>( |D|(|G|), <a href="#defn_absGraph" class="absOp">Graph</a>(|x|, |P|), <var>Î¼<sub>ctx</sub></var> )
                  =
                  <var>Î©</var>,
                </div>
                where <var>Î©</var> is the multiset of solution mappings produced by the following algorithm:
                <pre class="code nohighlight" style="font-family: sans-serif;">
<var>Î©</var> := the empty multiset
for each <a data-cite="RDF12-CONCEPTS#dfn-graph-name">graph name</a> <var>gn</var> in <var>D</var> (recall that a graph name may be an IRI or a blank node)
    <var>G'</var> := the RDF graph of the named graph with name <var>gn</var> in <var>D</var>
    <var>Î©'</var> := <a href="#defn_eval" class="evalFct">eval</a>( <var>D</var>(<var>G'</var>), <var>P</var>, <var>Î¼<sub>ctx</sub></var> )
    <var>Î©</var> := <a href="#defn_algUnion" class="algFct">Union</a>( <var>Î©</var>, <a href="#defn_algJoin" class="algFct">Join</a>(<var>Î©'</var>, <var>Î¼</var>) ), where <var>Î¼</var> = {<var>x</var> â†’ <var>gn</var>}
the result is <var>Î©</var>
                </pre>
              </li>
            </ul>
          </div>
          <div class="defn">
            <div id="defn_evalGroup">
              <b>Definition: Evaluation of Group</b>
            </div>
            <p><a href="#defn_eval" class="evalFct">eval</a>( |D|(|G|), <a href="#defn_absGroup" class="absOp">Group</a>(|exprlist|, |P|), <var>Î¼<sub>ctx</sub></var> ) = <a href="#defn_algGroup" class="algFct">Group</a>( |exprlist|, <a href="#defn_eval" class="evalFct">eval</a>(|D|(|G|), |P|, <var>Î¼<sub>ctx</sub></var>) )</p>
          </div>
          <div class="defn">
            <div id="defn_evalAggregation">
              <b>Definition: Evaluation of Aggregation</b>
            </div>
            <p><a href="#defn_eval" class="evalFct">eval</a>( |D|(|G|), <a href="#defn_absAggregation" class="absOp">Aggregation</a>(|exprlist|, |func|, |scalarvals|, |Grp|), <var>Î¼<sub>ctx</sub></var> ) = <a href="#defn_algAggregation" class="algFct">Aggregation</a>( |exprlist|, |func|,
              |scalarvals|, <a href="#defn_eval" class="evalFct">eval</a>(|D|(|G|), |Grp|, <var>Î¼<sub>ctx</sub></var>) )</p>
          </div>
          <div class="defn">
            <div id="defn_evalAggregateJoin">
              <b>Definition: Evaluation of AggregateJoin</b>
            </div>
            <p><a href="#defn_eval" class="evalFct">eval</a>( |D|(|G|), <a href="#defn_absAggregateJoin" class="absOp">AggregateJoin</a>(<var>A<sub>1</sub></var>, ..., <var>A<sub>n</sub></var>), <var>Î¼<sub>ctx</sub></var> ) =
              <a href="#defn_algAggregateJoin" class="algFct">AggregateJoin</a>( <a href="#defn_eval" class="evalFct">eval</a>(|D|(|G|), <var>A<sub>1</sub></var>, <var>Î¼<sub>ctx</sub></var>), ..., <a href="#defn_eval" class="evalFct">eval</a>(|D|(|G|), <var>A<sub>n</sub></var>, <var>Î¼<sub>ctx</sub></var>) )</p>
          </div>
          <p>Note that if <a href="#defn_eval" class="evalFct">eval</a>(|D|(|G|), <var>A<sub>i</sub></var>, <var>Î¼<sub>ctx</sub></var>) is an error, it is ignored.</p>
          <div class="defn">
            <p><b>Definition: <span id="defn_evalExtend">Evaluation of Extend</span></b></p>
            <p>
<a href="#defn_eval" class="evalFct">eval</a>( |D|(|G|), <a href="#defn_absExtend" class="absOp">Extend</a>(|P|, |var|, |expr|), <var>Î¼<sub>ctx</sub></var> ) = <a href="#defn_algExtend" class="algFct">Extend</a>( <a href="#defn_eval" class="evalFct">eval</a>(|D|(|G|), |P|, <var>Î¼<sub>ctx</sub></var>), |var|, |expr|, |D|, |G| )
            </p>
          </div>
          <div class="defn">
            <p><b>Definition: <span id="defn_evalList">Evaluation of ToList</span></b></p>
            <p><a href="#defn_eval" class="evalFct">eval</a>( |D|(|G|), <a href="#defn_absToList" class="absOp">ToList</a>(|P|), <var>Î¼<sub>ctx</sub></var> ) = <a href="#defn_algToList" class="algFct">ToList</a>( <a href="#defn_eval" class="evalFct">eval</a>(|D|(|G|), |P|, <var>Î¼<sub>ctx</sub></var>) )</p>
          </div>
          <div class="defn">
            <p><b>Definition: <span id="defn_evalDistinct">Evaluation of Distinct</span></b></p>
            <p><a href="#defn_eval" class="evalFct">eval</a>( |D|(|G|), <a href="#defn_absDistinct" class="absOp">Distinct</a>(|L|), <var>Î¼<sub>ctx</sub></var> ) = <a href="#defn_algDistinct" class="algFct">Distinct</a>( <a href="#defn_eval" class="evalFct">eval</a>(|D|(|G|), |L|, <var>Î¼<sub>ctx</sub></var>) )
            </p>
          </div>
          <div class="defn">
            <p><b>Definition: <span id="defn_evalReduced">Evaluation of Reduced</span></b></p>
            <p><a href="#defn_eval" class="evalFct">eval</a>( |D|(|G|), <a href="#defn_absReduced" class="absOp">Reduced</a>(|L|), <var>Î¼<sub>ctx</sub></var> ) = <a href="#defn_algReduced" class="algFct">Reduced</a>( <a href="#defn_eval" class="evalFct">eval</a>(|D|(|G|), |L|, <var>Î¼<sub>ctx</sub></var>) )
            </p>
          </div>
          <div class="defn">
            <p><b>Definition: <span id="defn_evalProject">Evaluation of Project</span></b></p>
            <p><a href="#defn_eval" class="evalFct">eval</a>( |D|(|G|), <a href="#defn_absProject" class="absOp">Project</a>(|L|, |vars|), <var>Î¼<sub>ctx</sub></var> ) = <a href="#defn_algProject" class="algFct">Project</a>( <a href="#defn_eval" class="evalFct">eval</a>(|D|(|G|), |L|, <var>Î¼<sub>ctx</sub></var>), |vars| )
            </p>
          </div>
          <div class="defn">
            <p><b>Definition: <span id="defn_evalOrderBy">Evaluation of OrderBy</span></b></p>
            <p><a href="#defn_eval" class="evalFct">eval</a>( |D|(|G|), <a href="#defn_absOrderBy" class="absOp">OrderBy</a>(|L|, |condition|), <var>Î¼<sub>ctx</sub></var> ) = <a href="#defn_algOrderBy" class="algFct">OrderBy</a>( <a href="#defn_eval" class="evalFct">eval</a>(|D|(|G|), |L|, <var>Î¼<sub>ctx</sub></var>), |condition| )
            </p>
          </div>
          <div class="defn">
            <p><b>Definition: <span id="defn_evalToMultiSet">Evaluation of ToMultiSet</span></b></p>
            <p><a href="#defn_eval" class="evalFct">eval</a>( |D|(|G|), <a href="#defn_absToMultiset" class="absOp">ToMultiset</a>(|L|), <var>Î¼<sub>ctx</sub></var> ) = <a href="#defn_algToMultiSet" class="algFct">ToMultiSet</a>( <a href="#defn_eval" class="evalFct">eval</a>(|D|(|G|), |L|, <var>Î¼<sub>ctx</sub></var>) )</p>
          </div>
          <div class="defn">
            <p><b>Definition: <span id="defn_evalSlice">Evaluation of Slice</span></b></p>
            <p><a href="#defn_eval" class="evalFct">eval</a>( |D|(|G|), <a href="#defn_absSlice" class="absOp">Slice</a>(|L|, |offset|), <var>Î¼<sub>ctx</sub></var> ) = <a href="#defn_algSlice" class="algFct">Slice</a>( <a href="#defn_eval" class="evalFct">eval</a>(|D|(|G|), |L|, <var>Î¼<sub>ctx</sub></var>), |offset| )
            </p>
            <p>
<a href="#defn_eval" class="evalFct">eval</a>( |D|(|G|), <a href="#defn_absSlice" class="absOp">Slice</a>(|L|, |offset|, |limit|), <var>Î¼<sub>ctx</sub></var> ) = <a href="#defn_algSlice" class="algFct">Slice</a>( <a href="#defn_eval" class="evalFct">eval</a>(|D|(|G|), |L|, <var>Î¼<sub>ctx</sub></var>), |offset|, |limit| )
            </p>
          </div>
        </section>
        <section id="sparqlBGPExtend">
          <h3>Extending SPARQL Basic Graph Matching</h3>
          <p>The overall SPARQL design can be used for queries which assume a more elaborate form of
            entailment than simple entailment, by re-writing the matching conditions for basic graph
            patterns. Since it is an open research problem to state such conditions in a single general
            form which applies to all forms of entailment and optimally eliminates needless or
            inappropriate redundancy, this document only gives necessary conditions which any such
            solution should satisfy. These will need to be extended to full definitions for each
            particular case.</p>
          <p>Basic graph patterns stand in the same relation to triple patterns that RDF graphs do to
            RDF triples, and much of the same terminology can be applied to them. In particular, two
            basic graph patterns are said to be <i>equivalent</i> if there is a bijection M between the
            terms of the triple patterns that maps blank nodes to blank nodes and maps variables,
            literals and IRIs to themselves, such that a triple ( s, p, o ) is in the first pattern if
            and only if the triple ( M(s), M(p), M(o) ) is in the second. This definition extends that
            for RDF graph equivalence to basic graph patterns by preserving variable names across
            equivalent patterns.</p>
          <p>An <i>entailment regime</i> specifies</p>
          <ol>
            <li>a subset of RDF graphs called <i>well-formed</i> for the regime</li>
            <li>an <i>entailment</i> relation between subsets of well-formed graphs and well-formed
              graphs.</li>
          </ol>
          <p>Detailed definitions for querying various entailment regimes can be found in
            [[[SPARQL11-ENTAILMENT]]].</p>
          <p>Some entailment regimes can categorize some RDF graphs as inconsistent. For example, the
            RDF graph:</p>
          <pre class="data nohighlight">
_:x rdf:type xsd:string .
_:x rdf:type xsd:decimal .
          </pre>
          <p>is D-inconsistent when D contains the XSD datatypes. The effect of a query on an
            inconsistent graph is not covered by this specification, but must be specified by the
            particular SPARQL extension.</p>
          <p>An entailment regime E must provide conditions on basic graph pattern evaluation such
            that for any basic graph pattern BGP, any RDF graph G, and any evaluation that satisfies
            the conditions, the resulting multiset of solutions is uniquely determined up to RDF graph
            equivalence. We denote the multiset of solutions from evaluating BGP over G using E with
            Eval-E(G, BGP).<br>
            An entailment regime must further satisfy the following conditions:</p>
          <ol>
            <li>For any E-consistent active graph AG, the entailment regime E uniquely specifies a
              <a href="#BGPsparqlBNodes">scoping graph</a> SG that is E-equivalent to AG.
            </li>
            <li>A set of well-formed graphs for E is specified such that, for any basic graph pattern
              BGP, scoping graph SG, and solution mapping Î¼ in Eval-E(SG, BGP), the graph Î¼(BGP) is
              well-formed for E.</li>
            <li>For any basic graph pattern BGP and scoping graph SG, if Î¼<sub>1</sub>, ...,
              Î¼<sub>n</sub> in Eval-E(SG, BGP) and BGP<sub>1</sub>, ..., BGP<sub>n</sub> are basic
              graph patterns all equivalent to BGP but not sharing any blank nodes with each other or
              with SG, then
              <blockquote>
                <p>SG E-entails (SG union Î¼<sub>1</sub>(BGP<sub>1</sub>) union ... union
                  Î¼<sub>n</sub>(BGP<sub>n</sub>))</p>
              </blockquote>
              <p>These conditions do not fully determine the set of possible answers, since RDF
                allows unlimited amounts of redundancy. In addition, therefore, the following must
                hold.</p>
            </li>
            <li>Entailment regimes should provide conditions to prevent trivial infinite solution
              multisets as appropriate to the regime.</li>
          </ol>
          <section id="sparqlBGPExtend-notes">
            <h4>Notes</h4>
            <p>(a) SG will often be graph equivalent to AG, but restricting this to E-equivalence
              allows some forms of normalization, for example elimination of semantic redundancies, to
              be applied to the source documents before querying.</p>
            <p>(b) The construction in condition 3 ensures that any blank nodes introduced by the
              solution mapping are used in a way which is internally consistent with the way that blank
              nodes occur in SG. This ensures that blank node identifiers occur in more than one answer
              in an answer set only when the blank nodes so identified are indeed identical in SG. If
              the extension does not allow bindings to blank nodes, then this condition can be
              simplified to the condition:</p>
            <blockquote>
              <p>SG E-entails Î¼(BGP) for each solution mapping Î¼.</p>
            </blockquote>
            <p>(c) These conditions do not impose the SPARQL requirement that SG shares no blank
              nodes with AG or BGP. In particular, it allows SG to actually be AG. This allows query
              protocols in which blank node identifiers retain their meaning between the query and the
              source document, or across multiple queries. Such protocols are not supported by the
              current SPARQL protocol specification, however.</p>
            <p>(d) Since conditions 1 to 3 are only necessary conditions on answers, condition 4
              allows cases where the set of legal answers can be restricted in various ways.</p>
            <p>(e) None of these conditions refer explicitly to instance mappings on blank nodes in
              BGP. For some entailment regimes, the existential interpretation of blank nodes cannot be
              fully captured by the existence of a single instance mapping. These conditions allow such
              regimes to give blank nodes in query patterns a 'fully existential' reading.</p>
            <p>It is straightforward to show that SPARQL satisfies these conditions for the case
              where E is simple entailment, given that the SPARQL condition on SG is that it is
              graph-equivalent to AG but shares no blank nodes with AG or BGP (which satisfies the
              first condition). The only condition which is nontrivial is (3).</p>
            <p>For every solution mapping Î¼<sub>i</sub>, there is, by definition of basic graph
              pattern matching, an RDF instance mapping Ïƒ<sub>i</sub> such that
              P<sub>i</sub>(BGP<sub>i</sub>) is a subgraph of SG where P<sub>i</sub> is the pattern
              instance mapping composed of Î¼<sub>i</sub> and Ïƒ<sub>i</sub>. Since BGP<sub>i</sub> and
              SG have no blank nodes in common, the ranges of Ïƒ<sub>i</sub> and Î¼<sub>i</sub> contain
              no blank nodes from BGP<sub>i</sub>; therefore, the solution mapping Î¼<sub>i</sub> and
              the RDF instance mapping Ïƒ<sub>i</sub> of P<sub>i</sub> commute, so
              P<sub>i</sub>(BGP<sub>i</sub>) = Ïƒ<sub>i</sub>(Î¼<sub>i</sub>(BGP<sub>i</sub>)). So</p>
            <p>P<sub>1</sub>(BGP<sub>1</sub>) union ... union P<sub>n</sub>(BGP<sub>n</sub>)<br>
              = Ïƒ<sub>1</sub>(Î¼<sub>1</sub>(BGP<sub>1</sub>)) union ... union
              Ïƒ<sub>n</sub>(Î¼<sub>n</sub>(BGP<sub>n</sub>))<br>
              = [ Ïƒ<sub>1</sub> + ... + Ïƒ<sub>n</sub>]( Î¼<sub>1</sub>(BGP<sub>1</sub>) union ... union
              Î¼<sub>n</sub>(BGP<sub>n</sub>) )</p>
            <p>since the domains of the Ïƒ<sub>i</sub> RDF instance mappings are all mutually
              exclusive. Since they are also exclusive from SG,</p>
            <p>SG union [ Ïƒ<sub>1</sub> + ... + Ïƒ<sub>n</sub>]( Î¼<sub>1</sub>(BGP<sub>1</sub>) union
              ... union Î¼<sub>n</sub>(BGP<sub>n</sub>) )<br>
              = [ Ïƒ<sub>1</sub> + ... + Ïƒ<sub>n</sub>](SG union Î¼<sub>1</sub>(BGP<sub>1</sub>) union
              ... union Î¼<sub>n</sub>(BGP<sub>n</sub>) )</p>
            <p>i.e.</p>
            <p>SG union Î¼<sub>1</sub>(BGP<sub>1</sub>) union ... union
              Î¼<sub>n</sub>(BGP<sub>n</sub>)</p>
            <p>has an instance which is a subgraph of SG, so is simply entailed by SG by the
              <a data-cite="RDF12-SEMANTICS#dfn-interpolation">RDF interpolation lemma</a> [[RDF12-SEMANTICS]].</p>
          </section>
        </section>
      </section>
    </section>

    <section id="grammar">
      <h2>SPARQL Grammar</h2>
      <p>The SPARQL grammar covers both SPARQL Query and [[[SPARQL11-UPDATE]]].</p>
      <section id="queryString">
        <h3>SPARQL String</h3>
        <p>
          <span id="defn_SPARQLRequestString"></span>
          A <dfn>SPARQL string</dfn> is an
          <a data-cite="RDF12-CONCEPTS#dfn-rdf-string">RDF string</a> that
          conforms to the grammar given in this section.
        </p>
        <p class="note">
          An <a data-cite="RDF12-CONCEPTS#dfn-rdf-string">RDF string</a> is
          a sequence of 
          <a data-cite="I18N-GLOSSARY#dfn-code-point" class="lint-ignore">Unicode code points</a>
          which are <a data-cite="I18N-GLOSSARY#dfn-scalar-value" class="lint-ignore">Unicode scalar values</a>.
          Unicode scalar values do not include the
          <a data-cite="I18N-GLOSSARY#dfn-surrogate" class="lint-ignore">surrogate code points</a>.
        </p>
        <p>
          <span id="defn_SPARQLQueryString"></span>
          A <dfn>SPARQL query string</dfn> is a
          <a>SPARQL string</a> that conforms to the grammar starting at 
          the <a href="#rQueryUnit">QueryUnit</a> production.
        </p>
        <p>
          <span id="defn_SPARQLUpdateString"></span>
          A <dfn>SPARQL update string</dfn> is a 
          <a>SPARQL string</a> that conforms to the grammar starting at 
          the <a href="#rUpdateUnit">UpdateUnit</a> production.
        </p>
        <p>
          For compatibility with future versions of Unicode, the characters in this string may
          include Unicode codepoints that are unassigned as of the date of this publication (see
          [[[UAX31]]] [[UAX31]] section 4 Pattern Syntax). For productions with excluded character
          classes (for example <code>[^&lt;&gt;'{}|^`]</code>), the characters are excluded from the
          range <code>#x0 - #x10FFFF</code>.
        </p>
      </section>

      <section id="codepointEscape">
        <h3>Codepoint Escape Sequences</h3>
        <p>
          A <a>SPARQL string</a> is processed for codepoint escape sequences before parsing by the
          grammar defined in EBNF below. The codepoint escape sequences for a SPARQL query string
          are:
        </p>
        <span class="doc-ref" id="table68"></span>
        <table title="Codepoint escapes">
          <colgroup>
            <col style="width: 40%">
            <col>
          </colgroup>
          <tbody>
            <tr>
              <th class="major">Escape</th>
              <th class="major">Unicode code point</th>
            </tr>
            <tr>
              <td>
                <span class="token">'\u'</span> <a href="#HEX">HEX</a> <a href="#HEX">HEX</a>
                <a href="#HEX">HEX</a> <a href="#HEX">HEX</a>
              </td>
              <td>A Unicode code point in the range U+0 to U+FFFF inclusive corresponding to the
                encoded hexadecimal value, excluding U+D800 to U+DFFF, the 
                <a data-cite="I18N-GLOSSARY#dfn-surrogate">surrogate code points</a>.
              </td>
            </tr>
            <tr>
              <td>
                <span class="token">'\U'</span> <a href="#HEX">HEX</a> <a href="#HEX">HEX</a>
                <a href="#HEX">HEX</a> <a href="#HEX">HEX</a> <a href="#HEX">HEX</a> <a href="#HEX">HEX</a> <a href="#HEX">HEX</a> <a href="#HEX">HEX</a>
              </td>
              <td>A Unicode code point in the range U+0 to U+10FFFF inclusive corresponding to the
                encoded hexadecimal value, excluding U+D800 to U+DFFF, the 
                <a data-cite="I18N-GLOSSARY#dfn-surrogate">surrogate code points</a>.
                
            </tr>
          </tbody>
        </table>
        <p>where <a href="#HEX">HEX</a> is a hexadecimal character</p>
        <blockquote>
          <p><code><span class="doc-ref" id="HEX">HEX</span> ::= [0-9] | [A-F] | [a-f]</code></p>
        </blockquote>
        <p>Examples:</p>
        <pre class="query nohighlight">
          &lt;ab\u00E9xy&gt;        # Codepoint 00E9 is Latin small e with acute - Ã©
          \u03B1:a            # Codepoint x03B1 is Greek small alpha - Î±
          a\u003Ab            # a:b -- codepoint x3A is colon</pre>
        <p>
          Codepoint escape sequences can appear anywhere in the query string. They are processed
          before parsing based on the grammar rules and so may be replaced by codepoints with
          significance in the grammar, such as "<code>:</code>" marking a prefixed name.
        </p>
        <p>These escape sequences are not included in the grammar below. Only escape sequences for
          characters that would be legal at that point in the grammar may be given. For example, the
          variable "<code>?x\u0020y</code>" is not legal (<code>\u0020</code> is a space and is not
          permitted in a variable name).
        </p>
      </section>
      <section id="whitespace">
        <h3>White Space</h3>
        <p>White space (production <code><a href="#rWS">WS</a></code>) is used to separate two
          terminals which would otherwise be (mis-)recognized as one terminal. Rule names below in
          capitals indicate where white space is significant; these form a possible choice of
          terminals for constructing a SPARQL parser. White space is significant in strings.
          Otherwise, white space is ignored between tokens.</p>
        <p>For example:</p>
        <blockquote>
          <p><code>?a&lt;?b&amp;&amp;?c&gt;?d</code></p>
        </blockquote>
        <p>is the token sequence variable '<code>?a</code>', an IRI
          '<code>&lt;?b&amp;&amp;?c&gt;</code>', and variable '<code>?d</code>', not an expression
          involving the operator '<code>&amp;&</code>' connecting two expression using
          '<code>&lt;</code>' (less than) and '<code>&gt;</code>' (greater than).</p>
      </section>
      <section id="grammarComments">
        <h3>Comments</h3>
        <p>Comments in SPARQL queries take the form of '<code>#</code>', outside an IRI or string,
          and continue to the end of line (marked by characters <code>0x0D</code> or
          <code>0x0A</code>) or end of file if there is no end of line after the comment marker.
          Comments are treated as white space.</p>
      </section>
      <section id="iriRefs">
        <h3>IRI References</h3>
        <p>Text matched by the <code><a href="#rIRIREF">IRIREF</a></code> production and
          <code><a href="#rPrefixedName">PrefixedName</a></code> (after prefix expansion) production,
          after escape processing, must conform to the generic syntax of IRI references in section
          2.2 of RFC 3987 "ABNF for IRI References and IRIs" [[RFC3987]]. For example, the
          <code><a href="#rIRIREF">IRIREF</a></code> <code>&lt;abc#def&gt;</code> may occur in a
          SPARQL query string, but the <code><a href="#rIRIREF">IRIREF</a></code>
          <code>&lt;abc##def&gt;</code> must not.</p>
        <p>Base IRIs declared with the <span class="token">BASE</span> keyword must be absolute
          IRIs. A prefix declared with the <span class="token">PREFIX</span> keyword may not be
          re-declared in the same query. See section 4.1.1, 
          <a href="#QSynIRI">Syntax of IRI Terms</a>, for a description of <span class="token">BASE</span> and
          <span class="token">PREFIX</span>.</p>
      </section>
      <section id="grammarBNodes">
        <h3>Blank Nodes and Blank Node Identifiers</h3>
        <p>Blank nodes can not be used in:</p>
        <ul>
          <li><code><a href="#rDeleteWhere">DELETE WHERE</a></code></li>
          <li><code><a href="#rDeleteData">DELETE DATA</a></code></li>
          <li>a <code><a href="#rDeleteClause">DeleteClause</a></code></li>
        </ul>
        <p>in a <a data-cite="SPARQL11-UPDATE#terminology">SPARQL update
            request</a>.
        </p>
        <p>
          <a data-cite="RDF12-CONCEPTS#dfn-blank-node-identifier">Blank node identifiers</a>
          are scoped to the <a>SPARQL string</a> in which they occur.
          Different uses of the same blank node identifier in a request
          string refer to the same blank node. Fresh blank nodes are generated for each request;
          blank nodes can not be referenced by identifier across requests.</p>
        <p>The same blank node identifier can not be used in:</p>
        <ul>
          <li>two separate basic graph patterns in a SPARQL Query</li>
          <li>two <code><a href="#rModify">WHERE</a></code> clauses within a single SPARQL update
            request</li>
          <li>two <code><a href="#rInsertData">INSERT DATA</a></code> operations within a single
            SPARQL update request</li>
        </ul>
        <p>Note that the same blank node identifier can occur in different
          <a href="#rQuadPattern">QuadPattern</a> clauses in a [[[SPARQL11-UPDATE]]] request.</p>
      </section>
      <section id="grammarEscapes">
        <h3>Escape sequences in strings</h3>
        <p>In addition to the <a href="#codepointEscape">codepoint escape sequences</a>, the
          following escape sequences apply to any <code><a href="#rString">string</a></code> production (e.g.
          <code><a href="#rSTRING_LITERAL1">STRING_LITERAL1</a></code>,
          <code><a href="#rSTRING_LITERAL2">STRING_LITERAL2</a></code>,
          <code><a href="#rSTRING_LITERAL_LONG1">STRING_LITERAL_LONG1</a></code>,
          <code><a href="#rSTRING_LITERAL_LONG2">STRING_LITERAL_LONG2</a></code>):</p>
        <table title="String escapes">
          <colgroup>
            <col style="width: 40%">
            <col>
          </colgroup>
          <tbody>
            <tr>
              <th class="major">Escape</th>
              <th class="major">Unicode code point</th>
            </tr>
            <tr>
              <td><span class="token">'\t'</span></td>
              <td>U+0009 (tab)</td>
            </tr>
            <tr>
              <td><span class="token">'\n'</span></td>
              <td>U+000A (line feed)</td>
            </tr>
            <tr>
              <td><span class="token">'\r'</span></td>
              <td>U+000D (carriage return)</td>
            </tr>
            <tr>
              <td><span class="token">'\b'</span></td>
              <td>U+0008 (backspace)</td>
            </tr>
            <tr>
              <td><span class="token">'\f'</span></td>
              <td>U+000C (form feed)</td>
            </tr>
            <tr>
              <td><span class="token">'\"'</span></td>
              <td>U+0022 (quotation mark, double quote mark)</td>
            </tr>
            <tr>
              <td><span class="token">"\'"</span></td>
              <td>U+0027 (apostrophe-quote, single quote mark)</td>
            </tr>
            <tr>
              <td><span class="token">'\\'</span></td>
              <td>U+005C (backslash)</td>
            </tr>
          </tbody>
        </table>
        <p>Examples:</p>
        <pre class="query nohighlight">
          "abc\n"
          "xy\rz"
          'xy\tz'
        </pre>
      </section>
      <section id="sparqlGrammar">
        <h3>Grammar</h3>
        <p>The EBNF notation used in the grammar is defined in 
          Extensible Markup Language (XML) 1.1 
          [[XML11]] 
          section 6 <a data-cite="xml11#sec-notation">Notation</a>.</p>
        <p>Notes:</p>
        <ol>
          <li>Keywords are matched in a case-insensitive manner with the exception of
            the keyword '<code>a</code>'  which, in line with Turtle and N3, is used
            in place of the IRI <code>rdf:type</code>
            (in full, <code><a href="http://www.w3.org/1999/02/22-rdf-syntax-ns#type">http://www.w3.org/1999/02/22-rdf-syntax-ns#type</a></code>).</li>
          <li>Escape sequences are case sensitive.</li>
          <li>When tokenizing the input and choosing grammar rules, the longest match is chosen.</li>
          <li>The SPARQL grammar is LL(1) when the rules with uppercased names are used as terminals.</li>
          <li>There are two entry points into the grammar: <code>QueryUnit</code> for the SPARQL query language
            and <code>UpdateUnit</code> for the SPARQL update language.</li>
          <li>In signed numbers, no white space is allowed between the sign and the number.
            The <code><a href="#rAdditiveExpression">AdditiveExpression</a></code> grammar rule allows for this by
            covering the two cases of an expression followed by a signed number. These 
            produce an addition or subtraction of the unsigned number as appropriate.</li>
          <li>The tokens <code><a href="#rInsertData">INSERT DATA</a></code>, 
            <code><a href="#rDeleteData">DELETE DATA</a></code> and 
            <code><a href="#rDeleteWhere">DELETE WHERE</a></code> allow any amount of white space between the words.
            The single space version is used in the grammar for clarity.</li>
          <li>The <code><a href="#rQuadData">QuadData</a></code> and 
            <code><a href="#rQuadPattern">QuadPattern</a></code> 
            rules both use rule <code><a href="#rQuads">Quads</a></code>. The rule
            <code><a href="#rQuadData">QuadData</a></code>, used in 
            <a href="#rInsertData"><code>INSERTDATA</code></a> and 
            <a href="#rDeleteData"><code>DELETE DATA</code></a>, 
            must not allow variables in the quad patterns.</li>
          <li>Blank node syntax is not allowed in <code><a href="#rDeleteWhere">DELETE WHERE</a></code>,
            the <code><a href="#rDeleteClause">DeleteClause</a></code> for 
            <code>DELETE</code>,
            nor in <code><a href="#rDeleteData">DELETE DATA</a></code>.</li>
          <li>Rules for limiting the use of blank node identifiers are given in <a href="#grammarBNodes">section 19.6</a>.</li>
          <li>The number of variables in the variable list of a <code>VALUES</code> block 
            must be the same as the number of each list of associated values in the <code>DataBlock</code>.</li>
          <li>Variables in the variable list of a <code>VALUES</code> block must be unique within that list.</li>
          <li>Variables introduced by <code>AS</code> in a <code>SELECT</code> clause
            must not already be <a href="#variableScope">in-scope</a>.</li>
          <li>The variable assigned in a <code>BIND</code> clause must not be already 
            in-use within the immediately preceding <code><a href="#rTriplesBlock">TriplesBlock</a></code> within a
            <code><a href="#rGroupGraphPattern">GroupGraphPattern</a></code>.</li>
          <li>Aggregate functions can be one of the 
            <a href="#rAggregate">built-in keywords for aggregates</a> 
            or a custom aggregate, which is syntactically a <a href="#rFunctionCall">function
              call</a>. Aggregate functions may only be used in 
            <a href="#rSelectClause">SELECT</a>, <a href="#rHavingClause">HAVING</a>
            and <a href="#rOrderClause">ORDER BY</a> clauses.</li>
          <li>The expression argument of an aggregate function can not contain an aggregate function.</li>
          <li>Only custom aggregate functions use the <code>DISTINCT</code> keyword
            in a <a href="#rFunctionCall">function call</a>.</li>
          <li>A <a href="#rReifier">reifier</a> or
            <a href="#rAnnotationBlockPath">annotation syntax</a>
            is only permitted after a triple when the property position is
            a simple path (an IRI, the keyword <code>a</code>, or a variable),
            and not for other path expressions.
          </li>
        </ol>

        <!-- GRAMMAR -->
        <div class="grammarTable">
          <table><tbody>

              <tr style="vertical-align: baseline">
                <td><code>[1]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rQueryUnit">QueryUnit</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rQuery">Query</a> <span class="token"></span></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[2]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rQuery">Query</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rPrologue">Prologue</a><br/>( <a href="#rSelectQuery">SelectQuery</a> | <a href="#rConstructQuery">ConstructQuery</a> | <a href="#rDescribeQuery">DescribeQuery</a> | <a href="#rAskQuery">AskQuery</a> )<br/><a href="#rValuesClause">ValuesClause</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[3]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rUpdateUnit">UpdateUnit</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rUpdate">Update</a> <span class="token"></span></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[4]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rPrologue">Prologue</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody">( <a href="#rBaseDecl">BaseDecl</a> | <a href="#rPrefixDecl">PrefixDecl</a> | <a href="#rVersionDecl">VersionDecl</a> )*</code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[5]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rBaseDecl">BaseDecl</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'BASE'</span> <a href="#rIRIREF">IRIREF</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[6]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rPrefixDecl">PrefixDecl</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'PREFIX'</span> <a href="#rPNAME_NS">PNAME_NS</a> <a href="#rIRIREF">IRIREF</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[7]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rVersionDecl">VersionDecl</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'VERSION'</span> <a href="#rVersionSpecifier">VersionSpecifier</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[8]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rVersionSpecifier">VersionSpecifier</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rSTRING_LITERAL1">STRING_LITERAL1</a> | <a href="#rSTRING_LITERAL2">STRING_LITERAL2</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[9]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rSelectQuery">SelectQuery</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rSelectClause">SelectClause</a> <a href="#rDatasetClause">DatasetClause</a>* <a href="#rWhereClause">WhereClause</a> <a href="#rSolutionModifier">SolutionModifier</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[10]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rSubSelect">SubSelect</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rSelectClause">SelectClause</a> <a href="#rWhereClause">WhereClause</a> <a href="#rSolutionModifier">SolutionModifier</a> <a href="#rValuesClause">ValuesClause</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[11]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rSelectClause">SelectClause</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'SELECT'</span> ( <span class="token">'DISTINCT'</span> | <span class="token">'REDUCED'</span> )? ( ( <a href="#rVar">Var</a> | ( <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">'AS'</span> <a href="#rVar">Var</a> <span class="token">')'</span> ) )+ | <span class="token">'*'</span> )</code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[12]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rConstructQuery">ConstructQuery</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'CONSTRUCT'</span> ( <a href="#rConstructTemplate">ConstructTemplate</a> <a href="#rDatasetClause">DatasetClause</a>* <a href="#rWhereClause">WhereClause</a> <a href="#rSolutionModifier">SolutionModifier</a> | <a href="#rDatasetClause">DatasetClause</a>* <span class="token">'WHERE'</span> <span class="token">'{'</span> <a href="#rTriplesTemplate">TriplesTemplate</a>? <span class="token">'}'</span> <a href="#rSolutionModifier">SolutionModifier</a> )</code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[13]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rDescribeQuery">DescribeQuery</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'DESCRIBE'</span> ( <a href="#rVarOrIri">VarOrIri</a>+ | <span class="token">'*'</span> ) <a href="#rDatasetClause">DatasetClause</a>* <a href="#rWhereClause">WhereClause</a>? <a href="#rSolutionModifier">SolutionModifier</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[14]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rAskQuery">AskQuery</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'ASK'</span> <a href="#rDatasetClause">DatasetClause</a>* <a href="#rWhereClause">WhereClause</a> <a href="#rSolutionModifier">SolutionModifier</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[15]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rDatasetClause">DatasetClause</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'FROM'</span> ( <a href="#rDefaultGraphClause">DefaultGraphClause</a> | <a href="#rNamedGraphClause">NamedGraphClause</a> )</code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[16]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rDefaultGraphClause">DefaultGraphClause</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rSourceSelector">SourceSelector</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[17]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rNamedGraphClause">NamedGraphClause</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'NAMED'</span> <a href="#rSourceSelector">SourceSelector</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[18]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rSourceSelector">SourceSelector</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#riri">iri</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[19]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rWhereClause">WhereClause</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'WHERE'</span>? <a href="#rGroupGraphPattern">GroupGraphPattern</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[20]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rSolutionModifier">SolutionModifier</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rGroupClause">GroupClause</a>? <a href="#rHavingClause">HavingClause</a>? <a href="#rOrderClause">OrderClause</a>? <a href="#rLimitOffsetClauses">LimitOffsetClauses</a>?</code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[21]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rGroupClause">GroupClause</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'GROUP'</span> <span class="token">'BY'</span> <a href="#rGroupCondition">GroupCondition</a>+</code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[22]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rGroupCondition">GroupCondition</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rBuiltInCall">BuiltInCall</a> | <a href="#rFunctionCall">FunctionCall</a> | <span class="token">'('</span> <a href="#rExpression">Expression</a> ( <span class="token">'AS'</span> <a href="#rVar">Var</a> )? <span class="token">')'</span> | <a href="#rVar">Var</a> </code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[23]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rHavingClause">HavingClause</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'HAVING'</span> <a href="#rHavingCondition">HavingCondition</a>+</code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[24]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rHavingCondition">HavingCondition</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rConstraint">Constraint</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[25]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rOrderClause">OrderClause</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'ORDER'</span> <span class="token">'BY'</span> <a href="#rOrderCondition">OrderCondition</a>+</code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[26]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rOrderCondition">OrderCondition</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody">   ( ( <span class="token">'ASC'</span> | <span class="token">'DESC'</span> ) <a href="#rBrackettedExpression">BrackettedExpression</a> )<br/>| ( <a href="#rConstraint">Constraint</a> | <a href="#rVar">Var</a> ) </code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[27]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rLimitOffsetClauses">LimitOffsetClauses</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rLimitClause">LimitClause</a> <a href="#rOffsetClause">OffsetClause</a>? | <a href="#rOffsetClause">OffsetClause</a> <a href="#rLimitClause">LimitClause</a>? </code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[28]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rLimitClause">LimitClause</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'LIMIT'</span> <a href="#rINTEGER">INTEGER</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[29]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rOffsetClause">OffsetClause</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'OFFSET'</span> <a href="#rINTEGER">INTEGER</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[30]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rValuesClause">ValuesClause</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody">( <span class="token">'VALUES'</span> <a href="#rDataBlock">DataBlock</a> )?</code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[31]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rUpdate">Update</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rPrologue">Prologue</a> ( <a href="#rUpdate1">Update1</a> ( <span class="token">';'</span> <a href="#rUpdate">Update</a> )? )?</code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[32]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rUpdate1">Update1</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rLoad">Load</a> | <a href="#rClear">Clear</a> | <a href="#rDrop">Drop</a> | <a href="#rAdd">Add</a> | <a href="#rMove">Move</a> | <a href="#rCopy">Copy</a> | <a href="#rCreate">Create</a> | <a href="#rDeleteWhere">DeleteWhere</a> | <a href="#rModify">Modify</a> | <a href="#rInsertData">InsertData</a> | <a href="#rDeleteData">DeleteData</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[33]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rLoad">Load</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'LOAD'</span> <span class="token">'SILENT'</span>? <a href="#riri">iri</a> ( <span class="token">'INTO'</span> <a href="#rGraphRef">GraphRef</a> )?</code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[34]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rClear">Clear</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'CLEAR'</span> <span class="token">'SILENT'</span>? <a href="#rGraphRefAll">GraphRefAll</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[35]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rDrop">Drop</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'DROP'</span> <span class="token">'SILENT'</span>? <a href="#rGraphRefAll">GraphRefAll</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[36]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rCreate">Create</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'CREATE'</span> <span class="token">'SILENT'</span>? <a href="#rGraphRef">GraphRef</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[37]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rAdd">Add</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'ADD'</span> <span class="token">'SILENT'</span>? <a href="#rGraphOrDefault">GraphOrDefault</a> <span class="token">'TO'</span> <a href="#rGraphOrDefault">GraphOrDefault</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[38]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rMove">Move</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'MOVE'</span> <span class="token">'SILENT'</span>? <a href="#rGraphOrDefault">GraphOrDefault</a> <span class="token">'TO'</span> <a href="#rGraphOrDefault">GraphOrDefault</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[39]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rCopy">Copy</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'COPY'</span> <span class="token">'SILENT'</span>? <a href="#rGraphOrDefault">GraphOrDefault</a> <span class="token">'TO'</span> <a href="#rGraphOrDefault">GraphOrDefault</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[40]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rInsertData">InsertData</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'INSERT DATA'</span> <a href="#rQuadData">QuadData</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[41]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rDeleteData">DeleteData</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'DELETE DATA'</span> <a href="#rQuadData">QuadData</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[42]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rDeleteWhere">DeleteWhere</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'DELETE WHERE'</span> <a href="#rQuadPattern">QuadPattern</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[43]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rModify">Modify</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody">( <span class="token">'WITH'</span> <a href="#riri">iri</a> )? ( <a href="#rDeleteClause">DeleteClause</a> <a href="#rInsertClause">InsertClause</a>? | <a href="#rInsertClause">InsertClause</a> ) <a href="#rUsingClause">UsingClause</a>* <span class="token">'WHERE'</span> <a href="#rGroupGraphPattern">GroupGraphPattern</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[44]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rDeleteClause">DeleteClause</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'DELETE'</span> <a href="#rQuadPattern">QuadPattern</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[45]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rInsertClause">InsertClause</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'INSERT'</span> <a href="#rQuadPattern">QuadPattern</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[46]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rUsingClause">UsingClause</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'USING'</span> ( <a href="#riri">iri</a> | <span class="token">'NAMED'</span> <a href="#riri">iri</a> )</code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[47]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rGraphOrDefault">GraphOrDefault</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'DEFAULT'</span> | <span class="token">'GRAPH'</span>? <a href="#riri">iri</a> </code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[48]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rGraphRef">GraphRef</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'GRAPH'</span> <a href="#riri">iri</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[49]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rGraphRefAll">GraphRefAll</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rGraphRef">GraphRef</a> | <span class="token">'DEFAULT'</span> | <span class="token">'NAMED'</span> | <span class="token">'ALL'</span></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[50]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rQuadPattern">QuadPattern</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'{'</span> <a href="#rQuads">Quads</a> <span class="token">'}'</span></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[51]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rQuadData">QuadData</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'{'</span> <a href="#rQuads">Quads</a> <span class="token">'}'</span></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[52]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rQuads">Quads</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rTriplesTemplate">TriplesTemplate</a>? ( <a href="#rQuadsNotTriples">QuadsNotTriples</a> <span class="token">'.'</span>? <a href="#rTriplesTemplate">TriplesTemplate</a>? )*</code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[53]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rQuadsNotTriples">QuadsNotTriples</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'GRAPH'</span> <a href="#rVarOrIri">VarOrIri</a> <span class="token">'{'</span> <a href="#rTriplesTemplate">TriplesTemplate</a>? <span class="token">'}'</span></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[54]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rTriplesTemplate">TriplesTemplate</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rTriplesSameSubject">TriplesSameSubject</a> ( <span class="token">'.'</span> <a href="#rTriplesTemplate">TriplesTemplate</a>? )?</code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[55]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rGroupGraphPattern">GroupGraphPattern</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'{'</span> ( <a href="#rSubSelect">SubSelect</a> | <a href="#rGroupGraphPatternSub">GroupGraphPatternSub</a> ) <span class="token">'}'</span></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[56]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rGroupGraphPatternSub">GroupGraphPatternSub</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rTriplesBlock">TriplesBlock</a>? ( <a href="#rGraphPatternNotTriples">GraphPatternNotTriples</a> <span class="token">'.'</span>? <a href="#rTriplesBlock">TriplesBlock</a>? )*</code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[57]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rTriplesBlock">TriplesBlock</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rTriplesSameSubjectPath">TriplesSameSubjectPath</a> ( <span class="token">'.'</span> <a href="#rTriplesBlock">TriplesBlock</a>? )?</code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[58]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rReifiedTripleBlock">ReifiedTripleBlock</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rReifiedTriple">ReifiedTriple</a> <a href="#rPropertyList">PropertyList</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[59]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rReifiedTripleBlockPath">ReifiedTripleBlockPath</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rReifiedTriple">ReifiedTriple</a> <a href="#rPropertyListPath">PropertyListPath</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[60]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rGraphPatternNotTriples">GraphPatternNotTriples</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rGroupOrUnionGraphPattern">GroupOrUnionGraphPattern</a> | <a href="#rOptionalGraphPattern">OptionalGraphPattern</a> | <a href="#rMinusGraphPattern">MinusGraphPattern</a> | <a href="#rGraphGraphPattern">GraphGraphPattern</a> | <a href="#rServiceGraphPattern">ServiceGraphPattern</a> | <a href="#rFilter">Filter</a> | <a href="#rBind">Bind</a> | <a href="#rInlineData">InlineData</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[61]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rOptionalGraphPattern">OptionalGraphPattern</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'OPTIONAL'</span> <a href="#rGroupGraphPattern">GroupGraphPattern</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[62]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rGraphGraphPattern">GraphGraphPattern</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'GRAPH'</span> <a href="#rVarOrIri">VarOrIri</a> <a href="#rGroupGraphPattern">GroupGraphPattern</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[63]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rServiceGraphPattern">ServiceGraphPattern</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'SERVICE'</span> <span class="token">'SILENT'</span>? <a href="#rVarOrIri">VarOrIri</a> <a href="#rGroupGraphPattern">GroupGraphPattern</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[64]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rBind">Bind</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'BIND'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">'AS'</span> <a href="#rVar">Var</a> <span class="token">')'</span></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[65]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rInlineData">InlineData</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'VALUES'</span> <a href="#rDataBlock">DataBlock</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[66]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rDataBlock">DataBlock</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rInlineDataOneVar">InlineDataOneVar</a> | <a href="#rInlineDataFull">InlineDataFull</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[67]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rInlineDataOneVar">InlineDataOneVar</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rVar">Var</a> <span class="token">'{'</span> <a href="#rDataBlockValue">DataBlockValue</a>* <span class="token">'}'</span></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[68]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rInlineDataFull">InlineDataFull</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody">( <a href="#rNIL">NIL</a> | <span class="token">'('</span> <a href="#rVar">Var</a>* <span class="token">')'</span> ) <span class="token">'{'</span> ( <span class="token">'('</span> <a href="#rDataBlockValue">DataBlockValue</a>* <span class="token">')'</span> | <a href="#rNIL">NIL</a> )* <span class="token">'}'</span></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[69]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rDataBlockValue">DataBlockValue</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#riri">iri</a> |	<a href="#rRDFLiteral">RDFLiteral</a> |	<a href="#rNumericLiteral">NumericLiteral</a> |	<a href="#rBooleanLiteral">BooleanLiteral</a> |	<span class="token">'UNDEF'</span> |	<a href="#rTripleTermData">TripleTermData</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[70]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rReifier">Reifier</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'~'</span> <a href="#rVarOrReifierId">VarOrReifierId</a>?</code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[71]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rVarOrReifierId">VarOrReifierId</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rVar">Var</a> | <a href="#riri">iri</a> | <a href="#rBlankNode">BlankNode</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[72]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rMinusGraphPattern">MinusGraphPattern</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'MINUS'</span> <a href="#rGroupGraphPattern">GroupGraphPattern</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[73]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rGroupOrUnionGraphPattern">GroupOrUnionGraphPattern</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rGroupGraphPattern">GroupGraphPattern</a> ( <span class="token">'UNION'</span> <a href="#rGroupGraphPattern">GroupGraphPattern</a> )*</code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[74]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rFilter">Filter</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'FILTER'</span> <a href="#rConstraint">Constraint</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[75]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rConstraint">Constraint</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rBrackettedExpression">BrackettedExpression</a> | <a href="#rBuiltInCall">BuiltInCall</a> | <a href="#rFunctionCall">FunctionCall</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[76]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rFunctionCall">FunctionCall</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#riri">iri</a> <a href="#rArgList">ArgList</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[77]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rArgList">ArgList</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rNIL">NIL</a> | <span class="token">'('</span> <span class="token">'DISTINCT'</span>? <a href="#rExpression">Expression</a> ( <span class="token">','</span> <a href="#rExpression">Expression</a> )* <span class="token">')'</span> </code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[78]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rExpressionList">ExpressionList</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rNIL">NIL</a> | <span class="token">'('</span> <a href="#rExpression">Expression</a> ( <span class="token">','</span> <a href="#rExpression">Expression</a> )* <span class="token">')'</span> </code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[79]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rConstructTemplate">ConstructTemplate</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'{'</span> <a href="#rConstructTriples">ConstructTriples</a>? <span class="token">'}'</span></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[80]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rConstructTriples">ConstructTriples</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rTriplesSameSubject">TriplesSameSubject</a> ( <span class="token">'.'</span> <a href="#rConstructTriples">ConstructTriples</a>? )?</code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[81]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rTriplesSameSubject">TriplesSameSubject</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rVarOrTerm">VarOrTerm</a> <a href="#rPropertyListNotEmpty">PropertyListNotEmpty</a> |	<a href="#rTriplesNode">TriplesNode</a> <a href="#rPropertyList">PropertyList</a> |	<a href="#rReifiedTripleBlock">ReifiedTripleBlock</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[82]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rPropertyList">PropertyList</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rPropertyListNotEmpty">PropertyListNotEmpty</a>?</code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[83]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rPropertyListNotEmpty">PropertyListNotEmpty</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rVerb">Verb</a> <a href="#rObjectList">ObjectList</a> ( <span class="token">';'</span> ( <a href="#rVerb">Verb</a> <a href="#rObjectList">ObjectList</a> )? )*</code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[84]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rVerb">Verb</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rVarOrIri">VarOrIri</a> | <span class="token">'a'</span></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[85]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rObjectList">ObjectList</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rObject">Object</a> ( <span class="token">','</span> <a href="#rObject">Object</a> )*</code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[86]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rObject">Object</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rGraphNode">GraphNode</a> <a href="#rAnnotation">Annotation</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[87]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rTriplesSameSubjectPath">TriplesSameSubjectPath</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rVarOrTerm">VarOrTerm</a> <a href="#rPropertyListPathNotEmpty">PropertyListPathNotEmpty</a> |	<a href="#rTriplesNodePath">TriplesNodePath</a> <a href="#rPropertyListPath">PropertyListPath</a> |	<a href="#rReifiedTripleBlockPath">ReifiedTripleBlockPath</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[88]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rPropertyListPath">PropertyListPath</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rPropertyListPathNotEmpty">PropertyListPathNotEmpty</a>?</code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[89]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rPropertyListPathNotEmpty">PropertyListPathNotEmpty</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody">( <a href="#rVerbPath">VerbPath</a> | <a href="#rVerbSimple">VerbSimple</a> ) <a href="#rObjectListPath">ObjectListPath</a> ( <span class="token">';'</span> ( ( <a href="#rVerbPath">VerbPath</a> | <a href="#rVerbSimple">VerbSimple</a> ) <a href="#rObjectListPath">ObjectListPath</a> )? )*</code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[90]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rVerbPath">VerbPath</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rPath">Path</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[91]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rVerbSimple">VerbSimple</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rVar">Var</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[92]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rObjectListPath">ObjectListPath</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rObjectPath">ObjectPath</a> ( <span class="token">','</span> <a href="#rObjectPath">ObjectPath</a> )*</code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[93]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rObjectPath">ObjectPath</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rGraphNodePath">GraphNodePath</a> <a href="#rAnnotationPath">AnnotationPath</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[94]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rPath">Path</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rPathAlternative">PathAlternative</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[95]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rPathAlternative">PathAlternative</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rPathSequence">PathSequence</a> ( <span class="token">'|'</span> <a href="#rPathSequence">PathSequence</a> )*</code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[96]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rPathSequence">PathSequence</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rPathEltOrInverse">PathEltOrInverse</a> ( <span class="token">'/'</span> <a href="#rPathEltOrInverse">PathEltOrInverse</a> )*</code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[97]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rPathElt">PathElt</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rPathPrimary">PathPrimary</a> <a href="#rPathMod">PathMod</a>?</code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[98]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rPathEltOrInverse">PathEltOrInverse</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rPathElt">PathElt</a> | <span class="token">'^'</span> <a href="#rPathElt">PathElt</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[99]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rPathMod">PathMod</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'?'</span> | <span class="token">'*'</span> | <span class="token">'+'</span></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[100]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rPathPrimary">PathPrimary</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#riri">iri</a> | <span class="token">'a'</span> | <span class="token">'!'</span> <a href="#rPathNegatedPropertySet">PathNegatedPropertySet</a> | <span class="token">'('</span> <a href="#rPath">Path</a> <span class="token">')'</span> </code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[101]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rPathNegatedPropertySet">PathNegatedPropertySet</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rPathOneInPropertySet">PathOneInPropertySet</a> | <span class="token">'('</span> ( <a href="#rPathOneInPropertySet">PathOneInPropertySet</a> ( <span class="token">'|'</span> <a href="#rPathOneInPropertySet">PathOneInPropertySet</a> )* )? <span class="token">')'</span> </code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[102]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rPathOneInPropertySet">PathOneInPropertySet</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#riri">iri</a> | <span class="token">'a'</span> | <span class="token">'^'</span> ( <a href="#riri">iri</a> | <span class="token">'a'</span> ) </code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[103]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rTriplesNode">TriplesNode</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rCollection">Collection</a> |	<a href="#rBlankNodePropertyList">BlankNodePropertyList</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[104]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rBlankNodePropertyList">BlankNodePropertyList</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'['</span> <a href="#rPropertyListNotEmpty">PropertyListNotEmpty</a> <span class="token">']'</span></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[105]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rTriplesNodePath">TriplesNodePath</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rCollectionPath">CollectionPath</a> |	<a href="#rBlankNodePropertyListPath">BlankNodePropertyListPath</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[106]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rBlankNodePropertyListPath">BlankNodePropertyListPath</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'['</span> <a href="#rPropertyListPathNotEmpty">PropertyListPathNotEmpty</a> <span class="token">']'</span></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[107]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rCollection">Collection</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'('</span> <a href="#rGraphNode">GraphNode</a>+ <span class="token">')'</span></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[108]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rCollectionPath">CollectionPath</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'('</span> <a href="#rGraphNodePath">GraphNodePath</a>+ <span class="token">')'</span></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[109]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rAnnotationPath">AnnotationPath</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody">( <a href="#rReifier">Reifier</a> | <a href="#rAnnotationBlockPath">AnnotationBlockPath</a> )*</code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[110]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rAnnotationBlockPath">AnnotationBlockPath</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'{|'</span> <a href="#rPropertyListPathNotEmpty">PropertyListPathNotEmpty</a> <span class="token">'|}'</span></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[111]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rAnnotation">Annotation</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody">( <a href="#rReifier">Reifier</a> | <a href="#rAnnotationBlock">AnnotationBlock</a> )*</code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[112]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rAnnotationBlock">AnnotationBlock</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'{|'</span> <a href="#rPropertyListNotEmpty">PropertyListNotEmpty</a> <span class="token">'|}'</span></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[113]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rGraphNode">GraphNode</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rVarOrTerm">VarOrTerm</a> |	<a href="#rTriplesNode">TriplesNode</a> |	<a href="#rReifiedTriple">ReifiedTriple</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[114]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rGraphNodePath">GraphNodePath</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rVarOrTerm">VarOrTerm</a> |	<a href="#rTriplesNodePath">TriplesNodePath</a> |	<a href="#rReifiedTriple">ReifiedTriple</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[115]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rVarOrTerm">VarOrTerm</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rVar">Var</a> | <a href="#riri">iri</a> | <a href="#rRDFLiteral">RDFLiteral</a> | <a href="#rNumericLiteral">NumericLiteral</a> | <a href="#rBooleanLiteral">BooleanLiteral</a> | <a href="#rBlankNode">BlankNode</a> | <a href="#rNIL">NIL</a> | <a href="#rTripleTerm">TripleTerm</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[116]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rReifiedTriple">ReifiedTriple</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'&lt;&lt;'</span> <a href="#rReifiedTripleSubject">ReifiedTripleSubject</a> <a href="#rVerb">Verb</a> <a href="#rReifiedTripleObject">ReifiedTripleObject</a> <a href="#rReifier">Reifier</a>? <span class="token">'&gt;&gt;'</span></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[117]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rReifiedTripleSubject">ReifiedTripleSubject</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rVar">Var</a> | <a href="#riri">iri</a> | <a href="#rRDFLiteral">RDFLiteral</a> | <a href="#rNumericLiteral">NumericLiteral</a> | <a href="#rBooleanLiteral">BooleanLiteral</a> | <a href="#rBlankNode">BlankNode</a> | <a href="#rReifiedTriple">ReifiedTriple</a> | <a href="#rTripleTerm">TripleTerm</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[118]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rReifiedTripleObject">ReifiedTripleObject</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rVar">Var</a> | <a href="#riri">iri</a> | <a href="#rRDFLiteral">RDFLiteral</a> | <a href="#rNumericLiteral">NumericLiteral</a> | <a href="#rBooleanLiteral">BooleanLiteral</a> | <a href="#rBlankNode">BlankNode</a> | <a href="#rReifiedTriple">ReifiedTriple</a> | <a href="#rTripleTerm">TripleTerm</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[119]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rTripleTerm">TripleTerm</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'&lt;&lt;('</span> <a href="#rTripleTermSubject">TripleTermSubject</a> <a href="#rVerb">Verb</a> <a href="#rTripleTermObject">TripleTermObject</a> <span class="token">')&gt;&gt;'</span></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[120]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rTripleTermSubject">TripleTermSubject</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rVar">Var</a> | <a href="#riri">iri</a> | <a href="#rRDFLiteral">RDFLiteral</a> | <a href="#rNumericLiteral">NumericLiteral</a> | <a href="#rBooleanLiteral">BooleanLiteral</a> | <a href="#rBlankNode">BlankNode</a> | <a href="#rTripleTerm">TripleTerm</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[121]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rTripleTermObject">TripleTermObject</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rVar">Var</a> | <a href="#riri">iri</a> | <a href="#rRDFLiteral">RDFLiteral</a> | <a href="#rNumericLiteral">NumericLiteral</a> | <a href="#rBooleanLiteral">BooleanLiteral</a> | <a href="#rBlankNode">BlankNode</a> | <a href="#rTripleTerm">TripleTerm</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[122]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rTripleTermData">TripleTermData</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'&lt;&lt;('</span> <a href="#rTripleTermDataSubject">TripleTermDataSubject</a> ( <a href="#riri">iri</a> | <span class="token">'a'</span> ) <a href="#rTripleTermDataObject">TripleTermDataObject</a> <span class="token">')&gt;&gt;'</span></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[123]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rTripleTermDataSubject">TripleTermDataSubject</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#riri">iri</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[124]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rTripleTermDataObject">TripleTermDataObject</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#riri">iri</a> | <a href="#rRDFLiteral">RDFLiteral</a> | <a href="#rNumericLiteral">NumericLiteral</a> | <a href="#rBooleanLiteral">BooleanLiteral</a> | <a href="#rTripleTermData">TripleTermData</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[125]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rVarOrIri">VarOrIri</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rVar">Var</a> | <a href="#riri">iri</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[126]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rVar">Var</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rVAR1">VAR1</a> | <a href="#rVAR2">VAR2</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[127]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rExpression">Expression</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rConditionalOrExpression">ConditionalOrExpression</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[128]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rConditionalOrExpression">ConditionalOrExpression</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rConditionalAndExpression">ConditionalAndExpression</a> ( <span class="token">'||'</span> <a href="#rConditionalAndExpression">ConditionalAndExpression</a> )*</code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[129]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rConditionalAndExpression">ConditionalAndExpression</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rValueLogical">ValueLogical</a> ( <span class="token">'&amp;&amp;'</span> <a href="#rValueLogical">ValueLogical</a> )*</code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[130]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rValueLogical">ValueLogical</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rRelationalExpression">RelationalExpression</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[131]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rRelationalExpression">RelationalExpression</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rNumericExpression">NumericExpression</a> ( <span class="token">'='</span> <a href="#rNumericExpression">NumericExpression</a> | <span class="token">'!='</span> <a href="#rNumericExpression">NumericExpression</a> | <span class="token">'&lt;'</span> <a href="#rNumericExpression">NumericExpression</a> | <span class="token">'&gt;'</span> <a href="#rNumericExpression">NumericExpression</a> | <span class="token">'&lt;='</span> <a href="#rNumericExpression">NumericExpression</a> | <span class="token">'&gt;='</span> <a href="#rNumericExpression">NumericExpression</a> | <span class="token">'IN'</span> <a href="#rExpressionList">ExpressionList</a> | <span class="token">'NOT'</span> <span class="token">'IN'</span> <a href="#rExpressionList">ExpressionList</a> )?</code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[132]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rNumericExpression">NumericExpression</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rAdditiveExpression">AdditiveExpression</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[133]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rAdditiveExpression">AdditiveExpression</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rMultiplicativeExpression">MultiplicativeExpression</a> ( <span class="token">'+'</span> <a href="#rMultiplicativeExpression">MultiplicativeExpression</a> | <span class="token">'-'</span> <a href="#rMultiplicativeExpression">MultiplicativeExpression</a> | ( <a href="#rNumericLiteralPositive">NumericLiteralPositive</a> | <a href="#rNumericLiteralNegative">NumericLiteralNegative</a> ) ( ( <span class="token">'*'</span> <a href="#rUnaryExpression">UnaryExpression</a> ) | ( <span class="token">'/'</span> <a href="#rUnaryExpression">UnaryExpression</a> ) )* )*</code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[134]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rMultiplicativeExpression">MultiplicativeExpression</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rUnaryExpression">UnaryExpression</a> ( <span class="token">'*'</span> <a href="#rUnaryExpression">UnaryExpression</a> | <span class="token">'/'</span> <a href="#rUnaryExpression">UnaryExpression</a> )*</code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[135]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rUnaryExpression">UnaryExpression</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody">&nbsp;&nbsp;<span class="token">'!'</span> <a href="#rUnaryExpression">UnaryExpression</a> <br/>|	<span class="token">'+'</span> <a href="#rPrimaryExpression">PrimaryExpression</a> <br/>|	<span class="token">'-'</span> <a href="#rPrimaryExpression">PrimaryExpression</a> <br/>|	<a href="#rPrimaryExpression">PrimaryExpression</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[136]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rPrimaryExpression">PrimaryExpression</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rBrackettedExpression">BrackettedExpression</a> | <a href="#rBuiltInCall">BuiltInCall</a> | <a href="#ririOrFunction">iriOrFunction</a> | <a href="#rRDFLiteral">RDFLiteral</a> | <a href="#rNumericLiteral">NumericLiteral</a> | <a href="#rBooleanLiteral">BooleanLiteral</a> | <a href="#rVar">Var</a> | <a href="#rExprTripleTerm">ExprTripleTerm</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[137]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rExprTripleTerm">ExprTripleTerm</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'&lt;&lt;('</span> <a href="#rExprTripleTermSubject">ExprTripleTermSubject</a> <a href="#rVerb">Verb</a> <a href="#rExprTripleTermObject">ExprTripleTermObject</a> <span class="token">')&gt;&gt;'</span></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[138]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rExprTripleTermSubject">ExprTripleTermSubject</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#riri">iri</a> | <a href="#rVar">Var</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[139]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rExprTripleTermObject">ExprTripleTermObject</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#riri">iri</a> | <a href="#rRDFLiteral">RDFLiteral</a> | <a href="#rNumericLiteral">NumericLiteral</a> | <a href="#rBooleanLiteral">BooleanLiteral</a> | <a href="#rVar">Var</a> | <a href="#rExprTripleTerm">ExprTripleTerm</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[140]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rBrackettedExpression">BrackettedExpression</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[141]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rBuiltInCall">BuiltInCall</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody">&nbsp;&nbsp;<a href="#rAggregate">Aggregate</a> <br/>|	<span class="token">'STR'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br/>|	<span class="token">'LANG'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br/>|	<span class="token">'LANGMATCHES'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br/>|	<span class="token">'LANGDIR'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br/>|	<span class="token">'DATATYPE'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br/>|	<span class="token">'BOUND'</span> <span class="token">'('</span> <a href="#rVar">Var</a> <span class="token">')'</span> <br/>|	<span class="token">'IRI'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br/>|	<span class="token">'URI'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br/>|	<span class="token">'BNODE'</span> ( <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> | <a href="#rNIL">NIL</a> ) <br/>|	<span class="token">'RAND'</span> <a href="#rNIL">NIL</a> <br/>|	<span class="token">'ABS'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br/>|	<span class="token">'CEIL'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br/>|	<span class="token">'FLOOR'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br/>|	<span class="token">'ROUND'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br/>|	<span class="token">'CONCAT'</span> <a href="#rExpressionList">ExpressionList</a> <br/>|	<a href="#rSubstringExpression">SubstringExpression</a> <br/>|	<span class="token">'STRLEN'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br/>|	<a href="#rStrReplaceExpression">StrReplaceExpression</a> <br/>|	<span class="token">'UCASE'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br/>|	<span class="token">'LCASE'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br/>|	<span class="token">'ENCODE_FOR_URI'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br/>|	<span class="token">'CONTAINS'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br/>|	<span class="token">'STRSTARTS'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br/>|	<span class="token">'STRENDS'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br/>|	<span class="token">'STRBEFORE'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br/>|	<span class="token">'STRAFTER'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br/>|	<span class="token">'YEAR'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br/>|	<span class="token">'MONTH'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br/>|	<span class="token">'DAY'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br/>|	<span class="token">'HOURS'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br/>|	<span class="token">'MINUTES'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br/>|	<span class="token">'SECONDS'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br/>|	<span class="token">'TIMEZONE'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br/>|	<span class="token">'TZ'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br/>|	<span class="token">'NOW'</span> <a href="#rNIL">NIL</a> <br/>|	<span class="token">'UUID'</span> <a href="#rNIL">NIL</a> <br/>|	<span class="token">'STRUUID'</span> <a href="#rNIL">NIL</a> <br/>|	<span class="token">'MD5'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br/>|	<span class="token">'SHA1'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br/>|	<span class="token">'SHA256'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br/>|	<span class="token">'SHA384'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br/>|	<span class="token">'SHA512'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br/>|	<span class="token">'COALESCE'</span> <a href="#rExpressionList">ExpressionList</a> <br/>|	<span class="token">'IF'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br/>|	<span class="token">'STRLANG'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br/>|	<span class="token">'STRLANGDIR'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br/>|	<span class="token">'STRDT'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br/>|	<span class="token">'sameTerm'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br/>|	<span class="token">'isIRI'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br/>|	<span class="token">'isURI'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br/>|	<span class="token">'isBLANK'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br/>|	<span class="token">'isLITERAL'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br/>|	<span class="token">'isNUMERIC'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br/>|	<span class="token">'hasLANG'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br/>|	<span class="token">'hasLANGDIR'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br/>|	<a href="#rRegexExpression">RegexExpression</a> <br/>|	<a href="#rExistsFunc">ExistsFunc</a> <br/>|	<a href="#rNotExistsFunc">NotExistsFunc</a> <br/>|	<span class="token">'isTRIPLE'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br/>|	<span class="token">'TRIPLE'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br/>|	<span class="token">'SUBJECT'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br/>|	<span class="token">'PREDICATE'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br/>|	<span class="token">'OBJECT'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[142]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rRegexExpression">RegexExpression</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'REGEX'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a> ( <span class="token">','</span> <a href="#rExpression">Expression</a> )? <span class="token">')'</span></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[143]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rSubstringExpression">SubstringExpression</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'SUBSTR'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a> ( <span class="token">','</span> <a href="#rExpression">Expression</a> )? <span class="token">')'</span></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[144]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rStrReplaceExpression">StrReplaceExpression</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'REPLACE'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a> ( <span class="token">','</span> <a href="#rExpression">Expression</a> )? <span class="token">')'</span></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[145]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rExistsFunc">ExistsFunc</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'EXISTS'</span> <a href="#rGroupGraphPattern">GroupGraphPattern</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[146]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rNotExistsFunc">NotExistsFunc</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'NOT'</span> <span class="token">'EXISTS'</span> <a href="#rGroupGraphPattern">GroupGraphPattern</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[147]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rAggregate">Aggregate</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody">&nbsp;&nbsp;<span class="token">'COUNT'</span> <span class="token">'('</span> <span class="token">'DISTINCT'</span>? ( <span class="token">'*'</span> | <a href="#rExpression">Expression</a> ) <span class="token">')'</span> <br/>| <span class="token">'SUM'</span> <span class="token">'('</span> <span class="token">'DISTINCT'</span>? <a href="#rExpression">Expression</a> <span class="token">')'</span> <br/>| <span class="token">'MIN'</span> <span class="token">'('</span> <span class="token">'DISTINCT'</span>? <a href="#rExpression">Expression</a> <span class="token">')'</span> <br/>| <span class="token">'MAX'</span> <span class="token">'('</span> <span class="token">'DISTINCT'</span>? <a href="#rExpression">Expression</a> <span class="token">')'</span> <br/>| <span class="token">'AVG'</span> <span class="token">'('</span> <span class="token">'DISTINCT'</span>? <a href="#rExpression">Expression</a> <span class="token">')'</span> <br/>| <span class="token">'SAMPLE'</span> <span class="token">'('</span> <span class="token">'DISTINCT'</span>? <a href="#rExpression">Expression</a> <span class="token">')'</span> <br/>| <span class="token">'GROUP_CONCAT'</span> <span class="token">'('</span> <span class="token">'DISTINCT'</span>? <a href="#rExpression">Expression</a> ( <span class="token">';'</span> <span class="token">'SEPARATOR'</span> <span class="token">'='</span> <a href="#rString">String</a> )? <span class="token">')'</span> </code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[148]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="ririOrFunction">iriOrFunction</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#riri">iri</a> <a href="#rArgList">ArgList</a>?</code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[149]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rRDFLiteral">RDFLiteral</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rString">String</a> ( <a href="#rLANG_DIR">LANG_DIR</a> | <span class="token">'^^'</span> <a href="#riri">iri</a> )?</code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[150]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rNumericLiteral">NumericLiteral</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rNumericLiteralUnsigned">NumericLiteralUnsigned</a> | <a href="#rNumericLiteralPositive">NumericLiteralPositive</a> | <a href="#rNumericLiteralNegative">NumericLiteralNegative</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[151]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rNumericLiteralUnsigned">NumericLiteralUnsigned</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rINTEGER">INTEGER</a> |	<a href="#rDECIMAL">DECIMAL</a> |	<a href="#rDOUBLE">DOUBLE</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[152]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rNumericLiteralPositive">NumericLiteralPositive</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rINTEGER_POSITIVE">INTEGER_POSITIVE</a> |	<a href="#rDECIMAL_POSITIVE">DECIMAL_POSITIVE</a> |	<a href="#rDOUBLE_POSITIVE">DOUBLE_POSITIVE</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[153]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rNumericLiteralNegative">NumericLiteralNegative</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rINTEGER_NEGATIVE">INTEGER_NEGATIVE</a> |	<a href="#rDECIMAL_NEGATIVE">DECIMAL_NEGATIVE</a> |	<a href="#rDOUBLE_NEGATIVE">DOUBLE_NEGATIVE</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[154]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rBooleanLiteral">BooleanLiteral</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'true'</span> |	<span class="token">'false'</span></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[155]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rString">String</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rSTRING_LITERAL1">STRING_LITERAL1</a> | <a href="#rSTRING_LITERAL2">STRING_LITERAL2</a> | <a href="#rSTRING_LITERAL_LONG1">STRING_LITERAL_LONG1</a> | <a href="#rSTRING_LITERAL_LONG2">STRING_LITERAL_LONG2</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[156]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="riri">iri</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rIRIREF">IRIREF</a> |	<a href="#rPrefixedName">PrefixedName</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[157]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rPrefixedName">PrefixedName</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rPNAME_LN">PNAME_LN</a> | <a href="#rPNAME_NS">PNAME_NS</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[158]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rBlankNode">BlankNode</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rBLANK_NODE_LABEL">BLANK_NODE_LABEL</a> |	<a href="#rANON">ANON</a></code></td>
              </tr>
          </tbody></table>
        </div>
        <p>Productions for terminals:</p>
        <div class="grammarTable">
          <table><tbody>

              <tr style="vertical-align: baseline">
                <td><code>[159]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rIRIREF">IRIREF</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'&lt;' ([^&lt;&gt;"{}|^`\]-[#x00-#x20])* '&gt;'</span></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[160]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rPNAME_NS">PNAME_NS</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rPN_PREFIX">PN_PREFIX</a>? ':'</code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[161]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rPNAME_LN">PNAME_LN</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rPNAME_NS">PNAME_NS</a> <a href="#rPN_LOCAL">PN_LOCAL</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[162]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rBLANK_NODE_LABEL">BLANK_NODE_LABEL</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody">'_:' ( <a href="#rPN_CHARS_U">PN_CHARS_U</a> | [0-9] ) ((<a href="#rPN_CHARS">PN_CHARS</a>|'.')* <a href="#rPN_CHARS">PN_CHARS</a>)?</code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[163]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rVAR1">VAR1</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody">'?' <a href="#rVARNAME">VARNAME</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[164]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rVAR2">VAR2</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody">'$' <a href="#rVARNAME">VARNAME</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[165]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rLANG_DIR">LANG_DIR</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody">'@' [a-zA-Z]+ ('-' [a-zA-Z0-9]+)* ('--' [a-zA-Z]+)?</code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[166]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rINTEGER">INTEGER</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody">[0-9]+</code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[167]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rDECIMAL">DECIMAL</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody">[0-9]* '.' [0-9]+</code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[168]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rDOUBLE">DOUBLE</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody">( ([0-9]+ ('.'[0-9]*)? ) | ( '.' ([0-9])+ ) ) <a href="#rEXPONENT">EXPONENT</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[169]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rEXPONENT">EXPONENT</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody">[eE] [+-]? [0-9]+</code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[170]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rINTEGER_POSITIVE">INTEGER_POSITIVE</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'+'</span> <a href="#rINTEGER">INTEGER</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[171]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rDECIMAL_POSITIVE">DECIMAL_POSITIVE</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'+'</span> <a href="#rDECIMAL">DECIMAL</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[172]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rDOUBLE_POSITIVE">DOUBLE_POSITIVE</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'+'</span> <a href="#rDOUBLE">DOUBLE</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[173]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rINTEGER_NEGATIVE">INTEGER_NEGATIVE</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'-'</span> <a href="#rINTEGER">INTEGER</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[174]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rDECIMAL_NEGATIVE">DECIMAL_NEGATIVE</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'-'</span> <a href="#rDECIMAL">DECIMAL</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[175]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rDOUBLE_NEGATIVE">DOUBLE_NEGATIVE</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><span class="token">'-'</span> <a href="#rDOUBLE">DOUBLE</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[176]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rSTRING_LITERAL1">STRING_LITERAL1</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody">"'" ( ([^#x27#x5C#xA#xD]) | <a href="#rECHAR">ECHAR</a> )* "'"</code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[177]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rSTRING_LITERAL2">STRING_LITERAL2</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody">'"' ( ([^#x22#x5C#xA#xD]) | <a href="#rECHAR">ECHAR</a> )* '"'</code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[178]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rSTRING_LITERAL_LONG1">STRING_LITERAL_LONG1</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody">"'''" ( ( "'" | "''" )? ( [^'\] | <a href="#rECHAR">ECHAR</a> ) )* "'''"</code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[179]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rSTRING_LITERAL_LONG2">STRING_LITERAL_LONG2</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody">'"""' ( ( '"' | '""' )? ( [^"\] | <a href="#rECHAR">ECHAR</a> ) )* '"""'</code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[180]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rECHAR">ECHAR</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody">'\' [tbnrf\"']</code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[181]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rNIL">NIL</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody">'(' <a href="#rWS">WS</a>* ')'</code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[182]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rWS">WS</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody">#x20 | #x9 | #xD | #xA</code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[183]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rANON">ANON</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody">'['  <a href="#rWS">WS</a>* ']'</code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[184]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rPN_CHARS_BASE">PN_CHARS_BASE</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody">[A-Z] | [a-z] | [#x00C0-#x00D6] | [#x00D8-#x00F6] | [#x00F8-#x02FF] | [#x0370-#x037D] | [#x037F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]</code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[185]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rPN_CHARS_U">PN_CHARS_U</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rPN_CHARS_BASE">PN_CHARS_BASE</a> | '_'</code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[186]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rVARNAME">VARNAME</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody">( <a href="#rPN_CHARS_U">PN_CHARS_U</a>  | [0-9] ) ( <a href="#rPN_CHARS_U">PN_CHARS_U</a> | [0-9] | #x00B7 | [#x0300-#x036F] | [#x203F-#x2040] )*</code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[187]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rPN_CHARS">PN_CHARS</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rPN_CHARS_U">PN_CHARS_U</a> | '-' | [0-9] | #x00B7 | [#x0300-#x036F] | [#x203F-#x2040]</code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[188]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rPN_PREFIX">PN_PREFIX</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rPN_CHARS_BASE">PN_CHARS_BASE</a> ((<a href="#rPN_CHARS">PN_CHARS</a>|'.')* <a href="#rPN_CHARS">PN_CHARS</a>)?</code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[189]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rPN_LOCAL">PN_LOCAL</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody">(<a href="#rPN_CHARS_U">PN_CHARS_U</a> | ':' | [0-9] | <a href="#rPLX">PLX</a> ) ((<a href="#rPN_CHARS">PN_CHARS</a> | '.' | ':' | <a href="#rPLX">PLX</a>)* (<a href="#rPN_CHARS">PN_CHARS</a> | ':' | <a href="#rPLX">PLX</a>) )?</code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[190]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rPLX">PLX</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody"><a href="#rPERCENT">PERCENT</a> | <a href="#rPN_LOCAL_ESC">PN_LOCAL_ESC</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[191]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rPERCENT">PERCENT</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody">'%' <a href="#rHEX">HEX</a> <a href="#rHEX">HEX</a></code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[192]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rHEX">HEX</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody">[0-9] | [A-F] | [a-f]</code></td>
              </tr>

              <tr style="vertical-align: baseline">
                <td><code>[193]&nbsp;&nbsp;</code></td>
                <td><code><span class="doc-ref" id="rPN_LOCAL_ESC">PN_LOCAL_ESC</span></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code class="gRuleBody">'\' ( '_' | '~' | '.' | '-' | '!' | '$' | '&amp;' | "'" | '(' | ')' | '*' | '+' | ',' | ';' | '=' | '/' | '?' | '#' | '@' | '%' )</code></td>
              </tr>
          </tbody></table>
        </div>
        <!-- GRAMMAR -->

        <p>A text version of this grammar is available <a href="sparql.bnf">here</a>.</p>

      </section>
    </section>

    <section id="conformance">
      <h2>Conformance</h2>
      <p>See Section <a href="#grammar">19 SPARQL Grammar</a> regarding conformance of 
        <a>SPARQL query strings</a>, and section 
        <a href="#QueryForms">16 Query Forms</a> for conformance of query results. 
        See section <a href="#mediaType">22. Internet Media Type</a> for conformance 
        to the application/sparql-query media type.</p>
      <p>This specification is intended for use in conjunction with the [[[SPARQL11-PROTOCOL]]]
        [[SPARQL11-PROTOCOL]], the [[[RDF-SPARQL-XMLRES]]] [[RDF-SPARQL-XMLRES]], the
        [[[SPARQL11-RESULTS-JSON]]] [[SPARQL11-RESULTS-JSON]] and the [[[SPARQL11-RESULTS-CSV-TSV]]]
        [[SPARQL11-RESULTS-CSV-TSV]]. See those specifications for their conformance criteria.</p>
      <p>Note that the SPARQL protocol describes a means for conveying SPARQL queries to an SPARQL
        query processing service and returning the query results to the entity that requested
        them.</p>
    </section>

    <section id="mediaType">
      <h2>Internet Media Type, File Extension and Macintosh File Type</h2>
      <p>The Internet Media Type (formerly known as MIME Type) for the SPARQL Query Language is
        "<code>application/sparql-query</code>".</p>
      <p>It is recommended that sparql query files have the extension ".rq" (lowercase) on all
        platforms.</p>
      <p>It is recommended that sparql query files stored on Macintosh HFS file systems be given a
        file type of "TEXT".</p>
      <div class="mediatype"><div id="mime"></div>
        <dl>
          <dt>Type name:</dt>
          <dd>application</dd>
          <dt>Subtype name:</dt>
          <dd>sparql-query</dd>
          <dt>Required parameters:</dt>
          <dd>None</dd>
          <dt>Optional parameters:</dt>
          <dd>None</dd>
          <dt>Encoding considerations:</dt>
          <dd>The syntax of the SPARQL Query Language is expressed over code points in Unicode
            [[UNICODE]]. The encoding is always UTF-8 [[RFC3629]].</dd>
          <dd>Unicode code points may also be expressed using an \uXXXX (U+0 to U+FFFF) or
            \UXXXXXXXX syntax (for U+10000 onwards) where X is a hexadecimal digit [0-9A-F]</dd>
          <dt>Security considerations:</dt>
          <dd>
            See SPARQL Query appendix C, <a href="#security">Security Considerations</a> as well as
            [[[RFC3629]]] [[RFC3629]] section 7, Security Considerations.
          </dd>
          <dt>Interoperability considerations:</dt>
          <dd>There are no known interoperability issues.</dd>
          <dt>Published specification:</dt>
          <dd>This specification.</dd>
          <dt>Applications which use this media type:</dt>
          <dd>No known applications currently use this media type.</dd>
          <dt>Additional information:</dt>
          <dt>Magic number(s):</dt>
          <dd>A SPARQL query may have the string 'PREFIX' (case independent) near the beginning of
            the document.</dd>
          <dt>File extension(s):</dt>
          <dd>".rq"</dd>
          <dt>Base URI:</dt>
          <dd>The SPARQL 'BASE &lt;IRIref&gt;' term can change the current base URI for relative
            IRIrefs in the query language that are used sequentially later in the document.</dd>
          <dt>Macintosh file type code(s):</dt>
          <dd>"TEXT"</dd>
          <dt>Person & email address to contact for further information:</dt>
          <dd>public-rdf-dawg-comments@w3.org</dd>
          <dt>Intended usage:</dt>
          <dd>COMMON</dd>
          <dt>Restrictions on usage:</dt>
          <dd>None</dd>
          <dt>Author/Change controller:</dt>
          <dd>The SPARQL 1.2 specification is a work product of the World Wide Web Consortium's
            RDF-star Working Group. The W3C has change control over these specifications.</dd>
        </dl>
      </div>
    </section>
    
    <section id="changes-1-1" class="appendix informative">
      <h2>Changes between SPARQL 1.1 Query Language and SPARQL 1.2 Query Language</h2>
      <ul>
        <li>
            Normative changes:
            <ul>
                <li>Update grammar for triple terms, reifiers, reified triples, annotation syntax, and triple term functions
                  in <a href="#sparqlGrammar" class="sectionRef"></a></li>
                <li>Add functions related to <a data-cite="RDF12-CONCEPTS#dfn-triple-term">triple terms</a> to
                  <a href="#func-triple-terms" class="sectionRef"></a>:
                  `TRIPLE`, `isTRIPLE`, `SUBJECT`, `PREDICATE`, `OBJECT`</li>
                <li>Update grammar for literal <a data-cite="RDF12-CONCEPTS#dfn-base-direction">base direction</a> syntax</li>
                <li>Update grammar for VERSION declaration and a <a href="#syntaxVersionAnnouncement" class="sectionRef">new section</a> to describe its usage</li>
                <li>Add functions related to 
                  <a data-cite="RDF12-CONCEPTS#dfn-language-tag">language tag</a> and
                  <a data-cite="RDF12-CONCEPTS#dfn-base-direction">base direction</a>:
                  `LANGDIR`, `hasLANG`, hasLANGDIR, and `STRLANGDIR`</li>
                <li>Define parser input as being an 
                  <a data-cite="RDF12-CONCEPTS#dfn-rdf-string">RDF string</a>. 
                  Exclude Unicode surrogates from Unicode escape sequences.</li>
                <li>Remove concepts of plain and simple literals, in favor of explicit mentions of `xsd:string`</li>
                <li>Migrate XML Schema references to 1.1. 
                Note that for datatypes involving years, the year 1 BCE is represented by `0000` and not as `-0001`.
                See the note about the
                <a data-cite="XMLSCHEMA11-2#dateTime-value-space">date/timeSevenPropertyModel</a>
                for details.
                </li>
                <li>Update references to XPath from 2.0 to 3.1</li>
                <li>Define `EBV` as a functional form.</li>
                <li>Forbid duplicated variables in `VALUES`.</li>
                <li>Add in-between term type ORDER BY support for triple terms in <a href="#modOrderBy" class="sectionRef"></a>.</li>
            </ul>
        </li>
        <li>
            Editorial changes:
            <ul>
                <li>Give an actual function signature to <a href="#func-sameValue" class="sectionRef"></a></li>
                <li>Improve wording of blank nodes in <a href="#templatesWithBNodes" class="sectionRef"></a></li>
                <li>Improve display on mobile</li>
                <li>Move `sameValue` (was `RDFterm-equal`) and `sameTerm` to <a href="#func-rdfTerms" class="sectionRef"></a></li>
                <li>Add note on deduplication of triples produced by CONSTRUCT to <a href="#construct" class="sectionRef"></a></li>
                <li>Remove historical notes on rdf:langString datatype from <a href="#func-datatype" class="sectionRef"></a></li>
                <li>Remove inconsistencies between the definitions of the set functions</li>
                <li>Introduce a function called multiplicity to replace card[Î©](Î¼) in <a href="#BasicGraphPattern" class="sectionRef"></a></li>
                <li>Update to Media Type language instead of MIME Type language</li>
                <li>Clarify that aggregation returns a single partial function in <a href="#sparqlGroupAggregate" class="sectionRef"></a></li>
                <li>Update Filter Evaluation language to reference more functional forms in <a href="#expression-evaluation" class="sectionRef"></a></li>
                <li>Use PREFIX instead of @prefix</li>
                <li>More accurate definition of the <a href="#defn_algSlice" class="algFct">Slice</a> algebra operator</li>
                <li>Clarify definition of the Sum set function in <a href="#aggSum" class="sectionRef"></a></li>
                <li>Improve definition of Group operator in <a href="#aggregateAlgebra" class="sectionRef"></a></li>
                <li>Move definitions of Flatten and Card to <a href="#setFunctions" class="sectionRef"></a></li>
                <li>Improve definitions in <a href="#initDefinitions" class="sectionRef"></a></li>
                <li>Fix algorithm for translation SELECT expressions <a href="#sparqlSelectExpressions" class="sectionRef"></a></li>
                <li>Clarify the use of ToList in algebra expressions in <a href="#translation" class="sectionRef"></a></li>
                <li>Add an explicit definition of the algebraic syntax
                  (<a href="#algebraicSyntax" class="sectionRef"></a>) into which the AST
                  expressions are translated according to <a href="#translation"
                  class="sectionRef"></a>, and mark up all mentions of symbols of this
                  syntax as links to their respective definition; similarly, mark up all
                  mentions of operators of the <a href="#sparqlAlgebra">SPARQL algebra</a>
                  as links to their respective definition</li>
                <li>Rename the function used to define the evaluation of property path expressions
                  in <a href="#PropertyPathPatterns" class="sectionRef"></a>
                  from <i>eval</i> to <i>ppeval</i>.</li>
                <li>Rename the function used within the definition of
                  the <a href="#defn_evalALP">ALP</a> function
                  from <i>eval</i> to <i>reachableTerms</i>.</li>
                <li>Add section <a href="#sparql-error" class="sectionRef"></a> about SPARQL expression evaluation errors</a>.</li>
                <li>Rename section "Filter evaluation" as <a href="#expression-evaluation" class="sectionRef"></a>.</li>
                <li>Improve definitions of all algebra operators that involve expressions
                  (<a href="#defn_algFilter" class="algFct">Filter</a>, <a href="#defn_algDiff" class="algFct">Diff</a>,
                  <a href="#defn_algLeftJoin" class="algFct">LeftJoin</a>, and <a href="#defn_algExtend" class="algFct">Extend</a>).</li>
            </ul>
        </li>
        <li>
            Errata:
            <ul>
              <li><a href="https://www.w3.org/2013/sparql-errata#editorial-query-1">editorial-query-1</a>: Missing right parenthesis in <a href="#defn_evalGraph">Evaluation of Graph definition</a></li>
              <li><a href="https://www.w3.org/2013/sparql-errata#editorial-query-2">editorial-query-2</a>: Missing space in <a href="#defn_algJoin">Join definition</a></li>
              <li><a href="https://www.w3.org/2013/sparql-errata#editorial-query-3">editorial-query-3</a>: Incorrect link for DELETE DATA in <a href="#grammarBNodes" class="sectionRef"></a></li>
              <li><a href="https://www.w3.org/2013/sparql-errata#clarification-query-1">clarification-query-1</a>: Fix explanation of IN and NOT IN in <a href="#func-in" class="sectionRef"></a> and <a href="#func-not-in" class="sectionRef"></a></li>
              <li><a href="https://www.w3.org/2013/sparql-errata#clarification-query-2">clarification-query-2</a>: Remove unneeded reference to the semantics above in <a href="#operatorExtensibility" class="sectionRef"></a></li>
              <li><a href="https://www.w3.org/2013/sparql-errata#clarification-query-3">clarification-query-3</a>: Rephrase equality definition in <a href="#func-sameValue" class="sectionRef"></a></li>
              <li><a href="https://www.w3.org/2013/sparql-errata#errata-query-1">errata-query-1</a>: Let V be an empty set instead of empty multiset in <a href="#defn_evalALP">Function ALP definition</a></li>
              <li><a href="https://www.w3.org/2013/sparql-errata#errata-query-2">errata-query-2</a>: Fix grammar of PropertyListPathNotEmpty in <a href="#grammar" class="sectionRef"></a></li>
              <li><a href="https://www.w3.org/2013/sparql-errata#errata-query-4">errata-query-4</a>: Fix CONCAT definition for zero and one argument in <a href="#func-concat" class="sectionRef"></a></li>
              <li><a href="https://www.w3.org/2013/sparql-errata#errata-query-5">errata-query-5</a>: Mention illegal nesting of aggregates in <a href="#sparqlGrammar" class="sectionRef"></a></li>
              <li><a href="https://www.w3.org/2013/sparql-errata#errata-query-7">errata-query-7</a> and <a href="https://www.w3.org/2013/sparql-errata#errata-query-7a">errata-query-7a</a>: Remove incorrect full example <a href="#defn_algLeftJoin">LeftJoin definition</a></li>
              <li><a href="https://www.w3.org/2013/sparql-errata#errata-query-9">errata-query-9</a>: Fix examples in <a href="#sparqlAlgebraExamples" class="sectionRef"></a></li>
              <li><a href="https://www.w3.org/2013/sparql-errata#errata-query-11">errata-query-11</a>: Rename group variable in <a href="#sparqlGroupAggregate" class="sectionRef"></a></li>
              <li><a href="https://www.w3.org/2013/sparql-errata#errata-query-12">errata-query-12</a>: Clarify definition of Diff in <a href="#sparqlAlgebra" class="sectionRef"></a></li>
              <li><a href="https://www.w3.org/2013/sparql-errata#errata-query-13">errata-query-13</a>: Fix definition of Project cardinality in <a href="#sparqlAlgebra" class="sectionRef"></a></li>
              <li><a href="https://www.w3.org/2013/sparql-errata#errata-query-18">errata-query-18</a>: Fix table in <a href="#sparqlTranslatePathPatterns" class="sectionRef"></a></li>
              <li><a href="https://www.w3.org/2013/sparql-errata#errata-query-19">errata-query-19</a>: Fix translation in <a href="#sparqlTranslateGraphPatterns" class="sectionRef"></a></li>
              <li><a href="https://www.w3.org/2013/sparql-errata#errata-query-23">errata-query-23</a>: Fix inconsistenties between <a href="#defn_aggMin">MIN</a> and <a
href="#defn_aggMax">MAX</a></li>
              <li>Grammar rule `UnaryExpression` to allow `!!`</li>
            </ul>
        </li>
      </ul>
    </section>
    
    <!-- BODY -->
    <section id="privacy">
      <h2>Privacy Considerations</h2>
      <p>TODO</p>
    </section>

    <section id="security">
      <h2>Security Considerations</h2>
      <p>SPARQL queries using FROM, FROM NAMED, or GRAPH may cause the specified URI to be
          dereferenced. This may cause additional use of network, disk or CPU resources along with
          associated secondary issues such as denial of service. The security issues of [[[RFC3986]]]
          [[RFC3986]] Section 7 should be considered. In addition, the contents of <code>file:</code>
          URIs can in some cases be accessed, processed and returned as results, providing unintended
          access to local resources.</p>
        <p>SPARQL requests may cause additional requests to be issued from the SPARQL endpoint, such
          as FROM NAMED. The endpoint is potentially within an organisations firewall or DMZ, and so
          such queries may be a source of indirection attacks.</p>
        <p>The SPARQL language permits extensions, which will have their own security
          implications.</p>
        <p>Multiple IRIs may have the same appearance. Characters in different scripts may look
          similar (a Cyrillic "Ð¾" may appear similar to a Latin "o"). A character followed by combining
          characters may have the same visual representation as another character (LATIN SMALL LETTER E
          followed by COMBINING ACUTE ACCENT has the same visual representation as LATIN SMALL LETTER E
          WITH ACUTE). Users of SPARQL must take care to construct queries with IRIs that match the
          IRIs in the data. Further information about matching of similar characters can be found in
          [[[UTR36]]] [[UTR36]] and [[[RFC3987]]] [[RFC3987]] Section 8.</p>
    </section>
    
    <section id="internationalization">
      <h2>Internationalization Considerations</h2>
      <p>TODO</p>                
    </section>

    <section id="index"></section>

  </body>
</html>
