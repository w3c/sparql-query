<!--?xml version="1.0" encoding="UTF-8"?-->
<html lang="EN">
<head>
  <meta name="generator" content="HTML Tidy for HTML5 for Linux version 5.6.0">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>SPARQL 1.1 Query Language</title>
  <style type="text/css">
  @import url("local.css");

  code           { font-family: monospace; }

  div.constraint,
  div.issue,
  div.note,
  div.notice     { margin-left: 2em; }

  ol.enumar      { list-style-type: decimal; }
  ol.enumla      { list-style-type: lower-alpha; }
  ol.enumlr      { list-style-type: lower-roman; }
  ol.enumua      { list-style-type: upper-alpha; }
  ol.enumur      { list-style-type: upper-roman; }


  div.exampleInner pre { margin-left: 1em;
                       margin-top: 0em; margin-bottom: 0em}
  div.exampleOuter {border: 4px double gray;
                  margin: 0em; padding: 0em}
  div.exampleInner { background-color: #d5dee3;
                   border-top-width: 4px;
                   border-top-style: double;
                   border-top-color: #d3d3d3;
                   border-bottom-width: 4px;
                   border-bottom-style: double;
                   border-bottom-color: #d3d3d3;
                   padding: 4px; margin: 0em }
  div.exampleWrapper { margin: 4px }
  div.exampleHeader { font-weight: bold;
                    margin: 4px}

  em.rfc2119 { text-transform: lowercase;
             font-variant: small-caps;
             font-style: normal; }
  </style>
  <link rel="stylesheet" type="text/css" href="http://www.w3.org/StyleSheets/TR/W3C-REC.css">
</head>
<body>
  <div class="head">
    <p><a href="http://www.w3.org/"><img src="SPARQL%201.1%20Query%20Language_files/w3c_home.svg" alt="W3C" width="72" height="48"></a></p>
    <h1><a name="title" id="title"></a>SPARQL 1.1 Query Language</h1>
    <h2><a name="w3c-doctype" id="w3c-doctype"></a>W3C Recommendation 21 March 2013</h2>
    <dl>
      <dt>This version:</dt>
      <dd><a href="http://www.w3.org/TR/2013/REC-sparql11-query-20130321/">http://www.w3.org/TR/2013/REC-sparql11-query-20130321/</a></dd>
      <dt>Latest version:</dt>
      <dd><a href="http://www.w3.org/TR/sparql11-query/">http://www.w3.org/TR/sparql11-query/</a></dd>
      <dt>Previous version:</dt>
      <dd><a href="http://www.w3.org/TR/2012/PR-sparql11-query-20121108/">http://www.w3.org/TR/2012/PR-sparql11-query-20121108/</a></dd>
      <dt>Editors:</dt>
      <dd>Steve Harris, Garlik, a part of Experian</dd>
      <dd>Andy Seaborne, The Apache Software Foundation</dd>
      <dt>Previous Editor:</dt>
      <dd>Eric Prud'hommeaux, W3C</dd>
    </dl>
    <p>Please refer to the <a href="http://www.w3.org/2013/sparql-errata#sparql11-query"><strong>errata</strong></a> for this document, which may include some normative corrections.</p>
    <p>See also <a href="http://www.w3.org/2003/03/Translations/byTechnology?technology=sparql11-query"><strong>translations</strong></a>.</p>
    <p class="copyright"><a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a>&nbsp;©&nbsp;2013&nbsp;<a href="http://www.w3.org/"><acronym title=
    "World Wide Web Consortium">W3C</acronym></a><sup>®</sup> (<a href="http://www.csail.mit.edu/"><acronym title="Massachusetts Institute of Technology">MIT</acronym></a>, <a href=
    "http://www.ercim.eu/"><acronym title="European Research Consortium for Informatics and Mathematics">ERCIM</acronym></a>, <a href="http://www.keio.ac.jp/">Keio</a>, <a href=
    "http://ev.buaa.edu.cn/">Beihang</a>), All Rights Reserved. W3C <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href=
    "http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a href="http://www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.</p>
  </div>
  <hr>
  <div>
    <h2><a name="abstract" id="abstract"></a>Abstract</h2>
    <p>RDF is a directed, labeled graph data format for representing information in the Web. This specification defines the syntax and semantics of the SPARQL query language for RDF. SPARQL can be
    used to express queries across diverse data sources, whether the data is stored natively as RDF or viewed as RDF via middleware. SPARQL contains capabilities for querying required and optional
    graph patterns along with their conjunctions and disjunctions. SPARQL also supports aggregation, subqueries, negation, creating values by expressions, extensible value testing, and constraining
    queries by source RDF graph. The results of SPARQL queries can be result sets or RDF graphs.</p>
  </div>
  <div>
    <h2><a name="status" id="status"></a>Status of This Document</h2>
    <h4 id="may-be">May Be Superseded</h4>
    <p><em>This section describes the status of this document at the time of its publication. Other documents may supersede this document. A list of current W3C publications and the latest revision
    of this technical report can be found in the <a href="http://www.w3.org/TR/">W3C technical reports index</a> at http://www.w3.org/TR/.</em></p>
    <h4 id="related">Set of Documents</h4>
    <p>This document is one of eleven SPARQL 1.1 Recommendations produced by the <a href="http://www.w3.org/2001/sw/DataAccess/">SPARQL Working Group</a>:</p>
    <ol>
      <li><a href="http://www.w3.org/TR/2013/REC-sparql11-overview-20130321">SPARQL 1.1 Overview</a></li>
      <li><a href="http://www.w3.org/TR/2013/REC-sparql11-query-20130321">SPARQL 1.1 Query Language</a> (this document)</li>
      <li><a href="http://www.w3.org/TR/2013/REC-sparql11-update-20130321">SPARQL 1.1 Update</a></li>
      <li><a href="http://www.w3.org/TR/2013/REC-sparql11-service-description-20130321">SPARQL1.1 Service Description</a></li>
      <li><a href="http://www.w3.org/TR/2013/REC-sparql11-federated-query-20130321">SPARQL 1.1 Federated Query</a></li>
      <li><a href="http://www.w3.org/TR/2013/REC-sparql11-results-json-20130321">SPARQL 1.1 Query Results JSON Format</a></li>
      <li><a href="http://www.w3.org/TR/2013/REC-sparql11-results-csv-tsv-20130321">SPARQL 1.1 Query Results CSV and TSV Formats</a></li>
      <li><a href="http://www.w3.org/TR/2013/REC-rdf-sparql-XMLres-20130321">SPARQL Query Results XML Format (Second Edition)</a></li>
      <li><a href="http://www.w3.org/TR/2013/REC-sparql11-entailment-20130321">SPARQL 1.1 Entailment Regimes</a></li>
      <li><a href="http://www.w3.org/TR/2013/REC-sparql11-protocol-20130321">SPARQL 1.1 Protocol</a></li>
      <li><a href="http://www.w3.org/TR/2013/REC-sparql11-http-rdf-update-20130321">SPARQL 1.1 Graph Store HTTP Protocol</a></li>
    </ol>
    <h4 class="no-toc no-num" id="status-changes">No Substantive Changes</h4>
    <p>There have been no substantive changes to this document since the <a href="http://www.w3.org/TR/2012/PR-sparql11-query-20121108/">previous version</a>. Minor editorial changes, if any, are
    detailed in the <a href="#changes-since-pr">change log</a> and visible in the <a href="https://www.w3.org/TR/sparql11-query/diff">color-coded diff</a>.</p>
    <h4 class="no-toc no-num" id="please">Please Send Comments</h4>
    <p>Please send any comments to <a class="mailto" href="mailto:public-rdf-dawg-comments@w3.org">public-rdf-dawg-comments@w3.org</a> (<a class="http" href=
    "http://lists.w3.org/Archives/Public/public-rdf-dawg-comments/">public archive</a>). Although work on this document by the <a href="http://www.w3.org/2009/sparql/">SPARQL Working Group</a> is
    complete, comments may be addressed in the <a href="http://www.w3.org/2013/sparql-errata">errata</a> or in future revisions. Open discussion is welcome at <a class="mailto" href=
    "mailto:public-sparql-dev@w3.org">public-sparql-dev@w3.org</a> (<a class="http" href="http://lists.w3.org/Archives/Public/public-sparql-dev/">public archive</a>).</p>
    <h4 class="no-toc no-num" id="endorsement">Endorsed By W3C</h4>
    <p><em>This document has been reviewed by W3C Members, by software developers, and by other W3C groups and interested parties, and is endorsed by the Director as a W3C Recommendation. It is a
    stable document and may be used as reference material or cited from another document. W3C's role in making the Recommendation is to draw attention to the specification and to promote its
    widespread deployment. This enhances the functionality and interoperability of the Web.</em></p>
    <h4 id="patents">Patents</h4>
    <p><em>This document was produced by a group operating under the <a href="http://www.w3.org/Consortium/Patent-Policy-20040205/">5 February 2004 W3C Patent Policy</a>. W3C maintains a <a href=
    "http://www.w3.org/2004/01/pp-impl/35463/status" rel="disclosure">public list of any patent disclosures</a> made in connection with the deliverables of the group; that page also includes
    instructions for disclosing a patent. An individual who has actual knowledge of a patent which the individual believes contains <a href=
    "http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">Essential Claim(s)</a> must disclose the information in accordance with <a href=
    "http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">section 6 of the W3C Patent Policy</a>.</em></p>
  </div>
  <div class="toc">
    <h2><a name="contents" id="contents"></a>Table of Contents</h2>
    <p class="toc">1 <b><a href="#introduction">Introduction</a></b><br>
    &nbsp;&nbsp;&nbsp;&nbsp;1.1 <a href="#docOutline">Document Outline</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;1.2 <a href="#docConventions">Document Conventions</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.2.1 <a href="#docNamespaces">Namespaces</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.2.2 <a href="#docDataDesc">Data Descriptions</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.2.3 <a href="#docResultDesc">Result Descriptions</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.2.4 <a href="#docTerminology">Terminology</a><br>
    2 <b><a href="#basicpatterns">Making Simple Queries (Informative)</a></b><br>
    &nbsp;&nbsp;&nbsp;&nbsp;2.1 <a href="#WritingSimpleQueries">Writing a Simple Query</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;2.2 <a href="#MultipleMatches">Multiple Matches</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;2.3 <a href="#matchingRDFLiterals">Matching RDF Literals</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.3.1 <a href="#matchLangTags">Matching Literals with Language Tags</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.3.2 <a href="#matchNumber">Matching Literals with Numeric Types</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.3.3 <a href="#matchArbDT">Matching Literals with Arbitrary Datatypes</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;2.4 <a href="#BlankNodesInResults">Blank Node Labels in Query Results</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;2.5 <a href="#CreatingValuesWithExpressions">Creating Values with Expressions</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;2.6 <a href="#constructGraph">Building RDF Graphs</a><br>
    3 <b><a href="#termConstraint">RDF Term Constraints (Informative)</a></b><br>
    &nbsp;&nbsp;&nbsp;&nbsp;3.1 <a href="#restrictString">Restricting the Value of Strings</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;3.2 <a href="#restrictNumber">Restricting Numeric Values</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;3.3 <a href="#otherTermConstraints">Other Term Constraints</a><br>
    4 <b><a href="#sparqlSyntax">SPARQL Syntax</a></b><br>
    &nbsp;&nbsp;&nbsp;&nbsp;4.1 <a href="#syntaxTerms">RDF Term Syntax</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.1.1 <a href="#QSynIRI">Syntax for IRIs</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.1.1.1 <a href="#prefNames">Prefixed Names</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.1.1.2 <a href="#relIRIs">Relative IRIs</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.1.2 <a href="#QSynLiterals">Syntax for Literals</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.1.3 <a href="#QSynVariables">Syntax for Query Variables</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.1.4 <a href="#QSynBlankNodes">Syntax for Blank Nodes</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;4.2 <a href="#QSynTriples">Syntax for Triple Patterns</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.2.1 <a href="#predObjLists">Predicate-Object Lists</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.2.2 <a href="#objLists">Object Lists</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.2.3 <a href="#collections">RDF Collections</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.2.4 <a href="#abbrevRdfType">rdf:type</a><br>
    5 <b><a href="#GraphPattern">Graph Patterns</a></b><br>
    &nbsp;&nbsp;&nbsp;&nbsp;5.1 <a href="#BasicGraphPatterns">Basic Graph Patterns</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.1.1 <a href="#bgpBNodeLabels">Blank Node Labels</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.1.2 <a href="#bgpExtend">Extending Basic Graph Pattern Matching</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;5.2 <a href="#GroupPatterns">Group Graph Patterns</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.2.1 <a href="#emptyGroupPattern">Empty Group Pattern</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.2.2 <a href="#scopeFilters">Scope of Filters</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.2.3 <a href="#groupExamples">Group Graph Pattern Examples</a><br>
    6 <b><a href="#optionals">Including Optional Values</a></b><br>
    &nbsp;&nbsp;&nbsp;&nbsp;6.1 <a href="#OptionalMatching">Optional Pattern Matching</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;6.2 <a href="#OptionalAndConstraints">Constraints in Optional Pattern Matching</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;6.3 <a href="#MultipleOptionals">Multiple Optional Graph Patterns</a><br>
    7 <b><a href="#alternatives">Matching Alternatives</a></b><br>
    8 <b><a href="#negation">Negation</a></b><br>
    &nbsp;&nbsp;&nbsp;&nbsp;8.1 <a href="#neg-pattern">Filtering Using Graph Patterns</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.1.1 <a href="#neg-notexists">Testing For the Absence of a Pattern</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.1.2 <a href="#neg-exists">Testing For the Presence of a Pattern</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;8.2 <a href="#neg-minus">Removing Possible Solutions</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;8.3 <a href="#neg-notexists-minus">Relationship and differences between NOT EXISTS and MINUS</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.3.1 <a href="#neg-example-1">Example: Sharing of variables</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.3.2 <a href="#neg-example-2">Example: Fixed pattern</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.3.3 <a href="#idp899488">Example: Inner FILTERs</a><br>
    9 <b><a href="#propertypaths">Property Paths</a></b><br>
    &nbsp;&nbsp;&nbsp;&nbsp;9.1 <a href="#pp-language">Property Path Syntax</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;9.2 <a href="#propertypath-examples">Examples</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;9.3 <a href="#propertypath-syntaxforms">Property Paths and Equivalent Patterns</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;9.4 <a href="#propertypath-arbitrary-length">Arbitrary Length Path Matching</a><br>
    10 <b><a href="#assignment">Assignment</a></b><br>
    &nbsp;&nbsp;&nbsp;&nbsp;10.1 <a href="#bind">BIND: Assigning to Variables</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;10.2 <a href="#inline-data">VALUES: Providing inline data</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.2.1 <a href="#inline-data-syntax">VALUES syntax</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.2.2 <a href="#inline-data-examples">VALUES Examples</a><br>
    11 <b><a href="#aggregates">Aggregates</a></b><br>
    &nbsp;&nbsp;&nbsp;&nbsp;11.1 <a href="#aggregateExample">Aggregate Example</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;11.2 <a href="#groupby">GROUP BY</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;11.3 <a href="#having">HAVING</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;11.4 <a href="#aggregateRestrictions">Aggregate Projection Restrictions</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;11.5 <a href="#aggregateExample2">Aggregate Example (with errors)</a><br>
    12 <b><a href="#subqueries">Subqueries</a></b><br>
    13 <b><a href="#rdfDataset">RDF Dataset</a></b><br>
    &nbsp;&nbsp;&nbsp;&nbsp;13.1 <a href="#exampleDatasets">Examples of RDF Datasets</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;13.2 <a href="#specifyingDataset">Specifying RDF Datasets</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;13.2.1 <a href="#unnamedGraph">Specifying the Default Graph</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;13.2.2 <a href="#namedGraphs">Specifying Named Graphs</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;13.2.3 <a href="#specDataset">Combining FROM and FROM NAMED</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;13.3 <a href="#queryDataset">Querying the Dataset</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;13.3.1 <a href="#accessByLabel">Accessing Graph Names</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;13.3.2 <a href="#restrictByLabel">Restricting by Graph IRI</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;13.3.3 <a href="#restrictInQuery">Restricting Possible Graph IRIs</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;13.3.4 <a href="#namedAndDefaultGraph">Named and Default Graphs</a><br>
    14 <b><a href="#basic-federated-query">Basic Federated Query</a></b><br>
    15 <b><a href="#solutionModifiers">Solution Sequences and Modifiers</a></b><br>
    &nbsp;&nbsp;&nbsp;&nbsp;15.1 <a href="#modOrderBy">ORDER BY</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;15.2 <a href="#modProjection">Projection</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;15.3 <a href="#modDuplicates">Duplicate Solutions</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;15.4 <a href="#modOffset">OFFSET</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;15.5 <a href="#modResultLimit">LIMIT</a><br>
    16 <b><a href="#QueryForms">Query Forms</a></b><br>
    &nbsp;&nbsp;&nbsp;&nbsp;16.1 <a href="#select">SELECT</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16.1.1 <a href="#selectproject">Projection</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16.1.2 <a href="#selectExpressions">SELECT Expressions</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;16.2 <a href="#construct">CONSTRUCT</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16.2.1 <a href="#templatesWithBNodes">Templates with Blank Nodes</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16.2.2 <a href="#accessingRdfGraphs">Accessing Graphs in the RDF Dataset</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16.2.3 <a href="#SolModandCONSTRUCT">Solution Modifiers and CONSTRUCT</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16.2.4 <a href="#constructWhere">CONSTRUCT WHERE</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;16.3 <a href="#ask">ASK</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;16.4 <a href="#describe">DESCRIBE (Informative)</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16.4.1 <a href="#explicitIRIs">Explicit IRIs</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16.4.2 <a href="#identifyingResources">Identifying Resources</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16.4.3 <a href="#descriptionsOfResources">Descriptions of Resources</a><br>
    17 <b><a href="#expressions">Expressions and Testing Values</a></b><br>
    &nbsp;&nbsp;&nbsp;&nbsp;17.1 <a href="#operandDataTypes">Operand Data Types</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;17.2 <a href="#evaluation">Filter Evaluation</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.2.1 <a href="#invocation">Invocation</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.2.2 <a href="#ebv">Effective Boolean Value (EBV)</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;17.3 <a href="#OperatorMapping">Operator Mapping</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.3.1 <a href="#operatorExtensibility">Operator Extensibility</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;17.4 <a href="#SparqlOps">Function Definitions</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.1 <a href="#func-forms">Functional Forms</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.1.1 <a href="#func-bound">bound</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.1.2 <a href="#func-if">IF</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.1.3 <a href="#func-coalesce">COALESCE</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.1.4 <a href="#func-filter-exists">NOT EXISTS and EXISTS</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.1.5 <a href="#func-logical-or">logical-or</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.1.6 <a href="#func-logical-and">logical-and</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.1.7 <a href="#func-RDFterm-equal">RDFterm-equal</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.1.8 <a href="#func-sameTerm">sameTerm</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.1.9 <a href="#func-in">IN</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.1.10 <a href="#func-not-in">NOT IN</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.2 <a href="#func-rdfTerms">Functions on RDF Terms</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.2.1 <a href="#func-isIRI">isIRI</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.2.2 <a href="#func-isBlank">isBlank</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.2.3 <a href="#func-isLiteral">isLiteral</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.2.4 <a href="#func-isNumeric">isNumeric</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.2.5 <a href="#func-str">str</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.2.6 <a href="#func-lang">lang</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.2.7 <a href="#func-datatype">datatype</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.2.8 <a href="#func-iri">IRI</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.2.9 <a href="#func-bnode">BNODE</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.2.10 <a href="#func-strdt">STRDT</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.2.11 <a href="#func-strlang">STRLANG</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.2.12 <a href="#func-uuid">UUID</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.2.13 <a href="#func-struuid">STRUUID</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.3 <a href="#func-strings">Functions on Strings</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.3.1 <a href="#idp1887976">Strings in SPARQL Functions</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.3.1.1 <a href="#func-string">String arguments</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.3.1.2 <a href="#func-arg-compatibility">Argument Compatibility Rules</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.3.1.3 <a href="#idp1915512">String Literal Return Type</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.3.2 <a href="#func-strlen">STRLEN</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.3.3 <a href="#func-substr">SUBSTR</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.3.4 <a href="#func-ucase">UCASE</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.3.5 <a href="#func-lcase">LCASE</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.3.6 <a href="#func-strstarts">STRSTARTS</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.3.7 <a href="#func-strends">STRENDS</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.3.8 <a href="#func-contains">CONTAINS</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.3.9 <a href="#func-strbefore">STRBEFORE</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.3.10 <a href="#func-strafter">STRAFTER</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.3.11 <a href="#func-encode">ENCODE_FOR_URI</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.3.12 <a href="#func-concat">CONCAT</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.3.13 <a href="#func-langMatches">langMatches</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.3.14 <a href="#func-regex">REGEX</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.3.15 <a href="#func-replace">REPLACE</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.4 <a href="#func-numerics">Functions on Numerics</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.4.1 <a href="#func-abs">abs</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.4.2 <a href="#func-round">round</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.4.3 <a href="#func-ceil">ceil</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.4.4 <a href="#func-floor">floor</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.4.5 <a href="#idp2130040">RAND</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.5 <a href="#func-date-time">Functions on Dates and Times</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.5.1 <a href="#func-now">now</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.5.2 <a href="#func-year">year</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.5.3 <a href="#func-month">month</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.5.4 <a href="#func-day">day</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.5.5 <a href="#func-hours">hours</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.5.6 <a href="#func-minutes">minutes</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.5.7 <a href="#func-seconds">seconds</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.5.8 <a href="#func-timezone">timezone</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.5.9 <a href="#func-tz">tz</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.6 <a href="#func-hash">Hash Functions</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.6.1 <a href="#func-md5">MD5</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.6.2 <a href="#func-sha1">SHA1</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.6.3 <a href="#func-sha256">SHA256</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.6.4 <a href="#func-sha384">SHA384</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.6.5 <a href="#func-sha512">SHA512</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;17.5 <a href="#FunctionMapping">XPath Constructor Functions</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;17.6 <a href="#extensionFunctions">Extensible Value Testing</a><br>
    18 <b><a href="#sparqlDefinition">Definition of SPARQL</a></b><br>
    &nbsp;&nbsp;&nbsp;&nbsp;18.1 <a href="#initDefinitions">Initial Definitions</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.1.1 <a href="#sparqlBasicTerms">RDF Terms</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.1.2 <a href="#simple_literal">Simple Literal</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.1.3 <a href="#sparqlDataset">RDF Dataset</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.1.4 <a href="#sparqlQueryVariables">Query Variables</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.1.5 <a href="#sparqlTriplePatterns">Triple Patterns</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.1.6 <a href="#sparqlBasicGraphPatterns">Basic Graph Patterns</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.1.7 <a href="#sparqlPropertyPaths">Property Path Patterns</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.1.8 <a href="#sparqlSolutions">Solution Mapping</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.1.9 <a href="#sparqlSolMod">Solution Sequence Modifiers</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.1.10 <a href="#idp2427544">SPARQL Query</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;18.2 <a href="#sparqlQuery">Translation to the SPARQL Algebra</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.2.1 <a href="#variableScope">Variable Scope</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.2.2 <a href="#convertGraphPattern">Converting Graph Patterns</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.2.2.1 <a href="#sparqlExpandForms">Expand Syntax Forms</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.2.2.2 <a href="#sparqlCollectFilters">Collect FILTER Elements</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.2.2.3 <a href="#sparqlTranslatePathExpressions">Translate Property Path Expressions</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.2.2.4 <a href="#sparqlTranslatePathPatterns">Translate Property Path Patterns</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.2.2.5 <a href="#sparqlTranslateBasicGraphPatterns">Translate Basic Graph Patterns</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.2.2.6 <a href="#sparqlTranslateGraphPatterns">Translate Graph Patterns</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.2.2.7 <a href="#sparqlAddFilters">Filters of Group</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.2.2.8 <a href="#sparqlSimplification">Simplification step</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.2.3 <a href="#sparqlAlgebraExamples">Examples of Mapped Graph Patterns</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.2.4 <a href="#convertGroupAggSelectExpressions">Converting Groups, Aggregates, HAVING, final VALUES clause and SELECT Expressions</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.2.4.1 <a href="#sparqlGroupAggregate">Grouping and Aggregation</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.2.4.2 <a href="#sparqlHavingClause">HAVING</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.2.4.3 <a href="#sparqlAlgebraFinalValues">VALUES</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.2.4.4 <a href="#sparqlSelectExpressions">SELECT Expressions</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.2.5 <a href="#convertSolMod">Converting Solution Modifiers</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.2.5.1 <a href="#sparqlOrderBy">ORDER BY</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.2.5.2 <a href="#sparqlProjection">Projection</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.2.5.3 <a href="#sparqlDistinct">DISTINCT</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.2.5.4 <a href="#sparqlReduced">REDUCED</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.2.5.5 <a href="#sparqlOffsetLimit">OFFSET and LIMIT</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.2.5.6 <a href="#sparqlAlgebraOutcome">Final Algebra Expression</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;18.3 <a href="#BasicGraphPattern">Basic Graph Patterns</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.3.1 <a href="#BGPsparql">SPARQL Basic Graph Pattern Matching</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.3.2 <a href="#BGPsparqlBNodes">Treatment of Blank Nodes</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;18.4 <a href="#PropertyPathPatterns">Property Path Patterns</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;18.5 <a href="#sparqlAlgebra">SPARQL Algebra</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.5.1 <a href="#aggregateAlgebra">Aggregate Algebra</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.5.1.1 <a href="#setFunctions">Set Functions</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.5.1.2 <a href="#defn_aggCount">Count</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.5.1.3 <a href="#defn_aggSum">Sum</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.5.1.4 <a href="#defn_aggAvg">Avg</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.5.1.5 <a href="#defn_aggMin">Min</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.5.1.6 <a href="#defn_aggMax">Max</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.5.1.7 <a href="#defn_aggGroupConcat">GroupConcat</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.5.1.8 <a href="#defn_aggSample">Sample</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;18.6 <a href="#sparqlAlgebraEval">Evaluation Semantics</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;18.7 <a href="#sparqlBGPExtend">Extending SPARQL Basic Graph Matching</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.7.1 <a href="#sparqlBGPExtend-notes">Notes</a><br>
    19 <b><a href="#grammar">SPARQL Grammar</a></b><br>
    &nbsp;&nbsp;&nbsp;&nbsp;19.1 <a href="#queryString">SPARQL Request String</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;19.2 <a href="#codepointEscape">Codepoint Escape Sequences</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;19.3 <a href="#whitespace">White Space</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;19.4 <a href="#grammarComments">Comments</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;19.5 <a href="#iriRefs">IRI References</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;19.6 <a href="#grammarBNodes">Blank Nodes and Blank Node Labels</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;19.7 <a href="#grammarEscapes">Escape sequences in strings</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;19.8 <a href="#sparqlGrammar">Grammar</a><br>
    20 <b><a href="#conformance">Conformance</a></b><br>
    21 <b><a href="#security">Security Considerations (Informative)</a></b><br>
    22 <b><a href="#mediaType">Internet Media Type, File Extension and Macintosh File Type</a></b><br></p>
    <h3><a name="appendices" id="appendices"></a>Appendix</h3>
    <p class="toc">A <b><a href="#sec-bibliography">References</a></b><br>
    &nbsp;&nbsp;&nbsp;&nbsp;A.1 <a href="#sec-normative-refs">Normative References</a><br>
    &nbsp;&nbsp;&nbsp;&nbsp;A.2 <a href="#sec-non-normative-refs">Other References</a><br></p>
  </div>
  <hr>
  <div class="body">
    <div class="div1">
      <h2><a name="introduction" id="introduction"></a>1 Introduction</h2>
      <p>RDF is a directed, labeled graph data format for representing information in the Web. RDF is often used to represent, among other things, personal information, social networks, metadata
      about digital artifacts, as well as to provide a means of integration over disparate sources of information. This specification defines the syntax and semantics of the SPARQL query language for
      RDF.</p>
      <p>The SPARQL query language for RDF is designed to meet the use cases and requirements identified by the RDF Data Access Working Group in <a href="http://www.w3.org/TR/rdf-dawg-uc/" class=
      "inform">RDF Data Access Use Cases and Requirements</a> [<a href="#UCNR">UCNR</a>] and <a href="http://www.w3.org/TR/sparql-features/" class="inform">SPARQL New Features and Rationale</a>
      [<a href="#UCNR2">UCNR2</a>].</p>
      <div class="div2">
        <h3><a name="docOutline" id="docOutline"></a>1.1 Document Outline</h3>
        <p>Unless otherwise noted in the section heading, all sections and appendices in this document are normative.</p>
        <p>This section of the document, <a href="#introduction">section 1</a>, introduces the SPARQL query language specification. It presents the organization of this specification document and the
        conventions used throughout the specification.</p>
        <p><a href="#basicpatterns">Section 2</a> of the specification introduces the SPARQL query language itself via a series of example queries and query results. <a href="#termConstraint">Section
        3</a> continues the introduction of the SPARQL query language with more examples that demonstrate SPARQL's ability to express constraints on the RDF terms that appear in a query's
        results.</p>
        <p><a href="#sparqlSyntax">Section 4</a> presents details of the SPARQL query language's syntax. It is a companion to the full grammar of the language and defines how grammatical constructs
        represent IRIs, blank nodes, literals, and variables. Section 4 also defines the meaning of several grammatical constructs that serve as syntactic sugar for more verbose expressions.</p>
        <p><a href="#GraphPattern">Section 5</a> introduces basic graph patterns and group graph patterns, the building blocks from which more complex SPARQL query patterns are constructed. Sections
        6, 7, and 8 present constructs that combine SPARQL graph patterns into larger graph patterns. In particular, <a href="#optionals">Section 6</a> introduces the ability to make portions of a
        query optional; <a href="#alternatives">Section 7</a> introduces the ability to express the disjunction of alternative graph patterns; and <a href="#negation">Section 8</a> introduces
        patterns to test for the absense of information.</p>
        <p><a href="#propertypaths">Section 9</a> adds property paths to graph pattern matching, giving a compact representation of queries and also the ability to match arbitrary length paths in the
        graph.</p>
        <p><a href="#assignment">Section 10</a> describes the forms of assignment possible in SPARQL.</p>
        <p><a href="#aggregates">Sections 11</a> introduces the mechanism to group and aggregate results, which can be incorporated as subqueries as described in <a href="#subqueries">Section
        12</a>.</p>
        <p><a href="#rdfDataset">Section 13</a> introduces the ability to constrain portions of a query to particular source graphs. Section 13 also presents SPARQL's mechanism for defining the
        source graphs for a query.</p>
        <p><a href="#basic-federated-query">Section 14</a> refers to the separate document <a href="http://www.w3.org/TR/sparql11-federated-query/">SPARQL 1.1 Federated Query</a>.</p>
        <p><a href="#solutionModifiers">Section 15</a> defines the constructs that affect the solutions of a query by ordering, slicing, projecting, limiting, and removing duplicates from a sequence
        of solutions.</p>
        <p><a href="#QueryForms">Section 16</a> defines the four types of SPARQL queries that produce results in different forms.</p>
        <p><a href="#expressions">Section 17</a> defines SPARQL's extensible value testing and expression framework. It presents the functions and operators that can be used to constrain the values
        that appear in a query's results and also calculate new values to be returned by a query.</p>
        <p><a href="#sparqlDefinition">Section 18</a> is a formal definition of the evaluation of SPARQL graph patterns and solution modifiers.</p>
        <p><a href="#grammar">Section 19</a> contains the normative definition of the syntax for the SPARQL query and <a href="http://www.w3.org/TR/sparql11-update/">SPARQL update</a> languages, as
        given by a grammar expressed in EBNF notation.</p>
      </div>
      <div class="div2">
        <h3><a name="docConventions" id="docConventions"></a>1.2 Document Conventions</h3>
        <div class="div3">
          <h4><a name="docNamespaces" id="docNamespaces"></a>1.2.1 Namespaces</h4>
          <p>In this document, examples assume the following namespace prefix bindings unless otherwise stated:</p>
          <div style="text-align: center;">
            <table style="border-collapse: collapse; border-color: #000000" cellpadding="5" border="1">
              <tbody>
                <tr>
                  <th>Prefix</th>
                  <th>IRI</th>
                </tr>
                <tr>
                  <td><code>rdf:</code></td>
                  <td><code>http://www.w3.org/1999/02/22-rdf-syntax-ns#</code></td>
                </tr>
                <tr>
                  <td><code>rdfs:</code></td>
                  <td><code>http://www.w3.org/2000/01/rdf-schema#</code></td>
                </tr>
                <tr>
                  <td><code>xsd:</code></td>
                  <td><code>http://www.w3.org/2001/XMLSchema#</code></td>
                </tr>
                <tr>
                  <td><code>fn:</code></td>
                  <td><code>http://www.w3.org/2005/xpath-functions#</code></td>
                </tr>
                <tr>
                  <td><code>sfn:</code></td>
                  <td><code>http://www.w3.org/ns/sparql#</code></td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
        <div class="div3">
          <h4><a name="docDataDesc" id="docDataDesc"></a>1.2.2 Data Descriptions</h4>
          <p>This document uses the <a class="inform" href="http://www.w3.org/TR/turtle/">Turtle</a> [<a href="#TURTLE">TURTLE</a>] data format to show each triple explicitly. Turtle allows IRIs to
          be abbreviated with prefixes:</p>
          <pre class="data">@prefix dc:   &lt;http://purl.org/dc/elements/1.1/&gt; .
@prefix :     &lt;http://example.org/book/&gt; .
:book1  dc:title  "SPARQL Tutorial" .</pre>
        </div>
        <div class="div3">
          <h4><a name="docResultDesc" id="docResultDesc"></a>1.2.3 Result Descriptions</h4>
          <p>Result sets are illustrated in tabular form.</p>
          <div class="result">
            <a name="table39" id="table39"></a>
            <table class="resultTable">
              <tbody>
                <tr>
                  <th>x</th>
                  <th>y</th>
                  <th>z</th>
                </tr>
                <tr>
                  <td>"Alice"</td>
                  <td><code>&lt;http://example/a&gt;</code></td>
                  <td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>A 'binding' is a pair (<a href="#defn_QueryVariable">variable</a>, <a href="#defn_RDFTerm">RDF term</a>). In this result set, there are three variables: <code>x</code>, <code>y</code>
          and <code>z</code> (shown as column headers). Each solution is shown as one row in the body of the table.&nbsp; Here, there is a single solution, in which variable <code>x</code> is bound
          to <code>"Alice"</code>, variable <code>y</code> is bound to <code>&lt;http://example/a&gt;</code>, and variable <code>z</code> is not bound to an RDF term. Variables are not required to be
          bound in a solution.</p>
        </div>
        <div class="div3">
          <h4><a name="docTerminology" id="docTerminology"></a>1.2.4 Terminology</h4>
          <p>The SPARQL language includes IRIs, a subset of RDF URI References that omits spaces. Note that all IRIs in SPARQL queries are absolute; they may or may not include a fragment identifier
          [<a href="#rfc3987">RFC3987</a>, section 3.1]. IRIs include URIs [<a href="#rfc3986">RFC3986</a>] and URLs. The abbreviated forms (<a href="#QSynIRI">relative IRIs and prefixed names</a>)
          in the SPARQL syntax are resolved to produce absolute IRIs.</p>
          <p>The following terms are defined in <a class="norm" href="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/">RDF Concepts and Abstract Syntax</a> <a href="#CONCEPTS">[CONCEPTS]</a> and
          used in SPARQL:</p>
          <ul>
            <li><a class="type IRI" href="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-URI-reference">IRI</a> (corresponds to the Concepts and Abstract Syntax term "<code>RDF URI
            reference</code>")</li>
            <li><a class="type literal" href="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-literal">literal</a></li>
            <li><a class="type lexicalForm" href="http://www.w3.org/TR/rdf-concepts/#dfn-lexical-form">lexical form</a></li>
            <li><a class="type plainLiteral" href="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-plain-literal">plain literal</a></li>
            <li><a class="type langTag" href="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-language-identifier">language tag</a></li>
            <li><a class="type typedLiteral" href="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-typed-literal">typed literal</a></li>
            <li><a class="type datatypeIRI" href="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-datatype-URI">datatype IRI</a> (corresponds to the Concepts and Abstract Syntax term
            "<code>datatype URI</code>")</li>
            <li><a class="type bNode" href="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-blank-node">blank node</a></li>
          </ul>
          <p>In addition, we define the following terms:</p>
          <ul>
            <li><a class="type" href="#defn_RDFTerm">RDF Term</a>, which includes IRIs, blank nodes and literals</li>
            <li><a class="type" href="#defn_SimpleLiteral">Simple Literal</a>, which covers literals without language tag or datatype IRI</li>
          </ul>
        </div>
      </div>
    </div>
    <div class="div1">
      <h2><a name="basicpatterns" id="basicpatterns"></a>2 Making Simple Queries (Informative)</h2>
      <p>Most forms of SPARQL query contain a set of triple patterns called a <em>basic graph pattern</em>. Triple patterns are like RDF triples except that each of the subject, predicate and object
      may be a variable. A basic graph pattern <em>matches</em> a subgraph of the RDF data when <a href="#defn_RDFTerm">RDF terms</a> from that subgraph may be substituted for the variables and the
      result is RDF graph equivalent to the subgraph.</p>
      <div class="div2">
        <h3><a name="WritingSimpleQueries" id="WritingSimpleQueries"></a>2.1 Writing a Simple Query</h3>
        <p>The example below shows a SPARQL query to find the title of a book from the given data graph. The query consists of two parts: the <code>SELECT</code> clause identifies the variables to
        appear in the query results, and the <code>WHERE</code> clause provides the basic graph pattern to match against the data graph. The basic graph pattern in this example consists of a single
        triple pattern with a single variable (<code>?title</code>) in the object position.</p>
        <div class="exampleGroup">
          <p>Data:</p>
          <pre class="data">&lt;http://example.org/book/book1&gt; &lt;http://purl.org/dc/elements/1.1/title&gt; "SPARQL Tutorial" .</pre>
          <div class="queryGroup">
            <p>Query:</p>
            <pre class="query">SELECT ?title
WHERE
{
  &lt;http://example.org/book/book1&gt; &lt;http://purl.org/dc/elements/1.1/title&gt; ?title .
}</pre>
            <p>This query, on the data above, has one solution:</p>
            <p>Query Result:</p>
            <div class="result">
              <a name="table109" id="table109"></a>
              <table class="resultTable">
                <tbody>
                  <tr>
                    <th>title</th>
                  </tr>
                  <tr>
                    <td>"SPARQL Tutorial"</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>
      </div>
      <div class="div2">
        <h3><a name="MultipleMatches" id="MultipleMatches"></a>2.2 Multiple Matches</h3>
        <p>The result of a query is a <a href="#defn_sparqlSolutionSequence">solution sequence</a>, corresponding to the ways in which the query's graph pattern matches the data. There may be zero,
        one or multiple solutions to a query.</p>
        <p>Data:</p>
        <div class="exampleGroup">
          <pre class="data">@prefix foaf:  &lt;<a href="http://xmlns.com/foaf/0.1/">http://xmlns.com/foaf/0.1/</a>&gt; .

_:a  foaf:name   "Johnny Lee Outlaw" .
_:a  foaf:mbox   &lt;mailto:jlow@example.com&gt; .
_:b  foaf:name   "Peter Goodguy" .
_:b  foaf:mbox   &lt;mailto:peter@example.org&gt; .
_:c  foaf:mbox   &lt;mailto:carol@example.org&gt; .
</pre>
          <p>Query:</p>
          <div class="queryGroup">
            <pre class="query">PREFIX foaf:   &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name ?mbox
WHERE
  { ?x foaf:name ?name .
    ?x foaf:mbox ?mbox }</pre>
            <p>Query Result:</p>
            <div class="result">
              <table class="resultTable">
                <tbody>
                  <tr>
                    <th>name</th>
                    <th>mbox</th>
                  </tr>
                  <tr>
                    <td>"Johnny Lee Outlaw"</td>
                    <td>&lt;mailto:jlow@example.com&gt;</td>
                  </tr>
                  <tr>
                    <td>"Peter Goodguy"</td>
                    <td>&lt;mailto:peter@example.org&gt;</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>
        <p>Each solution gives one way in which the selected variables can be bound to RDF terms so that the query pattern matches the data. The result set gives all the possible solutions. In the
        above example, the following two subsets of the data provided the two matches.</p>
        <pre class="dataExcerpt untested"> _:a foaf:name  "Johnny Lee Outlaw" .
 _:a foaf:box   &lt;mailto:jlow@example.com&gt; .</pre>
        <pre class="dataExcerpt untested"> _:b foaf:name  "Peter Goodguy" .
 _:b foaf:box   &lt;mailto:peter@example.org&gt; .</pre>
        <p>This is a <a href="#BGPsparql">basic graph pattern match</a>; all the variables used in the query pattern must be bound in every solution.</p>
      </div>
      <div class="div2">
        <h3><a name="matchingRDFLiterals" id="matchingRDFLiterals"></a>2.3 Matching RDF Literals</h3>
        <p>The data below contains three RDF literals:</p>
        <div class="exampleGroup">
          <pre class="data">@prefix dt:   &lt;http://example.org/datatype#&gt; .
@prefix ns:   &lt;http://example.org/ns#&gt; .
@prefix :     &lt;http://example.org/ns#&gt; .
@prefix xsd:  &lt;<code>http://www.w3.org/2001/XMLSchema#&gt; .</code>

:x   ns:p     "cat"@en .
:y   ns:p     "42"^^xsd:integer .
:z   ns:p     "abc"^^dt:specialDatatype .</pre>
          <p>Note that, in Turtle, <code>"cat"@en</code> is an RDF literal with a lexical form "cat" and a language tag "en"; <code>"42"^^xsd:integer</code> is a typed literal with the datatype
          <code>http://www.w3.org/2001/XMLSchema#integer</code>; and <code>"abc"^^dt:specialDatatype</code> is a typed literal with the datatype
          <code>http://example.org/datatype#specialDatatype</code>.</p>
        </div>
        <p>This RDF data is the data graph for the query examples in sections 2.3.1–2.3.3.</p>
        <div class="div3">
          <h4><a name="matchLangTags" id="matchLangTags"></a>2.3.1 Matching Literals with Language Tags</h4>
          <p>Language tags in SPARQL are expressed using <code>@</code> and the language tag, as defined in <a class="norm" href="http://www.rfc-editor.org/rfc/bcp/bcp47.txt">Best Common Practice
          47</a> [<a href="#BCP47">BCP47</a>].</p>
          <p>This following query has no solution because <code>"cat"</code> is not the same RDF literal as <code>"cat"@en</code>:</p>
          <div class="queryGroup">
            <pre class="query">SELECT ?v WHERE { ?v ?p "cat" }</pre>
            <div class="result">
              <table class="resultTable">
                <tbody>
                  <tr>
                    <th>&nbsp;&nbsp; v&nbsp;&nbsp;&nbsp;&nbsp;</th>
                  </tr>
                </tbody>
              </table>
            </div>
            <p>but the query below will find a solution where variable <code>v</code> is bound to <code>:x</code> because the language tag is specified and matches the given data:</p>
            <pre class="query">SELECT ?v WHERE { ?v ?p "cat"@en }
</pre>
            <div class="result">
              <table class="resultTable">
                <tbody>
                  <tr>
                    <th>v</th>
                  </tr>
                  <tr>
                    <td>&lt;http://example.org/ns#x&gt;</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>
        <div class="div3">
          <h4><a name="matchNumber" id="matchNumber"></a>2.3.2 Matching Literals with Numeric Types</h4>
          <p>Integers in a SPARQL query indicate an RDF typed literal with the datatype <code>xsd:integer</code>. For example: <code>42</code> is a shortened form of&nbsp;
          <code>"42"^^&lt;http://www.w3.org/2001/XMLSchema#integer&gt;</code>.</p>
          <p>The pattern in the following query has a solution with variable <code>v</code> bound to <code>:y</code>.</p>
          <div class="queryGroup">
            <pre class="query">SELECT ?v WHERE { ?v ?p 42 }
</pre>
            <div class="result">
              <a name="table60" id="table60"></a>
              <table class="resultTable">
                <tbody>
                  <tr>
                    <th>v</th>
                  </tr>
                  <tr>
                    <td>&lt;http://example.org/ns#y&gt;</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
          <p><a href="#QSynLiterals">Section 4.1.2</a> defines SPARQL shortened forms for <code>xsd:float</code> and <code>xsd:double</code>.</p>
        </div>
        <div class="div3">
          <h4><a name="matchArbDT" id="matchArbDT"></a>2.3.3 Matching Literals with Arbitrary Datatypes</h4>
          <p>The following query has a solution with variable <code>v</code> bound to <code>:z</code>. The query processor does not have to have any understanding of the values in the space of the
          datatype. Because the lexical form and datatype IRI both match, the literal matches.</p>
          <div class="queryGroup">
            <pre class="query">SELECT ?v WHERE { ?v ?p "abc"^^&lt;http://example.org/datatype#specialDatatype&gt; }
</pre>
            <div class="result">
              <a name="table61" id="table61"></a>
              <table class="resultTable">
                <tbody>
                  <tr>
                    <th>v</th>
                  </tr>
                  <tr>
                    <td>&lt;http://example.org/ns#z&gt;</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>
      </div>
      <div class="div2">
        <h3><a name="BlankNodesInResults" id="BlankNodesInResults"></a>2.4 Blank Node Labels in Query Results</h3>
        <p>Query results can contain blank nodes. Blank nodes in the example result sets in this document are written in the form "_:" followed by a blank node label.</p>
        <p>Blank node labels are scoped to a result set (see "<a class="inform" href="http://www.w3.org/TR/rdf-sparql-XMLres/">SPARQL Query Results XML Format</a>" and "<a href=
        "http://www.w3.org/TR/sparql11-results-json/">SPARQL 1.1 Query Results JSON Format</a>") or, for the <code>CONSTRUCT</code> query form, the result graph. Use of the same label within a result
        set indicates the same blank node.</p>
        <div class="exampleGroup">
          Data:
          <pre class="data">@prefix foaf:  &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a  foaf:name   "Alice" .
_:b  foaf:name   "Bob" .
</pre>
          <div class="queryGroup">
            Query:
            <pre class="query">PREFIX foaf:   &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?x ?name
WHERE  { ?x foaf:name ?name }
</pre>
            <div class="result">
              <a name="table56" id="table56"></a>
              <table class="resultTable">
                <tbody>
                  <tr>
                    <th>x</th>
                    <th>name</th>
                  </tr>
                  <tr>
                    <td>_:c</td>
                    <td>"Alice"</td>
                  </tr>
                  <tr>
                    <td>_:d</td>
                    <td>"Bob"</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
          <p>The results above could equally be given with different blank node labels because the labels in the results only indicate whether RDF terms in the solutions are the same or
          different.</p>
          <div class="result untested">
            <a name="table57" id="table57"></a>
            <table class="resultTable">
              <tbody>
                <tr>
                  <th>x</th>
                  <th>name</th>
                </tr>
                <tr>
                  <td>_:r</td>
                  <td>"Alice"</td>
                </tr>
                <tr>
                  <td>_:s</td>
                  <td>"Bob"</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
        <p>These two results have the same information: the blank nodes used to match the query are different in the two solutions. There need not be any relation between a label <code>_:a</code> in
        the result set and a blank node in the data graph with the same label.</p>
        <p>An application writer should not expect blank node labels in a query to refer to a particular blank node in the data.</p>
      </div>
      <div class="div2">
        <h3><a name="CreatingValuesWithExpressions" id="CreatingValuesWithExpressions"></a>2.5 Creating Values with Expressions</h3>
        <p>SPARQL 1.1 allows to create values from complex expressions. The queries below show how to the <a href="#func-concat">CONCAT</a> function can be used to concatenate first names and last
        names from foaf data, then assign the value using an <a href="#selectExpressions">expression in the <code>SELECT</code> clause</a> and also assign the value by using the <a href=
        "#bind">BIND</a> form.</p>
        <div class="exampleGroup">
          Data:
          <pre class="data">@prefix foaf:  &lt;http://xmlns.com/foaf/0.1/&gt; .
          
_:a  foaf:givenName   "John" .
_:a  foaf:surname  "Doe" .</pre>
          <div class="queryGroup">
            Query:
            <pre class="query">PREFIX foaf:   &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ( CONCAT(?G, " ", ?S) AS ?name )
WHERE  { ?P foaf:givenName ?G ; foaf:surname ?S }</pre>Query:
            <pre class="query">PREFIX foaf:   &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name
WHERE  { 
   ?P foaf:givenName ?G ; 
      foaf:surname ?S 
   BIND(CONCAT(?G, " ", ?S) AS ?name)
}</pre>
            <div class="result">
              <a name="table59" id="table59"></a>
              <table class="resultTable">
                <tbody>
                  <tr>
                    <th>name</th>
                  </tr>
                  <tr>
                    <td>"John Doe"</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>
      </div>
      <div class="div2">
        <h3><a name="constructGraph" id="constructGraph"></a>2.6 Building RDF Graphs</h3>
        <p>SPARQL has several <a href="#QueryForms">query forms</a>. The <code>SELECT</code> query form returns variable bindings. The <code>CONSTRUCT</code> query form returns an RDF graph. The
        graph is built based on a template which is used to generate RDF triples based on the results of matching the graph pattern of the query.</p>
        <div class="exampleGroup">
          <p>Data:</p>
          <pre class="data">@prefix org:    &lt;http://example.com/ns#&gt; .

_:a  org:employeeName   "Alice" .
_:a  org:employeeId     12345 .

_:b  org:employeeName   "Bob" .
_:b  org:employeeId     67890 .</pre>
          <div class="queryGroup">
            <p>Query:</p>
            <pre class="query">PREFIX foaf:   &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX org:    &lt;http://example.com/ns#&gt;

CONSTRUCT { ?x foaf:name ?name }
WHERE  { ?x org:employeeName ?name }</pre>
            <p>Results:</p>
            <div class="result">
              <pre class="resultGraph">@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .
      
_:x foaf:name "Alice" .
_:y foaf:name "Bob" .</pre>
            </div>
          </div>
          <p>which can be serialized in <a href="http://www.w3.org/TR/rdf-syntax-grammar/">RDF/XML</a> as:</p>
          <div class="result">
            <pre class="resultGraph" style="text-align: left;">&lt;rdf:RDF
    xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:foaf="http://xmlns.com/foaf/0.1/"
    &gt;
  &lt;rdf:Description&gt;
    &lt;foaf:name&gt;Alice&lt;/foaf:name&gt;
  &lt;/rdf:Description&gt;
  &lt;rdf:Description&gt;
    &lt;foaf:name&gt;Bob&lt;/foaf:name&gt;
  &lt;/rdf:Description&gt;
&lt;/rdf:RDF&gt;</pre>
          </div>
        </div>
      </div>
    </div>
    <div class="div1">
      <h2><a name="termConstraint" id="termConstraint"></a>3 RDF Term Constraints (Informative)</h2>
      <p>Graph pattern matching produces a solution sequence, where each solution has a set of bindings of variables to RDF terms. SPARQL <code>FILTER</code>s restrict solutions to those for which
      the filter expression evaluates to <code>TRUE</code>.</p>
      <p>This section provides an informal introduction to SPARQL <code>FILTER</code>s; their semantics are defined in section '<a href="#expressions">Expressions and Testing Values</a>' where there
      is a <a href="#SparqlOps">comprehensive function library</a>. The examples in this section share one input graph:</p>
      <div class="exampleGroup">
        Data:
        <pre class="data">@prefix dc:   &lt;http://purl.org/dc/elements/1.1/&gt; .
@prefix :     &lt;http://example.org/book/&gt; .
@prefix ns:   &lt;http://example.org/ns#&gt; .

:book1  dc:title  "SPARQL Tutorial" .
:book1  ns:price  42 .
:book2  dc:title  "The Semantic Web" .
:book2  ns:price  23 .
</pre>
      </div>
      <div class="div2">
        <h3><a name="restrictString" id="restrictString"></a>3.1 Restricting the Value of Strings</h3>
        <p>SPARQL <code>FILTER</code> functions like <code><a href="#func-regex">regex</a></code> can test RDF literals. <code>regex</code> matches only <a href="#func-string">string literals</a>.
        <code>regex</code> can be used to match the lexical forms of other literals by using the <a href="#func-str">str</a> function.</p>
        <p>Query:</p>
        <div class="queryGroup">
          <pre class="query">PREFIX  dc:  &lt;http://purl.org/dc/elements/1.1/&gt;
SELECT  ?title
WHERE   { ?x dc:title ?title
          FILTER regex(?title, "^SPARQL") 
        }
</pre>
          <p>Query Result:</p>
          <div class="result">
            <a name="table63" id="table63"></a>
            <table class="resultTable">
              <tbody>
                <tr>
                  <th>title</th>
                </tr>
                <tr>
                  <td>"SPARQL Tutorial"</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
        <p>Regular expression matches may be made case-insensitive with the "<code>i</code>" flag.</p>
        <p>Query:</p>
        <div class="queryGroup">
          <pre class="query">PREFIX  dc:  &lt;http://purl.org/dc/elements/1.1/&gt;
SELECT  ?title
WHERE   { ?x dc:title ?title
          FILTER regex(?title, "web", "i" ) 
        }
</pre>
          <p>Query Result:</p>
          <div class="result">
            <a name="table64" id="table64"></a>
            <table class="resultTable">
              <tbody>
                <tr>
                  <th>title</th>
                </tr>
                <tr>
                  <td>"The Semantic Web"</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
        <p>The regular expression language is <a href="http://www.w3.org/TR/xpath-functions/#regex-syntax">defined by XQuery 1.0 and XPath 2.0 Functions and Operators</a> and is based on <a href=
        "http://www.w3.org/TR/xmlschema-2/#regexs">XML Schema Regular Expressions</a>.</p>
      </div>
      <div class="div2">
        <h3><a name="restrictNumber" id="restrictNumber"></a>3.2 Restricting Numeric Values</h3>
        <p>SPARQL <code>FILTER</code>s can restrict on arithmetic expressions.</p>
        <p>Query:</p>
        <div class="queryGroup">
          <pre class="query">PREFIX  dc:  &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX  ns:  &lt;http://example.org/ns#&gt;
SELECT  ?title ?price
WHERE   { ?x ns:price ?price .
          FILTER (?price &lt; 30.5)
          ?x dc:title ?title . }</pre>
          <p>Query Result:</p>
          <div class="result">
            <a name="table58" id="table58"></a>
            <table class="resultTable">
              <tbody>
                <tr>
                  <th>title</th>
                  <th>price</th>
                </tr>
                <tr>
                  <td>"The Semantic Web"</td>
                  <td>23</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
      </div>
      <p>By constraining the <code>price</code> variable, only <code>:book2</code> matches the query because only <code>:book2</code> has a price less than <code>30.5</code>, as the filter condition
      requires.</p>
      <div class="div2">
        <h3><a name="otherTermConstraints" id="otherTermConstraints"></a>3.3 Other Term Constraints</h3>
        <p>In addition to <span class="type numeric">numeric</span> types, SPARQL supports types <code>xsd:string</code>, <code>xsd:boolean</code> and <code>xsd:dateTime</code> (see <a href=
        "#operandDataTypes">Operand Data Types</a>). Section <a href="#OperatorMapping">Operator Mapping</a> describes the operators and section <a href="#SparqlOps">Function Definitions</a> the
        functions that can be that can be applied to RDF terms.</p>
      </div>
    </div>
    <div class="div1">
      <h2><a name="sparqlSyntax" id="sparqlSyntax"></a>4 SPARQL Syntax</h2>
      <p>This section covers the syntax used by SPARQL for <a href="#sparqlBasicTerms">RDF terms</a> and <a href="#sparqlTriplePatterns">triple patterns</a>. The full grammar is given in <a href=
      "#grammar">section 19</a>.</p>
      <div class="div2">
        <h3><a name="syntaxTerms" id="syntaxTerms"></a>4.1 RDF Term Syntax</h3>
        <div class="div3">
          <h4><a name="QSynIRI" id="QSynIRI"></a>4.1.1 Syntax for IRIs</h4>
          <p>The <a href="#riri">iri</a> production designates the set of IRIs [<a href="#rfc3987">RFC3987</a>]; IRIs are a generalization of URIs [<a href="#rfc3986">RFC3986</a>] and are fully
          compatible with URIs and URLs. The <a href="#rPrefixedName">PrefixedName</a> production designates a prefixed name. The mapping from a prefixed name to an IRI is described below. IRI
          references (relative or absolute IRIs) are designated by the <a href="#rIRIREF">IRIREF</a> production, where the '&lt;' and '&gt;' delimiters do not form part of the IRI reference. Relative
          IRIs match the <code>irelative-ref</code> reference in section 2.2 ABNF for IRI References and IRIs in [<a href="#rfc3987">RFC3987</a>] and are resolved to IRIs as described below.</p>
          <p>The set of RDF terms defined in RDF Concepts and Abstract Syntax includes RDF URI references while SPARQL terms include IRIs. RDF URI references containing "<code>&lt;</code>",
          "<code>&gt;</code>", '<code>"</code>' (double quote), space, "<code>{</code>", "<code>}</code>", "<code>|</code>", "<code>\</code>", "<code>^</code>", and "<code>`</code>" are not IRIs. The
          behavior of a SPARQL query against RDF statements composed of such RDF URI references is not defined.</p>
          <div class="div4">
            <h5><a name="prefNames" id="prefNames"></a>4.1.1.1 Prefixed Names</h5>
            <p>The <code>PREFIX</code> keyword associates a prefix label with an IRI. A prefixed name is a prefix label and a local part, separated by a colon "<code>:</code>". A prefixed name is
            mapped to an IRI by concatenating the IRI associated with the prefix and the local part. The prefix label or the local part may be empty. Note that <a href="#rPN_LOCAL">SPARQL local
            names</a> allow leading digits while <a href="http://www.w3.org/TR/2006/REC-xml-names11-20060816/#NT-LocalPart">XML local names</a> do not. <a href="#rPN_LOCAL">SPARQL local names</a>
            also allow the non-alphanumeric characters allowed in IRIs via backslash character escapes (e.g. <code>ns:id\=123</code>). <a href="#rPN_LOCAL">SPARQL local names</a> have more syntactic
            restrictions than <a href="http://www.w3.org/TR/curie/">CURIE</a>s.</p>
          </div>
          <div class="div4">
            <h5><a name="relIRIs" id="relIRIs"></a>4.1.1.2 Relative IRIs</h5>
            <p>Relative IRIs are combined with base IRIs as per <a class="norm" href="http://www.ietf.org/rfc/rfc3986.txt">Uniform Resource Identifier (URI): Generic Syntax</a> [<a href=
            "#rfc3986">RFC3986</a>] using only the basic algorithm in section 5.2. Neither Syntax-Based Normalization nor Scheme-Based Normalization (described in sections 6.2.2 and 6.2.3 of RFC3986)
            are performed. Characters additionally allowed in IRI references are treated in the same way that unreserved characters are treated in URI references, per section 6.5 of <a class="norm"
            href="http://www.ietf.org/rfc/rfc3987.txt">Internationalized Resource Identifiers (IRIs)</a> [<a href="#rfc3987">RFC3987</a>].</p>
            <p>The <code>BASE</code> keyword defines the Base IRI used to resolve relative IRIs per RFC3986 section 5.1.1, "Base URI Embedded in Content". Section 5.1.2, "Base URI from the
            Encapsulating Entity" defines how the Base IRI may come from an encapsulating document, such as a SOAP envelope with an xml:base directive or a mime multipart document with a
            Content-Location header. The "Retrieval URI" identified in 5.1.3, Base "URI from the Retrieval URI", is the URL from which a particular SPARQL query was retrieved. If none of the above
            specifies the Base URI, the default Base URI (section 5.1.4, "Default Base URI") is used.</p>
            <p>The following fragments are some of the different ways to write the same IRI:</p>
            <pre class="data">&lt;http://example.org/book/book1&gt;</pre>
            <pre class="data">BASE &lt;http://example.org/book/&gt;
&lt;book1&gt;</pre>
            <pre class="data">PREFIX book: &lt;http://example.org/book/&gt;
book:book1</pre>
          </div>
        </div>
        <div class="div3">
          <h4><a name="QSynLiterals" id="QSynLiterals"></a>4.1.2 Syntax for Literals</h4>
          <p>The general syntax for literals is a string (enclosed in either double quotes, <code>"..."</code>, or single quotes, <code>'...'</code>), with either an optional language tag (introduced
          by <code>@</code>) or an optional datatype IRI or prefixed name (introduced by <code>^^</code>).</p>
          <p>As a convenience, integers can be written directly (without quotation marks and an explicit datatype IRI) and are interpreted as typed literals of datatype <code>xsd:integer</code>;
          decimal numbers for which there is '.' in the number but no exponent are interpreted as <code>xsd:decimal</code>; and numbers with exponents are interpreted as <code>xsd:double</code>.
          Values of type <code>xsd:boolean</code> can also be written as <code>true</code> or <code>false</code>.</p>
          <p>To facilitate writing literal values which themselves contain quotation marks or which are long and contain newline characters, SPARQL provides an additional quoting construct in which
          literals are enclosed in three single- or double-quotation marks.</p>
          <p>Examples of literal syntax in SPARQL include:</p>
          <ul>
            <li><code>"chat"</code></li>
            <li><code>'chat'@fr</code> with language tag "fr"</li>
            <li><code>"xyz"^^&lt;http://example.org/ns/userDatatype&gt;</code></li>
            <li><code>"abc"^^appNS:appDataType</code></li>
            <li><code>'''The librarian said, "Perhaps you would enjoy 'War and Peace'."'''</code></li>
            <li><code>1</code>, which is the same as <code>"1"^^xsd:integer</code></li>
            <li><code>1.3</code>, which is the same as <code>"1.3"^^xsd:decimal</code></li>
            <li><code>1.300</code>, which is the same as <code>"1.300"^^xsd:decimal</code></li>
            <li><code>1.0e6</code>, which is the same as <code>"1.0e6"^^xsd:double</code></li>
            <li><code>true</code>, which is the same as <code>"true"^^xsd:boolean</code></li>
            <li><code>false</code>, which is the same as <code>"false"^^xsd:boolean</code></li>
          </ul>
          <p>Tokens matching the productions <a href="#rINTEGER">INTEGER</a>, <a href="#rDECIMAL">DECIMAL</a>, <a href="#rDOUBLE">DOUBLE</a> and <a href="#rBooleanLiteral">BooleanLiteral</a> are
          equivalent to a typed literal with the lexical value of the token and the corresponding datatype (<code>xsd:integer</code>, <code>xsd:decimal</code>, <code>xsd:double</code>,
          <code>xsd:boolean</code>).</p>
        </div>
        <div class="div3">
          <h4><a name="QSynVariables" id="QSynVariables"></a>4.1.3 Syntax for Query Variables</h4>
          <p>A query variable is marked by the use of either "?" or "$"; the "?" or "$" is not part of the variable name. In a query, <code>$abc</code> and <code>?abc</code> identify the same
          variable. The <a href="#rVARNAME">possible names</a> for variables are given in the <a href="#grammar">SPARQL grammar</a>.</p>
        </div>
        <div class="div3">
          <h4><a name="QSynBlankNodes" id="QSynBlankNodes"></a>4.1.4 Syntax for Blank Nodes</h4>
          <p><a class="norm" href="http://www.w3.org/TR/rdf-concepts/#section-blank-nodes">Blank nodes</a> in graph patterns act as variables, not as references to specific blank nodes in the data
          being queried.</p>
          <p>Blank nodes are indicated by either the label form, such as "<code>_:abc</code>", or the abbreviated form "<code>[]</code>". A blank node that is used in only one place in the query
          syntax can be indicated with <code>[]</code>. A unique blank node will be used to form the triple pattern. Blank node labels are written as "<code>_:abc</code>" for a blank node with label
          "<code>abc</code>". The same blank node label cannot be used in two different basic graph patterns in the same query.</p>
          <p>The <code>[:p :v]</code> construct can be used in triple patterns. It creates a blank node label which is used as the subject of all contained predicate-object pairs. The created blank
          node can also be used in further triple patterns in the subject and object positions.</p>
          <p>The following two forms</p>
          <pre class="query untested">[ :p "v" ] .
</pre>
          <pre class="query untested">[] :p "v" .
</pre>
          <p>allocate a unique blank node label (here "<code>b57</code>") and are equivalent to writing:</p>
          <pre class="query untested">_:b57 :p "v" .
</pre>
          <p>This allocated blank node label can be used as the subject or object of further triple patterns. For example, as a subject:</p>
          <pre class="query untested">[ :p "v" ] :q "w" .
</pre>
          <p>which is equivalent to the two triples:</p>
          <pre class="query untested">_:b57 :p "v" .
_:b57 :q "w" .
</pre>
          <p>and as an object:</p>
          <pre class="query untested">:x :q [ :p "v" ] .
</pre>
          <p>which is equivalent to the two triples:</p>
          <pre class="query untested">:x  :q _:b57 .
_:b57 :p "v" .
</pre>
          <p>Abbreviated blank node syntax can be combined with other abbreviations for <a href="#predObjLists">common subjects</a> and <a href="#objLists">common predicates</a>.</p>
          <pre class="query untested">  [ foaf:name  ?name ;
    foaf:mbox  &lt;mailto:alice@example.org&gt; ]
</pre>
          <p>This is the same as writing the following basic graph pattern for some uniquely allocated blank node label, "<code>b18</code>":</p>
          <pre class="query untested">  _:b18  foaf:name  ?name .
  _:b18  foaf:mbox  &lt;mailto:alice@example.org&gt; .
</pre>
        </div>
      </div>
      <div class="div2">
        <h3><a name="QSynTriples" id="QSynTriples"></a>4.2 Syntax for Triple Patterns</h3>
        <p><a href="#defn_TriplePattern">Triple Patterns</a> are written as subject, predicate and object; there are abbreviated ways of writing some common triple pattern constructs.</p>
        <p>The following examples express the same query:</p>
        <pre class="query">PREFIX  dc: &lt;http://purl.org/dc/elements/1.1/&gt;
SELECT  ?title
WHERE   { &lt;http://example.org/book/book1&gt; dc:title ?title }  
</pre>
        <pre class="query">PREFIX  dc: &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX  : &lt;http://example.org/book/&gt;

SELECT  $title
WHERE   { :book1  dc:title  $title }
</pre>
        <pre class="query">BASE    &lt;http://example.org/book/&gt;
PREFIX  dc: &lt;http://purl.org/dc/elements/1.1/&gt;

SELECT  $title
WHERE   { &lt;book1&gt;  dc:title  ?title }
</pre>
        <div class="div3">
          <h4><a name="predObjLists" id="predObjLists"></a>4.2.1 Predicate-Object Lists</h4>
          <p>Triple patterns with a common subject can be written so that the subject is only written once and is used for more than one triple pattern by employing the "<code>;</code>" notation.</p>
          <pre class="query untested">    ?x  foaf:name  ?name ;
        foaf:mbox  ?mbox .
</pre>
          <p>This is the same as writing the triple patterns:</p>
          <pre class="query untested">    ?x  foaf:name  ?name .
    ?x  foaf:mbox  ?mbox .
</pre>
        </div>
        <div class="div3">
          <h4><a name="objLists" id="objLists"></a>4.2.2 Object Lists</h4>
          <p>If triple patterns share both subject and predicate, the objects may be separated by "<code>,</code>".</p>
          <pre class="query untested">    ?x foaf:nick  "Alice" , "Alice_" .
</pre>
          <p>is the same as writing the triple patterns:</p>
          <pre class="query untested">   ?x  foaf:nick  "Alice" .
   ?x  foaf:nick  "Alice_" .
</pre>
          <p>Object lists can be combined with predicate-object lists:</p>
          <pre class="query untested">   ?x  foaf:name ?name ; foaf:nick  "Alice" , "Alice_" .
</pre>
          <p>is equivalent to:</p>
          <pre class="query untested">   ?x  foaf:name  ?name .
   ?x  foaf:nick  "Alice" .
   ?x  foaf:nick  "Alice_" .
</pre>
        </div>
        <div class="div3">
          <h4><a name="collections" id="collections"></a>4.2.3 RDF Collections</h4>
          <p><a class="norm" href="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#collections">RDF collections</a> can be written in triple patterns using the syntax "(element1 element2 ...)". The
          form "<code>()</code>" is an alternative for the IRI <code><a href="http://www.w3.org/1999/02/22-rdf-syntax-ns#nil">http://www.w3.org/1999/02/22-rdf-syntax-ns#nil</a></code>. When used with
          collection elements, such as <code>(1 ?x 3 4)</code>, triple patterns with blank nodes are allocated for the collection. The blank node at the head of the collection can be used as a
          subject or object in other triple patterns. The blank nodes allocated by the collection syntax do not occur elsewhere in the query.</p>
          <pre class="query untested">(1 ?x 3 4) :p "w" .
</pre>
          <p>is syntactic sugar for (noting that <code>b0</code>, <code>b1</code>, <code>b2</code> and <code>b3</code> do not occur anywhere else in the query):</p>
          <pre class="query untested">    _:b0  rdf:first  1 ;
          rdf:rest   _:b1 .
    _:b1  rdf:first  ?x ;
          rdf:rest   _:b2 .
    _:b2  rdf:first  3 ;
          rdf:rest   _:b3 .
    _:b3  rdf:first  4 ;
          rdf:rest   rdf:nil .
    _:b0  :p         "w" . 
</pre>
          <p>RDF collections can be nested and can involve other syntactic forms:</p>
          <pre class="query untested">(1 [:p :q] ( 2 ) ) .
</pre>
          <p>is syntactic sugar for:</p>
          <pre class="query untested">    _:b0  rdf:first  1 ;
          rdf:rest   _:b1 .
    _:b1  rdf:first  _:b2 .
    _:b2  :p         :q .
    _:b1  rdf:rest   _:b3 .
    _:b3  rdf:first  _:b4 .
    _:b4  rdf:first  2 ;
          rdf:rest   rdf:nil .
    _:b3  rdf:rest   rdf:nil .
</pre>
        </div>
        <div class="div3">
          <h4><a name="abbrevRdfType" id="abbrevRdfType"></a>4.2.4 rdf:type</h4>
          <p>The keyword "<code>a</code>" can be used as a predicate in a triple pattern and is an alternative for the IRI&nbsp; <code><a href=
          "http://www.w3.org/1999/02/22-rdf-syntax-ns#type">http://www.w3.org/1999/02/22-rdf-syntax-ns#type</a></code>. This keyword is case-sensitive.</p>
          <pre class="query untested">  ?x  a  :Class1 .
  [ a :appClass ] :p "v" .
</pre>
          <p>is syntactic sugar for:</p>
          <pre class="query untested">  ?x    rdf:type  :Class1 .
  _:b0  rdf:type  :appClass .
  _:b0  :p        "v" .
</pre>
        </div>
      </div>
    </div>
    <div class="div1">
      <h2><a name="GraphPattern" id="GraphPattern"></a>5 Graph Patterns</h2>
      <p>SPARQL is based around graph pattern matching. More complex graph patterns can be formed by combining smaller patterns in various ways:</p>
      <ul>
        <li><a href="#BasicGraphPatterns">Basic Graph Patterns</a>, where a set of triple patterns must match</li>
        <li><a href="#GroupPatterns">Group Graph Pattern</a>, where a set of graph patterns must all match</li>
        <li><a href="#optionals">Optional Graph patterns</a>, where additional patterns may extend the solution</li>
        <li><a href="#alternatives">Alternative Graph Pattern</a>, where two or more possible patterns are tried</li>
        <li><a href="#queryDataset">Patterns on Named Graphs</a>, where patterns are matched against named graphs</li>
      </ul>
      <p>In this section we describe the two forms that combine patterns by conjunction: basic graph patterns, which combine triples patterns, and group graph patterns, which combine all other graph
      patterns.</p>
      <p>The outer-most graph pattern in a query is called the query pattern. It is grammatically identified by <code>GroupGraphPattern</code> in</p>
      <div class="grammarExtract">
        <div class="grammarTable">
          <table>
            <tbody>
              <tr valign="baseline">
                <td><code>[17]&nbsp;&nbsp;</code></td>
                <td><code><a href="#rWhereClause">WhereClause</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'WHERE'</span>? <a href="#rGroupGraphPattern">GroupGraphPattern</a></code></td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
      <div class="div2">
        <h3><a name="BasicGraphPatterns" id="BasicGraphPatterns"></a>5.1 Basic Graph Patterns</h3>
        <p>Basic graph patterns are sets of triple patterns. SPARQL graph pattern matching is defined in terms of combining the results from matching basic graph patterns.</p>
        <p>A sequence of triple patterns, with optional filters, comprises a single basic graph pattern. Any other graph pattern terminates a basic graph pattern.</p>
        <div class="div3">
          <h4><a name="bgpBNodeLabels" id="bgpBNodeLabels"></a>5.1.1 Blank Node Labels</h4>
          <p>When using blank nodes of the form <code>_:abc</code>,&nbsp; labels for blank nodes are scoped to the basic graph pattern.&nbsp; A label can be used in only a single basic graph pattern
          in any query.</p>
        </div>
        <div class="div3">
          <h4><a name="bgpExtend" id="bgpExtend"></a>5.1.2 Extending Basic Graph Pattern Matching</h4>
          <p>SPARQL evaluates basic graph patterns using subgraph matching, which is defined for simple entailment. SPARQL can be extended to other forms of entailment given <a href=
          "#sparqlBGPExtend">certain conditions</a> as described below. The document <a href="http://www.w3.org/TR/sparql11-entailment/">SPARQL 1.1 Entailment Regimes</a> describes several specific
          entailment regimes.</p>
        </div>
      </div>
      <div class="div2">
        <h3><a name="GroupPatterns" id="GroupPatterns"></a>5.2 Group Graph Patterns</h3>
        <p>In a SPARQL query string, a group graph pattern is delimited with braces: <code>{}</code>. For example, this query's query pattern is a group graph pattern of one basic graph pattern.</p>
        <div class="exampleGroup">
          <div class="queryGroup">
            <pre class="query">PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name ?mbox
WHERE  {
          ?x foaf:name ?name .
          ?x foaf:mbox ?mbox .
       }
</pre>
          </div>
        </div>
        <div class="exampleGroup">
          <div class="queryGroup">
            The same solutions would be obtained from a query that grouped the triple patterns into two basic graph patterns. For example, the query below has a different structure but would yield
            the same solutions as the previous query:
            <pre class="query">PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name ?mbox
WHERE  { { ?x foaf:name ?name . }
         { ?x foaf:mbox ?mbox . }
       }</pre>
          </div>
        </div>
        <div class="div3">
          <h4><a name="emptyGroupPattern" id="emptyGroupPattern"></a>5.2.1 Empty Group Pattern</h4>
          <p>The group pattern:</p>
          <pre class="query untested">{ }</pre>
          <p>matches any graph (including the empty graph) with one solution that does not bind any variables. For example:</p>
          <pre class="query untested">SELECT ?x
WHERE {}
</pre>
          <p>matches with one solution in which variable <code>x</code> is not bound.</p>
        </div>
        <div class="div3">
          <h4><a name="scopeFilters" id="scopeFilters"></a>5.2.2 Scope of Filters</h4>
          <p>A constraint, expressed by the keyword <code>FILTER</code>, is a restriction on solutions over the whole group in which the filter appears. The following patterns all have the same
          solutions:</p>
          <div class="exampleGroup">
            <div class="queryGroup">
              <pre class="query"> {  ?x foaf:name ?name .
    ?x foaf:mbox ?mbox .
    FILTER regex(?name, "Smith")
 }
  </pre>
            </div>
          </div>
          <div class="exampleGroup">
            <div class="queryGroup">
              <pre class="query"> {  FILTER regex(?name, "Smith")
    ?x foaf:name ?name .
    ?x foaf:mbox ?mbox .
 }
</pre>
            </div>
          </div>
          <div class="exampleGroup">
            <div class="queryGroup">
              <pre class="query"> {  ?x foaf:name ?name .
    FILTER regex(?name, "Smith")
    ?x foaf:mbox ?mbox .
 }
</pre>
            </div>
          </div>
        </div>
        <div class="div3">
          <h4><a name="groupExamples" id="groupExamples"></a>5.2.3 Group Graph Pattern Examples</h4>
          <div class="exampleGroup">
            <div class="queryGroup">
              <pre class="query">  {
    ?x foaf:name ?name .
    ?x foaf:mbox ?mbox .
  }</pre>
            </div>
          </div>
          <p>is a group of one basic graph pattern and that basic graph pattern consists of two triple patterns.</p>
          <div class="exampleGroup">
            <div class="queryGroup">
              <pre class="query">  {
    ?x foaf:name ?name . FILTER regex(?name, "Smith")
    ?x foaf:mbox ?mbox .
  }</pre>
            </div>
          </div>
          <p>is a group of one basic graph pattern and a filter, and that basic graph pattern consists of two triple patterns; the filter does not break the basic graph pattern into two basic graph
          patterns.</p>
          <div class="exampleGroup">
            <div class="queryGroup">
              <pre class="query">  {
    ?x foaf:name ?name .
    {}
    ?x foaf:mbox ?mbox .
  }</pre>
            </div>
          </div>
          <p>is a group of three elements, a basic graph pattern of one triple pattern, an empty group, and another basic graph pattern of one triple pattern.</p>
        </div>
      </div>
    </div>
    <div class="div1">
      <h2><a name="optionals" id="optionals"></a>6 Including Optional Values</h2>
      <p>Basic graph patterns allow applications to make queries where the entire query pattern must match for there to be a solution. For every solution of a query containing only group graph
      patterns with at least one basic graph pattern, every variable is bound to an RDF Term in a solution. However, regular, complete structures cannot be assumed in all RDF graphs. It is useful to
      be able to have queries that allow information to be added to the solution where the information is available, but do not reject the solution because some part of the query pattern does not
      match. Optional matching provides this facility: if the optional part does not match, it creates no bindings but does not eliminate the solution.</p>
      <div class="div2">
        <h3><a name="OptionalMatching" id="OptionalMatching"></a>6.1 Optional Pattern Matching</h3>
        <p>Optional parts of the graph pattern may be specified syntactically with the OPTIONAL keyword applied to a graph pattern:</p>
        <pre class="query untested"><i>pattern</i> OPTIONAL { <i>pattern</i> }
</pre>
        <div class="exampleGroup">
          <p>The syntactic form:</p>
          <pre class="query untested">{ OPTIONAL { <i>pattern</i> } }
</pre>
          <p>is equivalent to:</p>
          <pre class="query untested">{ { } OPTIONAL { <i>pattern</i> } }
</pre>
          <p>The <code>OPTIONAL</code> keyword is left-associative :</p>
          <pre class="query untested"><i>pattern</i> OPTIONAL { <i>pattern</i> } OPTIONAL { pattern }
</pre>
          <p>is the same as:</p>
          <pre class="query untested">{ <i>pattern</i> OPTIONAL { <i>pattern</i> } } OPTIONAL { pattern }
</pre>
          <p>In an optional match, either the optional graph pattern matches a graph, thereby defining and adding bindings to one or more solutions, or it leaves a solution unchanged without adding
          any additional bindings.</p>
          <p>Data:</p>
          <pre class="data">@prefix foaf:       &lt;http://xmlns.com/foaf/0.1/&gt; .
@prefix rdf:        &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .

_:a  rdf:type        foaf:Person .
_:a  foaf:name       "Alice" .
_:a  foaf:mbox       &lt;mailto:alice@example.com&gt; .
_:a  foaf:mbox       &lt;mailto:alice@work.example&gt; .

_:b  rdf:type        foaf:Person .
_:b  foaf:name       "Bob" .
</pre>
          <div class="queryGroup">
            Query:
            <pre class="query">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name ?mbox
WHERE  { ?x foaf:name  ?name .
         OPTIONAL { ?x  foaf:mbox  ?mbox }
       }
</pre>
            <p>With the data above, the query result is:</p>
            <div class="result">
              <a name="table92" id="table92"></a>
              <table class="resultTable">
                <tbody>
                  <tr>
                    <th>name</th>
                    <th>mbox</th>
                  </tr>
                  <tr>
                    <td>"Alice"</td>
                    <td>&lt;mailto:alice@example.com&gt;</td>
                  </tr>
                  <tr>
                    <td>"Alice"</td>
                    <td>&lt;mailto:alice@work.example&gt;</td>
                  </tr>
                  <tr>
                    <td>"Bob"</td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>
        <p>There is no value of <code>mbox</code> in the solution where the name is <code>"Bob"</code>.</p>
        <p>This query finds the names of people in the data. If there is a triple with predicate <code>mbox</code> and the same subject, a solution will contain the object of that triple as well. In
        this example, only a single triple pattern is given in the optional match part of the query but, in general, the optional part may be any graph pattern. The entire optional graph pattern must
        match for the optional graph pattern to affect the query solution.</p>
      </div>
      <div class="div2">
        <h3><a name="OptionalAndConstraints" id="OptionalAndConstraints"></a>6.2 Constraints in Optional Pattern Matching</h3>
        <p>Constraints can be given in an optional graph pattern. For example:</p>
        <div class="exampleGroup">
          <pre class="data">@prefix dc:   &lt;http://purl.org/dc/elements/1.1/&gt; .
@prefix :     &lt;http://example.org/book/&gt; .
@prefix ns:   &lt;http://example.org/ns#&gt; .

:book1  dc:title  "SPARQL Tutorial" .
:book1  ns:price  42 .
:book2  dc:title  "The Semantic Web" .
:book2  ns:price  23 .
</pre>
          <div class="queryGroup">
            <pre class="query">PREFIX  dc:  &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX  ns:  &lt;http://example.org/ns#&gt;
SELECT  ?title ?price
WHERE   { ?x dc:title ?title .
          OPTIONAL { ?x ns:price ?price . FILTER (?price &lt; 30) }
        }
</pre>
            <div class="result">
              <a name="table93" id="table93"></a>
              <table class="resultTable">
                <tbody>
                  <tr>
                    <th>title</th>
                    <th>price</th>
                  </tr>
                  <tr>
                    <td>"SPARQL Tutorial"</td>
                    <td></td>
                  </tr>
                  <tr>
                    <td>"The Semantic Web"</td>
                    <td>23</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>
        <p>No price appears for the book with title "SPARQL Tutorial" because the optional graph pattern did not lead to a solution involving the variable "<code>price</code>".</p>
      </div>
      <div class="div2">
        <h3><a name="MultipleOptionals" id="MultipleOptionals"></a>6.3 Multiple Optional Graph Patterns</h3>
        <p>Graph patterns are defined recursively. A graph pattern may have zero or more optional graph patterns, and any part of a query pattern may have an optional part. In this example, there are
        two optional graph patterns.</p>
        <div class="exampleGroup">
          Data:
          <pre class="data">@prefix foaf:       &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a  foaf:name       "Alice" .
_:a  foaf:homepage   &lt;http://work.example.org/alice/&gt; .

_:b  foaf:name       "Bob" .
_:b  foaf:mbox       &lt;mailto:bob@work.example&gt; .
</pre>
          <div class="queryGroup">
            Query:
            <pre class="query">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name ?mbox ?hpage
WHERE  { ?x foaf:name  ?name .
         OPTIONAL { ?x foaf:mbox ?mbox } .
         OPTIONAL { ?x foaf:homepage ?hpage }
       }
</pre>
            <p>Query result:</p>
            <div class="result">
              <a name="table94" id="table94"></a>
              <table class="resultTable">
                <tbody>
                  <tr>
                    <th>name</th>
                    <th>mbox</th>
                    <th>hpage</th>
                  </tr>
                  <tr>
                    <td>"Alice"</td>
                    <td></td>
                    <td>&lt;http://work.example.org/alice/&gt;</td>
                  </tr>
                  <tr>
                    <td>"Bob"</td>
                    <td>&lt;mailto:bob@work.example&gt;</td>
                    <td></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="div1">
      <h2><a name="alternatives" id="alternatives"></a>7 Matching Alternatives</h2>
      <p>SPARQL provides a means of combining graph patterns so that one of several alternative graph patterns may match. If more than one of the alternatives matches, all the possible pattern
      solutions are found.</p>
      <p>Pattern alternatives are syntactically specified with the <code>UNION</code> keyword.</p>
      <div class="exampleGroup">
        Data:
        <pre class="data">@prefix dc10:  &lt;http://purl.org/dc/elements/1.0/&gt; .
@prefix dc11:  &lt;http://purl.org/dc/elements/1.1/&gt; .

_:a  dc10:title     "SPARQL Query Language Tutorial" .
_:a  dc10:creator   "Alice" .

_:b  dc11:title     "SPARQL Protocol Tutorial" .
_:b  dc11:creator   "Bob" .

_:c  dc10:title     "SPARQL" .
_:c  dc11:title     "SPARQL (updated)" .
</pre>
        <div class="queryGroup">
          Query:
          <pre class="query">PREFIX dc10:  &lt;http://purl.org/dc/elements/1.0/&gt;
PREFIX dc11:  &lt;http://purl.org/dc/elements/1.1/&gt;

SELECT ?title
WHERE  { { ?book dc10:title  ?title } UNION { ?book dc11:title  ?title } }
</pre>
          <p>Query result:</p>
          <div class="result">
            <a name="table97" id="table97"></a>
            <table class="resultTable">
              <tbody>
                <tr>
                  <th>title</th>
                </tr>
                <tr>
                  <td>"SPARQL Protocol Tutorial"</td>
                </tr>
                <tr>
                  <td>"SPARQL"</td>
                </tr>
                <tr>
                  <td>"SPARQL (updated)"</td>
                </tr>
                <tr>
                  <td>"SPARQL Query Language Tutorial"</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
        <p>This query finds titles of the books in the data, whether the title is recorded using <a class="inform" href="http://dublincore.org/">Dublin Core</a> properties from version 1.0 or version
        1.1. To determine exactly how the information was recorded, a query could use different variables for the two alternatives:</p>
        <div class="queryGroup">
          <pre class="query">PREFIX dc10:  &lt;http://purl.org/dc/elements/1.0/&gt;
PREFIX dc11:  &lt;http://purl.org/dc/elements/1.1/&gt;

SELECT ?x ?y
WHERE  { { ?book dc10:title ?x } UNION { ?book dc11:title  ?y } }
</pre>
          <div class="result">
            <a name="table98" id="table98"></a>
            <table class="resultTable">
              <tbody>
                <tr>
                  <th>x</th>
                  <th>y</th>
                </tr>
                <tr>
                  <td></td>
                  <td>"SPARQL (updated)"</td>
                </tr>
                <tr>
                  <td></td>
                  <td>"SPARQL Protocol Tutorial"</td>
                </tr>
                <tr>
                  <td>"SPARQL"</td>
                  <td></td>
                </tr>
                <tr>
                  <td>"SPARQL Query Language Tutorial"</td>
                  <td></td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
        <p>This will return results with the variable <code>x</code> bound for solutions from the left branch of the <code>UNION</code>, and <code>y</code> bound for the solutions from the right
        branch. If neither part of the <code>UNION</code> pattern matched, then the graph pattern would not match.</p>
        <p>The <code>UNION</code> pattern combines graph patterns; each alternative possibility can contain more than one triple pattern:</p>
        <div class="queryGroup">
          <pre class="query">PREFIX dc10:  &lt;http://purl.org/dc/elements/1.0/&gt;
PREFIX dc11:  &lt;http://purl.org/dc/elements/1.1/&gt;

SELECT ?title ?author
WHERE  { { ?book dc10:title ?title .  ?book dc10:creator ?author }
         UNION
         { ?book dc11:title ?title .  ?book dc11:creator ?author }
       }
</pre>
          <div class="result">
            <a name="table99" id="table99"></a>
            <table class="resultTable">
              <tbody>
                <tr>
                  <th>title</th>
                  <th>author</th>
                </tr>
                <tr>
                  <td>"SPARQL Query Language Tutorial"</td>
                  <td>"Alice"</td>
                </tr>
                <tr>
                  <td>"SPARQL Protocol Tutorial"</td>
                  <td>"Bob"</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
      </div>
      <p>This query will only match a book if it has both a title and creator predicate from the same version of Dublin Core.</p>
    </div>
    <div class="div1">
      <h2><a name="negation" id="negation"></a>8 Negation</h2>
      <p>The SPARQL query language incorporates two styles of negation, one based on filtering results depending on whether a graph pattern does or does not match in the context of the query solution
      being filtered, and one based on removing solutions related to another pattern.</p>
      <div class="div2">
        <h3><a name="neg-pattern" id="neg-pattern"></a>8.1 Filtering Using Graph Patterns</h3>
        <p>Filtering of query solutions is done within a <code>FILTER</code> expression using <code>NOT EXISTS</code> and <code>EXISTS</code>. Note that the filter scope rules <a href=
        "#scopeFilters">apply to the whole group in which the filter appears</a>.</p>
        <div class="div3">
          <h4><a name="neg-notexists" id="neg-notexists"></a>8.1.1 Testing For the Absence of a Pattern</h4>
          <p>The <code>NOT EXISTS</code> filter expression tests whether a graph pattern does not match the dataset, given the values of variables in the group graph pattern in which the filter
          occurs. It does not generate any additional bindings.</p>
          <div class="exampleGroup">
            <p>Data:</p>
            <pre class="data">@prefix  :       &lt;http://example/&gt; .
@prefix  rdf:    &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .
@prefix  foaf:   &lt;http://xmlns.com/foaf/0.1/&gt; .

:alice  rdf:type   foaf:Person .
:alice  foaf:name  "Alice" .
:bob    rdf:type   foaf:Person .     </pre>
            <p>Query:</p>
            <div class="queryGroup">
              <pre class="query">PREFIX  rdf:    &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; 
PREFIX  foaf:   &lt;http://xmlns.com/foaf/0.1/&gt; 

SELECT ?person
WHERE 
{
    ?person rdf:type  foaf:Person .
    FILTER NOT EXISTS { ?person foaf:name ?name }
}     </pre>
              <p>Query Result:</p>
              <div class="result">
                <table class="resultTable">
                  <tbody>
                    <tr>
                      <th>person</th>
                    </tr>
                    <tr>
                      <td>&lt;http://example/bob&gt;</td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
          </div>
        </div>
        <div class="div3">
          <h4><a name="neg-exists" id="neg-exists"></a>8.1.2 Testing For the Presence of a Pattern</h4>
          <p>The filter expression <code>EXISTS</code> is also provided. It tests whether the pattern can be found in the data; it does not generate any additional bindings.</p>
          <div class="exampleGroup">
            <p>Query:</p>
            <div class="queryGroup">
              <pre class="query">PREFIX  rdf:    &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; 
PREFIX  foaf:   &lt;http://xmlns.com/foaf/0.1/&gt; 

SELECT ?person
WHERE 
{
    ?person rdf:type  foaf:Person .
    FILTER EXISTS { ?person foaf:name ?name }
}</pre>
              <p>Query Result:</p>
              <div class="result">
                <table class="resultTable">
                  <tbody>
                    <tr>
                      <th>person</th>
                    </tr>
                    <tr>
                      <td>&lt;http://example/alice&gt;</td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="div2">
        <h3><a name="neg-minus" id="neg-minus"></a>8.2 Removing Possible Solutions</h3>
        <p>The other style of negation provided in SPARQL is <code>MINUS</code> which evaluates both its arguments, then calculates solutions in the left-hand side that are not compatible with the
        solutions on the right-hand side.</p>
        <div class="exampleGroup">
          Data:
          <pre class="data">@prefix :       &lt;http://example/&gt; .
@prefix foaf:   &lt;http://xmlns.com/foaf/0.1/&gt; .

:alice  foaf:givenName "Alice" ;
        foaf:familyName "Smith" .

:bob    foaf:givenName "Bob" ;
        foaf:familyName "Jones" .

:carol  foaf:givenName "Carol" ;
        foaf:familyName "Smith" .</pre>
          <div class="queryGroup">
            Query:
            <pre class="query">PREFIX :       &lt;http://example/&gt;
PREFIX foaf:   &lt;http://xmlns.com/foaf/0.1/&gt;

SELECT DISTINCT ?s
WHERE {
   ?s ?p ?o .
   MINUS {
      ?s foaf:givenName "Bob" .
   }
}</pre>
            <p>Results:</p>
            <div class="result">
              <table class="resultTable">
                <tbody>
                  <tr>
                    <th>s</th>
                  </tr>
                  <tr>
                    <td>&lt;http://example/carol&gt;</td>
                  </tr>
                  <tr>
                    <td>&lt;http://example/alice&gt;</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>
      </div>
      <div class="div2">
        <h3><a name="neg-notexists-minus" id="neg-notexists-minus"></a>8.3 Relationship and differences between NOT EXISTS and MINUS</h3>
        <p><code>NOT EXISTS</code> and <code>MINUS</code> represent two ways of thinking about negation, one based on testing whether a pattern exists in the data, given the bindings already
        determined by the query pattern, and one based on removing matches based on the evaluation of two patterns. In some cases they can produce different answers.</p>
        <div class="div3">
          <h4><a name="neg-example-1" id="neg-example-1"></a>8.3.1 Example: Sharing of variables</h4>
          <pre class="data">@prefix : &lt;http://example/&gt; .
:a :b :c .</pre>
          <pre class="query">SELECT *
{ 
  ?s ?p ?o
  FILTER NOT EXISTS { ?x ?y ?z }
}</pre>
          <p>evaluates to a result set with no solutions because <code>{ ?x ?y ?z }</code> matches given any <code>?s ?p ?o</code>, so <code>NOT EXISTS { ?x ?y ?z }</code> eliminates any
          solutions.</p>
          <div class="result">
            <table class="resultTable">
              <tbody>
                <tr>
                  <th>s</th>
                  <th>p</th>
                  <th>o</th>
                </tr>
              </tbody>
            </table>
          </div>
          <p>whereas with <code>MINUS</code>, there is no shared variable between the first part (<code>?s ?p ?o</code>) and the second (<code>?x ?y ?z</code>) so no bindings are eliminated.</p>
          <pre class="query">SELECT *
{ 
   ?s ?p ?o 
   MINUS 
     { ?x ?y ?z }
}</pre>
          <p>Results:</p>
          <div class="result">
            <table class="resultTable">
              <tbody>
                <tr>
                  <th>s</th>
                  <th>p</th>
                  <th>o</th>
                </tr>
                <tr>
                  <td>&lt;http://example/a&gt;</td>
                  <td>&lt;http://example/b&gt;</td>
                  <td>&lt;http://example/c&gt;</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
        <div class="div3">
          <h4><a name="neg-example-2" id="neg-example-2"></a>8.3.2 Example: Fixed pattern</h4>
          <p>Another case is where there is a concrete pattern (no variables) in the example:</p>
          <pre class="query">PREFIX : &lt;http://example/&gt;
SELECT * 
{ 
  ?s ?p ?o 
  FILTER NOT EXISTS { :a :b :c }
}</pre>
          <p>evaluates to a result set with no query solutions:</p>Results:
          <div class="result">
            <table class="resultTable">
              <tbody>
                <tr>
                  <th>s</th>
                  <th>p</th>
                  <th>o</th>
                </tr>
              </tbody>
            </table>
          </div>
          <p>whereas</p>
          <pre class="query">PREFIX : &lt;http://example/&gt;
SELECT * 
{ 
  ?s ?p ?o 
  MINUS { :a :b :c }
}</pre>
          <p>evaluates to result set with one query solution:</p>
          <p>Results:</p>
          <div class="result">
            <table class="resultTable">
              <tbody>
                <tr>
                  <th>s</th>
                  <th>p</th>
                  <th>o</th>
                </tr>
                <tr>
                  <td>&lt;http://example/a&gt;</td>
                  <td>&lt;http://example/b&gt;</td>
                  <td>&lt;http://example/c&gt;</td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>because there is no match of bindings and so no solutions are eliminated.</p>
        </div>
        <div class="div3">
          <h4><a name="idp899488" id="idp899488"></a>8.3.3 Example: Inner FILTERs</h4>
          <p>Differences also arise because in a filter, variables from the group are <a href="#scopeFilters">in scope</a>. In this example, the <code>FILTER</code> inside the <code>NOT EXISTS</code>
          has access to the value of ?n for the solution being considered.</p>
          <pre class="data">@prefix : &lt;http://example.com/&gt; .
:a :p 1 .
:a :q 1 .
:a :q 2 .

:b :p 3.0 .
:b :q 4.0 .
:b :q 5.0 .</pre>
          <p>When using <code>FILTER NOT EXISTS</code>, the test is on each possible solution to <code>?x :p ?n</code>:</p>
          <pre class="query">PREFIX : &lt;http://example.com/&gt;
SELECT * WHERE {
        ?x :p ?n
        FILTER NOT EXISTS {
                ?x :q ?m .
                FILTER(?n = ?m)
        }
}</pre>
          <div class="result">
            <table class="resultTable">
              <tbody>
                <tr>
                  <th>x</th>
                  <th>n</th>
                </tr>
                <tr>
                  <td>&lt;http://example.com/b&gt;</td>
                  <td>3.0</td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>whereas with <code>MINUS</code>, the <code>FILTER</code> inside the pattern does not have a value for ?n and it is always unbound:</p>
          <pre class="query">PREFIX : &lt;http://example/&gt;
SELECT * WHERE {
        ?x :p ?n
        MINUS {
                ?x :q ?m .
                FILTER(?n = ?m)
        }
}</pre>
          <div class="result">
            <table class="resultTable">
              <tbody>
                <tr>
                  <th>x</th>
                  <th>n</th>
                </tr>
                <tr>
                  <td>&lt;http://example.com/b&gt;</td>
                  <td>3.0</td>
                </tr>
                <tr>
                  <td>&lt;http://example.com/a&gt;</td>
                  <td>1</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
      </div>
    </div>
    <div class="div1">
      <h2><a name="propertypaths" id="propertypaths"></a>9 Property Paths</h2>
      <p>A property path is a possible route through a graph between two graph nodes. A trivial case is a property path of length exactly 1, which is a triple pattern. The ends of the path may be RDF
      terms or variables. Variables can not be used as part of the path itself, only the ends.</p>
      <p>Property paths allow for more concise expressions for some SPARQL basic graph patterns and they also add the ability to match connectivity of two resources by an arbitrary length path.</p>
      <div class="div2">
        <h3><a name="pp-language" id="pp-language"></a>9.1 Property Path Syntax</h3>
        <p>In the description below, <i><tt>iri</tt></i> is either <a href="#QSynIRI">an IRI written in full or abbreviated by a prefixed name</a>, or the keyword <tt>a</tt>. <i><tt>elt</tt></i> is a
        path element, which may itself be composed of path constructs.</p>
        <table cellspacing="0" border="1">
          <tbody>
            <tr>
              <th>Syntax Form</th>
              <th>Property Path Expression Name</th>
              <th>Matches</th>
            </tr>
            <tr>
              <td><tt><i>iri</i></tt></td>
              <td>PredicatePath</td>
              <td>An IRI. A path of length one.</td>
            </tr>
            <tr>
              <td><tt>^<i>elt</i></tt></td>
              <td>InversePath</td>
              <td>Inverse path (object to subject).</td>
            </tr>
            <tr>
              <td><tt><i>elt1</i> / <i>elt2</i></tt></td>
              <td>SequencePath</td>
              <td>A sequence path of <tt><i>elt1</i></tt> followed by <tt><i>elt2</i></tt>.</td>
            </tr>
            <tr>
              <td><tt><i>elt1</i> | <i>elt2</i></tt></td>
              <td>AlternativePath</td>
              <td>A alternative path of <tt><i>elt1</i></tt> or <tt><i>elt2</i></tt> (all possibilities are tried).</td>
            </tr>
            <tr>
              <td><tt><i>elt</i>*</tt></td>
              <td>ZeroOrMorePath</td>
              <td>A path that connects the subject and object of the path by zero or more matches of <tt><i>elt</i></tt>.</td>
            </tr>
            <tr>
              <td><tt><i>elt</i>+</tt></td>
              <td>OneOrMorePath</td>
              <td>A path that connects the subject and object of the path by one or more matches of <tt><i>elt</i></tt>.</td>
            </tr>
            <tr>
              <td><tt><i>elt</i>?</tt></td>
              <td>ZeroOrOnePath</td>
              <td>A path that connects the subject and object of the path by zero or one matches of <tt><i>elt</i></tt>.</td>
            </tr>
            <tr>
              <td><tt>!<i>iri</i></tt> or <tt>!(<i>iri<sub>1</sub></i>| ...|<i>iri<sub>n</sub></i>)</tt></td>
              <td>NegatedPropertySet</td>
              <td>Negated property set. An IRI which is not one of <tt><i>iri<sub>i</sub></i></tt>. <tt>!<i>iri</i></tt> is short for <tt>!<i>(iri)</i></tt>.</td>
            </tr>
            <tr>
              <td><tt>!^<i>iri</i></tt> or <tt>!(^<i>iri<sub>1</sub></i>| ...|^<i>iri<sub>n</sub></i>)</tt></td>
              <td>NegatedPropertySet</td>
              <td>Negated property set where the excluded matches are based on reversed path.<br>
              That is, not one of <i>iri<sub>1</sub></i>...<i>iri<sub>n</sub></i> as reverse paths. <tt>!^<i>iri</i></tt> is short for <tt>!(^<i>iri</i>)</tt>.</td>
            </tr>
            <tr>
              <td><tt>!(<i>iri<sub>1</sub></i>| ...|<i>iri<sub>j</sub></i>|^<i>iri<sub>j+1</sub></i>| ...|^<i>iri<sub>n</sub></i>)</tt></td>
              <td>NegatedPropertySet</td>
              <td>A combination of forward and reverse properties in a negated property set.</td>
            </tr>
            <tr>
              <td><tt>(<i>elt</i>)</tt></td>
              <td>&nbsp;</td>
              <td>A group path <tt><i>elt</i></tt>, brackets control precedence.</td>
            </tr>
          </tbody>
        </table>
        <p>The order of IRIs, and reverse IRIs, in a negated property set is not significant and they can occur in a mixed order.</p>
        <p>The precedence of the syntax forms is, from highest to lowest:</p>
        <ul>
          <li>IRI, prefixed names</li>
          <li>Negated property sets</li>
          <li>Groups</li>
          <li>Unary operators <tt>*</tt>, <tt>?</tt> and <tt>+</tt></li>
          <li>Unary ^ inverse links</li>
          <li>Binary operator <tt>/</tt></li>
          <li>Binary operator <tt>|</tt></li>
        </ul>
        <p>Precedence is left-to-right within groups.</p>
      </div>
      <div class="div2">
        <h3><a name="propertypath-examples" id="propertypath-examples"></a>9.2 Examples</h3>
        <p><i>Alternatives</i>: Match one or both possibilities</p>
        <pre class="query">  { :book1 dc:title|rdfs:label ?displayString }</pre>
        <p>which could have writen:</p>
        <pre class="query">  { :book1 &lt;http://purl.org/dc/elements/1.1/title&gt; | &lt;http://www.w3.org/2000/01/rdf-schema#label&gt; ?displayString }</pre>
        <p><i>Sequence</i>: Find the name of any people that Alice knows.</p>
        <pre class="query">  {
    ?x foaf:mbox &lt;mailto:alice@example&gt; .
    ?x foaf:knows/foaf:name ?name .
  }</pre>
        <p><i>Sequence</i>: Find the names of people 2 "<tt>foaf:knows</tt>" links away.</p>
        <pre class="query">  { 
    ?x foaf:mbox &lt;mailto:alice@example&gt; .
    ?x foaf:knows/foaf:knows/foaf:name ?name .
  }</pre>
        <p>This is the same as the SPARQL query:</p>
        <pre class="query">  SELECT ?x ?name 
  {
     ?x  foaf:mbox &lt;mailto:alice@example&gt; .
     ?x  foaf:knows [ foaf:knows [ foaf:name ?name ]]. 
  }</pre>
        <p>or, with explicit variables:</p>
        <pre class="query">  SELECT ?x ?name
  {
    ?x  foaf:mbox &lt;mailto:alice@example&gt; .
    ?x  foaf:knows ?a1 .
    ?a1 foaf:knows ?a2 .
    ?a2 foaf:name ?name .
  }</pre>
        <p><i>Filtering duplicates</i>: Because someone Alice knows may well know Alice, the example above may include Alice herself. This could be avoided with:</p>
        <pre class="query">  { ?x foaf:mbox &lt;mailto:alice@example&gt; .
    ?x foaf:knows/foaf:knows ?y .
    FILTER ( ?x != ?y )
    ?y foaf:name ?name 
  }</pre>
        <p><i>Inverse Property Paths</i>: These two are the same query: the second is just reversing the property direction which swaps the roles of subject and object.</p>
        <pre class="query">  { ?x foaf:mbox &lt;mailto:alice@example&gt; }</pre>
        <pre class="query">  { &lt;mailto:alice@example&gt; ^foaf:mbox ?x }</pre>
        <p><i>Inverse Path Sequence</i>: Find all the people who know someone <tt>?x</tt> knows.</p>
        <pre class="query">  {
    ?x foaf:knows/^foaf:knows ?y .  
    FILTER(?x != ?y)
  }</pre>
        <p>which is equivalent to (<code>?gen1</code> is a system generated variable):</p>
        <pre class="query">  {
    ?x foaf:knows ?gen1 .
    ?y foaf:knows ?gen1 .  
    FILTER(?x != ?y)
  }</pre>
        <p><i>Arbitrary length match</i>: Find the names of all the people that can be reached from Alice by <tt>foaf:knows</tt>:</p>
        <pre class="query">  {
    ?x foaf:mbox &lt;mailto:alice@example&gt; .
    ?x foaf:knows+/foaf:name ?name .
  }</pre>
        <p><i>Alternatives in an arbitrary length path</i>:</p>
        <pre class="query">  { ?ancestor (ex:motherOf|ex:fatherOf)+ &lt;#me&gt; }</pre>
        <p><i>Arbitrary length path match</i>: Some forms of limited inference are possible as well. For example, for RDFS, all types and supertypes of a resource:</p>
        <pre class="query">  { &lt;http://example/thing&gt; rdf:type/rdfs:subClassOf* ?type }</pre>
        <p>All resources and all their inferred types:</p>
        <pre class="query">  { ?x rdf:type/rdfs:subClassOf* ?type }</pre>
        <p><i>Subproperty</i>:</p>
        <pre class="query">  { ?x ?p ?v . ?p rdfs:subPropertyOf* :property }</pre>
        <p><i>Negated Property Paths</i>: Find nodes connected but not by rdf:type (either way round):</p>
        <pre class="query">  { ?x !(rdf:type|^rdf:type) ?y }</pre>
        <p><i>Elements in an RDF collection</i>:</p>
        <pre class="query">  { :list rdf:rest*/rdf:first ?element }</pre>
        <p><i>Note: This path expression does not guarantee the order of the results.</i></p>
      </div>
      <div class="div2">
        <h3><a name="propertypath-syntaxforms" id="propertypath-syntaxforms"></a>9.3 Property Paths and Equivalent Patterns</h3>
        <p>SPARQL property paths treat the RDF triples as a directed, possibly cyclic, graph with named edges. Some property paths are equivalent to a <a href=
        "#sparqlTranslatePathExpressions">translation</a> into triple patterns and SPARQL UNION graph patterns. Evaluation of a property path expression can lead to duplicates because any variables
        introduced in the equivalent pattern are not part of the results and are not already used elsewhere. They are hidden by implicit projection of the results to just the variables given in the
        query.</p>
        <p>For example, on the data:</p>
        <pre class="data">@prefix :       &lt;http://example/&gt; .

:order  :item :z1 .
:order  :item :z2 .

:z1 :name "Small" .
:z1 :price 5 .

:z2 :name "Large" .
:z2 :price 5 .</pre>
        <p>Query:</p>
        <pre class="query">PREFIX :   &lt;http://example/&gt;
SELECT * 
{  ?s :item/:price ?x . }</pre>
        <p>Results:</p>
        <div class="result">
          <table class="resultTable">
            <tbody>
              <tr>
                <th>s</th>
                <th>x</th>
              </tr>
              <tr>
                <td>&lt;http://example/order&gt;</td>
                <td>5</td>
              </tr>
              <tr>
                <td>&lt;http://example/order&gt;</td>
                <td>5</td>
              </tr>
            </tbody>
          </table>
        </div>
        <p>whereas if the query were written out to include the intermediate variable (<code>?_a</code>), no rows in the results are duplicates:</p>
        <pre class="query">PREFIX :   &lt;http://example/&gt;
SELECT * 
{  ?s :item ?_a .
   ?_a :price ?x . }</pre>
        <p>Results:</p>
        <div class="result">
          <table class="resultTable">
            <tbody>
              <tr>
                <th>s</th>
                <th>_a</th>
                <th>x</th>
              </tr>
              <tr>
                <td>&lt;http://example/order&gt;</td>
                <td>&lt;http://example/z1&gt;</td>
                <td>5</td>
              </tr>
              <tr>
                <td>&lt;http://example/order&gt;</td>
                <td>&lt;http://example/z2&gt;</td>
                <td>5</td>
              </tr>
            </tbody>
          </table>
        </div>
        <p>The equivalance to graphs patterns is particularly significant when query also involves an aggregation operation. The total cost of the order can be found with</p>
        <pre class="query">  PREFIX :   &lt;http://example/&gt;
  SELECT (sum(?x) AS ?total)
  { 
    :order :item/:price ?x
  }</pre>
        <div class="result">
          <table class="resultTable">
            <tbody>
              <tr>
                <th>total</th>
              </tr>
              <tr>
                <td>10</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
      <div class="div2">
        <h3><a name="propertypath-arbitrary-length" id="propertypath-arbitrary-length"></a>9.4 Arbitrary Length Path Matching</h3>
        <p>Connectivity between the subject and object by a property path of arbitrary length can be found using the "zero or more" property path operator, <code>*</code>, and the "one or more"
        property path operator, <code>+</code>. There is also a "zero or one" connectivity property path operator, <code>?</code>.</p>
        <p>Each of these operators uses the property path expression to try to find a connection between subject and object, using the path step a number of times, as restricted by the operator.</p>
        <p>For example, finding all the the possible types of a resource, including supertypes of resources, can be achieved with:</p>
        <pre class="query">  PREFIX  rdfs:   &lt;http://www.w3.org/2000/01/rdf-schema#&gt; . 
  PREFIX  rdf:    &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;
  SELECT ?x ?type
  { 
    ?x rdf:type/rdfs:subClassOf* ?type
  }</pre>
        <p>Similarly, finding all the people <code>:x</code> connects to via the <code>foaf:knows</code> relationship,</p>
        <pre class="query">  PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
  PREFIX :     &lt;http://example/&gt;
  SELECT ?person
  { 
    :x foaf:knows+ ?person
  }</pre>
        <p>Such connectivity matching does not introduce duplicates (it does not incorporate any count of the number of ways the connection can be made) even if the repeated path itself would
        otherwise result in duplicates.</p>
        <p>The graph matched may include cycles. Connectivity matching is defined so that matching cycles does not lead to undefined or infinite results.</p>
      </div>
    </div>
    <div class="div1">
      <h2><a name="assignment" id="assignment"></a>10 Assignment</h2>
      <p>The value of an expression can be added to a solution mapping by binding a new variable to the value of the expression, which is an RDF term. The variable can then be used in the query and
      also can be returned in results.</p>
      <p>Three syntax forms allow this: the <a href="#assignment"><code>BIND</code> keyword</a>, <a href="#selectExpressions">expressions in the <code>SELECT</code> clause</a> and <a href=
      "#groupby">expressions in the <code>GROUP BY</code> clause</a>. The assignment form is <code>(<i>expression</i> AS ?var)</code>.</p>
      <p>If the evaluation of the expression produces an error, the variable remains unbound for that solution but the query evaluation continues.</p>
      <p>Data can also be directly included in a query using <a href="#inline-data"><code>VALUES</code></a> for inline data.</p>
      <div class="div2">
        <h3><a name="bind" id="bind"></a>10.1 BIND: Assigning to Variables</h3>
        <p>The <code>BIND</code> form allows a value to be assigned to a variable from a basic graph pattern or property path expression. Use of <code>BIND</code> ends the preceding basic graph
        pattern. The variable introduced by the <code>BIND</code> clause must not have been used in the group graph pattern up to the point of use in <code>BIND</code>.</p>
        <p>Example:</p>
        <div class="exampleGroup">
          <p>Data:</p>
          <pre class="data">@prefix dc:   &lt;http://purl.org/dc/elements/1.1/&gt; .
@prefix :     &lt;http://example.org/book/&gt; .
@prefix ns:   &lt;http://example.org/ns#&gt; .

:book1  dc:title     "SPARQL Tutorial" .
:book1  ns:price     42 .
:book1  ns:discount  0.2 .

:book2  dc:title     "The Semantic Web" .
:book2  ns:price     23 .
:book2  ns:discount  0.25 .</pre>
          <p>Query:</p>
          <pre class="query">PREFIX  dc:  &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX  ns:  &lt;http://example.org/ns#&gt;

SELECT  ?title ?price
{  ?x ns:price ?p .
   ?x ns:discount ?discount
   BIND (?p*(1-?discount) AS ?price)
   FILTER(?price &lt; 20)
   ?x dc:title ?title . 
}</pre>
          <p>Equivalent query (<code>BIND</code> ends the basic graph pattern; the <code>FILTER</code> applies to the whole group graph pattern):</p>
          <pre class="query">PREFIX  dc:  &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX  ns:  &lt;http://example.org/ns#&gt;

SELECT  ?title ?price
{  { ?x ns:price ?p .
     ?x ns:discount ?discount
     BIND (?p*(1-?discount) AS ?price)
   }
   {?x dc:title ?title . }
   FILTER(?price &lt; 20)
}</pre>
          <p>Results:</p>
          <div class="result">
            <table class="resultTable">
              <tbody>
                <tr>
                  <th>title</th>
                  <th>price</th>
                </tr>
                <tr>
                  <td>&nbsp;"The Semantic Web"</td>
                  <td>17.25</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
      </div>
      <div class="div2">
        <h3><a name="inline-data" id="inline-data"></a>10.2 VALUES: Providing inline data</h3>
        <p>Data can be directly written in a graph pattern or added to a query using <code>VALUES</code>. <code>VALUES</code> provides inline data as a <a href="#defn_sparqlSolutionSequence">solution
        sequence</a> which are combined with the results of query evaluation by a <a href="#defn_algJoin">join</a> operation. It can be used by an application to provide specific requirements on
        query results and also by SPARQL query engine implementations that provide <a href="#basic-federated-query">federated query</a> through the <code>SERVICE</code> keyword to send a more
        constrained query to a remote query service.</p>
        <div class="div3">
          <h4><a name="inline-data-syntax" id="inline-data-syntax"></a>10.2.1 VALUES syntax</h4>
          <p><code>VALUES</code> allows multiple variables to be specified in the data block; there is a special syntax for the common case of specifying just one variable and some values.</p>
          <p>In the following example, there is a table of two variables, <code>?x</code> and <code>?y</code>. The second row has no value for <code>?y</code>.</p>
          <pre class="data">VALUES (?x ?y) {
  (:uri1 1)
  (:uri2 UNDEF)
}</pre>
          <p>Optionally, when there is a single variable and some values:</p>
          <pre class="data">VALUES ?z { "abc" "def" }</pre>
          <p>which is the same as using the general form:</p>
          <pre class="data">VALUES (?z) { ("abc") ("def") }</pre>
        </div>
        <div class="div3">
          <h4><a name="inline-data-examples" id="inline-data-examples"></a>10.2.2 VALUES Examples</h4>
          <p>A <code>VALUES</code> block of data can appear in a query pattern or at the end of a <code>SELECT</code> query, including a <a href="#subqueries">subquery</a>.</p>
          <div class="exampleGroup">
            <p>Data:</p>
            <pre class="data">@prefix dc:   &lt;http://purl.org/dc/elements/1.1/&gt; .
@prefix :     &lt;http://example.org/book/&gt; .
@prefix ns:   &lt;http://example.org/ns#&gt; .

:book1  dc:title  "SPARQL Tutorial" .
:book1  ns:price  42 .
:book2  dc:title  "The Semantic Web" .
:book2  ns:price  23 .
</pre>
            <p>Query:</p>
            <pre class="query">PREFIX dc:   &lt;http://purl.org/dc/elements/1.1/&gt; 
PREFIX :     &lt;http://example.org/book/&gt; 
PREFIX ns:   &lt;http://example.org/ns#&gt; 

SELECT ?book ?title ?price
{
   VALUES ?book { :book1 :book3 }
   ?book dc:title ?title ;
         ns:price ?price .
}</pre>
            <p>Result:</p>
            <div class="result">
              <a name="table110" id="table110"></a>
              <table class="resultTable">
                <tbody>
                  <tr>
                    <th>book</th>
                    <th>title</th>
                    <th>price</th>
                  </tr>
                  <tr>
                    <td>&lt;http://example.org/book/book1&gt;</td>
                    <td>"SPARQL Tutorial"</td>
                    <td>42</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
          <p>If a variable has no value for a particular solution in the <code>VALUES</code> clause, the keyword <code>UNDEF</code> is used instead of an RDF term.</p>
          <pre class="query">PREFIX dc:   &lt;http://purl.org/dc/elements/1.1/&gt; 
PREFIX :     &lt;http://example.org/book/&gt; 
PREFIX ns:   &lt;http://example.org/ns#&gt; 

SELECT ?book ?title ?price
{
   ?book dc:title ?title ;
         ns:price ?price .
   VALUES (?book ?title)
   { (UNDEF "SPARQL Tutorial")
     (:book2 UNDEF)
   }
}</pre>
          <div class="result">
            <a name="table111" id="table111"></a>
            <table class="resultTable">
              <tbody>
                <tr>
                  <th>book</th>
                  <th>title</th>
                  <th>price</th>
                </tr>
                <tr>
                  <td>&lt;http://example.org/book/book1&gt;</td>
                  <td>"SPARQL Tutorial"</td>
                  <td>42</td>
                </tr>
                <tr>
                  <td>&lt;http://example.org/book/book2&gt;</td>
                  <td>"The Semantic Web"</td>
                  <td>23</td>
                </tr>
              </tbody>
            </table>
          </div>
          <p>In this example, the <code>VALUES</code> might have been specified to execute over the results of the <code>SELECT</code> query:</p>
          <pre class="query">PREFIX dc:   &lt;http://purl.org/dc/elements/1.1/&gt; 
PREFIX :     &lt;http://example.org/book/&gt; 
PREFIX ns:   &lt;http://example.org/ns#&gt; 

SELECT ?book ?title ?price
{
   ?book dc:title ?title ;
         ns:price ?price .
}
VALUES (?book ?title)
{ (UNDEF "SPARQL Tutorial")
  (:book2 UNDEF)
}</pre>
          <p>This is a different query but, in the example situation, has the same results.</p>
        </div>
      </div>
    </div>
    <div class="div1">
      <h2><a name="aggregates" id="aggregates"></a>11 Aggregates</h2>
      <p>Aggregates apply expressions over groups of solutions. By default a solution set consists of a single group, containing all solutions.</p>
      <p>Grouping may be specified using the <code>GROUP BY</code> syntax.</p>
      <p>Aggregates defined in version 1.1 of SPARQL are <code>COUNT</code>, <code>SUM</code>, <code>MIN</code>, <code>MAX</code>, <code>AVG</code>, <code>GROUP_CONCAT</code>, and
      <code>SAMPLE</code>.</p>
      <p>Aggregates are used where the querier wishes to see a result which is computed over a group of solutions, rather than a single solution. For example the maximum value that a particular
      variable takes, rather than each value individually.</p>
      <div class="div2">
        <h3><a name="aggregateExample" id="aggregateExample"></a>11.1 Aggregate Example</h3>
        <div class="exampleGroup">
          <p>Data:</p>
          <pre class="data">@prefix : &lt;http://books.example/&gt; .

:org1 :affiliates :auth1, :auth2 .
:auth1 :writesBook :book1, :book2 .
:book1 :price 9 .
:book2 :price 5 .
:auth2 :writesBook :book3 .
:book3 :price 7 .
:org2 :affiliates :auth3 .
:auth3 :writesBook :book4 .
:book4 :price 7 .</pre>
          <p>Query:</p>
          <pre class="query">PREFIX : &lt;http://books.example/&gt;
SELECT (SUM(?lprice) AS ?totalPrice)
WHERE {
  ?org :affiliates ?auth .
  ?auth :writesBook ?book .
  ?book :price ?lprice .
}
GROUP BY ?org
HAVING (SUM(?lprice) &gt; 10)</pre>
          <p>Results:</p>
          <div class="result">
            <table class="resultTable">
              <tbody>
                <tr>
                  <th>totalPrice</th>
                </tr>
                <tr>
                  <td>21</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
        <p>This example demonstrates two features of aggregates: <code>GROUP BY</code>, which groups query solutions according to one or more expressions (in this case <code>?org</code>), and
        <code>HAVING</code>, which is analogous to a <code>FILTER</code> expression, but operates over groups, rather than individual solutions.</p>
        <p>The example is produced by grouping solutions according to the <code>GROUP BY</code> expression (i.e. all solutions where <code>?org</code> takes a particular value appear within the same
        group), and evaluating the Set Function <code>SUM</code> over that group. The groups are then filtered by the <code>HAVING</code> expression, which removes all groups where
        <code>SUM(?lprice)</code> is not greater than 10.</p>
        <p>In aggregate queries and sub-queries, variables that appear in the query pattern, but are not in the <code>GROUP BY</code> clause, can only be projected or used in select expressions if
        they are aggregated. The <code>SAMPLE</code> aggregate may be used for this purpose. For details see the section on <a href="#aggregateRestrictions">Projection Restrictions</a>.</p>
        <p>It should be noted that <a href="#selectExpressions">as per functions</a>, aggregate expressions are required to be aliased (again, similar to the <code>BIND</code> clause, using the
        keyword <code>AS</code>) in order to project them from queries or subqueries. In the example above this is done using the variable <code>?totalPrice</code>. It is an error for aggregates to
        project variables with a name already used in other aggregate projections, or in the <code>WHERE</code> clause.</p>
      </div>
      <div class="div2">
        <h3><a name="groupby" id="groupby"></a>11.2 GROUP BY</h3>
        <p>In order to calculate aggregate values for a solution, the solution is first divided into one or more groups, and the aggregate value is calculated for each group.</p>
        <p>If aggregates are used in the query level in <code>SELECT</code>, <code>HAVING</code> or <code>ORDER BY</code> but the <code>GROUP BY</code> term is not used, then this is taken to be a
        single implicit group, to which all solutions belong.</p>
        <p>Within <code>GROUP BY</code> clauses the binding keyword, <code>AS</code>, may be used, such as <code>GROUP BY (?x + ?y AS ?z)</code>. This is equivalent to <code>{ ... BIND (?x + ?y AS
        ?z) } GROUP BY ?z</code>.</p>
        <p>For example, given a solution sequence S, ( {?x→2, ?y→3}, {?x→2, ?y→5}, {?x→6, ?y→7} ), we might wish to group the solutions according to the value of ?x, and calculate the average of the
        values of ?y for each group.</p>
        <p>This could be written as:</p>
        <pre class="query">SELECT (AVG(?y) AS ?avg)
WHERE {
  ?a :x ?x ;
     :y ?y .
}
GROUP BY ?x</pre>
      </div>
      <div class="div2">
        <h3><a name="having" id="having"></a>11.3 HAVING</h3>
        <p><code>HAVING</code> operates over grouped solution sets, in the same way that <code>FILTER</code> operates over un-grouped ones.</p>
        <p><code>HAVING</code> expressions have the same evaluation rules as projections from grouped queries, as described in the following section.</p>
        <p>An example of the use of <code>HAVING</code> is given below.</p>
        <pre class="query">PREFIX : &lt;http://data.example/&gt;
SELECT (AVG(?size) AS ?asize)
WHERE {
  ?x :size ?size
}
GROUP BY ?x
HAVING(AVG(?size) &gt; 10)</pre>
        <p>This will return average sizes, grouped by the subject, but only where the mean size is greater than 10.</p>
      </div>
      <div class="div2">
        <h3><a name="aggregateRestrictions" id="aggregateRestrictions"></a>11.4 Aggregate Projection Restrictions</h3>
        <p>In a query level which uses aggregates, only expressions consisting of aggregates and constants may be projected, with one exception. When <code>GROUP BY</code> is given with one or more
        simple expressions consisting of just a variable, those variables may be projected from the level.</p>
        <p>For example, the following query is legal as ?x is given as a <code>GROUP BY</code> term.</p>
        <pre class="query">PREFIX : &lt;http://example.com/data/#&gt;
SELECT ?x (MIN(?y) * 2 AS ?min)
WHERE {
  ?x :p ?y .
  ?x :q ?z .
} GROUP BY ?x (STR(?z))</pre>
        <p>Note that it would not be legal to project <code>STR(?z)</code> as this is not a simple variable expression. However, with <code>GROUP BY (STR(?z) AS ?strZ)</code> it would be possible to
        project <code>?strZ</code>.</p>
        <p>Other expressions, not using <code>GROUP BY</code> variables, or aggregates may have non-deterministic values projected from their groups using the <code>SAMPLE</code> aggregate.</p>
      </div>
      <div class="div2">
        <h3><a name="aggregateExample2" id="aggregateExample2"></a>11.5 Aggregate Example (with errors)</h3>
        <p>This section shows an example query using aggregation, which demonstrates how errors are handled in results, in the presence of aggregates.</p>
        <p>Data:</p>
        <pre class="data">@prefix : &lt;http://example.com/data/#&gt; .

:x :p 1, 2, 3, 4 .
:y :p 1, _:b2, 3, 4 .
:z :p 1.0, 2.0, 3.0, 4 .</pre>
        <p>Query:</p>
        <pre class="query">PREFIX : &lt;http://example.com/data/#&gt;
SELECT ?g (AVG(?p) AS ?avg) ((MIN(?p) + MAX(?p)) / 2 AS ?c)
WHERE {
  ?g :p ?p .
}
GROUP BY ?g</pre>
        <p>Result:</p>
        <div class="result">
          <table class="resultTable">
            <tbody>
              <tr>
                <th>g</th>
                <th>avg</th>
                <th>c</th>
              </tr>
              <tr>
                <td>&lt;http://example.com/data/#x&gt;</td>
                <td>2.5</td>
                <td>2.5</td>
              </tr>
              <tr>
                <td>&lt;http://example.com/data/#y&gt;</td>
                <td></td>
                <td></td>
              </tr>
              <tr>
                <td>&lt;http://example.com/data/#z&gt;</td>
                <td>2.5</td>
                <td>2.5</td>
              </tr>
            </tbody>
          </table>
        </div>
        <p>Note that the bindings for the :y group is not included in the results as the evaluation of Avg({1, _:b2, 3, 4}), and (_:b2 + 4) / 2 is an error, removing the bindings from the
        solution.</p>
      </div>
    </div>
    <div class="div1">
      <h2><a name="subqueries" id="subqueries"></a>12 Subqueries</h2>
      <p>Subqueries are a way to embed SPARQL queries within other queries, normally to achieve results which cannot otherwise be achieved, such as limiting the number of results from some
      sub-expression within the query.</p>
      <p>Due to the bottom-up nature of SPARQL query evaluation, the subqueries are evaluated logically first, and the results are projected up to the outer query.</p>
      <p>Note that only variables projected out of the subquery will be visible, or <a href="#variableScope">in scope</a>, to the outer query.</p>
      <h3 id="subquery-example">Example</h3>
      <p>Data:</p>
      <div class="exampleGroup">
        <pre class="data">@prefix : &lt;http://people.example/&gt; .

:alice :name "Alice", "Alice Foo", "A. Foo" .
:alice :knows :bob, :carol .
:bob :name "Bob", "Bob Bar", "B. Bar" .
:carol :name "Carol", "Carol Baz", "C. Baz" .</pre>
        <p>Return a name (the one with the lowest sort order) for all the people that know Alice and have a name.</p>
        <p>Query:</p>
        <pre class="query">PREFIX : &lt;http://people.example/&gt;
PREFIX : &lt;http://people.example/&gt;
SELECT ?y ?minName
WHERE {
  :alice :knows ?y .
  {
    SELECT ?y (MIN(?name) AS ?minName)
    WHERE {
      ?y :name ?name .
    } GROUP BY ?y
  }
}</pre>
      </div>
      <p>Results:</p>
      <div class="result">
        <table class="resultTable">
          <tbody>
            <tr>
              <th>y</th>
              <th>minName</th>
            </tr>
            <tr>
              <td>:bob</td>
              <td>"B. Bar"</td>
            </tr>
            <tr>
              <td>:carol</td>
              <td>"C. Baz"</td>
            </tr>
          </tbody>
        </table>
      </div>
      <p>This result is achieved by first evaluating the inner query:</p>
      <pre class="query">SELECT ?y (MIN(?name) AS ?minName)
WHERE {
  ?y :name ?name .
} GROUP BY ?y</pre>
      <p>This produces the following solution sequence:</p>
      <div class="result">
        <table class="resultTable">
          <tbody>
            <tr>
              <th>y</th>
              <th>minName</th>
            </tr>
            <tr>
              <td>:alice</td>
              <td>"A. Foo"</td>
            </tr>
            <tr>
              <td>:bob</td>
              <td>"B. Bar"</td>
            </tr>
            <tr>
              <td>:carol</td>
              <td>"C. Baz"</td>
            </tr>
          </tbody>
        </table>
      </div>
      <p>Which is joined with the results of the outer query:</p>
      <div class="result">
        <table class="resultTable">
          <tbody>
            <tr>
              <th>y</th>
            </tr>
            <tr>
              <td>:bob</td>
            </tr>
            <tr>
              <td>:carol</td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
    <div class="div1">
      <h2><a name="rdfDataset" id="rdfDataset"></a>13 RDF Dataset</h2>
      <p>The RDF data model expresses information as graphs consisting of triples with subject, predicate and object. Many RDF data stores hold multiple RDF graphs and record information about each
      graph, allowing an application to make queries that involve information from more than one graph.</p>
      <p>A SPARQL query is executed against an <em>RDF Dataset</em> which represents a collection of graphs. An RDF Dataset comprises one graph, the default graph, which does not have a name, and
      zero or more named graphs, where each named graph is identified by an IRI. A SPARQL query can match different parts of the query pattern against different graphs as described in section
      <a href="#queryDataset">13.3 Querying the Dataset</a>.</p>
      <p>An RDF Dataset may contain zero named graphs; an RDF Dataset always contains one default graph. A query does not need to involve matching the default graph; the query can just involve
      matching named graphs.</p>
      <p>The graph that is used for matching a basic graph pattern is the <i>active graph</i>. In the previous sections, all queries have been shown executed against a single graph, the default graph
      of an RDF dataset as the active graph. The <code>GRAPH</code> keyword is used to make the active graph one of all of the named graphs in the dataset for part of the query.</p>
      <div class="div2">
        <h3><a name="exampleDatasets" id="exampleDatasets"></a>13.1 Examples of RDF Datasets</h3>
        <p>The definition of RDF Dataset does not restrict the relationships of named and default graphs. Information can be repeated in different graphs; relationships between graphs can be exposed.
        Two useful arrangements are:</p>
        <ul>
          <li>to have information in the default graph that includes provenance information about the named graphs</li>
          <li>to include the information in the named graphs in the default graph as well.</li>
        </ul>
        <div class="exampleGroup">
          <b>Example 1:</b>
          <pre class="data"># <b>Default graph</b>
@prefix dc: &lt;http://purl.org/dc/elements/1.1/&gt; .

&lt;http://example.org/bob&gt;    dc:publisher  "Bob" .
&lt;http://example.org/alice&gt;  dc:publisher  "Alice" .
</pre>
          <pre class="data"># <b>Named graph: http://example.org/bob</b>
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a foaf:name "Bob" .
_:a foaf:mbox &lt;mailto:bob@oldcorp.example.org&gt; .
</pre>
          <pre class="data"># <b>Named graph: http://example.org/alice</b>
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a foaf:name "Alice" .
_:a foaf:mbox &lt;mailto:alice@work.example.org&gt; .
</pre>
        </div>
        <p>In this example, the default graph contains the names of the publishers of two named graphs. The triples in the named graphs are not visible in the default graph in this example.</p>
        <p id="ex_2"><b>Example 2:</b></p>
        <p>RDF data can be combined by the <a class="norm" href="http://www.w3.org/TR/rdf-mt/#graphdefs">RDF merge</a> [<a href="#RDF-MT">RDF-MT</a>] of graphs. One possible arrangement of graphs in
        an RDF Dataset is to have the default graph be the RDF merge of some or all of the information in the named graphs.</p>
        <p>In this next example, the named graphs contain the same triples as before. The RDF dataset includes an RDF merge of the named graphs in the default graph, re-labeling blank nodes to keep
        them distinct.</p>
        <div class="exampleGroup">
          <pre class="data"># <b>Default graph</b>
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

_:x foaf:name "Bob" .
_:x foaf:mbox &lt;mailto:bob@oldcorp.example.org&gt; .

_:y foaf:name "Alice" .
_:y foaf:mbox &lt;mailto:alice@work.example.org&gt; .
</pre>
          <pre class="data"># <b>Named graph: http://example.org/bob</b>
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a foaf:name "Bob" .
_:a foaf:mbox &lt;mailto:bob@oldcorp.example.org&gt; .
</pre>
          <pre class="data"># <b>Named graph: http://example.org/alice</b>
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a foaf:name "Alice" .
_:a foaf:mbox &lt;<a href="mailto:alice@work.example">mailto:alice@work.example</a>&gt; .</pre>
          <p>In an RDF merge, blank nodes in the merged graph are not shared with blank nodes from the graphs being merged.</p>
        </div>
      </div>
      <div class="div2">
        <h3><a name="specifyingDataset" id="specifyingDataset"></a>13.2 Specifying RDF Datasets</h3>
        <p>A SPARQL query may specify the dataset to be used for matching by using the <code>FROM</code> clause and the <code>FROM NAMED</code> clause to describe the RDF dataset. If a query provides
        such a dataset description, then it is used in place of any dataset that the query service would use if no dataset description is provided in a query. The RDF dataset may also be <a class=
        "inform" href="http://www.w3.org/TR/sparql11-protocol/">specified in a SPARQL protocol request</a>, in which case the protocol description overrides any description in the query itself. A
        query service may refuse a query request if the dataset description is not acceptable to the service.</p>
        <p>The <code>FROM</code> and <code>FROM NAMED</code> keywords allow a query to specify an RDF dataset by reference; they indicate that the dataset should include graphs that are obtained from
        representations of the resources identified by the given IRIs (i.e. the absolute form of the given IRI references). The dataset resulting from a number of <code>FROM</code> and <code>FROM
        NAMED</code> clauses is:</p>
        <ul>
          <li>a default graph consisting of the RDF merge of the graphs referred to in the <code>FROM</code> clauses, and</li>
          <li>a set of (IRI, graph) pairs, one from each <code>FROM NAMED</code> clause.</li>
        </ul>
        <p>If there is no <code>FROM</code> clause, but there is one or more <code>FROM NAMED</code> clauses, then the dataset includes an empty graph for the default graph.</p>
        <div class="div3">
          <h4><a name="unnamedGraph" id="unnamedGraph"></a>13.2.1 Specifying the Default Graph</h4>
          <p>Each <code>FROM</code> clause contains an IRI that indicates a graph to be used to form the default graph. This does not put the graph in as a named graph.</p>
          <p>In this example, the RDF Dataset contains a single default graph and no named graphs:</p>
          <div class="exampleGroup">
            <pre class="data"><b># Default graph (located at http://example.org/foaf/aliceFoaf)
</b>@prefix  foaf:  &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a  foaf:name     "Alice" .
_:a  foaf:mbox     &lt;mailto:alice@work.example&gt; .
</pre>
            <div class="queryGroup">
              <pre class="query">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT  ?name
FROM    &lt;http://example.org/foaf/aliceFoaf&gt;
WHERE   { ?x foaf:name ?name }
</pre>
              <div class="result">
                <a name="table102" id="table102"></a>
                <table class="resultTable">
                  <tbody>
                    <tr>
                      <th>name</th>
                    </tr>
                    <tr>
                      <td>"Alice"</td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
          </div>
          <p>If a query provides more than one <code>FROM</code> clause, providing more than one IRI to indicate the default graph, then the default graph is the <a class="norm" href=
          "http://www.w3.org/TR/rdf-mt/#graphdefs">RDF merge</a> of the graphs obtained from representations of the resources identified by the given IRIs.</p>
        </div>
        <div class="div3">
          <h4><a name="namedGraphs" id="namedGraphs"></a>13.2.2 Specifying Named Graphs</h4>
          <p>A query can supply IRIs for the named graphs in the RDF Dataset using the <code>FROM NAMED</code> clause. Each IRI is used to provide one named graph in the RDF Dataset. Using the same
          IRI in two or more <code>FROM NAMED</code> clauses results in one named graph with that IRI appearing in the dataset.</p>
          <pre class="data"><b># Graph: http://example.org/bob</b>
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a foaf:name "Bob" .
_:a foaf:mbox &lt;mailto:bob@oldcorp.example.org&gt; .
</pre>
          <pre class="data"><b># Graph: http://example.org/alice</b>
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a foaf:name "Alice" .
_:a foaf:mbox &lt;mailto:alice@work.example&gt; .
</pre>
          <div class="queryGroup">
            <pre class="query">...
FROM NAMED &lt;http://example.org/alice&gt;
FROM NAMED &lt;http://example.org/bob&gt;
...</pre>
          </div>
          <p>The <code>FROM NAMED</code> syntax suggests that the IRI identifies the corresponding graph, but the relationship between an IRI and a graph in an RDF dataset is indirect. The IRI
          identifies a resource, and the resource is represented by a graph (or, more precisely: by a document that serializes a graph). For <a class="inform" href=
          "http://www.w3.org/TR/webarch/#intro">further details</a> see [<a href="#WEBARCH">WEBARCH</a>].</p>
        </div>
        <div class="div3">
          <h4><a name="specDataset" id="specDataset"></a>13.2.3 Combining FROM and FROM NAMED</h4>
          <p>The <code>FROM</code> clause and <code>FROM NAMED</code> clause can be used in the same query.</p>
          <div class="exampleGroup">
            <pre class="data"># <b>Default graph (located at http://example.org/dft.ttl)
</b>@prefix dc: &lt;http://purl.org/dc/elements/1.1/&gt; .

&lt;http://example.org/bob&gt;    dc:publisher  "Bob Hacker" .
&lt;http://example.org/alice&gt;  dc:publisher  "Alice Hacker" .
</pre>
            <pre class="data"># <b>Named graph: http://example.org/bob</b>
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a foaf:name "Bob" .
_:a foaf:mbox &lt;mailto:bob@oldcorp.example.org&gt; .
</pre>
            <pre class="data"># <b>Named graph: http://example.org/alice</b>
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a foaf:name "Alice" .
_:a foaf:mbox &lt;mailto:alice@work.example.org&gt; .
</pre>
            <pre class="query">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX dc: &lt;http://purl.org/dc/elements/1.1/&gt;

SELECT ?who ?g ?mbox
FROM &lt;http://example.org/dft.ttl&gt;
FROM NAMED &lt;http://example.org/alice&gt;
FROM NAMED &lt;http://example.org/bob&gt;
WHERE
{
   ?g dc:publisher ?who .
   GRAPH ?g { ?x foaf:mbox ?mbox }
}
</pre>
          </div>
          <p>The RDF Dataset for this query contains a default graph and two named graphs. The <code>GRAPH</code> keyword is described below.</p>
          <p>The actions required to construct the dataset are not determined by the dataset description alone. If an IRI is given twice in a dataset description, either by using two
          <code>FROM</code> clauses, or a <code>FROM</code> clause and a <code>FROM NAMED</code> clause, then it does not assume that exactly one or exactly two attempts are made to obtain an RDF
          graph associated with the IRI. Therefore, no assumptions can be made about blank node identity in triples obtained from the two occurrences in the dataset description. In general, no
          assumptions can be made about the equivalence of the graphs.</p>
        </div>
      </div>
      <div class="div2">
        <h3><a name="queryDataset" id="queryDataset"></a>13.3 Querying the Dataset</h3>
        <p>When querying a collection of graphs, the <code>GRAPH</code> keyword is used to match patterns against named graphs. <code>GRAPH</code> can provide an IRI to select one graph or use a
        variable which will range over the IRI of all the named graphs in the query's RDF dataset.</p>
        <p>The use of <code>GRAPH</code> changes the active graph for matching graph patterns within that part of the query. Outside the use of <code>GRAPH</code>, matching is done using the default
        graph.</p>
        <p>The following two graphs will be used in examples:</p>
        <div class="exampleGroup">
          <pre class="data"><b># Named graph: http://example.org/foaf/aliceFoaf
</b>@prefix  foaf:     &lt;http://xmlns.com/foaf/0.1/&gt; .
@prefix  rdf:      &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .
@prefix  rdfs:     &lt;http://www.w3.org/2000/01/rdf-schema#&gt; .

_:a  foaf:name     "Alice" .
_:a  foaf:mbox     &lt;mailto:alice@work.example&gt; .
_:a  foaf:knows    _:b .

_:b  foaf:name     "Bob" .
_:b  foaf:mbox     &lt;mailto:bob@work.example&gt; .
_:b  foaf:nick     "Bobby" .
_:b  rdfs:seeAlso  &lt;http://example.org/foaf/bobFoaf&gt; .

&lt;http://example.org/foaf/bobFoaf&gt;
     rdf:type      foaf:PersonalProfileDocument .
</pre>
          <pre class="data"><b># Named graph: http://example.org/foaf/bobFoaf
</b>@prefix  foaf:     &lt;http://xmlns.com/foaf/0.1/&gt; .
@prefix  rdf:      &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .
@prefix  rdfs:     &lt;http://www.w3.org/2000/01/rdf-schema#&gt; .

_:z  foaf:mbox     &lt;mailto:bob@work.example&gt; .
_:z  rdfs:seeAlso  &lt;http://example.org/foaf/bobFoaf&gt; .
_:z  foaf:nick     "Robert" .

&lt;http://example.org/foaf/bobFoaf&gt;
     rdf:type      foaf:PersonalProfileDocument .
</pre>
        </div>
        <div class="div3">
          <h4><a name="accessByLabel" id="accessByLabel"></a>13.3.1 Accessing Graph Names</h4>
          <p>The query below matches the graph pattern against each of the named graphs in the dataset and forms solutions which have the <code>src</code> variable bound to IRIs of the graph being
          matched. The graph pattern is matched with the active graph being each of the named graphs in the dataset.</p>
          <div class="queryGroup">
            <pre class="query">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;

SELECT ?src ?bobNick
FROM NAMED &lt;http://example.org/foaf/aliceFoaf&gt;
FROM NAMED &lt;http://example.org/foaf/bobFoaf&gt;
WHERE
  {
    GRAPH ?src
    { ?x foaf:mbox &lt;mailto:bob@work.example&gt; .
      ?x foaf:nick ?bobNick
    }
  }
</pre>
            <p>The query result gives the name of the graphs where the information was found and the value for Bob's nick:</p>
            <div class="result">
              <a name="table105" id="table105"></a>
              <table class="resultTable">
                <tbody>
                  <tr>
                    <th>src</th>
                    <th>bobNick</th>
                  </tr>
                  <tr>
                    <td>&lt;http://example.org/foaf/aliceFoaf&gt;</td>
                    <td>"Bobby"</td>
                  </tr>
                  <tr>
                    <td>&lt;http://example.org/foaf/bobFoaf&gt;</td>
                    <td>"Robert"</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>
        <div class="div3">
          <h4><a name="restrictByLabel" id="restrictByLabel"></a>13.3.2 Restricting by Graph IRI</h4>
          <p>The query can restrict the matching applied to a specific graph by supplying the graph IRI. This sets the active graph to the graph named by the IRI. This query looks for Bob's nick as
          given in the graph <code>http://example.org/foaf/bobFoaf</code>.</p>
          <div class="queryGroup">
            <pre class="query">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX data: &lt;http://example.org/foaf/&gt;

SELECT ?nick
FROM NAMED &lt;http://example.org/foaf/aliceFoaf&gt;
FROM NAMED &lt;http://example.org/foaf/bobFoaf&gt;
WHERE
  {
     GRAPH data:bobFoaf {
         ?x foaf:mbox &lt;mailto:bob@work.example&gt; .
         ?x foaf:nick ?nick }
  }
</pre>
            <p>which yields a single solution:</p>
            <div class="result">
              <a name="table106" id="table106"></a>
              <table class="resultTable">
                <tbody>
                  <tr>
                    <th>nick</th>
                  </tr>
                  <tr>
                    <td>"Robert"</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>
        <div class="div3">
          <h4><a name="restrictInQuery" id="restrictInQuery"></a>13.3.3 Restricting Possible Graph IRIs</h4>
          <p>A variable used in the <code>GRAPH</code> clause may also be used in another <code>GRAPH</code> clause or in a graph pattern matched against the default graph in the dataset.</p>
          <p>The query below uses the graph with IRI <code>http://example.org/foaf/aliceFoaf</code> to find the profile document for Bob; it then matches another pattern against that graph. The
          pattern in the second <code>GRAPH</code> clause finds the blank node (variable <code>w</code>) for the person with the same mail box (given by variable <code>mbox</code>) as found in the
          first <code>GRAPH</code> clause (variable <code>whom</code>), because the blank node used to match for variable <code>whom</code> from Alice's FOAF file is not the same as the blank node in
          the profile document (they are in different graphs).</p>
          <div class="queryGroup">
            <pre class="query">PREFIX  data:  &lt;http://example.org/foaf/&gt;
PREFIX  foaf:  &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX  rdfs:  &lt;http://www.w3.org/2000/01/rdf-schema#&gt;

SELECT ?mbox ?nick ?ppd
FROM NAMED &lt;http://example.org/foaf/aliceFoaf&gt;
FROM NAMED &lt;http://example.org/foaf/bobFoaf&gt;
WHERE
{
  GRAPH data:aliceFoaf
  {
    ?alice foaf:mbox &lt;mailto:alice@work.example&gt; ;
           foaf:knows ?whom .
    ?whom  foaf:mbox ?mbox ;
           rdfs:seeAlso ?ppd .
    ?ppd  a foaf:PersonalProfileDocument .
  } .
  GRAPH ?ppd
  {
      ?w foaf:mbox ?mbox ;
         foaf:nick ?nick
  }
}
</pre>
            <div class="result">
              <a name="table107" id="table107"></a>
              <table class="resultTable">
                <tbody>
                  <tr>
                    <th>mbox</th>
                    <th>nick</th>
                    <th>ppd</th>
                  </tr>
                  <tr>
                    <td>&lt;mailto:bob@work.example&gt;</td>
                    <td>"Robert"</td>
                    <td>&lt;http://example.org/foaf/bobFoaf&gt;</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>
        <p>Any triple in Alice's FOAF file giving Bob's <code>nick</code> is not used to provide a nick for Bob because the pattern involving variable <code>nick</code> is restricted by
        <code>ppd</code> to a particular Personal Profile Document.</p>
        <div class="div3">
          <h4><a name="namedAndDefaultGraph" id="namedAndDefaultGraph"></a>13.3.4 Named and Default Graphs</h4>
          <p>Query patterns can involve both the default graph and the named graphs. In this example, an aggregator has read in a Web resource on two different occasions. Each time a graph is read
          into the aggregator, it is given an IRI by the local system. The graphs are nearly the same but the email address for "Bob" has changed.</p>
          <p>In this example, the default graph is being used to record the provenance information and the RDF data actually read is kept in two separate graphs, each of which is given a different
          IRI by the system. The RDF dataset consists of two named graphs and the information about them.</p>
          <p>RDF Dataset:</p>
          <div class="exampleGroup">
            <pre class="data"># <b>Default graph</b>
@prefix dc: &lt;http://purl.org/dc/elements/1.1/&gt; .
@prefix g:  &lt;tag:example.org,2005-06-06:&gt; .
@prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt; .

g:graph1 dc:publisher "Bob" .
g:graph1 dc:date "2004-12-06"^^xsd:date .

g:graph2 dc:publisher "Bob" .
g:graph2 dc:date "2005-01-10"^^xsd:date .
</pre>
            <pre class="data"># <b>Graph: locally allocated IRI: tag:example.org,2005-06-06:graph1</b>
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a foaf:name "Alice" .
_:a foaf:mbox &lt;mailto:alice@work.example&gt; .

_:b foaf:name "Bob" .
_:b foaf:mbox &lt;mailto:bob@oldcorp.example.org&gt; .
</pre>
            <pre class="data"># <b>Graph: locally allocated IRI: tag:example.org,2005-06-06:graph2</b>
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a foaf:name "Alice" .
_:a foaf:mbox &lt;mailto:alice@work.example&gt; .

_:b foaf:name "Bob" .
_:b foaf:mbox &lt;mailto:bob@newcorp.example.org&gt; .
</pre>
            <p>This query finds email addresses, detailing the name of the person and the date the information was discovered.</p>
            <div class="queryGroup">
              <pre class="query">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX dc:   &lt;http://purl.org/dc/elements/1.1/&gt;

SELECT ?name ?mbox ?date
WHERE
  {  ?g dc:publisher ?name ;
        dc:date ?date .
    GRAPH ?g
      { ?person foaf:name ?name ; foaf:mbox ?mbox }
  }
</pre>
              <p>The results show that the email address for "Bob" has changed.</p>
              <div class="result">
                <a name="table108" id="table108"></a>
                <table class="resultTable">
                  <tbody>
                    <tr>
                      <th>name</th>
                      <th>mbox</th>
                      <th>date</th>
                    </tr>
                    <tr>
                      <td>"Bob"</td>
                      <td>&lt;mailto:bob@oldcorp.example.org&gt;</td>
                      <td>"2004-12-06"^^xsd:date</td>
                    </tr>
                    <tr>
                      <td>"Bob"</td>
                      <td>&lt;mailto:bob@newcorp.example.org&gt;</td>
                      <td>"2005-01-10"^^xsd:date</td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="div1">
      <h2><a name="basic-federated-query" id="basic-federated-query"></a>14 Basic Federated Query</h2>
      <p>This document incorporates the syntax for SPARQL federation extensions.</p>
      <p>This feature is defined in the document <a href="http://www.w3.org/TR/sparql11-federated-query/">SPARQL 1.1 Federated Query</a>.</p>
    </div>
    <div class="div1">
      <h2><a name="solutionModifiers" id="solutionModifiers"></a>15 Solution Sequences and Modifiers</h2>
      <p>Query patterns generate an unordered collection of solutions, each <a href="#defn_sparqlSolutionMapping">solution</a> being a partial function from variables to RDF terms. These solutions
      are then treated as a sequence (a solution sequence), initially in no specific order; any sequence modifiers are then applied to create another sequence. Finally, this latter sequence is used
      to generate one of the results of a <a href="#QueryForms">SPARQL query form</a>.</p>
      <p>A <span class="definedTerm">solution sequence modifier</span> is one of:</p>
      <ul>
        <li><a href="#modOrderBy">Order</a> modifier: put the solutions in order</li>
        <li><a href="#modProjection">Projection</a> modifier: choose certain variables</li>
        <li><a href="#modDistinct">Distinct</a> modifier: ensure solutions in the sequence are unique</li>
        <li><a href="#modReduced">Reduced</a> modifier: permit elimination of some non-distinct solutions</li>
        <li><a href="#modOffset">Offset</a> modifier: control where the solutions start from in the overall sequence of solutions</li>
        <li><a href="#modResultLimit">Limit</a> modifier: restrict the number of solutions</li>
      </ul>
      <p>Modifiers are applied in the order given by the list above.</p>
      <div class="div2">
        <h3><a name="modOrderBy" id="modOrderBy"></a>15.1 ORDER BY</h3>
        <p>The <code>ORDER BY</code> clause establishes the order of a solution sequence.</p>
        <p>Following the <code>ORDER BY</code> clause is a sequence of order comparators, composed of an expression and an optional order modifier (either <code>ASC()</code> or <code>DESC()</code>).
        Each ordering comparator is either ascending (indicated by the <code>ASC()</code> modifier or by no modifier) or descending (indicated by the <code>DESC()</code> modifier).</p>
        <div class="exampleGroup">
          <div class="queryGroup">
            <pre class="query">PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;

SELECT ?name
WHERE { ?x foaf:name ?name }
ORDER BY ?name
</pre>
          </div>
        </div>
        <div class="exampleGroup">
          <div class="queryGroup">
            <pre class="query">PREFIX     :    &lt;http://example.org/ns#&gt;
PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;

SELECT ?name
WHERE { ?x foaf:name ?name ; :empId ?emp }
ORDER BY DESC(?emp)
</pre>
          </div>
        </div>
        <div class="exampleGroup">
          <div class="queryGroup">
            <pre class="query">PREFIX     :    &lt;http://example.org/ns#&gt;
PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;

SELECT ?name
WHERE { ?x foaf:name ?name ; :empId ?emp }
ORDER BY ?name DESC(?emp)
</pre>
          </div>
        </div>
        <p>The <a href="#op_lt">"&lt;" operator</a> (see the <a href="#OperatorMapping">Operator Mapping</a> and <a href="#operatorExtensibility">17.3.1 Operator Extensibility</a>) defines the
        relative order of pairs of <code>numerics</code>, <code>simple literals</code>, <code>xsd:strings</code>, <code>xsd:booleans</code> and <code>xsd:dateTimes</code>. Pairs of IRIs are ordered
        by comparing them as <code>simple literals</code>.</p>
        <p>SPARQL also fixes an order between some kinds of RDF terms that would not otherwise be ordered:</p>
        <ol>
          <li>(Lowest) no value assigned to the variable or expression in this solution.</li>
          <li>Blank nodes</li>
          <li>IRIs</li>
          <li>RDF literals</li>
        </ol>
        <p>A plain literal is lower than an RDF literal with type <code>xsd:string</code> of the same lexical form.</p>
        <p>SPARQL does not define a total ordering of all possible RDF terms. Here are a few examples of pairs of terms for which the relative order is undefined:</p>
        <ul>
          <li>"a" and "a"@en_gb (a simple literal and a literal with a language tag)</li>
          <li>"a"@en_gb and "b"@en_gb (two literals with language tags)</li>
          <li>"a" and "1"^^xsd:integer (a simple literal and a literal with a supported datatype)</li>
          <li>"1"^^my:integer and "2"^^my:integer (two unsupported datatypes)</li>
          <li>"1"^^xsd:integer and "2"^^my:integer (a supported datatype and an unsupported datatype)</li>
        </ul>
        <p>This list of variable bindings is in ascending order:</p>
        <div class="result">
          <table class="resultTable">
            <thead>
              <tr>
                <th>RDF Term</th>
                <th>Reason</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td></td>
                <td>Unbound results sort earliest.</td>
              </tr>
              <tr>
                <td><code>_:z</code></td>
                <td>Blank nodes follow unbound.</td>
              </tr>
              <tr>
                <td><code>_:a</code></td>
                <td>There is no relative ordering of blank nodes.</td>
              </tr>
              <tr>
                <td><code>&lt;http://script.example/Latin&gt;</code></td>
                <td>IRIs follow blank nodes.</td>
              </tr>
              <tr>
                <td><code>&lt;http://script.example/Кириллица&gt;</code></td>
                <td>The character in the 23rd position, "К", has a unicode codepoint 0x41A, which is higher than 0x4C ("L").</td>
              </tr>
              <tr>
                <td><code>&lt;http://script.example/漢字&gt;</code></td>
                <td>The character in the 23rd position, "漢", has a unicode codepoint 0x6F22, which is higher than 0x41A ("К").</td>
              </tr>
              <tr>
                <td><code>"http://script.example/Latin"</code></td>
                <td>Simple literals follow IRIs.</td>
              </tr>
              <tr>
                <td><code>"http://script.example/Latin"^^xsd:string</code></td>
                <td>xsd:strings follow simple literals.</td>
              </tr>
            </tbody>
          </table>
        </div>
        <p>The ascending order of two solutions with respect to an ordering comparator is established by substituting the solution bindings into the expressions and comparing them with the <a href=
        "#op_lt">"&lt;" operator</a>. The descending order is the reverse of the ascending order.</p>
        <p>The relative order of two solutions is the relative order of the two solutions with respect to the first ordering comparator in the sequence. For solutions where the substitutions of the
        solution bindings produce the same RDF term, the order is the relative order of the two solutions with respect to the next ordering comparator. The relative order of two solutions is
        undefined if no order expression evaluated for the two solutions produces distinct RDF terms.</p>
        <p>Ordering a sequence of solutions always results in a sequence with the same number of solutions in it.</p>
        <p>Using <code>ORDER BY</code> on a solution sequence for a <code>CONSTRUCT</code> or <code>DESCRIBE</code> query has no direct effect because only <code>SELECT</code> returns a sequence of
        results. Used in combination with <code>LIMIT</code> and <code>OFFSET</code>, <code>ORDER BY</code> can be used to return results generated from a different slice of the solution sequence. An
        <code>ASK</code> query does not include <code>ORDER BY</code>, <code>LIMIT</code> or <code>OFFSET</code>.</p>
      </div>
      <div class="div2">
        <h3><a name="modProjection" id="modProjection"></a>15.2 Projection</h3>
        <p>The solution sequence can be transformed into one involving only a subset of the variables. For each solution in the sequence, a new solution is formed using a specified selection of the
        variables using the SELECT query form.</p>
        <p>The following example shows a query to extract just the names of people described in an RDF graph using FOAF properties.</p>
        <div class="exampleGroup">
          <pre class="data">@prefix foaf:        &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a  foaf:name       "Alice" .
_:a  foaf:mbox       &lt;mailto:alice@work.example&gt; .

_:b  foaf:name       "Bob" .
_:b  foaf:mbox       &lt;mailto:bob@work.example&gt; .
</pre>
          <div class="queryGroup">
            <pre class="query">PREFIX foaf:       &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name
WHERE
 { ?x foaf:name ?name }
</pre>
            <div class="result">
              <table class="resultTable">
                <tbody>
                  <tr>
                    <th>name</th>
                  </tr>
                  <tr>
                    <td>"Bob"</td>
                  </tr>
                  <tr>
                    <td>"Alice"</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>
      </div>
      <div class="div2">
        <h3><a name="modDuplicates" id="modDuplicates"></a>15.3 Duplicate Solutions</h3>
        <p>A solution sequence with no <code>DISTINCT</code> or <code>REDUCED</code> query modifier will preserve duplicate solutions.</p>
        <div class="exampleGroup">
          <p>Data:</p>
          <pre class="data">@prefix  foaf:  &lt;http://xmlns.com/foaf/0.1/&gt; .

_:x    foaf:name   "Alice" .
_:x    foaf:mbox   &lt;mailto:alice@example.com&gt; .

_:y    foaf:name   "Alice" .
_:y    foaf:mbox   &lt;mailto:asmith@example.com&gt; .

_:z    foaf:name   "Alice" .
_:z    foaf:mbox   &lt;mailto:alice.smith@example.com&gt; .
</pre>
          <div class="queryGroup">
            <p>Query:</p>
            <pre class="query">PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name WHERE { ?x foaf:name ?name }
</pre>
            <div class="result">
              <p>Results:</p>
              <table class="resultTable">
                <tbody>
                  <tr>
                    <th>name</th>
                  </tr>
                  <tr>
                    <td>"Alice"</td>
                  </tr>
                  <tr>
                    <td>"Alice"</td>
                  </tr>
                  <tr>
                    <td>"Alice"</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
          <p>The modifiers <code>DISTINCT</code> and <code>REDUCED</code> affect whether duplicates are included in the query results.</p>
          <div class="div3">
            <h4><a name="modDistinct" id="modDistinct"></a>15.3.1 DISTINCT</h4>
            <p>The <code>DISTINCT</code> solution modifier eliminates duplicate solutions. Only one solution solution that binds the same variables to the same RDF terms is returned from the
            query.</p>
            <div class="queryGroup">
              <pre class="query">PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT DISTINCT ?name WHERE { ?x foaf:name ?name }
</pre>
              <div class="result">
                <table class="resultTable">
                  <tbody>
                    <tr>
                      <th>name</th>
                    </tr>
                    <tr>
                      <td>"Alice"</td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
            <p id="defunSELECT">Note that, per the <a href="#solutionModifiers">order of solution sequence modifiers</a>, duplicates are eliminated before either limit or offset is applied.</p>
          </div>
          <div class="div3">
            <h4><a name="modReduced" id="modReduced"></a>15.3.2 REDUCED</h4>
            <p>While the <code>DISTINCT</code> modifier ensures that duplicate solutions are eliminated from the solution set, <code>REDUCED</code> simply permits them to be eliminated. The
            cardinality of any set of variable bindings in a <code>REDUCED</code> solution set is at least one and not more than the cardinality of the solution set with no <code>DISTINCT</code> or
            <code>REDUCED</code> modifier. For example, using the data above, the query</p>
            <div class="queryGroup">
              <pre class="query">PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT REDUCED ?name WHERE { ?x foaf:name ?name }
</pre>
              <p>may have one, two (shown here) or three solutions:</p>
              <div class="result">
                <table class="resultTable">
                  <tbody>
                    <tr>
                      <th>name</th>
                    </tr>
                    <tr>
                      <td>"Alice"</td>
                    </tr>
                    <tr>
                      <td>"Alice"</td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="div2">
        <h3><a name="modOffset" id="modOffset"></a>15.4 OFFSET</h3>
        <p><code>OFFSET</code> causes the solutions generated to start after the specified number of solutions. An <code>OFFSET</code> of zero has no effect.</p>
        <p>Using <code>LIMIT</code> and <code>OFFSET</code> to select different subsets of the query solutions will not be useful unless the order is made predictable by using <code>ORDER
        BY</code>.</p>
        <div class="exampleGroup">
          <div class="queryGroup">
            <pre class="query">PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;

SELECT  ?name
WHERE   { ?x foaf:name ?name }
ORDER BY ?name
LIMIT   5
OFFSET  10</pre>
          </div>
        </div>
      </div>
      <div class="div2">
        <h3><a name="modResultLimit" id="modResultLimit"></a>15.5 LIMIT</h3>
        <p>The <code>LIMIT</code> clause puts an upper bound on the number of solutions returned. If the number of actual solutions, after <code>OFFSET</code> is applied, is greater than the limit,
        then at most the limit number of solutions will be returned.</p>
        <div class="exampleGroup">
          <div class="queryGroup">
            <pre class="query">PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;

SELECT ?name
WHERE { ?x foaf:name ?name }
LIMIT 20
</pre>
          </div>
        </div>
        <p>A <code>LIMIT</code> of 0 would cause no results to be returned. A limit may not be negative.</p>
      </div>
    </div>
    <div class="div1">
      <h2><a name="QueryForms" id="QueryForms"></a>16 Query Forms</h2>
      <p>SPARQL has four query forms. These query forms use the solutions from pattern matching to form result sets or RDF graphs. The query forms are:</p>
      <blockquote>
        <dl>
          <dt><a href="#select">SELECT</a></dt>
          <dd>Returns all, or a subset of, the variables bound in a query pattern match.</dd>
          <dt><a href="#construct">CONSTRUCT</a></dt>
          <dd>Returns an RDF graph constructed by substituting variables in a set of triple templates.</dd>
          <dt><a href="#ask">ASK</a></dt>
          <dd>Returns a boolean indicating whether a query pattern matches or not.</dd>
          <dt><a href="#describe">DESCRIBE</a></dt>
          <dd>Returns an RDF graph that describes the resources found.</dd>
        </dl>
      </blockquote>
      <p>Formats such as <a class="inform" href="http://www.w3.org/TR/sparql11-results-json/">SPARQL 1.1 Query Results JSON Format</a>, <a class="inform" href=
      "http://www.w3.org/TR/rdf-sparql-XMLres/">SPARQL Query Results XML Format</a> or <a class="inform" href="http://www.w3.org/TR/sparql11-results-csv-tsv/">SPARQL 1.1 Query Results CSV and TSV
      Formats</a> <a class="inform" href=""></a> <a class="inform" href=""></a> can be used to serialize the result set from a <code>SELECT</code> query or the boolean result of an <code>ASK</code>
      query.</p>
      <div class="div2">
        <h3><a name="select" id="select"></a>16.1 SELECT</h3>
        <p>The SELECT form of results returns variables and their bindings directly. It combines the operations of projecting the required variables with introducing new variable bindings into a
        query solution.</p>
        <div class="div3">
          <h4><a name="selectproject" id="selectproject"></a>16.1.1 Projection</h4>
          <p>Specific variables and their bindings are returned when a list of variable names is given in the SELECT clause. The syntax <code>SELECT *</code> is an abbreviation that selects all of
          the variables that are <a href="#variableScope">in-scope</a> at that point in the query. It excludes variables only used in <code>FILTER</code>, in the right-hand side of
          <code>MINUS</code>, and takes account of subqueries.</p>
          <p>Use of <code>SELECT *</code> is only permitted when the query does not have a <code>GROUP BY</code> clause.</p>
          <div class="exampleGroup">
            <pre class="data">@prefix  foaf:  &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a    foaf:name   "Alice" .
_:a    foaf:knows  _:b .
_:a    foaf:knows  _:c .

_:b    foaf:name   "Bob" .

_:c    foaf:name   "Clare" .
_:c    foaf:nick   "CT" .           </pre>
            <div class="queryGroup">
              <pre class="query">PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?nameX ?nameY ?nickY
WHERE
  { ?x foaf:knows ?y ;
       foaf:name ?nameX .
    ?y foaf:name ?nameY .
    OPTIONAL { ?y foaf:nick ?nickY }
  }</pre>
              <div class="result">
                <a name="table33" id="table33"></a>
                <table class="resultTable">
                  <tbody>
                    <tr>
                      <th>nameX</th>
                      <th>nameY</th>
                      <th>nickY</th>
                    </tr>
                    <tr>
                      <td>"Alice"</td>
                      <td>"Bob"</td>
                      <td></td>
                    </tr>
                    <tr>
                      <td>"Alice"</td>
                      <td>"Clare"</td>
                      <td>"CT"</td>
                    </tr>
                  </tbody>
                </table>
              </div>
              <p>Result sets can be accessed by a local API but also can be serialized into either JSON, XML, CSV or TSV.</p>
              <p><a class="inform" href="http://www.w3.org/TR/sparql11-results-json/">SPARQL 1.1 Query Results JSON Format</a>:</p>
              <div class="result">
                <pre class="resultSet">{
  "head": {
    "vars": [ "nameX" , "nameY" , "nickY" ]
  } ,
  "results": {
    "bindings": [
      {
        "nameX": { "type": "literal" , "value": "Alice" } ,
        "nameY": { "type": "literal" , "value": "Bob" }
      } ,
      {
        "nameX": { "type": "literal" , "value": "Alice" } ,
        "nameY": { "type": "literal" , "value": "Clare" } ,
        "nickY": { "type": "literal" , "value": "CT" }
      }
    ]
  }
}</pre>
              </div>
              <p><a class="inform" href="http://www.w3.org/TR/rdf-sparql-XMLres/">SPARQL Query Results XML Format</a>:</p>
              <div class="result">
                <pre class="resultSet">&lt;?xml version="1.0"?&gt;
&lt;sparql xmlns="http://www.w3.org/2005/sparql-results#"&gt;
  &lt;head&gt;
    &lt;variable name="nameX"/&gt;
    &lt;variable name="nameY"/&gt;
    &lt;variable name="nickY"/&gt;
  &lt;/head&gt;
  &lt;results&gt;
    &lt;result&gt;
      &lt;binding name="nameX"&gt;
        &lt;literal&gt;Alice&lt;/literal&gt;
      &lt;/binding&gt;
      &lt;binding name="nameY"&gt;
        &lt;literal&gt;Bob&lt;/literal&gt;
      &lt;/binding&gt;
   &lt;/result&gt;
    &lt;result&gt;
      &lt;binding name="nameX"&gt;
        &lt;literal&gt;Alice&lt;/literal&gt;
      &lt;/binding&gt;
      &lt;binding name="nameY"&gt;
        &lt;literal&gt;Clare&lt;/literal&gt;
      &lt;/binding&gt;
      &lt;binding name="nickY"&gt;
        &lt;literal&gt;CT&lt;/literal&gt;
      &lt;/binding&gt;
    &lt;/result&gt;
  &lt;/results&gt;
&lt;/sparql&gt;</pre>
              </div>
            </div>
          </div>
        </div>
        <div class="div3">
          <h4><a name="selectExpressions" id="selectExpressions"></a>16.1.2 SELECT Expressions</h4>
          <p>As well as choosing which variables from the pattern matching are included in the results, the SELECT clause can also introduce new variables. The rules of assignment in SELECT
          expression are the same as for assignment in BIND. The expression combines variable bindings already in the query solution, or defined earlier in the SELECT clause, to produce a binding in
          the query solution.</p>
          <p>The scoping for <code>(expr AS v)</code> applies immediately. In <code>SELECT</code> expressions, the variable may be used in an expression later in the same <code>SELECT</code> clause
          and may not be be assigned again in the same <code>SELECT</code> clause.</p>
          <p>Example:</p>
          <div class="exampleGroup">
            <p>Data:</p>
            <pre class="data">@prefix dc:   &lt;http://purl.org/dc/elements/1.1/&gt; .
@prefix :     &lt;http://example.org/book/&gt; .
@prefix ns:   &lt;http://example.org/ns#&gt; .

:book1  dc:title  "SPARQL Tutorial" .
:book1  ns:price  42 .
:book1  ns:discount 0.2 .

:book2  dc:title  "The Semantic Web" .
:book2  ns:price  23 .
:book2  ns:discount 0.25 .</pre>
            <p>Query:</p>
            <div class="queryGroup">
              <pre class="query">PREFIX  dc:  &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX  ns:  &lt;http://example.org/ns#&gt;
SELECT  ?title (?p*(1-?discount) AS ?price)
{ ?x ns:price ?p .
  ?x dc:title ?title . 
  ?x ns:discount ?discount 
}</pre>
              <p>Results:</p>
              <div class="result">
                <table class="resultTable">
                  <tbody>
                    <tr>
                      <th>title</th>
                      <th>price</th>
                    </tr>
                    <tr>
                      <td>"The Semantic Web"</td>
                      <td>17.25</td>
                    </tr>
                    <tr>
                      <td>"SPARQL Tutorial"</td>
                      <td>33.6</td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
          </div>
          <p>New variables can also be used in expressions if they are introduced earlier, syntactically, in the same SELECT clause:</p>
          <div class="exampleGroup">
            <div class="queryGroup">
              <pre class="query">PREFIX  dc:  &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX  ns:  &lt;http://example.org/ns#&gt;
SELECT  ?title (?p AS ?fullPrice) (?fullPrice*(1-?discount) AS ?customerPrice)
{ ?x ns:price ?p .
   ?x dc:title ?title . 
   ?x ns:discount ?discount 
}</pre>
              <p>Results:</p>
              <div class="result">
                <table class="resultTable">
                  <tbody>
                    <tr>
                      <th>title</th>
                      <th>fullPrice</th>
                      <th>customerPrice</th>
                    </tr>
                    <tr>
                      <td>"The Semantic Web"</td>
                      <td>23</td>
                      <td>17.25</td>
                    </tr>
                    <tr>
                      <td>"SPARQL Tutorial"</td>
                      <td>42</td>
                      <td>33.6</td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="div2">
        <h3><a name="construct" id="construct"></a>16.2 CONSTRUCT</h3>
        <p>The <code>CONSTRUCT</code> query form returns a single RDF graph specified by a graph template. The result is an RDF graph formed by taking each query solution in the solution sequence,
        substituting for the variables in the graph template, and combining the triples into a single RDF graph by set union.</p>
        <p>If any such instantiation produces a triple containing an unbound variable or an illegal RDF construct, such as a literal in subject or predicate position, then that triple is not included
        in the output RDF graph. The graph template can contain triples with no variables (known as ground or explicit triples), and these also appear in the output RDF graph returned by the
        CONSTRUCT query form.</p>
        <div class="exampleGroup">
          <pre class="data">@prefix  foaf:  &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a    foaf:name   "Alice" .
_:a    foaf:mbox   &lt;mailto:alice@example.org&gt; .
</pre>
          <div class="queryGroup">
            <pre class="query">PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX vcard:   &lt;http://www.w3.org/2001/vcard-rdf/3.0#&gt;
CONSTRUCT   { &lt;http://example.org/person#Alice&gt; vcard:FN ?name }
WHERE       { ?x foaf:name ?name }
</pre>
            <p>creates vcard properties from the FOAF information:</p>
            <div class="result">
              <pre class="resultGraph" style="text-align:left;">@prefix vcard: &lt;http://www.w3.org/2001/vcard-rdf/3.0#&gt; .

&lt;http://example.org/person#Alice&gt; vcard:FN "Alice" .
</pre>
            </div>
          </div>
        </div>
        <div class="div3">
          <h4><a name="templatesWithBNodes" id="templatesWithBNodes"></a>16.2.1 <a id="tempatesWithBNodes"></a>Templates with Blank Nodes</h4>
          <p>A template can create an RDF graph containing blank nodes. The blank node labels are scoped to the template for each solution. If the same label occurs twice in a template, then there
          will be one blank node created for each query solution, but there will be different blank nodes for triples generated by different query solutions.</p>
          <div class="exampleGroup">
            <pre class="data">@prefix  foaf:  &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a    foaf:givenname   "Alice" .
_:a    foaf:family_name "Hacker" .

_:b    foaf:firstname   "Bob" .
_:b    foaf:surname     "Hacker" .
</pre>
            <div class="queryGroup">
              <pre class="query">PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX vcard:   &lt;http://www.w3.org/2001/vcard-rdf/3.0#&gt;

CONSTRUCT { ?x  vcard:N _:v .
            _:v vcard:givenName ?gname .
            _:v vcard:familyName ?fname }
WHERE
 {
    { ?x foaf:firstname ?gname } UNION  { ?x foaf:givenname   ?gname } .
    { ?x foaf:surname   ?fname } UNION  { ?x foaf:family_name ?fname } .
 }
</pre>
              <p>creates vcard properties corresponding to the FOAF information:</p>
              <div class="result">
                <pre class="resultGraph" style="text-align:left;">@prefix vcard: &lt;http://www.w3.org/2001/vcard-rdf/3.0#&gt; .

_:v1 vcard:N         _:x .
_:x vcard:givenName  "Alice" .
_:x vcard:familyName "Hacker" .

_:v2 vcard:N         _:z .
_:z vcard:givenName  "Bob" .
_:z vcard:familyName "Hacker" .
</pre>
              </div>
            </div>
          </div>
          <p>The use of variable <code>x</code> in the template, which in this example will be bound to blank nodes with labels <code>_:a</code> and <code>_:b</code> in the data, causes different
          blank node labels (<code>_:v1</code> and <code>_:v2</code>) in the resulting RDF graph.</p>
        </div>
        <div class="div3">
          <h4><a name="accessingRdfGraphs" id="accessingRdfGraphs"></a>16.2.2 Accessing Graphs in the RDF Dataset</h4>
          <p>Using <code>CONSTRUCT</code>, it is possible to extract parts or the whole of graphs from the target RDF dataset. This first example returns the graph (if it is in the dataset) with IRI
          label <code>http://example.org/aGraph</code>; otherwise, it returns an empty graph.</p>
          <div class="exampleGroup">
            <div class="queryGroup">
              <pre class="query">CONSTRUCT { ?s ?p ?o } WHERE { GRAPH &lt;http://example.org/aGraph&gt; { ?s ?p ?o } . }
</pre>
            </div>
          </div>
          <p>The access to the graph can be conditional on other information. For example, if the default graph contains metadata about the named graphs in the dataset, then a query like the
          following one can extract one graph based on information about the named graph:</p>
          <div class="exampleGroup">
            <div class="queryGroup">
              <pre class="query">PREFIX  dc: &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX app: &lt;http://example.org/ns#&gt;
PREFIX xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt;

CONSTRUCT { ?s ?p ?o } WHERE
 {
   GRAPH ?g { ?s ?p ?o } .
   ?g dc:publisher &lt;http://www.w3.org/&gt; .
   ?g dc:date ?date .
   FILTER ( app:customDate(?date) &gt; "2005-02-28T00:00:00Z"^^xsd:dateTime ) .
 }
</pre>
            </div>
          </div>
          <p>where <code>app:customDate</code> identifies an <a href="#extensionFunctions">extension function</a> to turn the date format into an <code>xsd:dateTime</code> RDF term.</p>
        </div>
        <div class="div3">
          <h4><a name="SolModandCONSTRUCT" id="SolModandCONSTRUCT"></a>16.2.3 Solution Modifiers and CONSTRUCT</h4>
          <p>The solution modifiers of a query affect the results of a <code>CONSTRUCT</code> query. In this example, the output graph from the <code>CONSTRUCT</code> template is formed from just two
          of the solutions from graph pattern matching. The query outputs a graph with the names of the people with the top two sites, rated by hits. The triples in the RDF graph are not ordered.</p>
          <div class="exampleGroup">
            <pre class="data">@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .
@prefix site: &lt;http://example.org/stats#&gt; .

_:a foaf:name "Alice" .
_:a site:hits 2349 .

_:b foaf:name "Bob" .
_:b site:hits 105 .

_:c foaf:name "Eve" .
_:c site:hits 181 .
</pre>
            <div class="queryGroup">
              <pre class="query">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX site: &lt;http://example.org/stats#&gt;

CONSTRUCT { [] foaf:name ?name }
WHERE
{ [] foaf:name ?name ;
     site:hits ?hits .
}
ORDER BY desc(?hits)
LIMIT 2
</pre>
              <div class="result">
                <pre class="resultGraph">@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .
_:x foaf:name "Alice" .
_:y foaf:name "Eve" .
</pre>
              </div>
            </div>
          </div>
        </div>
        <div class="div3">
          <h4><a name="constructWhere" id="constructWhere"></a>16.2.4 CONSTRUCT WHERE</h4>
          <p>A short form for the CONSTRUCT query form is provided for the case where the template and the pattern are the same and the pattern is just a basic graph pattern (no <code>FILTER</code>s
          and no complex graph patterns are allowed in the short form). The keyword <code>WHERE</code> is required in the short form.</p>
          <p>The following two queries are the same; the first is a short form of the second.</p>
          <pre class="query">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
CONSTRUCT WHERE { ?x foaf:name ?name } 
</pre>
          <pre class="query">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;

CONSTRUCT { ?x foaf:name ?name } 
WHERE
{ ?x foaf:name ?name }
</pre>
        </div>
      </div>
      <div class="div2">
        <h3><a name="ask" id="ask"></a>16.3 ASK</h3>
        <p>Applications can use the <code>ASK</code> form to test whether or not a query pattern has a solution. No information is returned about the possible query solutions, just whether or not a
        solution exists.</p>
        <div class="exampleGroup">
          <pre class="data">@prefix foaf:       &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a  foaf:name       "Alice" .
_:a  foaf:homepage   &lt;http://work.example.org/alice/&gt; .

_:b  foaf:name       "Bob" .
_:b  foaf:mbox       &lt;mailto:bob@work.example&gt; .
</pre>
          <div class="queryGroup">
            <pre class="query">PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;
ASK  { ?x foaf:name  "Alice" }
</pre>
            <div class="result">
              <pre class="resultAsk">true</pre>
            </div>
            <p>The <a class="inform" href="http://www.w3.org/TR/rdf-sparql-XMLres/">SPARQL Query Results XML Format</a> form of this result set gives:</p>
            <div class="result">
              <pre class="resultSet">&lt;?xml version="1.0"?&gt;
&lt;sparql xmlns="http://www.w3.org/2005/sparql-results#"&gt;
  &lt;head&gt;&lt;/head&gt;
  &lt;boolean&gt;true&lt;/boolean&gt;
&lt;/sparql&gt;
</pre>
            </div>
          </div>
          <p>On the same data, the following returns no match because Alice's <code>mbox</code> is not mentioned.</p>
          <div class="queryGroup">
            <pre class="query">PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;
ASK  { ?x foaf:name  "Alice" ;
          foaf:mbox  &lt;mailto:alice@work.example&gt; }
</pre>
            <div class="result">
              <pre class="resultAsk">false</pre>
            </div>
          </div>
        </div>
      </div>
      <div class="div2">
        <h3><a name="describe" id="describe"></a>16.4 DESCRIBE (Informative)</h3>
        <p>The <code>DESCRIBE</code> form returns a single result RDF graph containing RDF data about resources. This data is not prescribed by a SPARQL query, where the query client would need to
        know the structure of the RDF in the data source, but, instead, is determined by the SPARQL query processor. The query pattern is used to create a result set. The <code>DESCRIBE</code> form
        takes each of the resources identified in a solution, together with any resources directly named by IRI, and assembles a single RDF graph by taking a "description" which can come from any
        information available including the target RDF Dataset. The description is determined by the query service. The syntax <code>DESCRIBE *</code> is an abbreviation that describes all of the
        variables in a query.</p>
        <div class="div3">
          <h4><a name="explicitIRIs" id="explicitIRIs"></a>16.4.1 Explicit IRIs</h4>
          <p>The <code>DESCRIBE</code> clause itself can take IRIs to identify the resources. The simplest <code>DESCRIBE</code> query is just an IRI in the <code>DESCRIBE</code> clause:</p>
          <div class="exampleGroup">
            <div class="queryGroup">
              <pre class="query">DESCRIBE &lt;http://example.org/&gt;
</pre>
            </div>
          </div>
        </div>
        <div class="div3">
          <h4><a name="identifyingResources" id="identifyingResources"></a>16.4.2 Identifying Resources</h4>
          <p>The resources to be described can also be taken from the bindings to a query variable in a result set. This enables description of resources whether they are identified by IRI or by
          blank node in the dataset:</p>
          <div class="exampleGroup">
            <div class="queryGroup">
              <pre class="query">PREFIX foaf:   &lt;http://xmlns.com/foaf/0.1/&gt;
DESCRIBE ?x
WHERE    { ?x foaf:mbox &lt;mailto:alice@org&gt; }
</pre>
            </div>
          </div>
          <p>The property <code>foaf:mbox</code> is defined as being an inverse functional property in the FOAF vocabulary. If treated as such, this query will return information about at most one
          person. If, however, the query pattern has multiple solutions, the RDF data for each is the union of all RDF graph descriptions.</p>
          <div class="exampleGroup">
            <div class="queryGroup">
              <pre class="query">PREFIX foaf:   &lt;http://xmlns.com/foaf/0.1/&gt;
DESCRIBE ?x
WHERE    { ?x foaf:name "Alice" }
</pre>
            </div>
          </div>
          <p>More than one IRI or variable can be given:</p>
          <div class="exampleGroup">
            <div class="queryGroup">
              <pre class="query">PREFIX foaf:   &lt;http://xmlns.com/foaf/0.1/&gt;
DESCRIBE ?x ?y &lt;http://example.org/&gt;
WHERE    {?x foaf:knows ?y}
</pre>
            </div>
          </div>
        </div>
        <div class="div3">
          <h4><a name="descriptionsOfResources" id="descriptionsOfResources"></a>16.4.3 Descriptions of Resources</h4>
          <p>The RDF returned is determined by the information publisher. It may be information the service deems relevant to the resources being described. It may include information about other
          resources: for example, the RDF data for a book may also include details about the author.</p>
          <p>A simple query such as</p>
          <div class="exampleGroup">
            <div class="queryGroup">
              <pre class="query">PREFIX ent:  &lt;http://org.example.com/employees#&gt;
DESCRIBE ?x WHERE { ?x ent:employeeId "1234" }
</pre>
              <p>might return a description of the employee and some other potentially useful details:</p>
              <div class="result">
                <pre class="resultGraph">@prefix foaf:   &lt;http://xmlns.com/foaf/0.1/&gt; .
@prefix vcard:  &lt;http://www.w3.org/2001/vcard-rdf/3.0&gt; .
@prefix exOrg:  &lt;http://org.example.com/employees#&gt; .
@prefix <code>rdf:    &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .
@prefix owl:    &lt;http://www.w3.org/2002/07/owl#&gt;</code>

_:a     exOrg:employeeId    "1234" ;
       
        <code>foaf:mbox_sha1sum   "bee135d3af1e418104bc42904596fe148e90f033" ;</code>
        vcard:N
         [ vcard:Family       "Smith" ;
           vcard:Given        "John"  ] .

<code>foaf:mbox_sha1sum  rdf:type  owl:InverseFunctionalProperty .</code>
</pre>
              </div>
            </div>
          </div>
          <p>which includes the blank node closure for the <a href="http://www.w3.org/TR/vcard-rdf" class="inform">vcard</a> vocabulary vcard:N. Other possible mechanisms for deciding what
          information to return include Concise Bounded Descriptions [<a href="#CBD">CBD</a>].</p>
          <p>For a vocabulary such as FOAF, where the resources are typically blank nodes, returning sufficient information to identify a node such as the InverseFunctionalProperty
          <code>foaf:mbox_sha1sum</code> as well as information like name and other details recorded would be appropriate. In the example, the match to the <code>WHERE</code> clause was returned, but
          this is not required.</p>
        </div>
      </div>
    </div>
    <div class="div1">
      <h2><a name="expressions" id="expressions"></a>17 Expressions and Testing Values</h2>
      <p>SPARQL <code>FILTERs</code> restrict the solutions of a graph pattern match according to a given <a href="#rConstraint">constraint</a>. Specifically, <code>FILTERs</code> eliminate any
      solutions that, when substituted into the expression, either result in an effective boolean value of <code>false</code> or produce an error. Effective boolean values are defined in section
      <a href="#ebv">17.2.2 <em>Effective Boolean Value</em></a> and errors are defined in XQuery 1.0: An XML Query Language [<a href="#XQUERY">XQUERY</a>] section <a class="norm" href=
      "http://www.w3.org/TR/2007/REC-xquery-20070123/#dt-type-error">2.3.1, <em>Kinds of Errors</em></a>. These errors have no effect outside of <code>FILTER</code> evaluation.</p>
      <div class="exampleGroup">
        <p>RDF literals may have a <a>datatype IRI</a>:</p>
        <pre class="data">@prefix a:          &lt;http://www.w3.org/2000/10/annotation-ns#&gt; .
@prefix dc:         &lt;http://purl.org/dc/elements/1.1/&gt; .

_:a   a:annotates   &lt;http://www.w3.org/TR/rdf-sparql-query/&gt; .
_:a   dc:date       "2004-12-31T19:00:00-05:00" .

_:b   a:annotates   &lt;http://www.w3.org/TR/rdf-sparql-query/&gt; .
_:b   dc:date       "2004-12-31T19:01:00-05:00"^^&lt;http://www.w3.org/2001/XMLSchema#dateTime&gt; .</pre>
        <p>The object of the first <code>dc:date</code> triple has no type information. The second has the datatype <code>xsd:dateTime</code>.</p>
        <p>SPARQL expressions are constructed according to the grammar and provide access to functions (named by IRI) and operator functions (invoked by keywords and symbols in the SPARQL grammar).
        SPARQL operators can be used to compare the values of typed literals:</p>
        <div class="queryGroup">
          <pre class="query">PREFIX a:      &lt;http://www.w3.org/2000/10/annotation-ns#&gt;
PREFIX dc:     &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX xsd:    &lt;http://www.w3.org/2001/XMLSchema#&gt;

SELECT ?annot
WHERE { ?annot  a:annotates  &lt;http://www.w3.org/TR/rdf-sparql-query/&gt; .
        ?annot  dc:date      ?date .
        FILTER ( ?date &gt; "2005-01-01T00:00:00Z"^^xsd:dateTime ) }</pre>
        </div>
      </div>
      <p>The SPARQL operators are listed in <a href="#OperatorMapping">section 17.3</a> and are associated with their productions in the grammar.</p>
      <p>In addition, SPARQL provides the ability to invoke arbitrary functions, including a subset of the XPath casting functions, listed in <a href="#FunctionMapping">section 17.5</a>. These
      functions are invoked by name (an IRI) within a SPARQL query. For example:</p>
      <pre class="query untested">... FILTER ( xsd:dateTime(?date) &lt; xsd:dateTime("2005-01-01T00:00:00Z") ) ...</pre>
      <p>Typographical convention in this section: XPath operators are labeled with the prefix <code>op:</code>. XPath operators have no namespace; <code>op:</code> is a labeling convention.</p>
      <div class="div2">
        <h3><a name="operandDataTypes" id="operandDataTypes"></a>17.1 Operand Data Types</h3>
        <p>SPARQL functions and operators operate on RDF terms and SPARQL variables. A subset of these functions and operators are taken from the <a class="norm" href=
        "http://www.w3.org/TR/xpath-functions/">XQuery 1.0 and XPath 2.0 Functions and Operators</a> [<a href="#FUNCOP">FUNCOP</a>] and have XML Schema <a href=
        "http://www.w3.org/TR/xpath20/#dt-typed-value">typed value</a> arguments and return types. RDF <code>typed literals</code> passed as arguments to these functions and operators are mapped to
        XML Schema typed values with a <a href="http://www.w3.org/TR/xpath20/#dt-string-value">string value</a> of the <code>lexical form</code> and an <a href=
        "http://www.w3.org/TR/xmlschema-2/#dt-atomic">atomic datatype</a> corresponding to the <span class="type datatypeIRI">datatype IRI</span>. The returned typed values are mapped back to RDF
        <code>typed literals</code> the same way.</p>
        <p>SPARQL has additional operators which operate on specific subsets of RDF terms. When referring to a type, the following terms denote a <code>typed literal</code> with the corresponding
        <a class="norm" href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/">XML Schema</a> [<a class="norm" href="#XSDT">XSDT</a>] <span class="type datatypeIRI">datatype IRI</span>:</p>
        <ul>
          <li><code><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-integer">xsd:integer</a></code></li>
          <li><code><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-decimal">xsd:decimal</a></code></li>
          <li><code><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-float">xsd:float</a></code></li>
          <li><code><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-double">xsd:double</a></code></li>
          <li><code><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-string">xsd:string</a></code></li>
          <li><code><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-boolean">xsd:boolean</a></code></li>
          <li><code><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-dateTime">xsd:dateTime</a></code></li>
        </ul>
        <p>The following terms identify additional types used in SPARQL value tests:</p>
        <ul>
          <li><span class="type numeric">numeric</span> denotes <code>typed literals</code> with datatypes <code>xsd:integer</code>, <code>xsd:decimal</code>, <code>xsd:float</code>, and
          <code>xsd:double</code>.</li>
          <li><span class="type simpleLiteral">simple literal</span> denotes a <code>plain literal</code> with no <code>language tag</code>.</li>
          <li><span class="type RDFterm">RDF term</span> denotes the types <code>IRI</code>, <code>literal</code>, and <code>blank node</code>.</li>
          <li><span class="type variable">variable</span> denotes a SPARQL variable.</li>
        </ul>
        <p>The following types are derived from <span class="type numeric">numeric</span> types and are valid arguments to functions and operators taking <span class="type numeric">numeric</span>
        arguments:</p>
        <ul>
          <li><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-nonPositiveInteger"><code>xsd:nonPositiveInteger</code></a></li>
          <li><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-negativeInteger"><code>xsd:negativeInteger</code></a></li>
          <li><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-long"><code>xsd:long</code></a></li>
          <li><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-int"><code>xsd:int</code></a></li>
          <li><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-short"><code>xsd:short</code></a></li>
          <li><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-byte"><code>xsd:byte</code></a></li>
          <li><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-nonNegativeInteger"><code>xsd:nonNegativeInteger</code></a></li>
          <li><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-unsignedLong"><code>xsd:unsignedLong</code></a></li>
          <li><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-unsignedInt"><code>xsd:unsignedInt</code></a></li>
          <li><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-unsignedShort"><code>xsd:unsignedShort</code></a></li>
          <li><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-unsignedByte"><code>xsd:unsignedByte</code></a></li>
          <li><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-positiveInteger"><code>xsd:positiveInteger</code></a></li>
        </ul>
        <p>SPARQL language extensions may treat additional types as being derived from XML schema datatypes.</p>
      </div>
      <div class="div2">
        <h3><a name="evaluation" id="evaluation"></a>17.2 Filter Evaluation</h3>
        <p>SPARQL provides a subset of the functions and operators defined by XQuery <a href="http://www.w3.org/TR/xquery/#mapping" class="norm">Operator Mapping</a>. XQuery 1.0 section <a href=
        "http://www.w3.org/TR/xquery/#id-expression-processing" class="norm">2.2.3 Expression Processing</a> describes the invocation of XPath functions. The following rules accommodate the
        differences in the data and execution models between XQuery and SPARQL:</p>
        <ul>
          <li>Unlike XPath/XQuery, SPARQL functions do not process node sequences. When interpreting the semantics of XPath functions, assume that each argument is a sequence of a single node.</li>
          <li>Functions invoked with an argument of the wrong type will produce a <a href="http://www.w3.org/TR/xquery/#dt-type-error" class="norm">type error</a>. Effective boolean value arguments
          (labeled "xsd:boolean (EBV)" in the operator mapping table below), are coerced to <code>xsd:boolean</code> using the <a href="#ebv">EBV rules</a> in section 17.2.2.</li>
          <li>Apart from <a href="#func-bound">BOUND</a>, <a href="#func-coalesce">COALESCE</a>, <a href="#func-filter-exists">NOT EXISTS</a> and <a href="#func-filter-exists">EXISTS</a>, all
          functions and operators operate on RDF Terms and will produce a type error if any arguments are unbound.</li>
          <li>Any expression other than <a href="#func-logical-or">logical-or</a> (<code>||</code>) or <a href="#func-logical-and">logical-and</a> (<code>&amp;&amp;</code>) that encounters an error
          will produce that error.</li>
          <li>A <a href="#func-logical-or">logical-or</a> that encounters an error on only one branch will return TRUE if the other branch is TRUE and an error if the other branch is FALSE.</li>
          <li>A <a href="#func-logical-and">logical-and</a> that encounters an error on only one branch will return an error if the other branch is TRUE and FALSE if the other branch is FALSE.</li>
          <li>A <a href="#func-logical-or">logical-or</a> or <a href="#func-logical-and">logical-and</a> that encounters errors on both branches will produce <em>either</em> of the errors.</li>
        </ul>
        <p>The logical-and and logical-or truth table for true (<span class="truth">T</span>), false (<span class="truth">F</span>), and error (<span class="truth error">E</span>) is as
        follows:</p><a name="truthTable" id="truthTable"></a>
        <table class="truthTable">
          <thead>
            <tr>
              <th>A</th>
              <th>B</th>
              <th>A || B</th>
              <th>A &amp;&amp; B</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <th>T</th>
              <th>T</th>
              <td>T</td>
              <td>T</td>
            </tr>
            <tr>
              <th>T</th>
              <th>F</th>
              <td>T</td>
              <td>F</td>
            </tr>
            <tr>
              <th>F</th>
              <th>T</th>
              <td>T</td>
              <td>F</td>
            </tr>
            <tr>
              <th>F</th>
              <th>F</th>
              <td>F</td>
              <td>F</td>
            </tr>
          </tbody>
          <tbody>
            <tr>
              <th>T</th>
              <th><span class="error">E</span></th>
              <td>T</td>
              <td><span class="error">E</span></td>
            </tr>
            <tr>
              <th><span class="error">E</span></th>
              <th>T</th>
              <td>T</td>
              <td><span class="error">E</span></td>
            </tr>
            <tr>
              <th>F</th>
              <th><span class="error">E</span></th>
              <td><span class="error">E</span></td>
              <td>F</td>
            </tr>
            <tr>
              <th><span class="error">E</span></th>
              <th>F</th>
              <td><span class="error">E</span></td>
              <td>F</td>
            </tr>
            <tr>
              <th><span class="error">E</span></th>
              <th><span class="error">E</span></th>
              <td><span class="error">E</span></td>
              <td><span class="error">E</span></td>
            </tr>
          </tbody>
        </table>
        <div class="div3">
          <h4><a name="invocation" id="invocation"></a>17.2.1 Invocation</h4>
          <p>SPARQL defines a syntax for invoking functions on a list of arguments. Unless otherwise noted, these are invoked as follows:</p>
          <ul>
            <li>Argument expressions are evaluated, producing argument values. The order of argument evaluation is not defined.</li>
            <li>Numeric arguments are promoted as necessary to fit the expected types for that function or operator.</li>
            <li>The function or operator is invoked on the argument values.</li>
          </ul>
          <p>If any of these steps fails, the invocation generates an error. The effects of errors are defined in <a href="#evaluation">Filter Evaluation</a>.</p>
          <p>There are also "<a href="#func-forms">functional forms</a>" which have different evaluation rules to functions as specified by each such form.</p>
        </div>
        <div class="div3">
          <h4><a name="ebv" id="ebv"></a>17.2.2 Effective Boolean Value (EBV)</h4>
          <p>Effective boolean value is used to calculate the arguments to the logical functions <a href="#func-logical-and">logical-and</a>, <a href="#func-logical-or">logical-or</a>, and <a class=
          "norm" href="http://www.w3.org/TR/xpath-functions/#func-not">fn:not</a>, as well as evaluate the result of a <code>FILTER</code> expression.</p>
          <p>The XQuery <a href="http://www.w3.org/TR/xquery/#id-ebv">Effective Boolean Value</a> rules rely on the definition of XPath's <a href=
          "http://www.w3.org/TR/xpath-functions/#func-boolean">fn:boolean</a>. The following rules reflect the rules for <code>fn:boolean</code> applied to the argument types present in SPARQL
          queries:</p>
          <ul>
            <li>The EBV of any literal whose type is <code>xsd:boolean</code> or <span class="type">numeric</span> is false if the lexical form is not valid for that datatype (e.g.
            "abc"^^xsd:integer).</li>
            <li>If the argument is a <span class="type typedLiteral">typed literal</span> with a <span class="type datatype">datatype</span> of <code>xsd:boolean</code>, and it has a valid lexical
            form, the EBV is the value of that argument.</li>
            <li>If the argument is a <span class="type plainLiteral">plain literal</span> or a <span class="type typedLiteral">typed literal</span> with a <span class="type datatype">datatype</span>
            of <code>xsd:string</code>, the EBV is false if the operand value has zero length; otherwise the EBV is true.</li>
            <li>If the argument is a <span class="type numeric">numeric</span> type or a <span class="type typedLiteral">typed literal</span> with a datatype derived from a <span class=
            "type numeric">numeric</span> type, and it has a valid lexical form, the EBV is false if the operand value is NaN or is numerically equal to zero; otherwise the EBV is true.</li>
            <li>All other arguments, including unbound arguments, produce a type error.</li>
          </ul>
          <p>An EBV of <code>true</code> is represented as a <span class="type typedLiteral">typed literal</span> with a datatype of <code>xsd:boolean</code> and a lexical value of "true"; an EBV of
          false is represented as a <span class="type typedLiteral">typed literal</span> with a datatype of <code>xsd:boolean</code> and a lexical value of "false".</p>
        </div>
      </div>
      <div class="div2">
        <h3><a name="OperatorMapping" id="OperatorMapping"></a>17.3 Operator Mapping</h3>
        <p>The SPARQL grammar identifies a set of operators (for instance, <span class="token">&amp;&amp;</span>, <span class="token">*</span>, <span class="token">isIRI</span>) used to construct
        constraints. The following table associates each of these grammatical productions with the appropriate operands and an operator function defined by either <a class="norm" href=
        "http://www.w3.org/TR/xpath-functions/">XQuery 1.0 and XPath 2.0 Functions and Operators</a> [<a href="#FUNCOP">FUNCOP</a>] or the SPARQL operators specified in <a href="#SparqlOps">section
        17.4</a>. When selecting the operator definition for a given set of parameters, the definition with the most specific parameters applies. For instance, when evaluating <code>xsd:integer =
        xsd:signedInt</code>, the definition for <code>=</code> with two <code>numeric</code> parameters applies, rather than the one with two <span class="type RDFterm">RDF terms</span>. The table
        is arranged so that the upper-most viable candidate is the most specific. Operators invoked without appropriate operands result in a type error.</p>
        <p>SPARQL follows XPath's scheme for numeric type promotions and subtype substitution for arguments to numeric operators. The <a href="http://www.w3.org/TR/xpath20/#mapping">XPath Operator
        Mapping</a> rules for <span class="type numeric">numeric</span> operands (<code>xsd:integer</code>, <code>xsd:decimal</code>, <code>xsd:float</code>, <code>xsd:double</code>, and types
        derived from a <span class="type numeric">numeric</span> type) apply to SPARQL operators as well (see <a class="norm" href="http://www.w3.org/TR/xpath20/">XML Path Language (XPath) 2.0</a>
        [<a href="#XPATH20">XPATH20</a>] for definitions of <a class="norm" href="http://www.w3.org/TR/xpath20/#promotion">numeric type promotions</a> and <a class="norm" href=
        "http://www.w3.org/TR/xpath20/#dt-subtype-substitution">subtype substitution</a>). Some of the operators are associated with nested function expressions, e.g. <code>fn:not(op:numeric-equal(A,
        B))</code>. Note that per the XPath definitions, <code>fn:not</code> and <code>op:numeric-equal</code> produce an error if their argument is an error.</p>
        <p>The collation for <code>fn:compare</code> is <a href="http://www.w3.org/TR/xpath-functions/#collations">defined by XPath</a> and identified by
        <code>http://www.w3.org/2005/xpath-functions/collation/codepoint</code>. This collation allows for string comparison based on code point values. Codepoint string equivalence can be tested
        with <span class="type RDFterm">RDF term</span> equivalence.</p>
        <table summary="SPARQL Unary Operators" class="FAndOTable">
          <caption>
            SPARQL Unary Operators
          </caption>
          <tbody>
            <tr>
              <th class="major" scope="col">Operator</th>
              <th class="major" scope="col">Type(A)</th>
              <th class="major" scope="col">Function</th>
              <th class="major" scope="col">Result type</th>
            </tr>
            <tr>
              <th colspan="4" class="subHeading" scope="col">XQuery Unary Operators</th>
            </tr>
            <tr>
              <th scope="row"><a href="#rUnaryExpression" title="UnaryExpression"><span class="FAOTtoken">!</span> A</a></th>
              <td>xsd:boolean <a href="#ebv-arg">(EBV)</a></td>
              <td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(A)</td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row"><a href="#rUnaryExpression" title="UnaryExpression"><span class="FAOTtoken">+</span> A</a></th>
              <td><span class="type numeric">numeric</span></td>
              <td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-numeric-unary-plus">op:numeric-unary-plus</a>(A)</td>
              <td><span class="type numeric">numeric</span></td>
            </tr>
            <tr>
              <th scope="row"><a href="#rUnaryExpression" title="UnaryExpression"><span class="FAOTtoken">-</span> A</a></th>
              <td><span class="type numeric">numeric</span></td>
              <td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-numeric-unary-minus">op:numeric-unary-minus</a>(A)</td>
              <td><span class="type numeric">numeric</span></td>
            </tr>
          </tbody>
        </table>
        <table summary="SPARQL Binary Operators" class="FAndOTable">
          <caption>
            SPARQL Binary Operators
          </caption>
          <tbody>
            <tr>
              <th class="major" scope="col">Operator</th>
              <th class="major" scope="col">Type(A)</th>
              <th class="major" scope="col">Type(B)</th>
              <th class="major" scope="col">Function</th>
              <th class="major" scope="col">Result type</th>
            </tr>
            <tr>
              <th colspan="5" class="subHeading" scope="col">Logical Connectives</th>
            </tr>
            <tr>
              <th><a href="#rConditionalOrExpression" title="ConditionalOrExpression">A <span class="FAOTtoken">||</span> B</a></th>
              <td>xsd:boolean <a href="#ebv-arg">(EBV)</a></td>
              <td>xsd:boolean <a href="#ebv-arg">(EBV)</a></td>
              <td class="sparqlOp"><a href="#func-logical-or" class="SPARQLoperator">logical-or</a>(A, B)</td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th><a href="#rConditionalAndExpression" title="ConditionalAndExpression">A <span class="FAOTtoken">&amp;&amp;</span> B</a></th>
              <td>xsd:boolean <a href="#ebv-arg">(EBV)</a></td>
              <td>xsd:boolean <a href="#ebv-arg">(EBV)</a></td>
              <td class="sparqlOp"><a href="#func-logical-and" class="SPARQLoperator">logical-and</a>(A, B)</td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th colspan="5" class="subHeading" scope="col">XPath Tests</th>
            </tr>
            <tr>
              <th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">=</span> B</a></th>
              <td><span class="type numeric">numeric</span></td>
              <td><span class="type numeric">numeric</span></td>
              <td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(A, B)</td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">=</span> B</a></th>
              <td><span class="type simpleLiteral">simple literal</span></td>
              <td><span class="type simpleLiteral">simple literal</span></td>
              <td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(<a class="norm" href=
              "http://www.w3.org/TR/xpath-functions/#func-compare">fn:compare</a>(A, B), 0)</td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">=</span> B</a></th>
              <td>xsd:string</td>
              <td>xsd:string</td>
              <td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(<a class="norm" href=
              "http://www.w3.org/TR/xpath-functions/#func-compare">fn:compare</a>(<a href="#func-str" class="FAOTtoken">STR</a>(A), <a href="#func-str" class="FAOTtoken">STR</a>(B)), 0)</td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">=</span> B</a></th>
              <td>xsd:boolean</td>
              <td>xsd:boolean</td>
              <td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-boolean-equal">op:boolean-equal</a>(A, B)</td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">=</span> B</a></th>
              <td>xsd:dateTime</td>
              <td>xsd:dateTime</td>
              <td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-dateTime-equal">op:dateTime-equal</a>(A, B)</td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">!=</span> B</a></th>
              <td><span class="type numeric">numeric</span></td>
              <td><span class="type numeric">numeric</span></td>
              <td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a class="norm" href=
              "http://www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(A, B))</td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">!=</span> B</a></th>
              <td><span class="type simpleLiteral">simple literal</span></td>
              <td><span class="type simpleLiteral">simple literal</span></td>
              <td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a class="norm" href=
              "http://www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(<a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-compare">fn:compare</a>(A, B), 0))</td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">!=</span> B</a></th>
              <td>xsd:string</td>
              <td>xsd:string</td>
              <td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a class="norm" href=
              "http://www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(<a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-compare">fn:compare</a>(<a href=
              "#func-str" class="FAOTtoken">STR</a>(A), <a href="#func-str" class="FAOTtoken">STR</a>(B)), 0))</td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">!=</span> B</a></th>
              <td>xsd:boolean</td>
              <td>xsd:boolean</td>
              <td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a class="norm" href=
              "http://www.w3.org/TR/xpath-functions/#func-boolean-equal">op:boolean-equal</a>(A, B))</td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">!=</span> B</a></th>
              <td>xsd:dateTime</td>
              <td>xsd:dateTime</td>
              <td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a class="norm" href=
              "http://www.w3.org/TR/xpath-functions/#func-dateTime-equal">op:dateTime-equal</a>(A, B))</td>
              <td>xsd:boolean</td>
            </tr>
            <tr id="op_lt">
              <th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&lt;</span> B</a></th>
              <td><span class="type numeric">numeric</span></td>
              <td><span class="type numeric">numeric</span></td>
              <td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-numeric-less-than">op:numeric-less-than</a>(A, B)</td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&lt;</span> B</a></th>
              <td><span class="type simpleLiteral">simple literal</span></td>
              <td><span class="type simpleLiteral">simple literal</span></td>
              <td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(<a class="norm" href=
              "http://www.w3.org/TR/xpath-functions/#func-compare">fn:compare</a>(A, B), -1)</td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&lt;</span> B</a></th>
              <td>xsd:string</td>
              <td>xsd:string</td>
              <td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(<a class="norm" href=
              "http://www.w3.org/TR/xpath-functions/#func-compare">fn:compare</a>(<a href="#func-str" class="FAOTtoken">STR</a>(A), <a href="#func-str" class="FAOTtoken">STR</a>(B)), -1)</td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&lt;</span> B</a></th>
              <td>xsd:boolean</td>
              <td>xsd:boolean</td>
              <td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-boolean-less-than">op:boolean-less-than</a>(A, B)</td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&lt;</span> B</a></th>
              <td>xsd:dateTime</td>
              <td>xsd:dateTime</td>
              <td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-dateTime-less-than">op:dateTime-less-than</a>(A, B)</td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&gt;</span> B</a></th>
              <td><span class="type numeric">numeric</span></td>
              <td><span class="type numeric">numeric</span></td>
              <td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-numeric-greater-than">op:numeric-greater-than</a>(A, B)</td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&gt;</span> B</a></th>
              <td><span class="type simpleLiteral">simple literal</span></td>
              <td><span class="type simpleLiteral">simple literal</span></td>
              <td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(<a class="norm" href=
              "http://www.w3.org/TR/xpath-functions/#func-compare">fn:compare</a>(A, B), 1)</td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&gt;</span> B</a></th>
              <td>xsd:string</td>
              <td>xsd:string</td>
              <td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(<a class="norm" href=
              "http://www.w3.org/TR/xpath-functions/#func-compare">fn:compare</a>(<a href="#func-str" class="FAOTtoken">STR</a>(A), <a href="#func-str" class="FAOTtoken">STR</a>(B)), 1)</td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&gt;</span> B</a></th>
              <td>xsd:boolean</td>
              <td>xsd:boolean</td>
              <td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-boolean-greater-than">op:boolean-greater-than</a>(A, B)</td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&gt;</span> B</a></th>
              <td>xsd:dateTime</td>
              <td>xsd:dateTime</td>
              <td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-dateTime-greater-than">op:dateTime-greater-than</a>(A, B)</td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&lt;=</span> B</a></th>
              <td><span class="type numeric">numeric</span></td>
              <td><span class="type numeric">numeric</span></td>
              <td class="xpathOp"><a href="#func-logical-or" class="SPARQLoperator">logical-or</a>(<a class="norm" href=
              "http://www.w3.org/TR/xpath-functions/#func-numeric-less-than">op:numeric-less-than</a>(A, B), <a class="norm" href=
              "http://www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(A, B))</td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&lt;=</span> B</a></th>
              <td><span class="type simpleLiteral">simple literal</span></td>
              <td><span class="type simpleLiteral">simple literal</span></td>
              <td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a class="norm" href=
              "http://www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(<a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-compare">fn:compare</a>(A, B), 1))</td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&lt;=</span> B</a></th>
              <td>xsd:string</td>
              <td>xsd:string</td>
              <td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a class="norm" href=
              "http://www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(<a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-compare">fn:compare</a>(<a href=
              "#func-str" class="FAOTtoken">STR</a>(A), <a href="#func-str" class="FAOTtoken">STR</a>(B)), 1))</td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&lt;=</span> B</a></th>
              <td>xsd:boolean</td>
              <td>xsd:boolean</td>
              <td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a class="norm" href=
              "http://www.w3.org/TR/xpath-functions/#func-boolean-greater-than">op:boolean-greater-than</a>(A, B))</td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&lt;=</span> B</a></th>
              <td>xsd:dateTime</td>
              <td>xsd:dateTime</td>
              <td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a class="norm" href=
              "http://www.w3.org/TR/xpath-functions/#func-dateTime-greater-than">op:dateTime-greater-than</a>(A, B))</td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&gt;=</span> B</a></th>
              <td><span class="type numeric">numeric</span></td>
              <td><span class="type numeric">numeric</span></td>
              <td class="xpathOp"><a href="#func-logical-or" class="SPARQLoperator">logical-or</a>(<a class="norm" href=
              "http://www.w3.org/TR/xpath-functions/#func-numeric-greater-than">op:numeric-greater-than</a>(A, B), <a class="norm" href=
              "http://www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(A, B))</td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&gt;=</span> B</a></th>
              <td><span class="type simpleLiteral">simple literal</span></td>
              <td><span class="type simpleLiteral">simple literal</span></td>
              <td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a class="norm" href=
              "http://www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(<a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-compare">fn:compare</a>(A, B), -1))</td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&gt;=</span> B</a></th>
              <td>xsd:string</td>
              <td>xsd:string</td>
              <td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a class="norm" href=
              "http://www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(<a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-compare">fn:compare</a>(<a href=
              "#func-str" class="FAOTtoken">STR</a>(A), <a href="#func-str" class="FAOTtoken">STR</a>(B)), -1))</td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&gt;=</span> B</a></th>
              <td>xsd:boolean</td>
              <td>xsd:boolean</td>
              <td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a class="norm" href=
              "http://www.w3.org/TR/xpath-functions/#func-boolean-less-than">op:boolean-less-than</a>(A, B))</td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&gt;=</span> B</a></th>
              <td>xsd:dateTime</td>
              <td>xsd:dateTime</td>
              <td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a class="norm" href=
              "http://www.w3.org/TR/xpath-functions/#func-dateTime-less-than">op:dateTime-less-than</a>(A, B))</td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th colspan="5" class="subHeading" scope="col">XPath Arithmetic</th>
            </tr>
            <tr>
              <th scope="row"><a href="#rMultiplicativeExpression" title="MultiplicativeExpression">A <span class="FAOTtoken">*</span> B</a></th>
              <td><span class="type numeric">numeric</span></td>
              <td><span class="type numeric">numeric</span></td>
              <td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-numeric-multiply">op:numeric-multiply</a>(A, B)</td>
              <td><span class="type numeric">numeric</span></td>
            </tr>
            <tr>
              <th scope="row"><a href="#rMultiplicativeExpression" title="MultiplicativeExpression">A <span class="FAOTtoken">/</span> B</a></th>
              <td><span class="type numeric">numeric</span></td>
              <td><span class="type numeric">numeric</span></td>
              <td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-numeric-divide">op:numeric-divide</a>(A, B)</td>
              <td><span class="type numeric">numeric</span>; but xsd:decimal if both operands are xsd:integer</td>
            </tr>
            <tr>
              <th scope="row"><a href="#rAdditiveExpression" title="AdditiveExpression">A <span class="FAOTtoken">+</span> B</a></th>
              <td><span class="type numeric">numeric</span></td>
              <td><span class="type numeric">numeric</span></td>
              <td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-numeric-add">op:numeric-add</a>(A, B)</td>
              <td><span class="type numeric">numeric</span></td>
            </tr>
            <tr>
              <th scope="row"><a href="#rAdditiveExpression" title="AdditiveExpression">A <span class="FAOTtoken">-</span> B</a></th>
              <td><span class="type numeric">numeric</span></td>
              <td><span class="type numeric">numeric</span></td>
              <td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-numeric-subtract">op:numeric-subtract</a>(A, B)</td>
              <td><span class="type numeric">numeric</span></td>
            </tr>
            <tr>
              <th colspan="5" class="subHeading" scope="col">SPARQL Tests</th>
            </tr>
            <tr>
              <th><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">=</span> B</a></th>
              <td><span class="type RDFterm">RDF term</span></td>
              <td><span class="type RDFterm">RDF term</span></td>
              <td class="xpathOp"><a href="#func-RDFterm-equal" class="SPARQLoperator">RDFterm-equal</a>(A, B)</td>
              <td>xsd:boolean</td>
            </tr>
            <tr>
              <th><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">!=</span> B</a></th>
              <td><span class="type RDFterm">RDF term</span></td>
              <td><span class="type RDFterm">RDF term</span></td>
              <td class="xpathOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a href="#func-RDFterm-equal" class="SPARQLoperator">RDFterm-equal</a>(A, B))</td>
              <td>xsd:boolean</td>
            </tr>
          </tbody>
        </table>
        <p><a id="ebv-arg" name="ebv-arg"></a>xsd:boolean function arguments marked with "(EBV)" are coerced to xsd:boolean by evaluating the <a href="#ebv">effective boolean value of that
        argument.</a></p>
        <div class="div3">
          <h4><a name="operatorExtensibility" id="operatorExtensibility"></a>17.3.1 Operator Extensibility</h4>
          <p>SPARQL language extensions may provide additional associations between operators and operator functions; this amounts to adding rows to the table above. No additional operator may yield
          a result that replaces any result other than a type error in the semantics defined above. The consequence of this rule is that SPARQL <code>FILTER</code>s will produce <em>at least</em> the
          same intermediate bindings after applying a <code>FILTER</code> as an unextended implementation.</p>
          <p>Additional mappings of the '&lt;' operator are expected to control the relative ordering of the operands, specifically, when used in an <a href="#modOrderBy"><code>ORDER BY</code></a>
          clause.</p>
        </div>
      </div>
      <div class="div2">
        <h3><a name="SparqlOps" id="SparqlOps"></a>17.4 Function Definitions</h3>
        <p>This section defines the operators and functions introduced by the SPARQL Query language. The examples show the behavior of the operators as invoked by the appropriate grammatical
        constructs.</p>
        <div class="div3">
          <h4><a name="func-forms" id="func-forms"></a>17.4.1 Functional Forms</h4>
          <div class="div4">
            <h5><a name="func-bound" id="func-bound"></a>17.4.1.1 bound</h5>
            <pre class="prototype"><span class="return">xsd:boolean</span>  <span class="operator">BOUND</span> (<span class="type">variable</span> <span class="name">var</span>)</pre>
            <p>Returns <code>true</code> if <code>var</code> is bound to a value. Returns false otherwise. Variables with the value NaN or INF are considered bound.</p>
            <div class="exampleGroup">
              <p>Data:</p>
              <pre class="data">@prefix foaf:        &lt;http://xmlns.com/foaf/0.1/&gt; .
@prefix dc:          &lt;http://purl.org/dc/elements/1.1/&gt; .
@prefix xsd:          &lt;http://www.w3.org/2001/XMLSchema#&gt; .

_:a  foaf:givenName  "Alice".

_:b  foaf:givenName  "Bob" .
_:b  dc:date         "2005-04-04T04:04:04Z"^^xsd:dateTime .</pre>
              <div class="queryGroup">
                <pre class="query">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX dc:   &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX xsd:   &lt;http://www.w3.org/2001/XMLSchema#&gt;
SELECT ?givenName
 WHERE { ?x foaf:givenName  ?givenName .
         OPTIONAL { ?x dc:date ?date } .
         FILTER ( bound(?date) ) }
</pre>
                <p>Query result:</p>
                <div class="result">
                  <table class="resultTable">
                    <tbody>
                      <tr>
                        <th>givenName</th>
                      </tr>
                      <tr>
                        <td>"Bob"</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
              <p>One may test that a graph pattern is <em>not</em> expressed by specifying an <a><span class="term">OPTIONAL</span></a> <a>graph pattern</a> that introduces a variable and testing to
              see that the variable is <a><span class="term">not</span></a> <a><span class="term">bound</span></a>. This is called <em>Negation as Failure</em> in logic programming.</p>
              <div class="queryGroup">
                <p>This query matches the people with a <code>name</code> but <em>no</em> expressed <code>date</code>:</p>
                <pre class="query">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX dc:   &lt;http://purl.org/dc/elements/1.1/&gt;
SELECT ?name
 WHERE { ?x foaf:givenName  ?name .
         OPTIONAL { ?x dc:date ?date } .
         FILTER (!bound(?date)) }</pre>
                <p>Query result:</p>
                <div class="result">
                  <table class="resultTable">
                    <tbody>
                      <tr>
                        <th>name</th>
                      </tr>
                      <tr>
                        <td>"Alice"</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
            <p>Because Bob's <code>dc:date</code> was known, <code>"Bob"</code> was not a solution to the query.</p>
          </div>
          <div class="div4">
            <h5><a name="func-if" id="func-if"></a>17.4.1.2 IF</h5>
            <pre class="prototype"><span class="return">rdfTerm</span>  <span class="operator">IF</span> (<span class="expression">expression1</span>, <span class=
            "expression">expression2</span>, <span class="expression">expression3</span>)</pre>
            <p>The <code>IF</code> function form evaluates the first argument, interprets it as a <a href="#ebv">effective boolean value</a>, then returns the value of <code>expression2</code> if the
            EBV is true, otherwise it returns the value of <code>expression3</code>. Only one of <code>expression2</code> and <code>expression3</code> is evaluated. If evaluating the first argument
            raises an error, then an error is raised for the evaluation of the <code>IF</code> expression.</p>
            <p>Examples: Suppose ?x = 2, ?z = 0 and ?y is not bound in some query solution:</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>IF(?x = 2, "yes", "no")</code></td>
                    <td>returns "yes"</td>
                  </tr>
                  <tr>
                    <td><code>IF(bound(?y), "yes", "no")</code></td>
                    <td>returns "no"</td>
                  </tr>
                  <tr>
                    <td><code>IF(?x=2, "yes", 1/?z)</code></td>
                    <td>returns "yes", the expression <code>1/?z</code> is not evaluated</td>
                  </tr>
                  <tr>
                    <td><code>IF(?x=1, "yes", 1/?z)</code></td>
                    <td>raises an error</td>
                  </tr>
                  <tr>
                    <td><code>IF("2" &gt; 1, "yes", "no")</code></td>
                    <td>raises an error</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
          <div class="div4">
            <h5><a name="func-coalesce" id="func-coalesce"></a>17.4.1.3 COALESCE</h5>
            <pre class="prototype"><span class="return">rdfTerm</span>  <span class="operator">COALESCE</span>(<span class="expression">expression, ....</span>)</pre>
            <p>The <code>COALESCE</code> function form returns the RDF term value of the first expression that evaluates without error. In SPARQL, evaluating an unbound variable raises an error.</p>
            <p>If none of the arguments evaluates to an RDF term, an error is raised. If no expressions are evaluated without error, an error is raised.</p>
            <p>Examples: Suppose ?x = 2 and ?y is not bound in some query solution:</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>COALESCE(?x, 1/0)</code></td>
                    <td>returns 2, the value of <code>x</code></td>
                  </tr>
                  <tr>
                    <td><code>COALESCE(1/0, ?x)</code></td>
                    <td>returns 2</td>
                  </tr>
                  <tr>
                    <td><code>COALESCE(5, ?x)</code></td>
                    <td>returns 5</td>
                  </tr>
                  <tr>
                    <td><code>COALESCE(?y, 3)</code></td>
                    <td>returns 3</td>
                  </tr>
                  <tr>
                    <td><code>COALESCE(?y)</code></td>
                    <td>raises an error because <code>y</code> is not bound.</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
          <div class="div4">
            <h5><a name="func-filter-exists" id="func-filter-exists"></a>17.4.1.4 NOT EXISTS and EXISTS</h5>
            <p>There is a filter operator <code>EXISTS</code> that takes a graph pattern. <code>EXISTS</code> returns <code>true</code>/<code>false</code> depending on whether the pattern matches the
            dataset given the bindings in the current group graph pattern, the dataset and the <a href="#defn_ActiveGraph">active graph</a> at this point in the query evaluation. No additional
            binding of variables occurs. The <code>NOT EXISTS</code> form translates into <code>fn:not(EXISTS{...})</code>.</p>
            <pre class="prototype"> <span class="return">xsd:boolean</span>  <span class="operator">NOT EXISTS</span> { <span class="pattern">pattern</span> }</pre>
            <p>Returns <code>false</code> if <code>pattern</code> matches. Returns true otherwise.</p>
            <p><code>NOT EXISTS { pattern }</code> is equivalent to <code>fn:not(EXISTS { pattern })</code>.</p>
            <pre class="prototype"> <span class="return">xsd:boolean</span>  <code>EXISTS</code> { <span class="pattern">pattern</span> }</pre>
            <p>Returns <code>true</code> if <code>pattern</code> matches. Returns false otherwise.</p>
            <p>Variables in the <code>pattern</code> that are bound in the current <a href="http://www.w3.org/TR/rdf-sparql-query/#defn_sparqlSolutionMapping">solution mapping</a> take the value that
            they have from the solution mapping. Variables in the pattern <code>pattern</code> that are not bound in the current solution mapping take part in pattern matching.</p>
            <p>To facilitate this, we introduce a function <a href="#defn_exists">Exists</a> that evaluates a SPARQL Algebra expression and returns true or false, depending on whether there are any
            solutions to the pattern, given the solution mapping being tested by the filter operation.</p>
          </div>
          <div class="div4">
            <h5><a name="func-logical-or" id="func-logical-or"></a>17.4.1.5 logical-or</h5>
            <pre class="prototype"> <span class="return">xsd:boolean</span>  <span class="type">xsd:boolean</span> <span class="name">left</span> <span class="operator">||</span> <span class=
            "type">xsd:boolean</span> <span class="name">right</span></pre>
            <p>Returns a logical <code>OR</code> of <code>left</code> and <code>right</code>. Note that <span class="SPARQLoperator">logical-or</span> operates on the <a href="#ebv">effective boolean
            value</a> of its arguments.</p>
            <p>Note: see section 17.2, <a href="#evaluation">Filter Evaluation</a>, for the <code>||</code> operator's treatment of errors.</p>
          </div>
          <div class="div4">
            <h5><a name="func-logical-and" id="func-logical-and"></a>17.4.1.6 logical-and</h5>
            <pre class="prototype"> <span class="return">xsd:boolean</span>  <span class="type">xsd:boolean</span> <span class="name">left</span> <span class="operator">&amp;&amp;</span> <span class=
            "type">xsd:boolean</span> <span class="name">right</span></pre>
            <p>Returns a logical <code>AND</code> of <code>left</code> and <code>right</code>. Note that <span class="SPARQLoperator">logical-and</span> operates on the <a href="#ebv">effective
            boolean value</a> of its arguments.</p>
            <p>Note: see section 17.2, <a href="#evaluation">Filter Evaluation</a>, for the <code>&amp;&amp;</code> operator's treatment of errors.</p>
          </div>
          <div class="div4">
            <h5><a name="func-RDFterm-equal" id="func-RDFterm-equal"></a>17.4.1.7 RDFterm-equal</h5>
            <pre class="prototype"> <span class="return">xsd:boolean</span>  <span class="type">RDF term</span> <span class="name">term1</span> <span class="operator">=</span> <span class=
            "type">RDF term</span> <span class="name">term2</span></pre>
            <p>Returns TRUE if <code>term1</code> and <code>term2</code> are the same RDF term as defined in <a class="norm" href="http://www.w3.org/TR/rdf-concepts/">Resource Description Framework
            (RDF): Concepts and Abstract Syntax</a> [<a href="#CONCEPTS">CONCEPTS</a>]; produces a type error if the arguments are both literal but are not the same RDF term <sup><a href=
            "#func-RDFterm-equal-foot1" class="footnote">*</a></sup>; returns FALSE otherwise. <code>term1</code> and <code>term2</code> are the same if any of the following is true:</p>
            <ul>
              <li><span class="name">term1</span> and <span class="name">term2</span> are equivalent <span class="IRI type">IRIs</span> as defined in <a href=
              "http://www.w3.org/TR/rdf-concepts/#section-Graph-URIref">6.4 RDF URI References</a> of [<a href="#CONCEPTS">CONCEPTS</a>].</li>
              <li><span class="name">term1</span> and <span class="name">term2</span> are equivalent <span class="literal type">literals</span> as defined in <a class="norm" href=
              "http://www.w3.org/TR/rdf-concepts/#section-Literal-Equality">6.5.1 Literal Equality</a> of [<a href="#CONCEPTS">CONCEPTS</a>].</li>
              <li><span class="name">term1</span> and <span class="name">term2</span> are the same <span class="bnode type">blank node</span> as described in <a class="norm" href=
              "http://www.w3.org/TR/rdf-concepts/#section-blank-nodes">6.6 Blank Nodes</a> of [<a href="#CONCEPTS">CONCEPTS</a>].</li>
            </ul>
            <div class="exampleGroup">
              <pre class="data">@prefix foaf:       &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a  foaf:name       "Alice".
_:a  foaf:mbox       &lt;mailto:alice@work.example&gt; .

_:b  foaf:name       "Ms A.".
_:b  foaf:mbox       &lt;mailto:alice@work.example&gt; .
              </pre>
              <div class="queryGroup">
                <p>This query finds the people who have multiple <code>foaf:name</code> triples:</p>
                <pre class="query">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name1 ?name2
WHERE { ?x foaf:name  ?name1 ;
        foaf:mbox  ?mbox1 .
        ?y foaf:name  ?name2 ;
        foaf:mbox  ?mbox2 .
        FILTER (?mbox1 = ?mbox2 &amp;&amp; ?name1 != ?name2)
      }</pre>
                <p>Query result:</p>
                <div class="result">
                  <table class="resultTable">
                    <tbody>
                      <tr>
                        <th>name1</th>
                        <th>name2</th>
                      </tr>
                      <tr>
                        <td>"Alice"</td>
                        <td>"Ms A."</td>
                      </tr>
                      <tr>
                        <td>"Ms A."</td>
                        <td>"Alice"</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
            <p>In this query for documents that were annotated at a specific date and time (New Year's Day 2005, measures in timezone +00:00), the RDF terms are not the same, but have equivalent
            values:</p>
            <div class="exampleGroup">
              <pre class="data">@prefix a:          &lt;http://www.w3.org/2000/10/annotation-ns#&gt; .
@prefix dc:         &lt;http://purl.org/dc/elements/1.1/&gt; .

_:b   a:annotates   &lt;http://www.w3.org/TR/rdf-sparql-query/&gt; .
_:b   dc:date       "2004-12-31T19:00:00-05:00"^^&lt;http://www.w3.org/2001/XMLSchema#dateTime&gt; .</pre>
              <div class="queryGroup">
                <pre class="query">PREFIX a:      &lt;http://www.w3.org/2000/10/annotation-ns#&gt;
PREFIX dc:     &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX xsd:    &lt;http://www.w3.org/2001/XMLSchema#&gt;

SELECT ?annotates
WHERE { ?annot  a:annotates  ?annotates .
        ?annot  dc:date      ?date .
        FILTER ( ?date = xsd:dateTime("2005-01-01T00:00:00Z") ) 
      }</pre>
                <div class="result">
                  <table class="resultTable">
                    <tbody>
                      <tr>
                        <th>annotates</th>
                      </tr>
                      <tr>
                        <td>&lt;http://www.w3.org/TR/rdf-sparql-query/&gt;</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
            <div id="func-RDFterm-equal-foot1" class="footnote">
              <p><sup>*</sup> Invoking RDFterm-equal on two typed literals tests for equivalent values. An extended implementation may have support for additional datatypes. An implementation
              processing a query that tests for equivalence on unsupported datatypes (and non-identical lexical form and datatype IRI) returns an error, indicating that it was unable to determine
              whether or not the values are equivalent. For example, an unextended implementation will produce an error when testing either <span class=
              "queryExcerpt untested"><code>"iiii"^^my:romanNumeral = "iv"^^my:romanNumeral</code></span> or <span class="queryExcerpt untested"><code>"iiii"^^my:romanNumeral !=
              "iv"^^my:romanNumeral</code></span>.</p>
            </div>
          </div>
          <div class="div4">
            <h5><a name="func-sameTerm" id="func-sameTerm"></a>17.4.1.8 sameTerm</h5>
            <pre class="prototype"> <span class="return">xsd:boolean</span>  <span class="operator">sameTerm</span> (<span class="type"><span class="type RDFterm">RDF term</span></span> <span class=
            "name">term1</span>, <span class="type"><span class="type RDFterm">RDF term</span></span> <span class="name">term2</span>)</pre>
            <p>Returns TRUE if <code>term1</code> and <code>term2</code> are the same RDF term as defined in <a class="norm" href="http://www.w3.org/TR/rdf-concepts/">Resource Description Framework
            (RDF): Concepts and Abstract Syntax</a> [<a href="#CONCEPTS">CONCEPTS</a>]; returns FALSE otherwise.</p>
            <div class="exampleGroup">
              <pre class="data">@prefix foaf:       &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a  foaf:name       "Alice".
_:a  foaf:mbox       &lt;mailto:alice@work.example&gt; .

_:b  foaf:name       "Ms A.".
_:b  foaf:mbox       &lt;mailto:alice@work.example&gt; .</pre>
              <div class="queryGroup">
                <p>This query finds the people who have multiple <code>foaf:name</code> triples:</p>
                <pre class="query">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name1 ?name2
WHERE { ?x foaf:name  ?name1 ;
        foaf:mbox  ?mbox1 .
         ?y foaf:name  ?name2 ;
         foaf:mbox  ?mbox2 .
         FILTER (sameTerm(?mbox1, ?mbox2) &amp;&amp; !sameTerm(?name1, ?name2))
      } </pre>
                <p>Query result:</p>
                <div class="result">
                  <table class="resultTable">
                    <tbody>
                      <tr>
                        <th>name1</th>
                        <th>name2</th>
                      </tr>
                      <tr>
                        <td>"Alice"</td>
                        <td>"Ms A."</td>
                      </tr>
                      <tr>
                        <td>"Ms A."</td>
                        <td>"Alice"</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
            <p>Unlike <span class="operator">RDFterm-equal</span>, <span class="operator">sameTerm</span> can be used to test for non-equivalent <span class="type typedLiteral">typed literals</span>
            with unsupported datatypes:</p>
            <div class="exampleGroup">
              <pre class="data">@prefix :          &lt;http://example.org/WMterms#&gt; .
@prefix t:         &lt;http://example.org/types#&gt; .

_:c1  :label        "Container 1" .
_:c1  :weight       "100"^^t:kilos .
_:c1  :displacement  "100"^^t:liters .

_:c2  :label        "Container 2" .
_:c2  :weight       "100"^^t:kilos .
_:c2  :displacement  "85"^^t:liters .

_:c3  :label        "Container 3" .
_:c3  :weight       "85"^^t:kilos .
_:c3  :displacement  "85"^^t:liters .</pre>
              <div class="queryGroup">
                <pre class="query">PREFIX  :      &lt;http://example.org/WMterms#&gt;
PREFIX  t:     &lt;http://example.org/types#&gt;

SELECT ?aLabel1 ?bLabel
WHERE { ?a  :label        ?aLabel .
        ?a  :weight       ?aWeight .
        ?a  :displacement ?aDisp .

        ?b  :label        ?bLabel .
        ?b  :weight       ?bWeight .
        ?b  :displacement ?bDisp .

        FILTER ( sameTerm(?aWeight, ?bWeight) &amp;&amp; !sameTerm(?aDisp, ?bDisp)) }</pre>
                <div class="result">
                  <table class="resultTable">
                    <tbody>
                      <tr>
                        <th>aLabel</th>
                        <th>bLabel</th>
                      </tr>
                      <tr>
                        <td>"Container 1"</td>
                        <td>"Container 2"</td>
                      </tr>
                      <tr>
                        <td>"Container 2"</td>
                        <td>"Container 1"</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
            <p>The test for boxes with the same weight may also be done with the '=' operator (<a href="#func-RDFterm-equal" class="SPARQLoperator">RDFterm-equal</a>) as the test for
            <code>"100"^^t:kilos = "85"^^t:kilos</code> will result in an error, eliminating that potential solution.</p>
          </div>
          <div class="div4">
            <h5><a name="func-in" id="func-in"></a>17.4.1.9 IN</h5>
            <pre class="prototype"><span class="return">boolean</span>  <code>rdfTerm</code> <span class="operator">IN</span> (<span class="expression">expression</span>, <span class=
            "expression">...</span>)</pre>
            <p>The <code>IN</code> operator tests whether the RDF term on the left-hand side is found in the values of list of expressions on the right-hand side. The test is done with "=" operator,
            which tests for the same value, as determined by the <a href="#OperatorMapping">operator mapping</a>.</p>
            <p>A list of zero terms on the right-hand side is legal.</p>
            <p>Errors in comparisons cause the <code>IN</code> expression to raise an error if the RDF term being tested is not found elsewhere in the list of terms.</p>
            <p>The <code>IN</code> operator is equivalent to the SPARQL expression:</p>
            <pre>(lhs = expression1) || (lhs = expression2) || ...</pre>
            <p>Examples:</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>2 IN (1, 2, 3)</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>2 IN ()</code></td>
                    <td>false</td>
                  </tr>
                  <tr>
                    <td><code>2 IN (&lt;http://example/iri&gt;, "str", 2.0)</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>2 IN (1/0, 2)</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>2 IN (2, 1/0)</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>2 IN (3, 1/0)</code></td>
                    <td>raises an error</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
          <div class="div4">
            <h5><a name="func-not-in" id="func-not-in"></a>17.4.1.10 NOT IN</h5>
            <pre class="prototype"><span class="return">boolean</span>  <code>rdfTerm</code> <span class="operator">NOT IN</span> (<span class="expression">expression</span>, <span class=
            "expression">...</span>)</pre>
            <p>The <code>NOT IN</code> operator tests whether the RDF term on the left-hand side is not found in the values of list of expressions on the right-hand side. The test is done with "!="
            operator, which tests for not the same value, as determined by the <a href="#OperatorMapping">operator mapping</a>.</p>
            <p>A list of zero terms on the right-hand side is legal.</p>
            <p>Errors in comparisons cause the <code>NOT IN</code> expression to raise an error if the RDF term being tested is not found to be in the list elsewhere in the list of terms.</p>
            <p>The <code>NOT IN</code> operator is equivalent to the SPARQL expression:</p>
            <pre>(lhs != expression1) &amp;&amp; (lhs != expression2) &amp;&amp; ...</pre>
            <p><code>NOT IN (...)</code> is equivalent to <code>!(IN (...))</code>.</p>
            <p>Examples:</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>2 NOT IN (1, 2, 3)</code></td>
                    <td>false</td>
                  </tr>
                  <tr>
                    <td><code>2 NOT IN ()</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>2 NOT IN (&lt;http://example/iri&gt;, "str", 2.0)</code></td>
                    <td>false</td>
                  </tr>
                  <tr>
                    <td><code>2 NOT IN (1/0, 2)</code></td>
                    <td>false</td>
                  </tr>
                  <tr>
                    <td><code>2 NOT IN (2, 1/0)</code></td>
                    <td>false</td>
                  </tr>
                  <tr>
                    <td><code>2 NOT IN (3, 1/0)</code></td>
                    <td>raises an error</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>
        <div class="div3">
          <h4><a name="func-rdfTerms" id="func-rdfTerms"></a>17.4.2 Functions on RDF Terms</h4>
          <div class="div4">
            <h5><a name="func-isIRI" id="func-isIRI"></a>17.4.2.1 isIRI</h5>
            <pre class="prototype"> <span class="return">xsd:boolean</span>  <span class="operator">isIRI</span> (<span class="type">RDF term</span> <span class="name">term</span>)
 <span class="return">xsd:boolean</span>  <span class="operator">isURI</span> (<span class="type">RDF term</span> <span class="name">term</span>)</pre>
            <p>Returns <code>true</code> if <code>term</code> is an <span class="type IRI">IRI</span>. Returns <code>false</code> otherwise. <span class="operator">isURI</span> is an alternate
            spelling for the <span class="operator">isIRI</span> operator.</p>
            <div class="exampleGroup">
              <pre class="data">@prefix foaf:       &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a  foaf:name       "Alice".
_:a  foaf:mbox       &lt;mailto:alice@work.example&gt; .

_:b  foaf:name       "Bob" .
_:b  foaf:mbox       "bob@work.example" .
              </pre>
              <div class="queryGroup">
                <p>This query matches the people with a <code>name</code> and an <code>mbox</code> which is an IRI:</p>
                <pre class="query">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name ?mbox
 WHERE { ?x foaf:name  ?name ;
            foaf:mbox  ?mbox .
         FILTER isIRI(?mbox) }</pre>
                <p>Query result:</p>
                <div class="result">
                  <table class="resultTable">
                    <tbody>
                      <tr>
                        <th>name</th>
                        <th>mbox</th>
                      </tr>
                      <tr>
                        <td>"Alice"</td>
                        <td>&lt;mailto:alice@work.example&gt;</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
          </div>
          <div class="div4">
            <h5><a name="func-isBlank" id="func-isBlank"></a>17.4.2.2 isBlank</h5>
            <pre class="prototype"> <span class="return">xsd:boolean</span>  <span class="operator">isBlank</span> (<span class="type"><span class="type">RDF term</span></span> <span class=
            "name">term</span>)</pre>
            <p>Returns <code>true</code> if <code>term</code> is a <span class="type bNode">blank node</span>. Returns <code>false</code> otherwise.</p>
            <div class="exampleGroup">
              <pre class="data">@prefix a:          &lt;http://www.w3.org/2000/10/annotation-ns#&gt; .
@prefix dc:         &lt;http://purl.org/dc/elements/1.1/&gt; .
@prefix foaf:       &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a   a:annotates   &lt;http://www.w3.org/TR/rdf-sparql-query/&gt; .
_:a   dc:creator    "Alice B. Toeclips" .

_:b   a:annotates   &lt;http://www.w3.org/TR/rdf-sparql-query/&gt; .
_:b   dc:creator    _:c .
_:c   foaf:given    "Bob".
_:c   foaf:family   "Smith".</pre>
              <div class="queryGroup">
                <p>This query matches the people with a <code>dc:creator</code> which uses predicates from the FOAF vocabulary to express the name.</p>
                <pre class="query">PREFIX a:      &lt;http://www.w3.org/2000/10/annotation-ns#&gt;
PREFIX dc:     &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX foaf:   &lt;http://xmlns.com/foaf/0.1/&gt;

SELECT ?given ?family
WHERE { ?annot  a:annotates  &lt;http://www.w3.org/TR/rdf-sparql-query/&gt; .
  ?annot  dc:creator   ?c .
  OPTIONAL { ?c  foaf:given   ?given ; foaf:family  ?family } .
  FILTER isBlank(?c)
}</pre>
                <p>Query result:</p>
                <div class="result">
                  <table class="resultTable">
                    <tbody>
                      <tr>
                        <th>given</th>
                        <th>family</th>
                      </tr>
                      <tr>
                        <td>"Bob"</td>
                        <td>"Smith"</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
            <p>In this example, there were two objects of <code>dc:creator</code> predicates, but only one (<code>_:c</code>) was a blank node.</p>
          </div>
          <div class="div4">
            <h5><a name="func-isLiteral" id="func-isLiteral"></a>17.4.2.3 isLiteral</h5>
            <pre class="prototype"> <span class="return">xsd:boolean</span>  <span class="operator">isLiteral</span> (<span class="type"><span class="type">RDF term</span></span> <span class=
            "name">term</span>)</pre>
            <p>Returns <code>true</code> if <code>term</code> is a <span class="type literal">literal</span>. Returns <code>false</code> otherwise.</p>
            <div class="exampleGroup">
              <pre class="data">@prefix foaf:       &lt;http://xmlns.com/foaf/0.1/&gt; .
              
_:a  foaf:name       "Alice".
_:a  foaf:mbox       &lt;mailto:alice@work.example&gt; .

_:b  foaf:name       "Bob" .
_:b  foaf:mbox       "bob@work.example" .</pre>
              <div class="queryGroup">
                <p>This query is similar to the one in <a href="#func-isIRI">17.4.2.1</a> except that is matches the people with a <code>name</code> and an <code>mbox</code> which is a literal. This
                could be used to look for erroneous data (<code>foaf:mbox</code> should only have an IRI as its object).</p>
                <pre class="query">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name ?mbox
WHERE { ?x foaf:name  ?name ;
        foaf:mbox  ?mbox .
        FILTER isLiteral(?mbox) }</pre>
                <p>Query result:</p>
                <div class="result">
                  <table class="resultTable">
                    <tbody>
                      <tr>
                        <th>name</th>
                        <th>mbox</th>
                      </tr>
                      <tr>
                        <td>"Bob"</td>
                        <td>"bob@work.example"</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
          </div>
          <div class="div4">
            <h5><a name="func-isNumeric" id="func-isNumeric"></a>17.4.2.4 isNumeric</h5>
            <pre class="prototype"> <span class="return">xsd:boolean</span>  <span class="operator">isNumeric</span> (<span class="type"><span class="type">RDF term</span></span> <span class=
            "name">term</span>)</pre>
            <p>Returns <code>true</code> if <code>term</code> is a numeric value. Returns <code>false</code> otherwise. <code>term</code> is numeric if it has an appropriate datatype (see the section
            <a href="#operandDataTypes">Operand Data Types</a>) and has a valid lexical form, making it a valid argument to functions and operators taking numeric arguments.</p>
            <p>Examples:</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>isNumeric(12)</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>isNumeric("12")</code></td>
                    <td>false</td>
                  </tr>
                  <tr>
                    <td><code>isNumeric("12"^^xsd:nonNegativeInteger)</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>isNumeric("1200"^^xsd:byte)</code></td>
                    <td>false</td>
                  </tr>
                  <tr>
                    <td><code>isNumeric(&lt;http://example/&gt;)</code></td>
                    <td>false</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
          <div class="div4">
            <h5><a name="func-str" id="func-str"></a>17.4.2.5 str</h5>
            <pre class="prototype"> <span class="return"><span class="type">simple literal</span></span>  <span class="operator">STR</span> (<span class="type"><span class=
            "type literal">literal</span></span> <span class="name">ltrl</span>)
 <span class="return"><span class="type">simple literal</span></span>  <span class="operator">STR</span> (<span class="type"><span class="type IRI">IRI</span></span> <span class="name">rsrc</span>)
</pre>
            <p>Returns the <span class="type lexicalForm">lexical form</span> of <code>ltrl</code> (a <span class="type literal">literal</span>); returns the codepoint representation of
            <code>rsrc</code> (an <span class="type IRI">IRI</span>). This is useful for examining parts of an IRI, for instance, the host-name.</p>
            <div class="exampleGroup">
              <pre class="data">@prefix foaf:       &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a  foaf:name       "Alice".
_:a  foaf:mbox       &lt;mailto:alice@work.example&gt; .

_:b  foaf:name       "Bob" .
_:b  foaf:mbox       &lt;mailto:bob@home.example&gt; .
</pre>
              <div class="queryGroup">
                <p>This query selects the set of people who use their <code>work.example</code> address in their foaf profile:</p>
                <pre class="query">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name ?mbox
 WHERE { ?x foaf:name  ?name ;
            foaf:mbox  ?mbox .
         FILTER regex(str(?mbox), "@work\\.example$") }
</pre>
                <p>Query result:</p>
                <div class="result">
                  <table class="resultTable">
                    <tbody>
                      <tr>
                        <th>name</th>
                        <th>mbox</th>
                      </tr>
                      <tr>
                        <td>"Alice"</td>
                        <td>&lt;mailto:alice@work.example&gt;</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
          </div>
          <div class="div4">
            <h5><a name="func-lang" id="func-lang"></a>17.4.2.6 lang</h5>
            <pre class="prototype"> <span class="return"><span class="type">simple literal</span></span>  <span class="operator">LANG</span> (<span class="type"><span class=
            "type literal">literal</span></span> <span class="name">ltrl</span>)
</pre>
            <p>Returns the <span class="type langTag">language tag</span> of <code>ltrl</code>, if it has one. It returns <code>""</code> if <code>ltrl</code> has no <span class=
            "type langTag">language tag</span>. Note that the RDF data model does not include literals with an empty <span class="type langTag">language tag</span>.</p>
            <div class="exampleGroup">
              <pre class="data">@prefix foaf:       &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a  foaf:name       "Robert"@en.
_:a  foaf:name       "Roberto"@es.
_:a  foaf:mbox       &lt;mailto:bob@work.example&gt; .
</pre>
              <div class="queryGroup">
                <p>This query finds the Spanish <code>foaf:name</code> and <code>foaf:mbox</code>:</p>
                <pre class="query">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name ?mbox
 WHERE { ?x foaf:name  ?name ;
            foaf:mbox  ?mbox .
         FILTER ( lang(?name) = "es" ) }</pre>
                <p>Query result:</p>
                <div class="result">
                  <table class="resultTable">
                    <tbody>
                      <tr>
                        <th>name</th>
                        <th>mbox</th>
                      </tr>
                      <tr>
                        <td>"Roberto"@es</td>
                        <td>&lt;mailto:bob@work.example&gt;</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
          </div>
          <div class="div4">
            <h5><a name="func-datatype" id="func-datatype"></a>17.4.2.7 datatype</h5>
            <pre class="prototype"> <span class="return"><span class="type IRI">iri</span></span>  <span class="operator">DATATYPE</span> (<span class="type"><span class=
            "type">literal</span></span> <span class="name">literal</span>)
</pre>
            <p>Returns the <span class="type datatypeIRI">datatype IRI</span> of a <code>literal</code>.</p>
            <ul>
              <li>If the literal is a typed literal, return the datatype IRI.</li>
              <li>If the literal is a simple literal, return <code>xsd:string</code></li>
              <li>If the literal is literal with a language tag, return <code>rdf:langString</code></li>
            </ul>
            <div class="exampleGroup">
              <pre class="data">@prefix foaf:       &lt;http://xmlns.com/foaf/0.1/&gt; .
@prefix eg:         &lt;http://biometrics.example/ns#&gt; .
@prefix xsd:        &lt;http://www.w3.org/2001/XMLSchema#&gt; .

_:a  foaf:name       "Alice".
_:a  eg:shoeSize     "9.5"^^xsd:float .

_:b  foaf:name       "Bob".
_:b  eg:shoeSize     "42"^^xsd:integer .
</pre>
              <div class="queryGroup">
                <p>This query finds the <code>foaf:name</code> and <code>foaf:shoeSize</code> of everyone with a shoeSize that is an integer:</p>
                <pre class="query">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX xsd:  &lt;http://www.w3.org/2001/XMLSchema#&gt;
PREFIX eg:   &lt;http://biometrics.example/ns#&gt;
SELECT ?name ?shoeSize
 WHERE { ?x foaf:name  ?name ; eg:shoeSize  ?shoeSize .
         FILTER ( datatype(?shoeSize) = xsd:integer ) }</pre>
                <p>Query result:</p>
                <div class="result">
                  <table class="resultTable">
                    <tbody>
                      <tr>
                        <th>name</th>
                        <th>shoeSize</th>
                      </tr>
                      <tr>
                        <td>"Bob"</td>
                        <td>42</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
            <div class="note">
              <p>In <a href="http://www.w3.org/TR/rdf-sparql-query/">SPARQL 1.0</a>, the <code>DATATYPE</code> function was not defined for literals with a language tag. Therefore, an unextended
              implementation would raise an error when <code>DATATYPE</code> was called with a literal with a language tag. <a href="#operatorExtensibility">Operator extensibility</a> allows
              implementations to return a result rather than raise an error. SPARQL 1.1 defines the result of <code>DATATYPE</code> applied to a literal with a language tag to be
              <code>rdf:langString</code>.</p>
            </div>
            <div class="wgNote">
              The SPARQL Working Group is using <code>rdf:langString</code> based on the latest Working Drafts of the RDF Working Group. This usage should be considered experimental (and
              non-normative) until/unless <code>rdf:langString</code> becomes part of an updated RDF Recommendation.
            </div>
          </div>
          <div class="div4">
            <h5><a name="func-iri" id="func-iri"></a>17.4.2.8 IRI</h5>
            <pre class="prototype"> <span class="return">iri</span>  <span class="operator">IRI</span>(<code>simple literal</code>)
 <span class="return">iri</span>  <span class="operator">IRI</span>(<span class="type">xsd:string</span>)
 <span class="return">iri</span>  <span class="operator">IRI</span>(<span class="type">iri</span>)
 <span class="return">iri</span>  <span class="operator">URI</span>(<code>simple literal</code>)
 <span class="return">iri</span>  <span class="operator">URI</span>(<span class="type">xsd:string</span>)
 <span class="return">iri</span>  <span class="operator">URI</span>(<span class="type">iri</span>)</pre>
            <p>The <code>IRI</code> function constructs an IRI by resolving the string argument (see <a href="http://www.ietf.org/rfc/rfc3986.txt">RFC 3986</a> and <a href=
            "http://www.ietf.org/rfc/rfc3987.txt">RFC 3987</a> or any later RFC that superceeds RFC 3986 or RFC 3987). The IRI is resolved against the base IRI of the query and must result in an
            absolute IRI.</p>
            <p>The <code>URI</code> function is a synonym for <a href="#func-iri"><code>IRI</code></a>.</p>
            <p>If the function is passed an IRI, it returns the IRI unchanged.</p>
            <p>Passing any RDF term other than a simple literal, xsd:string or an IRI is an error.</p>
            <p>An implementation <em class="rfc2119" title="Keyword in RFC 2119 context">MAY</em> normalize the IRI.</p>
            <p>Examples:</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>IRI("http://example/")</code></td>
                    <td>&lt;http://example/&gt;</td>
                  </tr>
                  <tr>
                    <td><code>IRI(&lt;http://example/&gt;)</code></td>
                    <td>&lt;http://example/&gt;</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
          <div class="div4">
            <h5><a name="func-bnode" id="func-bnode"></a>17.4.2.9 BNODE</h5>
            <pre class="prototype"><span class="return">blank node</span>  <span class="operator">BNODE</span>()</pre>
            <pre class="prototype"><span class="return">blank node</span>  <span class="operator">BNODE</span>(<span class="type">simple literal</span>)</pre>
            <pre class="prototype"><span class="return">blank node</span>  <span class="operator">BNODE</span>(<span class="type">xsd:string</span>)</pre>
            <p>The <code>BNODE</code> function constructs a blank node that is distinct from all blank nodes in the dataset being queried and distinct from all blank nodes created by calls to this
            constructor for other query solutions. If the no argument form is used, every call results in a distinct blank node. If the form with a simple literal is used, every call results in
            distinct blank nodes for different simple literals, and the same blank node for calls with the same simple literal within expressions for one <a href=
            "#defn_sparqlSolutionMapping">solution mapping</a>.</p>
            <p>This functionality is compatible with the <a href="#tempatesWithBNodes">treatment of blank nodes in SPARQL CONSTRUCT templates</a>.</p>
          </div>
          <div class="div4">
            <h5><a name="func-strdt" id="func-strdt"></a>17.4.2.10 STRDT</h5>
            <pre class="prototype"><span class="return">literal</span>  <span class="operator">STRDT</span>(<span class="type">simple literal</span> lexicalForm, <span class=
            "type">IRI</span> datatypeIRI)</pre>
            <p>The <code>STRDT</code> function constructs a literal with lexical form and type as specified by the arguments.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>STRDT("123", xsd:integer)</code></td>
                    <td>"123"^^&lt;http://www.w3.org/2001/XMLSchema#integer&gt;</td>
                  </tr>
                  <tr>
                    <td><code>STRDT("iiii", &lt;http://example/romanNumeral&gt;)</code></td>
                    <td>"iiii"^^&lt;http://example/romanNumeral&gt;</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
          <div class="div4">
            <h5><a name="func-strlang" id="func-strlang"></a>17.4.2.11 STRLANG</h5>
            <pre class="prototype"><span class="return">literal</span>  <span class="operator">STRLANG</span>(<span class="type">simple literal</span> lexicalForm, <span class=
            "type">simple literal</span> langTag)</pre>
            <p>The <code>STRLANG</code> function constructs a literal with lexical form and language tag as specified by the arguments.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>STRLANG("chat", "en")</code></td>
                    <td>"chat"@en</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
          <div class="div4">
            <h5><a name="func-uuid" id="func-uuid"></a>17.4.2.12 UUID</h5>
            <pre class="prototype"><span class="return">iri</span>  <span class="operator">UUID</span>()</pre>
            <p>Return a fresh IRI from the <a href="http://www.ietf.org/rfc/rfc4122.txt">UUID URN scheme</a>. Each call of <code>UUID()</code> returns a different UUID. It must not be the "nil" UUID
            (all zeroes). The variant and version of the UUID is implementation dependent.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>UUID()</code></td>
                    <td><code>&lt;urn:uuid:b9302fb5-642e-4d3b-af19-29a8f6d894c9&gt;</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
          <div class="div4">
            <h5><a name="func-struuid" id="func-struuid"></a>17.4.2.13 STRUUID</h5>
            <pre class="prototype"><span class="return">simple literal</span>  <span class="operator">STRUUID</span>()</pre>
            <p>Return a string that is the scheme specific part of UUID. That is, as a simple literal, the result of generating a UUID, converting to a simple literal and removing the initial
            <code>urn:uuid:</code>.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>STRUUID()</code></td>
                    <td><code>"73cd4307-8a99-4691-a608-b5bda64fb6c1"</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>
        <div class="div3">
          <h4><a name="func-strings" id="func-strings"></a>17.4.3 Functions on Strings</h4>
          <div class="div4">
            <h5><a name="idp1887976" id="idp1887976"></a>17.4.3.1 Strings in SPARQL Functions</h5>
            <div class="div5">
              <h6><a name="func-string" id="func-string"></a>17.4.3.1.1 String arguments</h6>
              <p>Certain functions (e.g. <a href="#func-regex">REGEX</a>, <a href="#func-strlen">STRLEN</a>, <a href="#func-contains">CONTAINS</a>) take a <code>string literal</code> as an argument
              and accept a simple literal, a plain literal with language tag, or a literal with datatype xsd:string. They then act on the lexcial form of the literal.</p>
              <p>The term <code>string literal</code> is used in the function descriptions for this. Use of any other RDF term will cause a call to the function to raise an error.</p>
            </div>
            <div class="div5">
              <h6><a name="func-arg-compatibility" id="func-arg-compatibility"></a>17.4.3.1.2 Argument Compatibility Rules</h6>
              <p>The functions <a href="#func-strstarts">STRSTARTS</a>, <a href="#func-strends">STRENDS</a>, <a href="#func-contains">CONTAINS</a>, <a href="#func-strbefore">STRBEFORE</a> and
              <a href="#func-strafter">STRAFTER</a> take two arguments. These arguments must be compatible otherwise invocation of one of these functions raises an error.</p>
              <p>Compatibility of two arguments is defined as:</p>
              <ul>
                <li>The arguments are simple literals or literals typed as xsd:string</li>
                <li>The arguments are plain literals with identical language tags</li>
                <li>The first argument is a plain literal with language tag and the second argument is a simple literal or literal typed as xsd:string</li>
              </ul>
              <div class="result">
                <table>
                  <tbody>
                    <tr>
                      <th>Argument1</th>
                      <th>Argument2</th>
                      <th>Compatible?</th>
                    </tr>
                    <tr>
                      <td>"abc"</td>
                      <td>"b"</td>
                      <td>yes</td>
                    </tr>
                    <tr>
                      <td>"abc"</td>
                      <td>"b"^^xsd:string</td>
                      <td>yes</td>
                    </tr>
                    <tr>
                      <td>"abc"^^xsd:string</td>
                      <td>"b"</td>
                      <td>yes</td>
                    </tr>
                    <tr>
                      <td>"abc"^^xsd:string</td>
                      <td>"b"^^xsd:string</td>
                      <td>yes</td>
                    </tr>
                    <tr>
                      <td>"abc"@en</td>
                      <td>"b"</td>
                      <td>yes</td>
                    </tr>
                    <tr>
                      <td>"abc"@en</td>
                      <td>"b"^^xsd:string</td>
                      <td>yes</td>
                    </tr>
                    <tr>
                      <td>"abc"@en</td>
                      <td>"b"@en</td>
                      <td>yes</td>
                    </tr>
                    <tr>
                      <td>"abc"@fr</td>
                      <td>"b"@ja</td>
                      <td>no</td>
                    </tr>
                    <tr>
                      <td>"abc"</td>
                      <td>"b"@ja</td>
                      <td>no</td>
                    </tr>
                    <tr>
                      <td>"abc"</td>
                      <td>"b"@en</td>
                      <td>no</td>
                    </tr>
                    <tr>
                      <td>"abc"^^xsd:string</td>
                      <td>"b"@en</td>
                      <td>no</td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
            <div class="div5">
              <h6><a name="idp1915512" id="idp1915512"></a>17.4.3.1.3 String Literal Return Type</h6>
              <p>Functions that return a string literal do so with the string literal of the same kind as the first argument (simple literal, plain literal with same language tag, xsd:string). This
              includes <a href="#func-substr">SUBSTR</a>, <a href="#func-strbefore">STRBEFORE</a> and <a href="#func-strafter">STRAFTER</a>.</p>
              <p>The function <a href="#func-concat">CONCAT</a> returns a string literal based on the details of all its arguments.</p>
            </div>
          </div>
          <div class="div4">
            <h5><a name="func-strlen" id="func-strlen"></a>17.4.3.2 STRLEN</h5>
            <pre class="prototype"><span class="return">xsd:integer</span>  <span class="operator">STRLEN</span>(<span class="type">string literal</span> str)</pre>
            <p>The <code>strlen</code> function corresponds to the XPath <a href="http://www.w3.org/TR/xpath-functions/#func-string-length">fn:string-length</a> function and returns an
            <code>xsd:integer</code> equal to the length in characters of the lexical form of the literal.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>strlen("chat")</code></td>
                    <td>4</td>
                  </tr>
                  <tr>
                    <td><code>strlen("chat"@en)</code></td>
                    <td>4</td>
                  </tr>
                  <tr>
                    <td><code>strlen("chat"^^xsd:string)</code></td>
                    <td>4</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
          <div class="div4">
            <h5><a name="func-substr" id="func-substr"></a>17.4.3.3 SUBSTR</h5>
            <pre class="prototype"><span class="return">string literal</span>  <span class="operator">SUBSTR</span>(<span class="type">string literal</span> source, <span class=
            "type">xsd:integer</span> startingLoc)</pre>
            <pre class="prototype"><span class="return">string literal</span>  <span class="operator">SUBSTR</span>(<span class="type">string literal</span> source, <span class=
            "type">xsd:integer</span> startingLoc, <span class="type">xsd:integer</span> length)</pre>
            <p>The <code>substr</code> function corresponds to the XPath <a href="http://www.w3.org/TR/xpath-functions/#func-substring">fn:substring</a> function and returns a literal of the same
            kind (simple literal, literal with language tag, <code>xsd:string</code> typed literal) as the <code>source</code> input parameter but with a lexical form formed from the substring of the
            lexcial form of the source.</p>
            <p>The arguments <code>startingLoc</code> and <code>length</code> may be derived types of xsd:integer.</p>
            <p>The index of the first character in a strings is 1.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>substr("foobar", 4)</code></td>
                    <td>"bar"</td>
                  </tr>
                  <tr>
                    <td><code>substr("foobar"@en, 4)</code></td>
                    <td>"bar"@en</td>
                  </tr>
                  <tr>
                    <td><code>substr("foobar"^^xsd:string, 4)</code></td>
                    <td>"bar"^^xsd:string</td>
                  </tr>
                  <tr>
                    <td><code>substr("foobar", 4, 1)</code></td>
                    <td>"b"</td>
                  </tr>
                  <tr>
                    <td><code>substr("foobar"@en, 4, 1)</code></td>
                    <td>"b"@en</td>
                  </tr>
                  <tr>
                    <td><code>substr("foobar"^^xsd:string, 4, 1)</code></td>
                    <td>"b"^^xsd:string</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
          <div class="div4">
            <h5><a name="func-ucase" id="func-ucase"></a>17.4.3.4 UCASE</h5>
            <pre class="prototype"><span class="return">string literal</span>  <span class="operator">UCASE</span>(<span class="type">string literal</span> str)</pre>
            <p>The <code>UCASE</code> function corresponds to the XPath <a href="http://www.w3.org/TR/xpath-functions/#func-upper-case">fn:upper-case</a> function. It returns a string literal whose
            lexical form is the upper case of the lexcial form of the argument.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>ucase("foo")</code></td>
                    <td>"FOO"</td>
                  </tr>
                  <tr>
                    <td><code>ucase("foo"@en)</code></td>
                    <td>"FOO"@en</td>
                  </tr>
                  <tr>
                    <td><code>ucase("foo"^^xsd:string)</code></td>
                    <td>"FOO"^^xsd:string</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
          <div class="div4">
            <h5><a name="func-lcase" id="func-lcase"></a>17.4.3.5 LCASE</h5>
            <pre class="prototype"><span class="return">string literal</span>  <span class="operator">LCASE</span>(<span class="type">string literal</span> str)</pre>
            <p>The <code>LCASE</code> function corresponds to the XPath <a href="http://www.w3.org/TR/xpath-functions/#func-lower-case">fn:lower-case</a> function. It returns a string literal whose
            lexical form is the lower case of the lexcial form of the argument.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>lcase("BAR")</code></td>
                    <td>"bar"</td>
                  </tr>
                  <tr>
                    <td><code>lcase("BAR"@en)</code></td>
                    <td>"bar"@en</td>
                  </tr>
                  <tr>
                    <td><code>lcase("BAR"^^xsd:string)</code></td>
                    <td>"bar"^^xsd:string</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
          <div class="div4">
            <h5><a name="func-strstarts" id="func-strstarts"></a>17.4.3.6 STRSTARTS</h5>
            <pre class="prototype"><span class="return">xsd:boolean</span>  <span class="operator">STRSTARTS</span>(<span class="type">string literal</span> arg1, <span class=
            "type">string literal</span> arg2)</pre>
            <p>The <code>STRSTARTS</code> function corresponds to the XPath <a href="http://www.w3.org/TR/xpath-functions/#func-starts-with">fn:starts-with</a> function. The arguments must be
            <a href="#func-arg-compatibility">argument compatible</a> otherwise an error is raised.</p>
            <p>For such input pairs, the function returns true if the lexical form of <code>arg1</code> starts with the lexical form of <code>arg2</code>, otherwise it returns false.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>strStarts("foobar", "foo")</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>strStarts("foobar"@en, "foo"@en)</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>strStarts("foobar"^^xsd:string, "foo"^^xsd:string)</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>strStarts("foobar"^^xsd:string, "foo")</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>strStarts("foobar", "foo"^^xsd:string)</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>strStarts("foobar"@en, "foo")</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>strStarts("foobar"@en, "foo"^^xsd:string)</code></td>
                    <td>true</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
          <div class="div4">
            <h5><a name="func-strends" id="func-strends"></a>17.4.3.7 STRENDS</h5>
            <pre class="prototype"><span class="return">xsd:boolean</span>  <span class="operator">STRENDS</span>(<span class="type">string literal</span> arg1, <span class=
            "type">string literal</span> arg2)</pre>
            <p>The <code>STRENDS</code> function corresponds to the XPath <a href="http://www.w3.org/TR/xpath-functions/#func-ends-with">fn:ends-with</a> function. The arguments must be <a href=
            "#func-arg-compatibility">argument compatible</a> otherwise an error is raised.</p>
            <p>For such input pairs, the function returns true if the lexical form of <code>arg1</code> ends with the lexical form of <code>arg2</code>, otherwise it returns false.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>strEnds("foobar", "bar")</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>strEnds("foobar"@en, "bar"@en)</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>strEnds("foobar"^^xsd:string, "bar"^^xsd:string)</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>strEnds("foobar"^^xsd:string, "bar")</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>strEnds("foobar", "bar"^^xsd:string)</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>strEnds("foobar"@en, "bar")</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>strEnds("foobar"@en, "bar"^^xsd:string)</code></td>
                    <td>true</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
          <div class="div4">
            <h5><a name="func-contains" id="func-contains"></a>17.4.3.8 CONTAINS</h5>
            <pre class="prototype"><span class="return">xsd:boolean</span>  <span class="operator">CONTAINS</span>(<span class="type">string literal</span> arg1, <span class=
            "type">string literal</span> arg2)</pre>
            <p>The <code>CONTAINS</code> function corresponds to the XPath <a href="http://www.w3.org/TR/xpath-functions/#func-contains">fn:contains</a>. The arguments must be <a href=
            "#func-arg-compatibility">argument compatible</a> otherwise an error is raised.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>contains("foobar", "bar")</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>contains("foobar"@en, "foo"@en)</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>contains("foobar"^^xsd:string, "bar"^^xsd:string)</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>contains("foobar"^^xsd:string, "foo")</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>contains("foobar", "bar"^^xsd:string)</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>contains("foobar"@en, "foo")</code></td>
                    <td>true</td>
                  </tr>
                  <tr>
                    <td><code>contains("foobar"@en, "bar"^^xsd:string)</code></td>
                    <td>true</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
          <div class="div4">
            <h5><a name="func-strbefore" id="func-strbefore"></a>17.4.3.9 STRBEFORE</h5>
            <pre class="prototype"><span class="return">literal</span>  <span class="operator">STRBEFORE</span>(<span class="type">string literal</span> arg1, <span class=
            "type">string literal</span> arg2)</pre>
            <p>The <code>STRBEFORE</code> function corresponds to the XPath <a href="http://www.w3.org/TR/xpath-functions/#func-substring-before">fn:substring-before</a> function. The arguments must
            be <a href="#func-arg-compatibility">argument compatible</a> otherwise an error is raised.</p>
            <p>For compatible arguments, if the lexical part of the second argument occurs as a substring of the lexical part of the first argument, the function returns a literal of the same kind as
            the first argument <code>arg1</code> (simple literal, plain literal same language tag, xsd:string). The lexical form of the result is the substring of the lexical form of
            <code>arg1</code> that precedes the first occurrence of the lexical form of <code>arg2</code>. If the lexical form of <code>arg2</code> is the empty string, this is considered to be a
            match and the lexical form of the result is the empty string.</p>
            <p>If there is no such occurrence, an empty simple literal is returned.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td>strbefore("abc","b")</td>
                    <td>"a"</td>
                  </tr>
                  <tr>
                    <td>strbefore("abc"@en,"bc")</td>
                    <td>"a"@en</td>
                  </tr>
                  <tr>
                    <td>strbefore("abc"@en,"b"@cy)</td>
                    <td>error</td>
                  </tr>
                  <tr>
                    <td>strbefore("abc"^^xsd:string,"")</td>
                    <td>""^^xsd:string</td>
                  </tr>
                  <tr>
                    <td>strbefore("abc","xyz")</td>
                    <td>""</td>
                  </tr>
                  <tr>
                    <td>strbefore("abc"@en, "z"@en)</td>
                    <td>""</td>
                  </tr>
                  <tr>
                    <td>strbefore("abc"@en, "z")</td>
                    <td>""</td>
                  </tr>
                  <tr>
                    <td>strbefore("abc"@en, ""@en)</td>
                    <td>""@en</td>
                  </tr>
                  <tr>
                    <td>strbefore("abc"@en, "")</td>
                    <td>""@en</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
          <div class="div4">
            <h5><a name="func-strafter" id="func-strafter"></a>17.4.3.10 STRAFTER</h5>
            <pre class="prototype"><span class="return">literal</span>  <span class="operator">STRAFTER</span>(<span class="type">string literal</span> arg1, <span class=
            "type">string literal</span> arg2)</pre>
            <p>The <code>STRAFTER</code> function corresponds to the XPath <a href="http://www.w3.org/TR/xpath-functions/#func-substring-after">fn:substring-after</a> function. The arguments must be
            <a href="#func-arg-compatibility">argument compatible</a> otherwise an error is raised.</p>
            <p>For compatible arguments, if the lexical part of the second argument occurs as a substring of the lexical part of the first argument, the function returns a literal of the same kind as
            the first argument <code>arg1</code> (simple literal, plain literal same language tag, xsd:string). The lexical form of the result is the substring of the lexcial form of
            <code>arg1</code> that follows the first occurrence of the lexical form of <code>arg2</code>. If the lexical form of <code>arg2</code> is the empty string, this is considered to be a
            match and the lexical form of the result is the lexical form of <code>arg1</code>.</p>
            <p>If there is no such occurrence, an empty simple literal is returned.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td>strafter("abc","b")</td>
                    <td>"c"</td>
                  </tr>
                  <tr>
                    <td>strafter("abc"@en,"ab")</td>
                    <td>"c"@en</td>
                  </tr>
                  <tr>
                    <td>strafter("abc"@en,"b"@cy)</td>
                    <td>error</td>
                  </tr>
                  <tr>
                    <td>strafter("abc"^^xsd:string,"")</td>
                    <td>"abc"^^xsd:string</td>
                  </tr>
                  <tr>
                    <td>strafter("abc","xyz")</td>
                    <td>""</td>
                  </tr>
                  <tr>
                    <td>strafter("abc"@en, "z"@en)</td>
                    <td>""</td>
                  </tr>
                  <tr>
                    <td>strafter("abc"@en, "z")</td>
                    <td>""</td>
                  </tr>
                  <tr>
                    <td>strafter("abc"@en, ""@en)</td>
                    <td>"abc"@en</td>
                  </tr>
                  <tr>
                    <td>strafter("abc"@en, "")</td>
                    <td>"abc"@en</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
          <div class="div4">
            <h5><a name="func-encode" id="func-encode"></a>17.4.3.11 ENCODE_FOR_URI</h5>
            <pre class="prototype"><span class="return">simple literal</span>  <span class="operator">ENCODE_FOR_URI</span>(<span class="type">string literal</span> ltrl)</pre>
            <p>The <code>ENCODE_FOR_URI</code> function corresponds to the XPath <a href="http://www.w3.org/TR/xpath-functions/#func-encode-for-uri">fn:encode-for-uri</a> function. It returns a
            simple literal with the lexical form obtained from the lexical form of its input after translating reserved characters according to the <a href=
            "http://www.w3.org/TR/xpath-functions/#func-encode-for-uri">fn:encode-for-uri</a> function.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>encode_for_uri("Los Angeles")</code></td>
                    <td><code>"Los%20Angeles"</code></td>
                  </tr>
                  <tr>
                    <td><code>encode_for_uri("Los Angeles"@en)</code></td>
                    <td><code>"Los%20Angeles"</code></td>
                  </tr>
                  <tr>
                    <td><code>encode_for_uri("Los Angeles"^^xsd:string)</code></td>
                    <td><code>"Los%20Angeles"</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
          <div class="div4">
            <h5><a name="func-concat" id="func-concat"></a>17.4.3.12 CONCAT</h5>
            <pre class="prototype"><span class="return">string literal</span>  <span class="operator">CONCAT</span>(<span class=
            "type">string literal</span> <span>ltrl<sub>1</sub></span> ... <span class="type">string literal</span> <span>ltrl<sub>n</sub></span>)</pre>
            <p>The <code>CONCAT</code> function corresponds to the XPath <a href="http://www.w3.org/TR/xpath-functions/#func-concat">fn:concat</a> function. The function accepts string literals as
            arguments.</p>
            <p>The lexical form of the returned literal is obtained by concatenating the lexical forms of its inputs. If all input literals are typed literals of type <code>xsd:string</code>, then
            the returned literal is also of type <code>xsd:string</code>, if all input literals are plain literals with identical language tag, then the returned literal is a plain literal with the
            same language tag, in all other cases, the returned literal is a simple literal.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>concat("foo", "bar")</code></td>
                    <td>"foobar"</td>
                  </tr>
                  <tr>
                    <td><code>concat("foo"@en, "bar"@en)</code></td>
                    <td>"foobar"@en</td>
                  </tr>
                  <tr>
                    <td><code>concat("foo"^^xsd:string, "bar"^^xsd:string)</code></td>
                    <td>"foobar"^^xsd:string</td>
                  </tr>
                  <tr>
                    <td><code>concat("foo", "bar"^^xsd:string)</code></td>
                    <td>"foobar"</td>
                  </tr>
                  <tr>
                    <td><code>concat("foo"@en, "bar")</code></td>
                    <td>"foobar"</td>
                  </tr>
                  <tr>
                    <td><code>concat("foo"@en, "bar"^^xsd:string)</code></td>
                    <td>"foobar"</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
          <div class="div4">
            <h5><a name="func-langMatches" id="func-langMatches"></a>17.4.3.13 langMatches</h5>
            <pre class="prototype"> <span class="return">xsd:boolean</span>  <span class="operator">langMatches</span> (<span class="type"><span class="type">simple literal</span></span> <span class=
            "name">language-tag</span>, <span class="type"><span class="type">simple literal</span></span> <span class="name">language-range</span>)
</pre>
            <p>Returns <code>true</code> if <code>language-tag</code> (first argument) matches <code>language-range</code> (second argument) per the basic filtering scheme defined in [<a href=
            "#rfc4647">RFC4647</a>] section 3.3.1. <code>language-range</code> is a basic language range per <a class="norm" href="http://www.ietf.org/rfc/rfc4647.txt">Matching of Language Tags</a>
            [<a href="#rfc4647">RFC4647</a>] section 2.1. A <code>language-range</code> of "*" matches any non-empty <code>language-tag</code> string.</p>
            <div class="exampleGroup">
              <pre class="data">@prefix dc:       &lt;http://purl.org/dc/elements/1.1/&gt; .

_:a  dc:title         "That Seventies Show"@en .
_:a  dc:title         "Cette Série des Années Soixante-dix"@fr .
_:a  dc:title         "Cette Série des Années Septante"@fr-BE .
_:b  dc:title         "Il Buono, il Bruto, il Cattivo" .
</pre>
              <div class="queryGroup">
                <p>This query uses <a href="#func-langMatches"><code>langMatches</code></a> and <a href="#func-lang"><code>lang</code></a> to find the French titles for the show known in English as
                "That Seventies Show":</p>
                <pre class="query">PREFIX dc: &lt;http://purl.org/dc/elements/1.1/&gt;
SELECT ?title
 WHERE { ?x dc:title  "That Seventies Show"@en ;
            dc:title  ?title .
         FILTER langMatches( lang(?title), "FR" ) }</pre>
                <p>Query result:</p>
                <div class="result">
                  <table class="resultTable">
                    <tbody>
                      <tr>
                        <th>title</th>
                      </tr>
                      <tr>
                        <td>"Cette Série des Années Soixante-dix"@fr</td>
                      </tr>
                      <tr>
                        <td>"Cette Série des Années Septante"@fr-BE</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
              <div class="queryGroup">
                <p>The idiom <code>langMatches( lang( ?v ), "*" )</code> will not match literals without a language tag as <code>lang( ?v )</code> will return an empty string, so</p>
                <pre class="query add">PREFIX dc: &lt;http://purl.org/dc/elements/1.1/&gt;
SELECT ?title
 WHERE { ?x dc:title  ?title .
         FILTER langMatches( lang(?title), "*" ) }</pre>
                <p>will report all of the titles with a language tag:</p>
                <div class="result add">
                  <table class="resultTable">
                    <tbody>
                      <tr>
                        <th>title</th>
                      </tr>
                      <tr>
                        <td>"That Seventies Show"@en</td>
                      </tr>
                      <tr>
                        <td>"Cette Série des Années Soixante-dix"@fr</td>
                      </tr>
                      <tr>
                        <td>"Cette Série des Années Septante"@fr-BE</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
          </div>
          <div class="div4">
            <h5><a name="func-regex" id="func-regex"></a>17.4.3.14 REGEX</h5>
            <pre class="prototype"> <span class="return">xsd:boolean</span>  <span class="operator">REGEX</span> (<span class="type"><span class="type">string literal</span></span> <span class=
            "name">text</span>, <span class="type"><span class="type">simple literal</span></span> <span class="name">pattern</span>)
 <span class="return">xsd:boolean</span>  <span class="operator">REGEX</span> (<span class="type"><span class="type">string literal</span></span> <span class="name">text</span>, <span class=
"type"><span class="type">simple literal</span></span> <span class="name">pattern</span>, <span class="type"><span class="type">simple literal</span></span> <span class="name">flags</span>)
</pre>
            <p>Invokes the XPath <a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-matches">fn:matches</a> function to match <code>text</code> against a regular expression
            <code>pattern</code>. The regular expression language is defined in XQuery 1.0 and XPath 2.0 Functions and Operators section <a class="norm" href=
            "http://www.w3.org/TR/xpath-functions/#regex-syntax">7.6.1 Regular Expression Syntax</a> [<a href="#FUNCOP">FUNCOP</a>].</p>
            <div class="exampleGroup">
              <pre class="data">@prefix foaf:       &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a  foaf:name       "Alice".
_:b  foaf:name       "Bob" .
</pre>
              <div class="queryGroup">
                <pre class="query">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name
 WHERE { ?x foaf:name  ?name
         FILTER regex(?name, "^ali", "i") }
</pre>
                <p>Query result:</p>
                <div class="result">
                  <table class="resultTable">
                    <tbody>
                      <tr>
                        <th>name</th>
                      </tr>
                      <tr>
                        <td>"Alice"</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
          </div>
          <div class="div4">
            <h5><a name="func-replace" id="func-replace"></a>17.4.3.15 REPLACE</h5>
            <pre class="prototype"> <span class="return"><span class="type">string literal</span></span>  <span class="operator">REPLACE</span> (<span class="type"><span class=
            "type">string literal</span></span> arg, <span class="type"><span class="type">simple literal</span></span> pattern, <span class="type"><span class=
            "type">simple literal</span></span> replacement )
 <span class="return"><span class="type">string literal</span></span>  <span class="operator">REPLACE</span> (<span class="type"><span class="type">string literal</span></span> arg, <span class=
"type"><span class="type">simple literal</span></span> pattern, <span class="type"><span class="type">simple literal</span></span> replacement,  <span class="type"><span class=
"type">simple literal</span></span> flags)</pre>
            <p>The <code>REPLACE</code> function corresponds to the XPath <a href="http://www.w3.org/TR/xpath-functions/#func-replace">fn:replace</a> function. It replaces each non-overlapping
            occurrence of the regular expression <tt>pattern</tt> with the replacement string. Regular expession matching may involve modifier flags. See <a href="#func-regex">REGEX</a>.</p>
            <div class="result">
              <table class="resultTable">
                <tbody>
                  <tr>
                    <td>replace("abcd", "b", "Z")</td>
                    <td>"aZcd"</td>
                  </tr>
                  <tr>
                    <td>replace("abab", "B", "Z","i")</td>
                    <td>"aZaZ"</td>
                  </tr>
                  <tr>
                    <td>replace("abab", "B.", "Z","i")</td>
                    <td>"aZb"</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>
        <div class="div3">
          <h4><a name="func-numerics" id="func-numerics"></a>17.4.4 Functions on Numerics</h4>
          <div class="div4">
            <h5><a name="func-abs" id="func-abs"></a>17.4.4.1 abs</h5>
            <pre class="prototype"> <span class="return">numeric</span>  <span class="operator">ABS</span> (<span class="type"><span class="type numeric">numeric</span></span> <span class=
            "name">term</span>)</pre>
            <p>Returns the absolute value of <code>arg</code>. An error is raised if <code>arg</code> is not a numeric value.</p>
            <p>This function is the same as <a href="http://www.w3.org/TR/xpath-functions/#func-abs">fn:numeric-abs</a> for terms with a datatype from <a href=
            "http://www.w3.org/TR/xpath-datamodel/">XDM</a>.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>abs(1)</code></td>
                    <td><code>1</code></td>
                  </tr>
                  <tr>
                    <td><code>abs(-1.5)</code></td>
                    <td><code>1.5</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
          <div class="div4">
            <h5><a name="func-round" id="func-round"></a>17.4.4.2 round</h5>
            <pre class="prototype"> <span class="return">numeric</span>  <span class="operator">ROUND</span> (<span class="type"><span class="type numeric">numeric</span></span> <span class=
            "name">term</span>)</pre>
            <p>Returns the number with no fractional part that is closest to the argument. If there are two such numbers, then the one that is closest to positive infinity is returned. An error is
            raised if <code>arg</code> is not a numeric value.</p>
            <p>This function is the same as <a href="http://www.w3.org/TR/xpath-functions/#func-round">fn:numeric-round</a> for terms with a datatype from <a href=
            "http://www.w3.org/TR/xpath-datamodel/">XDM</a>.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>round(2.4999)</code></td>
                    <td><code>2.0</code></td>
                  </tr>
                  <tr>
                    <td><code>round(2.5)</code></td>
                    <td><code>3.0</code></td>
                  </tr>
                  <tr>
                    <td><code>round(-2.5)</code></td>
                    <td><code>-2.0</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
          <div class="div4">
            <h5><a name="func-ceil" id="func-ceil"></a>17.4.4.3 ceil</h5>
            <pre class="prototype"> <span class="return">numeric</span>  <span class="operator">CEIL</span> (<span class="type"><span class="type numeric">numeric</span></span> <span class=
            "name">term</span>)</pre>
            <p>Returns the smallest (closest to negative infinity) number with no fractional part that is not less than the value of <code>arg</code>. An error is raised if <code>arg</code> is not a
            numeric value.</p>
            <p>This function is the same as <a href="http://www.w3.org/TR/xpath-functions/#func-ceiling">fn:numeric-ceil</a> for terms with a datatype from <a href=
            "http://www.w3.org/TR/xpath-datamodel/">XDM</a>.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>ceil(10.5)</code></td>
                    <td><code>11.0</code></td>
                  </tr>
                  <tr>
                    <td><code>ceil(-10.5)</code></td>
                    <td><code>-10.0</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
          <div class="div4">
            <h5><a name="func-floor" id="func-floor"></a>17.4.4.4 floor</h5>
            <pre class="prototype"> <span class="return">numeric</span>  <span class="operator">FLOOR</span> (<span class="type"><span class="type numeric">numeric</span></span> <span class=
            "name">term</span>)</pre>
            <p>Returns the largest (closest to positive infinity) number with no fractional part that is not greater than the value of <code>arg</code>. An error is raised if <code>arg</code> is not
            a numeric value.</p>
            <p>This function is the same as <a href="http://www.w3.org/TR/xpath-functions/#func-floor">fn:numeric-floor</a> for terms with a datatype from <a href=
            "http://www.w3.org/TR/xpath-datamodel/">XDM</a>.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>floor(10.5)</code></td>
                    <td><code>10.0</code></td>
                  </tr>
                  <tr>
                    <td><code>floor(-10.5)</code></td>
                    <td><code>-11.0</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
          <div class="div4">
            <h5><a name="idp2130040" id="idp2130040"></a>17.4.4.5 RAND</h5>
            <pre class="prototype"> <span class="return">xsd:double</span>  <span class="operator">RAND</span> ( )</pre>
            <p>Returns a pseudo-random number between 0 (inclusive) and 1.0e0 (exclusive). Different numbers can be produced every time this function is invoked. Numbers should be produced with
            approximately equal probability.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>rand()</code></td>
                    <td><code>"0.31221030831984886"^^xsd:double</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>
        <div class="div3">
          <h4><a name="func-date-time" id="func-date-time"></a>17.4.5 Functions on Dates and Times</h4>
          <div class="div4">
            <h5><a name="func-now" id="func-now"></a>17.4.5.1 now</h5>
            <pre class="prototype"> <span class="return">xsd:dateTime</span>  <span class="operator">NOW</span> ()</pre>
            <p>Returns an XSD dateTime value for the current query execution. All calls to this function in any one query execution must return the same value. The exact moment returned is not
            specified.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>now()</code></td>
                    <td><code>"2011-01-10T14:45:13.815-05:00"^^xsd:dateTime</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
          <div class="div4">
            <h5><a name="func-year" id="func-year"></a>17.4.5.2 year</h5>
            <pre class="prototype"> <span class="return">xsd:integer</span>  <span class="operator">YEAR</span> (<span class="type"><span class="type">xsd:dateTime</span></span> <span class=
            "parm">arg</span>)</pre>
            <p>Returns the year part of <code>arg</code> as an integer.</p>
            <p>This function corresponds to <a href="http://www.w3.org/TR/xpath-functions/#func-year-from-dateTime">fn:year-from-dateTime</a>.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>year("2011-01-10T14:45:13.815-05:00"^^xsd:dateTime)</code></td>
                    <td><code>2011</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
          <div class="div4">
            <h5><a name="func-month" id="func-month"></a>17.4.5.3 month</h5>
            <pre class="prototype"> <span class="return">xsd:integer</span>  <span class="operator">MONTH</span> (<span class="type"><span class="type">xsd:dateTime</span></span> <span class=
            "parm">arg</span>)</pre>
            <p>Returns the month part of <code>arg</code> as an integer.</p>
            <p>This function corresponds to <a href="http://www.w3.org/TR/xpath-functions/#func-month-from-dateTime">fn:month-from-dateTime</a>.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>month("2011-01-10T14:45:13.815-05:00"^^xsd:dateTime)</code></td>
                    <td><code>1</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
          <div class="div4">
            <h5><a name="func-day" id="func-day"></a>17.4.5.4 day</h5>
            <pre class="prototype"> <span class="return">xsd:integer</span>  <span class="operator">DAY</span> (<span class="type"><span class="type">xsd:dateTime</span></span> <span class=
            "parm">arg</span>)</pre>
            <p>Returns the day part of <code>arg</code> as an integer.</p>
            <p>This function corresponds to <a href="http://www.w3.org/TR/xpath-functions/#func-day-from-dateTime">fn:day-from-dateTime</a>.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>day("2011-01-10T14:45:13.815-05:00"^^xsd:dateTime)</code></td>
                    <td><code>10</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
          <div class="div4">
            <h5><a name="func-hours" id="func-hours"></a>17.4.5.5 hours</h5>
            <pre class="prototype"> <span class="return">xsd:integer</span>  <span class="operator">HOURS</span> (<span class="type"><span class="type">xsd:dateTime</span></span> <span class=
            "parm">arg</span>)</pre>
            <p>Returns the hours part of <code>arg</code> as an integer. The value is as given in the lexical form of the XSD dateTime.</p>
            <p>This function corresponds to <a href="http://www.w3.org/TR/xpath-functions/#func-hours-from-dateTime">fn:hours-from-dateTime</a>.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>hours("2011-01-10T14:45:13.815-05:00"^^xsd:dateTime)</code></td>
                    <td><code>14</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
          <div class="div4">
            <h5><a name="func-minutes" id="func-minutes"></a>17.4.5.6 minutes</h5>
            <pre class="prototype"> <span class="return">xsd:integer</span>  <span class="operator">MINUTES</span> (<span class="type"><span class="type">xsd:dateTime</span></span> <span class=
            "parm">arg</span>)</pre>
            <p>Returns the minutes part of the lexical form of <code>arg</code>. The value is as given in the lexical form of the XSD dateTime.</p>
            <p>This function corresponds to <a href="http://www.w3.org/TR/xpath-functions/#func-minutes-from-dateTime">fn:minutes-from-dateTime</a>.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>minutes("2011-01-10T14:45:13.815-05:00"^^xsd:dateTime)</code></td>
                    <td><code>45</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
          <div class="div4">
            <h5><a name="func-seconds" id="func-seconds"></a>17.4.5.7 seconds</h5>
            <pre class="prototype"> <span class="return">xsd:decimal</span>  <span class="operator">SECONDS</span> (<span class="type"><span class="type">xsd:dateTime</span></span> <span class=
            "parm">arg</span>)</pre>
            <p>Returns the seconds part of the lexical form of <code>arg</code>.</p>
            <p>This function corresponds to <a href="http://www.w3.org/TR/xpath-functions/#func-seconds-from-dateTime">fn:seconds-from-dateTime</a>.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>seconds("2011-01-10T14:45:13.815-05:00"^^xsd:dateTime)</code></td>
                    <td><code>13.815</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
          <div class="div4">
            <h5><a name="func-timezone" id="func-timezone"></a>17.4.5.8 timezone</h5>
            <pre class="prototype"> <span class="return">xsd:dayTimeDuration</span>  <span class="operator">TIMEZONE</span> (<span class="type"><span class=
            "type">xsd:dateTime</span></span> <span class="parm">arg</span>)</pre>
            <p>Returns the timezone part of <code>arg</code> as an xsd:dayTimeDuration. Raises an error if there is no timezone.</p>
            <p>This function corresponds to <a href="http://www.w3.org/TR/xpath-functions/#func-timezone-from-dateTime">fn:timezone-from-dateTime</a> except for the treatment of literals with no
            timezone.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>timezone("2011-01-10T14:45:13.815-05:00"^^xsd:dateTime)</code></td>
                    <td><code>"-PT5H"^^xsd:dayTimeDuration</code></td>
                  </tr>
                  <tr>
                    <td><code>timezone("2011-01-10T14:45:13.815Z"^^xsd:dateTime)</code></td>
                    <td><code>"PT0S"^^xsd:dayTimeDuration</code></td>
                  </tr>
                  <tr>
                    <td><code>timezone("2011-01-10T14:45:13.815"^^xsd:dateTime)</code></td>
                    <td>error</td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
          <div class="div4">
            <h5><a name="func-tz" id="func-tz"></a>17.4.5.9 tz</h5>
            <pre class="prototype"> <span class="return">simple literal</span>  <span class="operator">TZ</span> (<span class="type"><span class="type">xsd:dateTime</span></span> <span class=
            "parm">arg</span>)</pre>
            <p>Returns the timezone part of <code>arg</code> as a simple literal. Returns the empty string if there is no timezone.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>tz("2011-01-10T14:45:13.815-05:00"^^xsd:dateTime)</code></td>
                    <td><code>"-05:00"</code></td>
                  </tr>
                  <tr>
                    <td><code>tz("2011-01-10T14:45:13.815Z"^^xsd:dateTime)</code></td>
                    <td><code>"Z"</code></td>
                  </tr>
                  <tr>
                    <td><code>tz("2011-01-10T14:45:13.815"^^xsd:dateTime)</code></td>
                    <td><code>""</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>
        <div class="div3">
          <h4><a name="func-hash" id="func-hash"></a>17.4.6 Hash Functions</h4>
          <div class="div4">
            <h5><a name="func-md5" id="func-md5"></a>17.4.6.1 MD5</h5>
            <pre class="prototype"> <span class="return">simple literal</span>  <span class="operator">MD5</span> (<span class="type"><span class=
            "type simple literal">simple literal</span></span> <span class="name">arg</span>)</pre>
            <pre class="prototype"> <span class="return">simple literal</span>  <span class="operator">MD5</span> (<span class="type"><span class=
            "type simple literal">xsd:string</span></span> <span class="name">arg</span>)</pre>
            <p>Returns the MD5 checksum, as a hex digit string, calculated on the UTF-8 representation of the simple literal or lexical form of the <code>xsd:string</code>. Hex digits <em class=
            "rfc2119" title="Keyword in RFC 2119 context">SHOULD</em> be in lower case.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>MD5("abc")</code></td>
                    <td><code>"900150983cd24fb0d6963f7d28e17f72"</code></td>
                  </tr>
                  <tr>
                    <td><code>MD5("abc"^^xsd:string)</code></td>
                    <td><code>"900150983cd24fb0d6963f7d28e17f72"</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
          <div class="div4">
            <h5><a name="func-sha1" id="func-sha1"></a>17.4.6.2 SHA1</h5>
            <pre class="prototype"> <span class="return">simple literal</span>  <span class="operator">SHA1</span> (<span class="type"><span class=
            "type simple literal">simple literal</span></span> <span class="name">arg</span>)</pre>
            <pre class="prototype"> <span class="return">simple literal</span>  <span class="operator">SHA1</span> (<span class="type"><span class=
            "type simple literal">xsd:string</span></span> <span class="name">arg</span>)</pre>
            <p>Returns the SHA1 checksum, as a hex digit string, calculated on the UTF-8 representation of the simple literal or lexical form of the <code>xsd:string</code>. Hex digits <em class=
            "rfc2119" title="Keyword in RFC 2119 context">SHOULD</em> be in lower case.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>SHA1("abc")</code></td>
                    <td><code>"a9993e364706816aba3e25717850c26c9cd0d89d"</code></td>
                  </tr>
                  <tr>
                    <td><code>SHA1("abc"^^xsd:string)</code></td>
                    <td><code>"a9993e364706816aba3e25717850c26c9cd0d89d"</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
          <div class="div4">
            <h5><a name="func-sha256" id="func-sha256"></a>17.4.6.3 SHA256</h5>
            <pre class="prototype"> <span class="return">simple literal</span>  <span class="operator">SHA256</span> (<span class="type"><span class=
            "type simple literal">simple literal</span></span> <span class="name">arg</span>)</pre>
            <pre class="prototype"> <span class="return">simple literal</span>  <span class="operator">SHA256</span> (<span class="type"><span class=
            "type simple literal">xsd:string</span></span> <span class="name">arg</span>)</pre>
            <p>Returns the SHA256 checksum, as a hex digit string, calculated on the UTF-8 representation of the simple literal or lexical form of the <code>xsd:string</code>. Hex digits <em class=
            "rfc2119" title="Keyword in RFC 2119 context">SHOULD</em> be in lower case.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>SHA256("abc")</code></td>
                    <td><code>"ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad"</code></td>
                  </tr>
                  <tr>
                    <td><code>SHA256("abc"^^xsd:string)</code></td>
                    <td><code>"ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad"</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
          <div class="div4">
            <h5><a name="func-sha384" id="func-sha384"></a>17.4.6.4 SHA384</h5>
            <pre class="prototype"> <span class="return">simple literal</span>  <span class="operator">SHA384</span> (<span class="type"><span class=
            "type simple literal">simple literal</span></span> <span class="name">arg</span>)</pre>
            <pre class="prototype"> <span class="return">simple literal</span>  <span class="operator">SHA384</span> (<span class="type"><span class=
            "type simple literal">xsd:string</span></span> <span class="name">arg</span>)</pre>
            <p>Returns the SHA384 checksum, as a hex digit string, calculated on the UTF-8 representation of the simple literal or lexical form of the <code>xsd:string</code>. Hex digits <em class=
            "rfc2119" title="Keyword in RFC 2119 context">SHOULD</em> be in lower case.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>SHA384("abc")</code></td>
                    <td><code>"cb00753f45a35e8bb5a03d699ac65007272c32ab0eded1631a8b605a43ff5bed8086072ba1e7cc2358baeca134c825a7"</code></td>
                  </tr>
                  <tr>
                    <td><code>SHA384("abc"^^xsd:string)</code></td>
                    <td><code>"cb00753f45a35e8bb5a03d699ac65007272c32ab0eded1631a8b605a43ff5bed8086072ba1e7cc2358baeca134c825a7"</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
          <div class="div4">
            <h5><a name="func-sha512" id="func-sha512"></a>17.4.6.5 SHA512</h5>
            <pre class="prototype"> <span class="return">simple literal</span>  <span class="operator">SHA512</span> (<span class="type"><span class=
            "type simple literal">simple literal</span></span> <span class="name">arg</span>)</pre>
            <pre class="prototype"> <span class="return">simple literal</span>  <span class="operator">SHA512</span> (<span class="type"><span class=
            "type simple literal">xsd:string</span></span> <span class="name">arg</span>)</pre>
            <p>Returns the SHA512 checksum, as a hex digit string, calculated on the UTF-8 representation of the simple literal or lexical form of the <code>xsd:string</code>. Hex digits <em class=
            "rfc2119" title="Keyword in RFC 2119 context">SHOULD</em> be in lower case.</p>
            <div class="result">
              <table>
                <tbody>
                  <tr>
                    <td><code>SHA512("abc")</code></td>
                    <td><code>"ddaf35a193617abacc417349ae20413112e6fa4e89a97ea20a9eeee64b55d39a2192992a274fc1a836ba3c23a3feebbd454d4423643ce80e2a9ac94fa54ca49f"</code></td>
                  </tr>
                  <tr>
                    <td><code>SHA512("abc"^^xsd:string)</code></td>
                    <td><code>"ddaf35a193617abacc417349ae20413112e6fa4e89a97ea20a9eeee64b55d39a2192992a274fc1a836ba3c23a3feebbd454d4423643ce80e2a9ac94fa54ca49f"</code></td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>
      </div>
      <div class="div2">
        <h3><a name="FunctionMapping" id="FunctionMapping"></a>17.5 XPath Constructor Functions</h3>
        <p>SPARQL imports a subset of the XPath constructor functions defined in <a class="norm" href="http://www.w3.org/TR/xpath-functions/">XQuery 1.0 and XPath 2.0 Functions and Operators</a>
        [<a href="#FUNCOP">FUNCOP</a>] in section <a class="norm" href="http://www.w3.org/TR/xpath-functions/#casting-from-primitive-to-primitive">17.1 Casting from primitive types to primitive
        types</a>. SPARQL constructors include all of the XPath constructors for the <a href="#operandDataTypes">SPARQL operand datatypes</a> plus the <a href="#operandDataTypes">additional
        datatypes</a> imposed by the RDF data model. Casting in SPARQL is performed by calling a constructor function for the target type on an operand of the source type.</p>
        <p>XPath defines only the casts from one XML Schema datatype to another. The remaining casts are defined as follows:</p>
        <ul>
          <li>Casting an <span class="IRI type">IRI</span> to an <code>xsd:string</code> produces a <span class="IRI typedLiteral">typed literal</span> with a lexical value of the codepoints
          comprising the IRI, and a datatype of <code>xsd:string</code>.</li>
          <li>Casting a <span class="simpleLiteral type">simple literal</span> to any XML Schema datatype is defined as the product of casting an <code>xsd:string</code> with the <a href=
          "http://www.w3.org/TR/xpath20/#dt-string-value">string value</a> equal to the lexical value of the literal to the target datatype.</li>
        </ul>
        <p>The table below summarizes the casting operations that are always allowed (<span class="castY">Y</span>), never allowed (<span class="castN">N</span>) and dependent on the lexical value
        (<span class="castM">M</span>). For example, a casting operation from an <code>xsd:string</code> (the first row) to an <code>xsd:float</code> (the second column) is dependent on the lexical
        value (<span class="castM">M</span>).</p>
        <blockquote>
          <p>bool = <a class="norm" href="http://www.w3.org/TR/xmlschema-2/#boolean">xsd:boolean</a><br>
          dbl = <a class="norm" href="http://www.w3.org/TR/xmlschema-2/#double">xsd:double</a><br>
          flt = <a class="norm" href="http://www.w3.org/TR/xmlschema-2/#float">xsd:float</a><br>
          dec = <a class="norm" href="http://www.w3.org/TR/xmlschema-2/#decimal">xsd:decimal</a><br>
          int = <a class="norm" href="http://www.w3.org/TR/xmlschema-2/#integer">xsd:integer</a><br>
          dT = <a class="norm" href="http://www.w3.org/TR/xmlschema-2/#dateTime">xsd:dateTime</a><br>
          str = <a class="norm" href="http://www.w3.org/TR/xmlschema-2/#string">xsd:string</a><br>
          <span class="rdfDM">IRI</span> = <span class="type IRI">IRI</span><br>
          <span class="rdfDM">ltrl</span> = <code>simple literal</code></p>
        </blockquote>
        <table class="casting" summary="Casting table" cellpadding="1" border="1">
          <colgroup>
            <col width="13%" span="1">
            <col width="11%" span="1">
            <col width="11%" span="1">
            <col width="11%" span="1">
            <col width="11%" span="1">
            <col width="11%" span="1">
            <col width="11%" span="1">
            <col width="11%" span="1">
          </colgroup>
          <thead>
            <tr>
              <th><span class="cancast" title="From\To">From \ To</span></th>
              <th><span class="cancast" title="string">str</span></th>
              <th><span class="cancast" title="float">flt</span></th>
              <th><span class="cancast" title="double">dbl</span></th>
              <th><span class="cancast" title="decimal">dec</span></th>
              <th><span class="cancast" title="integer">int</span></th>
              <th><span class="cancast" title="dateTime">dT</span></th>
              <th><span class="cancast" title="boolean">bool</span></th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <th><span class="cancast" title="string">str</span></th>
              <td class="castY" valign="middle" align="center"><span class="cancast" title="Cast string to string? Yes">Y</span></td>
              <td class="castM" valign="middle" align="center"><span class="cancast" title="Cast string to float? Maybe">M</span></td>
              <td class="castM" valign="middle" align="center"><span class="cancast" title="Cast string to double? Maybe">M</span></td>
              <td class="castM" valign="middle" align="center"><span class="cancast" title="Cast string to decimal? Maybe">M</span></td>
              <td class="castM" valign="middle" align="center"><span class="cancast" title="Cast string to integer? Maybe">M</span></td>
              <td class="castM" valign="middle" align="center"><span class="cancast" title="Cast string to dateTime? Maybe">M</span></td>
              <td class="castM" valign="middle" align="center"><span class="cancast" title="Cast string to boolean? Maybe">M</span></td>
            </tr>
            <tr>
              <th><span class="cancast" title="float">flt</span></th>
              <td class="castY" valign="middle" align="center"><span class="cancast" title="Cast float to string? Yes">Y</span></td>
              <td class="castY" valign="middle" align="center"><span class="cancast" title="Cast float to float? Yes">Y</span></td>
              <td class="castY" valign="middle" align="center"><span class="cancast" title="Cast float to double? Yes">Y</span></td>
              <td class="castM" valign="middle" align="center"><span class="cancast" title="Cast float to decimal? Maybe">M</span></td>
              <td class="castM" valign="middle" align="center"><span class="cancast" title="Cast float to integer? Maybe">M</span></td>
              <td class="castN" valign="middle" align="center"><span class="cancast" title="Cast float to dateTime? No">N</span></td>
              <td class="castY" valign="middle" align="center"><span class="cancast" title="Cast float to boolean? Yes">Y</span></td>
            </tr>
            <tr>
              <th><span class="cancast" title="double">dbl</span></th>
              <td class="castY" valign="middle" align="center"><span class="cancast" title="Cast double to string? Yes">Y</span></td>
              <td class="castY" valign="middle" align="center"><span class="cancast" title="Cast double to float? Yes">Y</span></td>
              <td class="castY" valign="middle" align="center"><span class="cancast" title="Cast double to double? Yes">Y</span></td>
              <td class="castM" valign="middle" align="center"><span class="cancast" title="Cast double to decimal? Maybe">M</span></td>
              <td class="castM" valign="middle" align="center"><span class="cancast" title="Cast double to integer? Maybe">M</span></td>
              <td class="castN" valign="middle" align="center"><span class="cancast" title="Cast double to dateTime? No">N</span></td>
              <td class="castY" valign="middle" align="center"><span class="cancast" title="Cast double to boolean? Yes">Y</span></td>
            </tr>
            <tr>
              <th><span class="cancast" title="decimal">dec</span></th>
              <td class="castY" valign="middle" align="center"><span class="cancast" title="Cast decimal to string? Yes">Y</span></td>
              <td class="castY" valign="middle" align="center"><span class="cancast" title="Cast decimal to float? Yes">Y</span></td>
              <td class="castY" valign="middle" align="center"><span class="cancast" title="Cast decimal to double? Yes">Y</span></td>
              <td class="castY" valign="middle" align="center"><span class="cancast" title="Cast decimal to decimal? Yes">Y</span></td>
              <td class="castY" valign="middle" align="center"><span class="cancast" title="Cast decimal to integer? Yes">Y</span></td>
              <td class="castN" valign="middle" align="center"><span class="cancast" title="Cast decimal to dateTime? No">N</span></td>
              <td class="castY" valign="middle" align="center"><span class="cancast" title="Cast decimal to boolean? Yes">Y</span></td>
            </tr>
            <tr>
              <th><span class="cancast" title="integer">int</span></th>
              <td class="castY" valign="middle" align="center"><span class="cancast" title="Cast integer to string? Yes">Y</span></td>
              <td class="castY" valign="middle" align="center"><span class="cancast" title="Cast integer to float? Yes">Y</span></td>
              <td class="castY" valign="middle" align="center"><span class="cancast" title="Cast integer to double? Yes">Y</span></td>
              <td class="castY" valign="middle" align="center"><span class="cancast" title="Cast integer to decimal? Yes">Y</span></td>
              <td class="castY" valign="middle" align="center"><span class="cancast" title="Cast integer to integer? Yes">Y</span></td>
              <td class="castN" valign="middle" align="center"><span class="cancast" title="Cast integer to dateTime? No">N</span></td>
              <td class="castY" valign="middle" align="center"><span class="cancast" title="Cast integer to boolean? Yes">Y</span></td>
            </tr>
            <tr>
              <th><span class="cancast" title="dateTime">dT</span></th>
              <td class="castY" valign="middle" align="center"><span class="cancast" title="Cast dateTime to string? Yes">Y</span></td>
              <td class="castN" valign="middle" align="center"><span class="cancast" title="Cast dateTime to float? No">N</span></td>
              <td class="castN" valign="middle" align="center"><span class="cancast" title="Cast dateTime to double? No">N</span></td>
              <td class="castN" valign="middle" align="center"><span class="cancast" title="Cast dateTime to decimal? No">N</span></td>
              <td class="castN" valign="middle" align="center"><span class="cancast" title="Cast dateTime to integer? No">N</span></td>
              <td class="castY" valign="middle" align="center"><span class="cancast" title="Cast dateTime to dateTime? Yes">Y</span></td>
              <td class="castN" valign="middle" align="center"><span class="cancast" title="Cast dateTime to boolean? No">N</span></td>
            </tr>
            <tr>
              <th><span class="cancast" title="boolean">bool</span></th>
              <td class="castY" valign="middle" align="center"><span class="cancast" title="Cast boolean to string? Yes">Y</span></td>
              <td class="castY" valign="middle" align="center"><span class="cancast" title="Cast boolean to float? Yes">Y</span></td>
              <td class="castY" valign="middle" align="center"><span class="cancast" title="Cast boolean to double? Yes">Y</span></td>
              <td class="castY" valign="middle" align="center"><span class="cancast" title="Cast boolean to decimal? Yes">Y</span></td>
              <td class="castY" valign="middle" align="center"><span class="cancast" title="Cast boolean to integer? Yes">Y</span></td>
              <td class="castN" valign="middle" align="center"><span class="cancast" title="Cast boolean to dateTime? No">N</span></td>
              <td class="castY" valign="middle" align="center"><span class="cancast" title="Cast boolean to boolean? Yes">Y</span></td>
            </tr>
            <tr>
              <th><span class="cancast rdfDM" title="IRI">IRI</span></th>
              <td class="castY" valign="middle" align="center"><span class="cancast rdfDM" title="Cast IRI to string? Yes">Y</span></td>
              <td class="castN" valign="middle" align="center"><span class="cancast rdfDM" title="Cast IRI to float? No">N</span></td>
              <td class="castN" valign="middle" align="center"><span class="cancast rdfDM" title="Cast IRI to double? No">N</span></td>
              <td class="castN" valign="middle" align="center"><span class="cancast rdfDM" title="Cast IRI to decimal? No">N</span></td>
              <td class="castN" valign="middle" align="center"><span class="cancast rdfDM" title="Cast IRI to integer? No">N</span></td>
              <td class="castN" valign="middle" align="center"><span class="cancast rdfDM" title="Cast IRI to dateTime? No">N</span></td>
              <td class="castN" valign="middle" align="center"><span class="cancast rdfDM" title="Cast IRI to boolean? No">N</span></td>
            </tr>
            <tr>
              <th><span class="cancast rdfDM" title="Literal">ltrl</span></th>
              <td class="castY" valign="middle" align="center"><span class="cancast rdfDM" title="Cast Literal to string? Yes">Y</span></td>
              <td class="castM" valign="middle" align="center"><span class="cancast rdfDM" title="Cast Literal to float? No">M</span></td>
              <td class="castM" valign="middle" align="center"><span class="cancast rdfDM" title="Cast Literal to double? No">M</span></td>
              <td class="castM" valign="middle" align="center"><span class="cancast rdfDM" title="Cast Literal to decimal? No">M</span></td>
              <td class="castM" valign="middle" align="center"><span class="cancast rdfDM" title="Cast Literal to integer? No">M</span></td>
              <td class="castM" valign="middle" align="center"><span class="cancast rdfDM" title="Cast Literal to dateTime? No">M</span></td>
              <td class="castM" valign="middle" align="center"><span class="cancast rdfDM" title="Cast Literal to boolean? No">M</span></td>
            </tr>
          </tbody>
        </table>
      </div>
      <div class="div2">
        <h3><a name="extensionFunctions" id="extensionFunctions"></a>17.6 Extensible Value Testing</h3>
        <p>It should be noted that any function or operator that is specified to return an error under some conditions is a valid extension point. That is, an implementation may return a non-error
        value in these error cases, and still be conformant with this recommendation.</p>
        <p>A <a href="#rPrimaryExpression">PrimaryExpression</a> grammar rule can be a call to an extension function named by an IRI. An extension function takes some number of RDF terms as arguments
        and returns an RDF term. The semantics of these functions are identified by the IRI that identifies the function.</p>
        <p>SPARQL queries using extension functions are likely to have limited interoperability.</p>
        <p>As an example, consider a function called <code>func:even</code>:</p>
        <pre class="prototype"> <code>xsd:boolean</code>   <code>func:even</code> (<code><span class="type numeric">numeric</span></code> <code>value</code>)
</pre>
        <div class="exampleGroup">
          <div class="queryGroup">
            <p>This function would be invoked in a FILTER as such:</p>
            <pre class="query">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX func: &lt;http://example.org/functions#&gt;
SELECT ?name ?id
WHERE { ?x foaf:name  ?name ;
           func:empId   ?id .
        FILTER (func:even(?id)) }</pre>
          </div>
        </div>
        <p>For a second example, consider a function <code>aGeo:distance</code> that calculates the distance between two points, which is used here to find the places near Grenoble:</p>
        <pre class="prototype"> <code>xsd:double</code>   <code>aGeo:distance</code> (<code><span class="type numeric">numeric</span></code> <code>x1</code>, <code><span class=
        "type numeric">numeric</span></code> <code>y1</code>, <code><span class="type numeric">numeric</span></code> <code>x2</code>, <code><span class=
        "type numeric">numeric</span></code> <code>y2</code>)
</pre>
        <div class="exampleGroup">
          <div class="queryGroup">
            <pre class="query">PREFIX aGeo: &lt;http://example.org/geo#&gt;

SELECT ?neighbor
WHERE { ?a aGeo:placeName "Grenoble" .
        ?a aGeo:locationX ?axLoc .
        ?a aGeo:locationY ?ayLoc .

        ?b aGeo:placeName ?neighbor .
        ?b aGeo:locationX ?bxLoc .
        ?b aGeo:locationY ?byLoc .

        FILTER ( aGeo:distance(?axLoc, ?ayLoc, ?bxLoc, ?byLoc) &lt; 10 ) .
      }
</pre>
          </div>
        </div>
        <p>An extension function might be used to test some application datatype not supported by the core SPARQL specification, it might be a transformation between datatype formats, for example
        into an XSD dateTime RDF term from another date format.</p>
      </div>
    </div>
    <div class="div1">
      <h2><a name="sparqlDefinition" id="sparqlDefinition"></a>18 Definition of SPARQL</h2>
      <p>This section defines the correct behavior for evaluation of graph patterns and solution modifiers, given a query string and an RDF dataset. It does not imply a SPARQL implementation must use
      the process defined here.</p>
      <p>The outcome of executing a SPARQL query is defined by a series of steps, starting from the SPARQL query as a string, turning that string into an abstract syntax form, then turning the
      abstract syntax into a SPARQL abstract query comprising operators from the SPARQL algebra. This abstract query is then evaluated on an RDF dataset.</p>
      <div class="div2">
        <h3><a name="initDefinitions" id="initDefinitions"></a>18.1 Initial Definitions</h3>
        <div class="div3">
          <h4><a name="sparqlBasicTerms" id="sparqlBasicTerms"></a>18.1.1 RDF Terms</h4>
          <p>SPARQL is defined in terms of IRIs [<a href="#rfc3987">RFC3987</a>]. IRIs are a subset of RDF URI References that omits the use of spaces.</p>
          <div class="defn">
            <b>Definition: <a id="defn_RDFTerm" name="defn_RDFTerm">RDF Term</a></b>
            <p>Let I be the set of all IRIs.<br>
            Let RDF-L be the set of all <a class="norm" href="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-literal">RDF Literals</a><br>
            Let RDF-B be the set of all <a class="norm" href="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-blank-node">blank nodes</a> in RDF graphs</p>
            <p>The set of <span class="definedTerm">RDF Terms</span>, RDF-T, is I ∪ RDF-L ∪ RDF-B.</p>
          </div>
          <p>This definition of <span class="definedTerm">RDF Term</span> collects together several basic notions from the <a class="norm" href=
          "http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#section-data-model">RDF data model</a>, but <a href="http://www.w3.org/TR/rdf-concepts/#section-Graph-URIref">updated</a> to refer to
          IRIs rather than RDF URI references.</p>
        </div>
        <div class="div3">
          <h4><a name="simple_literal" id="simple_literal"></a>18.1.2 Simple Literal</h4>
          <div class="defn">
            <p><b>Definition: <a id="defn_SimpleLiteral" name="defn_SimpleLiteral">Simple Literal</a></b></p>
            <p>The set of <b>Simple Literals</b> is the set of all <a class="norm" href="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-literal">RDF Literals</a> with no language tag or
            datatype IRI.</p>
          </div>
        </div>
        <div class="div3">
          <h4><a name="sparqlDataset" id="sparqlDataset"></a>18.1.3 RDF Dataset</h4>
          <div class="defn">
            <b>Definition: <a id="defn_RDFDataset" name="defn_RDFDataset">RDF Dataset</a></b>
            <p>An RDF dataset is a set:<br>
            { G, (&lt;u<sub>1</sub>&gt;, G<sub>1</sub>), (&lt;u<sub>2</sub>&gt;, G<sub>2</sub>), . . . (&lt;u<sub>n</sub>&gt;, G<sub>n</sub>) }<br>
            where G and each G<sub>i</sub> are graphs, and each &lt;u<sub>i</sub>&gt; is an IRI. Each &lt;u<sub>i</sub>&gt; is distinct.</p>
            <p>G is called the default graph. (&lt;u<sub>i</sub>&gt;, G<sub>i</sub>) are called named graphs.</p>
          </div>
          <div class="defn">
            <b>Definition: <a id="defn_ActiveGraph" name="defn_ActiveGraph">Active Graph</a></b>
            <p>The <b>active graph</b> is the graph from the dataset used for basic graph pattern matching.</p>
          </div>
          <div class="defn">
            <p><b><a id="defn_RDFDatasetMerge" name="defn_RDFDatasetMerge">Definition: RDF Dataset Merge</a></b></p>
            <p>Let DS1 = { G1, (&lt;u1<sub>1</sub>&gt;, G1<sub>1</sub>), (&lt;u1<sub>2</sub>&gt;, G1<sub>2</sub>), . . . (&lt;u1<sub>n</sub>&gt;, G1<sub>n</sub>) },<br>
            and DS2 = { G2, (&lt;u2<sub>1</sub>&gt;, G2<sub>1</sub>), (&lt;u2<sub>2</sub>&gt;, G2<sub>2</sub>), . . . (&lt;u2<sub>m</sub>&gt;, G2<sub>m</sub>) }</p>
            <p>then we define the RDF Dataset Merge of DS1 and DS2 to be:<br>
            DS={ G, (&lt;u<sub>1</sub>&gt;, G<sub>1</sub>), (&lt;u<sub>2</sub>&gt;, G<sub>2</sub>), . . . (&lt;u<sub>k</sub>&gt;, G<sub>k</sub>) }<br>
            where:</p>
            <p>Write N1 for { &lt;u1<sub>j</sub>&gt; j = 1 to n }<br>
            Write N2 for { &lt;u2<sub>j</sub>&gt; j = 1 to m }<br></p>
            <ul>
              <li>G is the <a href="http://www.w3.org/TR/rdf-mt/#defmerge">merge</a> of G1 and G2</li>
              <li>(&lt;u<sub>i</sub>&gt;, G<sub>i</sub>) where &lt;u<sub>i</sub>&gt; is in N1 but not in N2</li>
              <li>(&lt;u<sub>i</sub>&gt;, G<sub>i</sub>) where &lt;u<sub>i</sub>&gt; is in N2 but not in N1</li>
              <li>(&lt;u<sub>i</sub>&gt;, G<sub>i</sub>) where &lt;u<sub>i</sub>&gt; is equal to &lt;u<sub>j</sub>&gt; in N1 and equal to &lt;u<sub>k</sub>&gt; in N2 and G<sub>i</sub> is the <a href=
              "http://www.w3.org/TR/rdf-mt/#defmerge">merge</a> of G1<sub>j</sub> and G2<sub>k</sub></li>
            </ul>
          </div>
        </div>
        <div class="div3">
          <h4><a name="sparqlQueryVariables" id="sparqlQueryVariables"></a>18.1.4 Query Variables</h4>
          <div class="defn">
            <b>Definition: <a id="defn_QueryVariable" name="defn_QueryVariable">Query Variable</a></b>
            <p>A <span class="definedTerm">query variable</span> is a member of the set V where V is infinite and disjoint from RDF-T.</p>
          </div>
        </div>
        <div class="div3">
          <h4><a name="sparqlTriplePatterns" id="sparqlTriplePatterns"></a>18.1.5 Triple Patterns</h4>
          <div class="defn">
            <b>Definition: <a id="defn_TriplePattern" name="defn_TriplePattern">Triple Pattern</a></b>
            <p>A <span class="definedTerm">triple pattern</span> is member of the set:<br>
            (RDF-T ∪ V) x (I ∪ V) x (RDF-T ∪ V)</p>
          </div>
          <p>This definition of Triple Pattern includes literal subjects. <a href="http://www.w3.org/2000/03/rdf-tracking/#rdfms-literalsubjects">This has been noted by RDF-core</a>.</p>
          <pre>"[The RDF core Working Group] noted that it is aware of no reason why literals should
not be subjects and a future WG with a less restrictive charter may
extend the syntaxes to allow literals as the subjects of statements."</pre>
          <p>Because RDF graphs may not contain literal subjects, any SPARQL triple pattern with a literal as subject will fail to match on any RDF graph.</p>
        </div>
        <div class="div3">
          <h4><a name="sparqlBasicGraphPatterns" id="sparqlBasicGraphPatterns"></a>18.1.6 Basic Graph Patterns</h4>
          <div class="defn">
            <b>Definition: <a id="defn_BasicGraphPattern" name="defn_BasicGraphPattern">Basic Graph Pattern</a></b>
            <p>A <span class="definedTerm">Basic Graph Pattern</span> is a set of <a href="#defn_TriplePattern">Triple Patterns</a>.</p>
          </div>
          <p>The empty graph pattern is a basic graph pattern which is the empty set.</p>
        </div>
        <div class="div3">
          <h4><a name="sparqlPropertyPaths" id="sparqlPropertyPaths"></a>18.1.7 Property Path Patterns</h4>
          <div class="defn">
            <b>Definition: <a id="defn_PropertyPath" name="defn_PropertyPath">Property Path</a></b>
            <p>A Property Path is a sequence of triples, t<sub>i</sub> in sequence ST, with n = length(ST)-1, such that, for i=0 to n, the object of t<sub>i</sub> is the same term as the subject of
            t<sub>i+1</sub>.</p>
            <p>We call the subject of t<sub>0</sub> the start of the path.</p>
            <p>We call the object of t<sub>n</sub> the end of the path.</p>
            <p>A Property Path is a path in graph G if each t<sub>i</sub> is a triple of G.</p>
          </div>
          <p>A property path does not span multiple graphs in a dataset.</p>
          <div class="defn">
            <b>Definition: <a id="defn_PropertyPathExpr" name="defn_PropertyPathExpr">Property Path Expression</a></b>
            <p>A property path expression is an expression using the property path forms <a href="">described above</a>.</p>
          </div>
          <div class="defn">
            <b>Definition: <a id="defn_PropertyPathPattern" name="defn_PropertyPathPattern">Property Path Pattern</a></b>
            <p>Let PP be the set of all property path expressions. A property path pattern is a member of the set:<br>
            (RDF-T ∪ V) x PP x (RDF-T ∪ V)</p>
          </div>
          <p>A Property Path Pattern is a generalization of a <a href="#defn_TriplePattern">Triple Pattern</a> to include a property path expression in the property position.</p>
        </div>
        <div class="div3">
          <h4><a name="sparqlSolutions" id="sparqlSolutions"></a>18.1.8 Solution Mapping</h4>
          <p>A solution mapping is a mapping from a set of variables to a set of RDF terms. We use the term 'solution' where it is clear.</p>
          <div class="defn">
            <b>Definition: <a id="defn_sparqlSolutionMapping" name="defn_sparqlSolutionMapping">Solution Mapping</a></b>
            <p>A <b>solution mapping</b>, μ, is a partial function μ : V -&gt; RDF-T.</p>
            <p>The domain of μ, dom(μ), is the subset of V where μ is defined.</p>
          </div>
          <div class="defn">
            <b>Definition: <a id="defn_sparqlSolutionSequence" name="defn_sparqlSolutionSequence">Solution Sequence</a></b>
            <p>A <b>solution sequence</b> is a list of solutions, possibly unordered.</p>
          </div>
          <p>Write expr(μ) for the value of the expression expr, using the terms for variables given by μ. Evaluation may result in an error.</p>
        </div>
        <div class="div3">
          <h4><a name="sparqlSolMod" id="sparqlSolMod"></a>18.1.9 Solution Sequence Modifiers</h4>
          <div class="defn">
            <b>Definition: <a id="defn_SolutionModifier" name="defn_SolutionModifier">Solution Sequence Modifier</a></b>
            <p>A <span class="definedTerm">solution sequence modifier</span> is one of:</p>
            <ul>
              <li><a href="#defn_algOrdered">Order By</a> modifier: put the solutions in order</li>
              <li><a href="#defn_algProjection">Projection</a> modifier: choose certain variables</li>
              <li><a href="#defn_algDistinct">Distinct</a> modifier: ensure solutions in the sequence are unique</li>
              <li><a href="#defn_algReduced">Reduced</a> modifier: permit any non-distinct solutions to be eliminated</li>
              <li><a href="#defn_algSlice">Offset</a> modifier: control where the solutions start from in the overall sequence of solutions</li>
              <li><a href="#defn_algSlice">Limit</a> modifier: restrict the number of solutions</li>
            </ul>
          </div>
        </div>
        <div class="div3">
          <h4><a name="idp2427544" id="idp2427544"></a>18.1.10 SPARQL Query</h4>
          <div class="defn">
            <b>Definition: <a id="defn_SPARQLQuery" name="defn_SPARQLQuery">SPARQL Query</a></b>
            <p>A <span class="definedTerm">SPARQL Abstract Query</span> is a tuple (E, DS, QF) where:</p>
            <ul>
              <li>E is a <a href="#sparqlAlgebra">SPARQL algebra</a> expression</li>
              <li>DS is an <a href="#defn_RDFDataset">RDF Dataset</a></li>
              <li>QF is a <a href="#QueryForms">query form</a></li>
            </ul>
          </div>
          <div class="defn">
            <b>Definition: <a id="defn_QueryUnit" name="defn_QueryUnit">Query Level</a></b>
            <p>A query level is a graph pattern, a set of group and aggregation, and a set of solution modifiers.</p>
          </div>
          <p>A query is a tree of "query levels", where each <a href="#subqueries">subquery</a> forms one query level in the tree.</p>
        </div>
      </div>
      <div class="div2">
        <h3><a name="sparqlQuery" id="sparqlQuery"></a>18.2 Translation to the SPARQL Algebra</h3>
        <p>This section defines the process of converting graph patterns and solution modifiers in a SPARQL query string into a SPARQL algebra expression. The process described converts one level of
        query nesting, as formed by subqueries using the nested <tt>SELECT</tt> syntax and is applied recursively on subqueries. Each level consists of graph pattern matching and filtering, followed
        by the application of solution modifiers.</p>
        <p>The SPARQL query string is parsed and the abbreviations for IRIs and triple patterns given in <a href="#sparqlSyntax">section 4</a> are applied. At this point the abstract syntax tree is
        composed of:</p>
        <table class="plain">
          <tbody>
            <tr>
              <th>Patterns</th>
              <th>Modifiers</th>
              <th>Query Forms</th>
              <th>Other</th>
            </tr>
            <tr>
              <td>RDF terms</td>
              <td>DISTINCT</td>
              <td>SELECT</td>
              <td>VALUES</td>
            </tr>
            <tr>
              <td>Property path expression</td>
              <td>REDUCED</td>
              <td>CONSTRUCT</td>
              <td>SERVICE</td>
            </tr>
            <tr>
              <td>Property path patterns</td>
              <td>Projection</td>
              <td>DESCRIBE</td>
              <td>&nbsp;</td>
            </tr>
            <tr>
              <td>Groups</td>
              <td>ORDER BY</td>
              <td>ASK</td>
              <td>&nbsp;</td>
            </tr>
            <tr>
              <td>OPTIONAL</td>
              <td>LIMIT</td>
              <td>&nbsp;</td>
              <td>&nbsp;</td>
            </tr>
            <tr>
              <td>UNION</td>
              <td>OFFSET</td>
              <td>&nbsp;</td>
              <td>&nbsp;</td>
            </tr>
            <tr>
              <td>GRAPH</td>
              <td>Select expressions</td>
              <td>&nbsp;</td>
              <td>&nbsp;</td>
            </tr>
            <tr>
              <td>BIND</td>
              <td>&nbsp;</td>
              <td>&nbsp;</td>
              <td>&nbsp;</td>
            </tr>
            <tr>
              <td>GROUP BY</td>
              <td>&nbsp;</td>
              <td>&nbsp;</td>
              <td>&nbsp;</td>
            </tr>
            <tr>
              <td>HAVING</td>
              <td>&nbsp;</td>
              <td>&nbsp;</td>
              <td>&nbsp;</td>
            </tr>
            <tr>
              <td>MINUS</td>
              <td>&nbsp;</td>
              <td>&nbsp;</td>
              <td>&nbsp;</td>
            </tr>
            <tr>
              <td>FILTER</td>
              <td>&nbsp;</td>
              <td>&nbsp;</td>
              <td>&nbsp;</td>
            </tr>
          </tbody>
        </table>
        <p>The result of converting such an abstract syntax tree is a SPARQL query that uses the following symbols in the SPARQL algebra:</p>
        <table class="plain">
          <tbody>
            <tr>
              <th>Graph Pattern</th>
              <th>Solution Modifiers</th>
              <th>Property Path</th>
            </tr>
            <tr>
              <td>BGP</td>
              <td>ToList</td>
              <td>PredicatePath</td>
            </tr>
            <tr>
              <td>Join</td>
              <td>OrderBy</td>
              <td>InversePath</td>
            </tr>
            <tr>
              <td>LeftJoin</td>
              <td>Project</td>
              <td>SequencePath</td>
            </tr>
            <tr>
              <td>Filter</td>
              <td>Distinct</td>
              <td>AlernativePath</td>
            </tr>
            <tr>
              <td>Union</td>
              <td>Reduced</td>
              <td>ZeroOrMorePath</td>
            </tr>
            <tr>
              <td>Graph</td>
              <td>Slice</td>
              <td>OneOrMorePath</td>
            </tr>
            <tr>
              <td>Extend</td>
              <td>ToMultiSet</td>
              <td>ZeroOrOnePath</td>
            </tr>
            <tr>
              <td>Minus</td>
              <td>&nbsp;</td>
              <td>NegatedPropertySet</td>
            </tr>
            <tr>
              <td>Group</td>
              <td>&nbsp;</td>
              <td>&nbsp;</td>
            </tr>
            <tr>
              <td>Aggregation</td>
              <td>&nbsp;</td>
              <td>&nbsp;</td>
            </tr>
            <tr>
              <td>AggregateJoin</td>
              <td>&nbsp;</td>
              <td>&nbsp;</td>
            </tr>
          </tbody>
        </table>
        <p><i>Slice</i> is the combination of OFFSET and LIMIT.</p>
        <p><i>ToList</i> is used where conversion from the results of graph pattern matching to sequences occurs.</p>
        <p><i>ToMultiSet</i> is used where conversion from a solution sequence to a multiset occurs.</p>
        <div class="div3">
          <h4><a name="variableScope" id="variableScope"></a>18.2.1 Variable Scope</h4>
          <p>We define a variable to be <i>in-scope</i> if there is a way for a variable to be in the domain of a solution mapping at that point in the execution of the SPARQL algebra for the query.
          The definition below provides a way of determing this from the abstract syntax of a query.</p>
          <p>Note that a subquery with a projection can hide variables; use of a variable in <code>FILTER</code>, or in <code>MINUS</code> does not cause a variable to be in-scope outside of those
          forms.</p>
          <p>Let <b>P</b>, <b>P1</b>, <b>P2</b> be graph patterns and <b>E</b>, <b>E1</b>,...<b>En</b> be expressions. A variable <code>v</code> is in-scope if:</p>
          <table style="border-collapse: collapse; border-color: #000000" cellpadding="5" border="1">
            <tbody>
              <tr>
                <th>Syntax Form</th>
                <th>In-scope variables</th>
              </tr>
              <tr>
                <td>Basic Graph Pattern (BGP)</td>
                <td><code>v</code> occurs in the BGP</td>
              </tr>
              <tr>
                <td>Path</td>
                <td><code>v</code> occurs in the path</td>
              </tr>
              <tr>
                <td>Group <code>{ P1 P2 ... }</code></td>
                <td><code>v</code> is in-scope if it is in-scope in one or more of P1, P2, ...</td>
              </tr>
              <tr>
                <td><code>GRAPH term { P }</code></td>
                <td><code>v</code> is <code>term</code> or <code>v</code> is in-scope in P</td>
              </tr>
              <tr>
                <td><code>{ P1 } UNION { P2 }</code></td>
                <td><code>v</code> is in-scope in P1 or in-scope in P2</td>
              </tr>
              <tr>
                <td><code>OPTIONAL {P}</code></td>
                <td><code>v</code> is in-scope in P</td>
              </tr>
              <tr>
                <td><code>SERVICE term {P}</code></td>
                <td><code>v</code> is <code>term</code> or <code>v</code> is in-scope in P</td>
              </tr>
              <tr>
                <td><code>BIND (expr AS v)</code></td>
                <td><code>v</code> is in-scope</td>
              </tr>
              <tr>
                <td><code>SELECT .. v .. { P }</code></td>
                <td><code>v</code> is in-scope</td>
              </tr>
              <tr>
                <td><code>SELECT ... (expr AS v)</code></td>
                <td><code>v</code> is in-scope</td>
              </tr>
              <tr>
                <td><code>GROUP BY (expr AS v)</code></td>
                <td><code>v</code> is in-scope</td>
              </tr>
              <tr>
                <td><code>SELECT * { P }</code></td>
                <td><code>v</code> is in-scope in <code>P</code></td>
              </tr>
              <tr>
                <td><code>VALUES v { values }</code></td>
                <td><code>v</code> is in-scope</td>
              </tr>
              <tr>
                <td><code>VALUES varlist { values }</code></td>
                <td><code>v</code> is in-scope if <code>v</code> is in <code>varlist</code></td>
              </tr>
            </tbody>
          </table>
          <p>The variable <tt>v</tt> must not be in-scope at the point of the <code>(expr AS v)</code> form. The scoping for <code>(expr AS v)</code> applies immediately in <code>SELECT</code>
          expressions.</p>
          <p>In <code>BIND (expr AS v)</code> requires that the variable <code>v</code> is not in-scope from the preceeding elements in the group graph pattern in which it is used.</p>
          <p>In <code>SELECT</code>, the variable <code>v</code> must not be in-scope in the graph pattern of the <code>SELECT</code> clause, nor used in another select expression earlier in the
          clause.</p>
        </div>
        <div class="div3">
          <h4><a name="convertGraphPattern" id="convertGraphPattern"></a>18.2.2 Converting Graph Patterns</h4>
          <p>This section describes the process for translating a SPARQL graph pattern into a SPARQL algebra expression. This process is applied to the group graph pattern (the unit between
          <code>{...}</code> delimiters) forming the <code>WHERE</code> clause of a query, and recursively to each syntactic element within the group graph pattern. The result of the translation is a
          SPARQL algebra expression.</p>
          <p>In summary, the steps are applied as follows:</p>
          <ul>
            <li><a href="#sparqlExpandForms">Expand syntax forms</a> for IRIs, literals and triple patterns.</li>
            <li><a href="#sparqlTranslatePathExpressions">Translate property path expressions</a></li>
            <li><a href="#sparqlTranslatePathPatterns">Convert some property path patterns to triples</a></li>
            <li><a href="#sparqlCollectFilters">Collect the <code>FILTER</code>s in the group</a></li>
            <li><a href="#sparqlTranslateBasicGraphPatterns">Translate Basic Graph Patterns</a></li>
            <li><a href="#sparqlTranslateGraphPatterns">Translate the remaining graph patterns in the group</a></li>
            <li><a href="#sparqlAddFilters">Add in Filters</a></li>
            <li><a href="#sparqlSimplification">Simplify the algebra expression</a></li>
          </ul>
          <p>We write</p>
          <blockquote>
            translate(graph pattern)
          </blockquote>
          <p>for the algorthm described here to translate graph patterns.</p>
          <div class="wgNote">
            The working group notes that in SPARQL 1.0, the point at which the simplification step is applied leads to ambiguous transformation of queries involving a doubly nested filter and pattern
            in an optional:
            <pre><code>OPTIONAL { { ... FILTER ( ... ?x ... ) } }.</code>.</pre>
            <p>This is illustrated by two non-normative test cases:</p>
            <ul>
              <li><a href="http://www.w3.org/2001/sw/DataAccess/tests/data-r2/optional-filter/manifest#dawg-optional-filter-005-not-simplified">Simplification applied after all transformations</a> or
              not at all.</li>
              <li><a href="http://www.w3.org/2001/sw/DataAccess/tests/data-r2/optional-filter/manifest#dawg-optional-filter-005-simplified">Simplification applied during transformation</a>.</li>
            </ul>
          </div>
          <p>Applying the simpification step after all the translation of graph patterns is the preferred reading.</p>
          <div class="div4">
            <h5><a name="sparqlExpandForms" id="sparqlExpandForms"></a>18.2.2.1 Expand Syntax Forms</h5>
            <p>Expand abbreviations for IRIs and triple patterns given in <a href="#sparqlSyntax">section 4</a>.</p>
          </div>
          <div class="div4">
            <h5><a name="sparqlCollectFilters" id="sparqlCollectFilters"></a>18.2.2.2 Collect <code>FILTER</code> Elements</h5>
            <p><code>FILTER</code> expressions apply to the whole group graph pattern in which they appear. The algebra operators to perform filtering are added to the group after translation of each
            group element. We collect the filters together here and remove them from group, then <a href="#sparqlAddFilters">apply them to the whole translated group graph pattern</a>.</p>
            <p>In this step, we also translate graph patterns within <code>FILTER</code> expressions <a href="#func-filter-exists"><code>EXISTS</code> and <code>NOT EXISTS</code></a>.</p>
            <pre class="codeBlock">Let FS := empty set

For each form FILTER(expr) in the group graph pattern:
    In expr, replace NOT EXISTS{P} with fn:not(<a href="#defn_evalExists">exists(translate(P)))</a> 
    In expr, replace EXISTS{P} with <a href="#defn_evalExists">exists(translate(P))</a>
    FS := FS ∪ {expr}
    End</pre>
            <p>The set of filter expressions <code>FS</code> is <a href="#sparqlAddFilters">used later</a>.</p>
          </div>
          <div class="div4">
            <h5><a name="sparqlTranslatePathExpressions" id="sparqlTranslatePathExpressions"></a>18.2.2.3 Translate Property Path Expressions</h5>
            <p>The following table gives the translation of property paths expressions from SPARQL syntax to terms in the SPARQL algebra. This applies to all elements of a property path expression
            recursively.</p>
            <p>The <a href="#sparqlTranslatePathPatterns">next step after this one</a> translates certain forms to triple patterns, and these are converted later to basic graph patterns by adjacency
            (without intervening group pattern delimiters <tt>{</tt> and <tt>})</tt> or other syntax forms. Overall, SPARQL syntax property paths of just an IRI become triple patterns and these are
            aggregated into basic graph patterns.</p>
            <p>Notes:</p>
            <ul>
              <li>The order of forms IRI and ^IRI in negated property sets is not relevant.</li>
            </ul>
            <p>We introduce the following symbols:</p>
            <ul>
              <li>link</li>
              <li>inv</li>
              <li>alt</li>
              <li>seq</li>
              <li>ZeroOrMorePath</li>
              <li>OneOrMorePath</li>
              <li>ZeroOrOnePath</li>
              <li>NPS (for NegatedPropertySet)</li>
            </ul>
            <table style="border-collapse: collapse; border-color: #000000" cellpadding="5" border="1">
              <tbody>
                <tr>
                  <th>Syntax Form (path)</th>
                  <th>Algebra (path)</th>
                </tr>
                <tr>
                  <td><code>iri</code></td>
                  <td><code>link(iri)</code></td>
                </tr>
                <tr>
                  <td><code>^path</code></td>
                  <td><code>inv(path)</code></td>
                </tr>
                <tr>
                  <td><code>!(:iri<sub>1</sub>|...|:iri<sub>n</sub>)</code></td>
                  <td><code>NPS({:iri<sub>1</sub> ... :iri<sub>n</sub>})</code></td>
                </tr>
                <tr>
                  <td><code>!(^:iri<sub>1</sub>|...|^:iri<sub>n</sub>)</code></td>
                  <td><code>inv(NPS({:iri<sub>1</sub> ... :iri<sub>n</sub>}))</code></td>
                </tr>
                <tr>
                  <td><code>!(:iri<sub>1</sub>|...|:iri<sub>i</sub>|^:iri<sub>i+1</sub>|...|^:iri<sub>m</sub>)</code>&nbsp;</td>
                  <td><code>alt(NPS({:iri<sub>1</sub> ...:iri<sub>i</sub>}),<br>
                  &nbsp;&nbsp;&nbsp;&nbsp;inv(NPS({:iri<sub>i+1</sub>, ..., :iri<sub>m</sub>})) )</code></td>
                </tr>
                <tr>
                  <td><code>path1 / path2</code></td>
                  <td><code>seq(path1, path2)</code></td>
                </tr>
                <tr>
                  <td><code>path1 | path2</code></td>
                  <td><code>alt(path1, path2)</code></td>
                </tr>
                <tr>
                  <td><code>path*</code></td>
                  <td><code>ZeroOrMorePath(path)</code></td>
                </tr>
                <tr>
                  <td><code>path+</code></td>
                  <td><code>OneOrMorePath(path)</code></td>
                </tr>
                <tr>
                  <td><code>path?</code></td>
                  <td><code>ZeroOrOnePath(path)</code></td>
                </tr>
              </tbody>
            </table>
          </div>
          <div class="div4">
            <h5><a name="sparqlTranslatePathPatterns" id="sparqlTranslatePathPatterns"></a>18.2.2.4 Translate Property Path Patterns</h5>
            <p>The previous step translated <a href="#defn_PropertyPathExpr">property path expressions</a>. This step translates <a href="#defn_PropertyPathPattern">property path patterns</a>, which
            are a subject end point, property path expression and object end point, into triple patterns or wraps in a general algebra operation for path evaluation.</p>
            <p>Notes:</p>
            <ul>
              <li>X and Y are RDF terms or variables.</li>
              <li>?V is a fresh variable.</li>
              <li>P and Q are path expressions.</li>
              <li>These are only applied to property path patterns, not within property path expressions.</li>
              <li>Translations earlier in the table are applied in preference to the last translation.</li>
              <li>The final translation simply wraps any remaining property path expression to use a common form <code>Path(...)</code>.</li>
            </ul>
            <table style="border-collapse: collapse; border-color: #000000" cellpadding="5" border="1">
              <tbody>
                <tr>
                  <th>Algebra (path)</th>
                  <th>Translation</th>
                </tr>
                <tr>
                  <td><code>X link(iri) Y</code></td>
                  <td><code>X iri Y</code></td>
                </tr>
                <tr>
                  <td><code>X inv(iri) Y</code></td>
                  <td><code>Y iri X</code></td>
                </tr>
                <tr>
                  <td><code>X seq(P, Q) Y</code></td>
                  <td><code>X P ?V . ?V Q P</code></td>
                </tr>
                <tr>
                  <td><code>X P Y</code></td>
                  <td><code>Path(X, P, Y)</code></td>
                </tr>
              </tbody>
            </table>
            <p>Examples of the whole path translation process (<code>?_V</code> is a fresh variable):</p>
            <div class="algExample">
              <div class="algExample1">
                ?s :p/:q ?o
              </div>
              <div class="algExample2">
                ?s :p ?_V .<br>
                ?_V :q ?o
              </div>
            </div>
            <div class="algExample">
              <div class="algExample1">
                ?s :p* ?o
              </div>
              <div class="algExample2">
                Path(?s, ZeroOrMorePath(link(:p)), ?o)
              </div>
            </div>
            <div class="algExample">
              <div class="algExample1">
                :list rdf:rest*/rdf:first ?member
              </div>
              <div class="algExample2">
                Path(:list, ZeroOrMorePath(link(rdf:rest)), ?_V) .<br>
                ?_V rdf:first ?member
              </div>
            </div>
          </div>
          <div class="div4">
            <h5><a name="sparqlTranslateBasicGraphPatterns" id="sparqlTranslateBasicGraphPatterns"></a>18.2.2.5 Translate Basic Graph Patterns</h5>
            <p>After translating property paths, any adjacent triple patterns are collected together to form a basic graph pattern <code>BGP(triples)</code>.</p>
          </div>
          <div class="div4">
            <h5><a name="sparqlTranslateGraphPatterns" id="sparqlTranslateGraphPatterns"></a>18.2.2.6 Translate Graph Patterns</h5>
            <p>Next, we translate each remaining graph pattern form, recursively applying the translation process.</p>
            <blockquote>
              <p>If the form is <code><a href="#rGroupOrUnionGraphPattern">GroupOrUnionGraphPattern</a></code></p>
            </blockquote>
            <pre class="codeBlock">Let A := undefined
          
For each element G in the GroupOrUnionGraphPattern
    If A is undefined
        A := Translate(G)
    Else
        A := Union(A, Translate(G))
    End

The result is A
            </pre>
            <blockquote>
              <p>If the form is <code><a href="#rGraphGraphPattern">GraphGraphPattern</a></code></p>
            </blockquote>
            <pre class="codeBlock">If the form is GRAPH IRI GroupGraphPattern
    The result is Graph(IRI, Translate(GroupGraphPattern))</pre>
            <pre class="codeBlock">If the form is GRAPH Var GroupGraphPattern
    The result is Graph(Var, Translate(GroupGraphPattern))</pre>
            <blockquote>
              <p>If the form is <code><a href="#rGroupGraphPattern">GroupGraphPattern</a></code>:</p>
            </blockquote>
            <pre class="codeBlock">Let FS := the empty set
Let G := the empty pattern, a basic graph pattern which is the empty set.

For each element E in the GroupGraphPattern

    If E is of the form OPTIONAL{P} 
        Let A := Translate(P)
        If A is of the form Filter(F, A2)
            G := LeftJoin(G, A2, F)
        Else 
            G := LeftJoin(G, A, true)
            End
        End

    If E is of the form MINUS{P}
        G := Minus(G, Translate(P))
        End

    If E is of the form BIND(expr AS var)
        G := Extend(G, var, expr)
        End

    If E is any other form 
        Let A := Translate(E)
        G := Join(G, A)
        End

   End
   
The result is G.
            </pre>
            <blockquote>
              <p>If the form is <a href="#rInlineData">InlineData</a></p>
            </blockquote>
            <pre class="codeBlock">The result is a multiset of solution mappings 'data'.</pre>
            <div id="data-block">
              <blockquote>
                <i>data</i> is formed by forming a solution mapping from the variable in the corresponding position in list of variables (or single variable), omitting a binding if the
                <code>BindingValue</code> is the word <code>UNDEF</code>.
              </blockquote>
            </div>
            <blockquote>
              <p>If the form is <a href="#rSubSelect">SubSelect</a></p>
            </blockquote>
            <pre class="codeBlock">The result is ToMultiset(Translate(SubSelect))</pre>
          </div>
          <div class="div4">
            <h5><a name="sparqlAddFilters" id="sparqlAddFilters"></a>18.2.2.7 Filters of Group</h5>
            <p>After the group has been translated, the filter expressions are added so they wil apply to the whole of the rest of the group:</p>
            <pre class="codeBlock">If FS is not empty
    Let G := output of preceding step
    Let X := Conjunction of expressions in FS
    G := Filter(X, G)
    End</pre>
          </div>
          <div class="div4">
            <h5><a name="sparqlSimplification" id="sparqlSimplification"></a>18.2.2.8 Simplification step</h5>
            <p>Some groups of one graph pattern become <code>join(Z, A)</code>, where Z is the empty basic graph pattern (which is the empty set). These can be replaced by A. The empty graph pattern
            Z is the identity for join:</p>
            <pre class="codeBlock">Replace join(Z, A) by A
Replace join(A, Z) by A</pre>
          </div>
        </div>
        <div class="div3">
          <h4><a name="sparqlAlgebraExamples" id="sparqlAlgebraExamples"></a>18.2.3 Examples of Mapped Graph Patterns</h4>
          <p>The second form of a rewrite example is the first with empty group joins removed by the simplification step.</p>
          <p>Example: group with a basic graph pattern consisting of a single triple pattern:</p>
          <div class="algExample">
            <div class="algExample1">
              { ?s ?p ?o }
            </div>
            <div class="algExample2">
              Join(Z, BGP(?s ?p ?o) )
            </div>
            <div class="algExample2">
              BGP(?s ?p ?o)
            </div>
          </div>
          <p>Example: group with a basic graph pattern consisting of two triple patterns:</p>
          <div class="algExample">
            <div class="algExample1">
              { ?s :p1 ?v1 ; :p2 ?v2 }
            </div>
            <div class="algExample2">
              BGP( ?s :p1 ?v1 . ?s :p2 ?v2 )
            </div>
          </div>
          <p>Example: group consisting of a union of two basic graph patterns:</p>
          <div class="algExample">
            <div class="algExample1">
              { { ?s :p1 ?v1 } UNION {?s :p2 ?v2 } }
            </div>
            <div class="algExample2">
              Union(Join(Z, BGP(?s :p1 ?v1)),<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Join(Z, BGP(?s :p2 ?v2)) )
            </div>
            <div class="algExample2">
              Union( BGP(?s :p1 ?v1) , BGP(?s :p2 ?v2) )
            </div>
          </div>
          <p>Example: group consisting of a union of a union and a basic graph pattern:</p>
          <div class="algExample">
            <div class="algExample1">
              { { ?s :p1 ?v1 } UNION {?s :p2 ?v2 } UNION {?s :p3 ?v3 } }
            </div>
            <div class="algExample2">
              Union(<br>
              &nbsp;&nbsp;&nbsp; Union( Join(Z, BGP(?s :p1 ?v1)),<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Join(Z, BGP(?s :p2 ?v2))) ,<br>
              &nbsp;&nbsp;&nbsp; Join(Z, BGP(?s :p3 ?v3)) )
            </div>
            <div class="algExample2">
              Union(<br>
              &nbsp;&nbsp;&nbsp; Union( BGP(?s :p1 ?v1) ,<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BGP(?s :p2 ?v2),<br>
              &nbsp;&nbsp;&nbsp; BGP(?s :p3 ?v3))
            </div>
          </div>
          <p>Example: group consisting of a basic graph pattern and an optional graph pattern:</p>
          <div class="algExample">
            <div class="algExample1">
              { ?s :p1 ?v1 OPTIONAL {?s :p2 ?v2 } }
            </div>
            <div class="algExample2">
              LeftJoin(<br>
              &nbsp;&nbsp;&nbsp; Join(Z, BGP(?s :p1 ?v1)),<br>
              &nbsp;&nbsp;&nbsp; Join(Z, BGP(?s :p2 ?v2)),<br>
              &nbsp;&nbsp;&nbsp; true)
            </div>
            <div class="algExample2">
              LeftJoin(BGP(?s :p1 ?v1), BGP(?s :p2 ?v2), true)
            </div>
          </div>
          <p>Example: group consisting of a basic graph pattern and two optional graph patterns:</p>
          <div class="algExample">
            <div class="algExample1">
              { ?s :p1 ?v1 OPTIONAL {?s :p2 ?v2 } OPTIONAL { ?s :p3 ?v3 } }
            </div>
            <div class="algExample2">
              LeftJoin(<br>
              &nbsp;&nbsp;&nbsp; LeftJoin(<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BGP(?s :p1 ?v1),<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BGP(?s :p2 ?v2),<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; true) ,<br>
              &nbsp;&nbsp;&nbsp; BGP(?s :p3 ?v3),<br>
              &nbsp;&nbsp;&nbsp; true)
            </div>
          </div>
          <p>Example: group consisting of a basic graph pattern and an optional graph pattern with a filter:</p>
          <div class="algExample">
            <div class="algExample1">
              { ?s :p1 ?v1 OPTIONAL {?s :p2 ?v2 FILTER(?v1&lt;3) } }
            </div>
            <div class="algExample2">
              LeftJoin(<br>
              &nbsp;&nbsp;&nbsp;&nbsp; Join(Z, BGP(?s :p1 ?v1)),<br>
              &nbsp;&nbsp;&nbsp;&nbsp; Join(Z, BGP(?s :p2 ?v2)),<br>
              &nbsp;&nbsp;&nbsp;&nbsp; (?v1&lt;3) )
            </div>
            <div class="algExample2">
              LeftJoin(<br>
              &nbsp;&nbsp;&nbsp; BGP(?s :p1 ?v1) ,<br>
              &nbsp;&nbsp;&nbsp; BGP(?s :p2 ?v2) ,<br>
              &nbsp;&nbsp; (?v1&lt;3) )
            </div>
          </div>
          <p>Example: group consisting of a union graph pattern and an optional graph pattern:</p>
          <div class="algExample">
            <div class="algExample1">
              { {?s :p1 ?v1} UNION {?s :p2 ?v2} OPTIONAL {?s :p3 ?v3} }
            </div>
            <div class="algExample2">
              LeftJoin(<br>
              &nbsp; Union(BGP(?s :p1 ?v1),<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BGP(?s :p2 ?v2)) ,<br>
              &nbsp; BGP(?s :p3 ?v3) ,<br>
              &nbsp; true )
            </div>
          </div>
          <p>Example: group consisting of a basic graph pattern, a filter and an optional graph pattern:</p>
          <div class="algExample">
            <div class="algExample1">
              { ?s :p1 ?v1 FILTER (?v1 &lt; 3 ) OPTIONAL {?s :p2 ?v2} }
            </div>
            <div class="algExample2">
              Filter( ?v1 &lt; 3 ,<br>
              &nbsp; LeftJoin( BGP(?s :p1 ?v1), BGP(?s :p2 ?v2), true) ,<br>
              &nbsp; )
            </div>
          </div>
          <p>Example: Pattern involving BIND:</p>
          <div class="algExample">
            <div class="algExample1">
              { ?s :p ?v . BIND (2*?v AS ?v2) ?s :p1 ?v2 }
            </div>
            <div class="algExample2">
              Join(<br>
              &nbsp;&nbsp; Extend( BGP(?s :p ?v), ?v2, 2*?v) ,<br>
              &nbsp;&nbsp; BGP(?s :p1 ?v2) )
            </div>
          </div>
          <p>Example: Pattern involving BIND:</p>
          <div class="algExample">
            <div class="algExample1">
              { ?s :p ?v . {} BIND (2*?v AS ?v2) }
            </div>
            <div class="algExample2">
              Join(<br>
              &nbsp;&nbsp; BGP(?s :p ?v), ?v2, 2*?v) ,<br>
              &nbsp;&nbsp; Extend({}, ?v2, 2*?v)<br>
              )
            </div>
          </div>
          <p>Example: Pattern involving MINUS:</p>
          <div class="algExample">
            <div class="algExample1">
              { ?s :p ?v . MINUS {?s :p1 ?v2 } }
            </div>
            <div class="algExample2">
              Minus(<br>
              &nbsp;&nbsp; BGP(?s :p ?v)<br>
              &nbsp;&nbsp; BGP(?s :p1 ?v2))
            </div>
          </div>
          <p>Example: Pattern involving a subquery:</p>
          <div class="algExample">
            <div class="algExample1">
              { ?s :p ?o . {SELECT DISTINCT ?o {?o ?p ?z} } }
            </div>
            <div class="algExample2">
              Join(<br>
              &nbsp;&nbsp; BGP(?s :p ?o) ,<br>
              &nbsp;&nbsp; ToMultiSet(<br>
              &nbsp;&nbsp;&nbsp;&nbsp; Distinct(Project(BGP(?o ?p ?z), {?o})) )<br>
              &nbsp;&nbsp; )
            </div>
          </div>
        </div>
        <div class="div3">
          <h4><a name="convertGroupAggSelectExpressions" id="convertGroupAggSelectExpressions"></a>18.2.4 Converting Groups, Aggregates, HAVING, final VALUES clause and SELECT Expressions</h4>
          <p>In this step, we process clauses on the query level in the following order:</p>
          <ul>
            <li>Grouping</li>
            <li>Aggregates</li>
            <li>HAVING</li>
            <li>VALUES</li>
            <li>Select expressions</li>
          </ul>
          <div class="div4">
            <h5><a name="sparqlGroupAggregate" id="sparqlGroupAggregate"></a>18.2.4.1 Grouping and Aggregation</h5>
            <p>Step: GROUP BY</p>
            <p>If the <code>GROUP BY</code> keyword is used, or there is implicit grouping due to the use of aggregates in the projection, then grouping is performed by the <a href=
            "#defn_algGroup">Group</a> function. It divides the solution set into groups of one or more solutions, with the same overall cardinality. In case of implicit grouping, a fixed constant
            (1) is used to group all solutions into a single group.</p>
            <p>Step: Aggregates</p>
            <p>The aggregation step is applied as a transformation on the query level, replacing aggregate expressions in the query level with Aggregation() algebraic expressions.</p>
            <p>The transformation for query levels that use any aggregates is given below:</p>
            <pre class="codeBlock">Let A := the empty sequence
Let Q := the query level being evaluated
Let P := the algebra translation of the GroupGraphPattern of the query level
Let E := [], a list of pairs of the form (variable, expression)

If Q contains GROUP BY exprlist
   Let G := Group(exprlist, P)
Else If Q contains an aggregate in SELECT, HAVING, ORDER BY
   Let G := Group((1), P)
Else
   skip the rest of the aggregate step
   End

Global i := 1   # Initially 1 for each query processed

For each (X AS Var) in SELECT, each HAVING(X), and each ORDER BY X in Q
  For each unaggregated variable V in X
      Replace V with Sample(V)
      End
  For each aggregate R(args ; scalarvals) now in X
      # note scalarvals may be omitted, then it's equivalent to the empty set
      A<span><sub>i</sub></span> := Aggregation(args, R, scalarvals, G)
      Replace R(...) with agg<span><sub>i</sub></span> in Q
      i := i + 1
      End
  End

For each variable V appearing outside of an aggregate
   A<span><sub>i</sub></span> := Aggregation(V, Sample, {}, G)
   E := E append (V, agg<span><sub>i</sub></span>)
   i := i + 1
   End

A := A<span><sub>i</sub></span>, ..., A<span><sub>i-1</sub></span>
P := AggregateJoin(A)
</pre>
            <p>Note: agg<sub>i</sub> is a temporary variable. E is then used in 18.2.4.4 for the processing of select expressions.</p>
            <p>Example:</p>
            <pre class="query">PREFIX rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;
SELECT (SUM(?val) AS ?sum) (COUNT(?a) AS ?count)
WHERE {
  ?a rdf:value ?val .
} GROUP BY ?a</pre>
            <p>The SUM expression becomes agg<sub>1</sub>, and the COUNT expression becomes agg<sub>2</sub>.</p>
            <pre class="code">Let G := Group((?a), BGP(?a rdf:value ?val))
<span>A<sub>1</sub></span> = Aggregation((?val), Sum, {}, G)
<span>A<sub>2</sub></span> = Aggregation((?a), Count, {}, G)
A := (<span>A<sub>1</sub>, A<sub>2</sub></span>)
Let P := AggregateJoin(A)</pre>
          </div>
          <div class="div4">
            <h5><a name="sparqlHavingClause" id="sparqlHavingClause"></a>18.2.4.2 HAVING</h5>
            <p>The HAVING expression is evaluated using the same rules as FILTER(). Note that, due to the logic position in which the HAVING clause is evaluated, expressions projected by the SELECT
            clause are not visible to the HAVING clause.</p>
            <pre class="codeBlock">Let Q := the query level being evaluated
Let P := the algebra translation of the query level so far

For each HAVING(E) in Q
    P := Filter(E, P)
    End</pre>
          </div>
          <div class="div4">
            <h5><a name="sparqlAlgebraFinalValues" id="sparqlAlgebraFinalValues"></a>18.2.4.3 VALUES</h5>
            <p>If the query has a trailing VALUES clause:</p>
            <pre class="codeBlock">Let P := the algebra translation of the query level so far
P := Join(P, ToMultiSet(data))
  where <i>data</i> is a solution sequence formed from the VALUES clause</pre>
            <p>The translatation of the data is the same as for <a href="#data-block">inline data</a>.</p>
          </div>
          <div class="div4">
            <h5><a name="sparqlSelectExpressions" id="sparqlSelectExpressions"></a>18.2.4.4 SELECT Expressions</h5>
            <p>Step: Select expressions</p>
            <p>We have two forms of the abstract syntax to consider:</p>
            <pre class="codeBlock">SELECT selItem ... { pattern }
SELECT * { pattern }</pre>
            <pre class="codeBlock">Let X := algebra from earlier steps
Let VS := list of all variables visible in the pattern,
           so restricted by sub-SELECT projected variables and GROUP BY variables.
           Not visible: only in filter, exists/not exists, masked by a subselect, 
                        non-projected GROUP variables, only in the right hand side of MINUS

Let PV := {}, a set of variable names
Note, E is a list of pairs of the form (variable, expression), defined in <a href="#convertGroupAggSelectExpressions">section 18.2.4</a>
  
If "SELECT *"
    PV := VS

If  "SELECT <code>selItem ...</code>:"  
    For each selItem:
        If selItem is a variable
            PV := PV ∪ { variable }
        End
        If selItem is (expr AS variable)
            variable must not appear in VS nor in PV; if it does then generate a syntax error and stop
            PV := PV ∪ { variable }
            E := E append (variable, expr) 
        End
    End

For each pair (var, expr) in E
    X := Extend(X, var, expr)
    End
  
Result is X  
The set PV is used later for projection.
            </pre>
            <p>The syntax error arises for use of a variable as the named target of AS (e.g. ... AS ?x) when the variable is used inside the WHERE clause of the SELECT or if already used as the
            traget of AS in this SELECT expression.</p>
          </div>
        </div>
        <div class="div3">
          <h4><a name="convertSolMod" id="convertSolMod"></a>18.2.5 Converting Solution Modifiers</h4>
          <p>Solutions modifiers apply to the processing of a SPARQL query after pattern matching. The solution modifiers are applied to a query in the following order:</p>
          <ul>
            <li>Order by</li>
            <li>Projection</li>
            <li>Distinct</li>
            <li>Reduced</li>
            <li>Offset</li>
            <li>Limit</li>
          </ul>
          <p>Step: ToList</p>
          <p>ToList turns a multiset into a sequence with the same elements and cardinality. There is no implied ordering to the sequence; duplicates need not be adjacent.</p>
          <blockquote>
            <p>Let M := ToList(Pattern)</p>
          </blockquote>
          <div class="div4">
            <h5><a name="sparqlOrderBy" id="sparqlOrderBy"></a>18.2.5.1 ORDER BY</h5>
            <p>If the query string has an ORDER BY clause</p>
            <blockquote>
              <p>M := OrderBy(M, list of order comparators)</p>
            </blockquote>
          </div>
          <div class="div4">
            <h5><a name="sparqlProjection" id="sparqlProjection"></a>18.2.5.2 Projection</h5>
            <p>The set of projection variables, <code>PV</code>, was calculated in the <a href="#sparqlSelectExpressions">processing of SELECT expressions</a>.</p>
            <blockquote>
              <p>M := Project(M, PV)</p>
            </blockquote>
            <p>where vars is the set of variables mentioned in the SELECT clause or all named variables that are <a href="#variableScope">in-scope</a> in the query if SELECT * used.</p>
          </div>
          <div class="div4">
            <h5><a name="sparqlDistinct" id="sparqlDistinct"></a>18.2.5.3 DISTINCT</h5>
            <p>If the query contains DISTINCT,</p>
            <blockquote>
              <p>M := Distinct(M)</p>
            </blockquote>
          </div>
          <div class="div4">
            <h5><a name="sparqlReduced" id="sparqlReduced"></a>18.2.5.4 REDUCED</h5>
            <p>If the query contains REDUCED,</p>
            <blockquote>
              <p>M := Reduced(M)</p>
            </blockquote>
          </div>
          <div class="div4">
            <h5><a name="sparqlOffsetLimit" id="sparqlOffsetLimit"></a>18.2.5.5 OFFSET and LIMIT</h5>
            <p>If the query contains "OFFSET start" or "LIMIT length"</p>
            <blockquote>
              <p>M := Slice(M, start, length)</p>
              <blockquote>
                <p>start defaults to 0</p>
                <p>length defaults to (size(M)-start).</p>
              </blockquote>
            </blockquote>
          </div>
          <div class="div4">
            <h5><a name="sparqlAlgebraOutcome" id="sparqlAlgebraOutcome"></a>18.2.5.6 Final Algebra Expression</h5>
            <blockquote>
              The overall abstract query is M.
            </blockquote>
          </div>
        </div>
      </div>
      <div class="div2">
        <h3><a name="BasicGraphPattern" id="BasicGraphPattern"></a>18.3 Basic Graph Patterns</h3>
        <p>When matching graph patterns, the possible solutions form a <i><a href="http://en.wikipedia.org/w/index.php?title=Multiset&amp;oldid=163605900">multiset</a></i> [<a href=
        "#multiset">multiset</a>], also known as a <i>bag</i>. A multiset is an unordered collection of elements in which each element may appear more than once. It is described by a set of elements
        and a cardinality function giving the number of occurrences of each element from the set in the multiset.</p>
        <p>Write μ for solution mappings.</p>
        <p>Write μ<sub>0</sub> for the mapping such that dom(μ<sub>0</sub>) is the empty set.</p>
        <p>Write Ω<sub>0</sub> for the multiset consisting of exactly the empty mapping μ<sub>0,</sub> with cardinality 1. This is the join identity.</p>
        <p>Write μ(x) for the solution mapping variable x to RDF term t : { (x, t) }</p>
        <p>Write Ω(x) for the multiset consisting of exactly μ(?x-&gt;t), that is, { { (x, t) } } with cardinality 1.</p>
        <div class="defn">
          <b>Definition: <a id="defn_algCompatibleMapping" name="defn_algCompatibleMapping">Compatible Mappings</a></b>
          <p>Two solution mappings μ<sub>1</sub> and μ<sub>2</sub> are compatible if, for every variable v in dom(μ<sub>1</sub>) and in dom(μ<sub>2</sub>), μ<sub>1</sub>(v) = μ<sub>2</sub>(v).</p>
        </div>
        <p>Here, μ<sub>1</sub>(v) = μ<sub>2</sub>(v) means that μ<sub>1</sub>(v) and μ<sub>2</sub>(v) are the same RDF term.</p>
        <p>If μ<sub>1</sub> and μ<sub>2</sub> are compatible then μ<sub>1</sub> ∪ μ<sub>2</sub> is also a mapping. Write merge(μ<sub>1</sub>, μ<sub>2</sub>) for μ<sub>1</sub> ∪ μ<sub>2</sub></p>
        <p>Write card[Ω](μ) for the cardinality of solution mapping μ in a multiset of mappings Ω.</p>
        <div class="div3">
          <h4><a name="BGPsparql" id="BGPsparql"></a>18.3.1 SPARQL Basic Graph Pattern Matching</h4>
          <p>A basic graph pattern is matched against the active graph for that part of the query. Basic graph patterns can be instantiated by replacing both variables and blank nodes by terms,
          giving two notions of instance. Blank nodes are replaced using an <a href="http://www.w3.org/TR/rdf-mt#definst">RDF instance mapping</a>, &nbsp;σ, from blank nodes to RDF terms; variables
          are replaced by a solution mapping from query variables to RDF terms.</p>
          <div class="defn">
            <b>Definition: <a id="defn_PatternInstanceMapping" name="defn_PatternInstanceMapping">Pattern Instance Mapping</a></b>
            <p>A <b>Pattern Instance Mapping</b>, P, is the combination of an RDF instance mapping, σ, and solution mapping, μ. P(x) = μ(σ(x))</p>
          </div>
          <p>For a BGP 'x', P(x) denotes the result of replacing blank nodes b in x for which σ is defined with σ(b) and all variables v in x for which μ is defined with μ(v).</p>
          <p>Any pattern instance mapping defines a unique solution mapping and a unique RDF instance mapping obtained by restricting it to query variables and blank nodes respectively.</p>
          <div class="defn">
            <b>Definition: Basic Graph Pattern Matching</b>
            <p>Let BGP be a basic graph pattern and let G be an RDF graph.</p>
            <p>μ is a <b>solution</b> for BGP from G when there is a pattern instance mapping P such that P(BGP) is a subgraph of G and μ is the restriction of P to the query variables in BGP.</p>
            <p>card[Ω](μ) = card[Ω](number of distinct RDF instance mappings, σ, such that P = μ(σ) is a pattern instance mapping and P(BGP) is a subgraph of G).</p>
          </div>
          <p>If a basic graph pattern is the empty set, then the solution is Ω<sub>0</sub>.</p>
        </div>
        <div class="div3">
          <h4><a name="BGPsparqlBNodes" id="BGPsparqlBNodes"></a>18.3.2 Treatment of Blank Nodes</h4>
          <p>This definition allows the solution mapping to bind a variable in a basic graph pattern, BGP, to a blank node in G. Since SPARQL treats blank node identifiers in a results format
          document (<a href="http://www.w3.org/TR/rdf-sparql-XMLres/">SPARQL Query Results XML Format</a>, <a href="http://www.w3.org/TR/sparql11-results-json/">SPARQL 1.1 Query Results JSON
          Format</a> and <a href="http://www.w3.org/TR/sparql11-results-csv-tsv/">SPARQL 1.1 Query Results CSV and TSV Formats</a>) as scoped to the document, they cannot be understood as identifying
          nodes in the active graph of the dataset. If DS is the dataset of a query, pattern solutions are therefore understood to be not from the active graph of DS itself, but from an RDF graph,
          called the <i>scoping graph,</i> which is graph-equivalent to the active graph of DS but shares no blank nodes with DS or with BGP. The same scoping graph is used for all solutions to a
          single query. The scoping graph is purely a theoretical construct; in practice, the effect is obtained simply by the document scope conventions for blank node identifiers.</p>
          <p>Since RDF blank nodes allow infinitely many redundant solutions for many patterns, there can be infinitely many pattern solutions (obtained by replacing blank nodes by different blank
          nodes). It is necessary, therefore, to somehow delimit the solutions for a basic graph pattern. SPARQL uses the subgraph match criterion to determine the solutions of a basic graph pattern.
          There is one solution for each distinct pattern instance mapping from the basic graph pattern to a subset of the active graph.</p>
          <p>This is optimized for ease of computation rather than redundancy elimination. It allows query results to contain redundancies even when the active graph of the dataset is <a href=
          "http://www.w3.org/TR/rdf-mt/#deflean">lean</a>, and it allows logically equivalent datasets to yield different query results.</p>
        </div>
      </div>
      <div class="div2">
        <h3><a name="PropertyPathPatterns" id="PropertyPathPatterns"></a>18.4 Property Path Patterns</h3>
        <p>This section defines the evaluation of <a href="#defn_PropertyPathPattern">property path patterns</a>. A property path pattern is a subject endpoint (an RDF term or a variable), a property
        path express and an object endpoint. The <a href="#sparqlTranslatePathExpressions">translation of property path expressions</a> converts some forms to other SPARQL expressions, such as
        converting property paths of length one to triple patterns, which in turn are combined into basic graph patterns. This leaves property path operators ZeroOrOnePath, ZeroOrMorePath,
        OneOrMorePath and NegatedPropertySets and also path expressions contained within these operators.</p>
        <p>All remaining property path expressions are present in the algebra in the form <code>Path(X, path, Y)</code> for endpoints X and Y. For example: syntax<code>(:p/:q)*</code> is a
        ZeroOrMorePath expression involving a sequence property path becoming the algebra expession <code>ZeroOrMorePath(seq(link(:p), link(:q)))</code>.</p>
        <div class="defn">
          <p><b><a name="pp-eval-notation" id="pp-eval-notation">Notation</a></b></p>
          <p>Write</p>
          <pre>eval(Path(X, PP, Y))</pre>
          <p>for the evaluation of the property path patterns. This produces a multiset of solution mappings μ, each solution mapping having a binding for variables used (each of X and Y can be a
          variable). Some operators only produce a set of solution mappings.</p>
          <p>Write</p>
          <div class="pre">
            Var(x<sub>1</sub>, x<sub>2</sub>, ..., x<sub>n</sub>) = { x<sub>i</sub> | i in 1...n and x<sub>i</sub> is a variable }
          </div>
          <p>for the variables in <code>x<sub>1</sub>, x<sub>2</sub>, ..., x<sub>n</sub></code>.</p>
          <p>Write</p>
          <table style="border-collapse: collapse; border-color: #000000" cellpadding="10" border="1">
            <tbody>
              <tr>
                <td><code>x:term</code></td>
                <td>when <code>x</code> is an RDF term</td>
              </tr>
              <tr>
                <td><code>x:var</code></td>
                <td>when <code>x</code> is a variable</td>
              </tr>
              <tr>
                <td><code>x:path</code></td>
                <td>when <code>x</code> is a path expression</td>
              </tr>
            </tbody>
          </table>
        </div>
        <p>All evaluation is carried out by matching the <a href="#defn_ActiveGraph">active graph</a> at that point in the overall query evaluation. We omit explicitly including the active graph in
        each definition for clarity.</p>
        <div class="defn">
          <p><b>Definition: <a name="defn_evalPP_predicate" id="defn_evalPP_predicate">Evaluation of Predicate Property Path</a></b></p>
          <p>Let Path(X, link(iri), Y) be an predicate inverse property path pattern, using some IRI iri.</p>
          <blockquote>
            <div class="pre">
              eval(Path(X, link(iri), Y)) = <a href="#BasicGraphPattern">evaluation of basic graph pattern</a> {X iri Y}
            </div>
          </blockquote>
        </div>
        <p>If both X and Y are variables, this is the same as:</p>
        <div class="pre">
          eval(Path(X:var, link(iri), Y:var)) = { (X, xn) (Y, yn) | xn and yn are RDF terms and triple (xn iri yn) is in the active graph }
        </div>
        <p>If X is a variable and Y an RDF term:</p>
        <div class="pre">
          eval(Path(X:var, link(iri), Y:term)) = { (X, xn) | xn is an RDF term and triple (xn iri Y) is in the active graph }
        </div>
        <p>If X is an RDF term and Y is a variable:</p>
        <div class="pre">
          eval(Path(X:term, link(iri), Y:var)) = { (Y, yn) | yn is an RDF term and triple (X iri yn) is in the active graph }
        </div>
        <p>If both X and Y are RDF terms:</p>
        <div class="pre">
          eval(Path(X:term, link(iri), Y:term)) = { μ<sub>0</sub> } if triple (X iri Y) is in the active graph = { { } } = Ω<sub>0</sub> eval(Path(X:term, link(iri), Y:term)) = { } if triple (X iri
          Y) is not in the active graph
        </div>
        <p>Informally, evaluating a Predicate Property Path is the same as executing a subquery <code>SELECT * { <i>X P Y</i> }</code> at that point in the query evaluation.</p>
        <div class="defn">
          <p><b>Definition: <a name="defn_evalPP_inverse" id="defn_evalPP_inverse">Evaluation of Inverse Property Path</a></b></p>
          <p>Let P be a property path expression, then:</p>
          <blockquote>
            <pre>eval(Path(X, inv(P), Y)) = eval(Path(Y, P, X))</pre>
          </blockquote>
        </div>
        <div class="defn">
          <p><b>Definition: <a name="defn_evalPP_sequence" id="defn_evalPP_sequence">Evaluation of Sequence Property Path</a></b></p>
          <p>Let P and Q be property path expressions. Let V be a fresh variable.</p>
          <blockquote>
            <pre>A = Join( eval(Path(X, P, V)), eval(Path(V, Q, Y)) )</pre>
            <pre>eval(Path(X, seq(P,Q), Y)) = Project(A, Var(X,Y))</pre>
          </blockquote>
        </div>
        <p>Informally, this is the same as:</p>
        <pre>SELECT * { X P _:a . _:a Q Y }</pre>
        <p>using the fact that a blank node <code>_:a</code> acts like a variable (under simple entailment) except it does not appear in the results from <code>SELECT *</code>.</p>
        <div class="defn">
          <p><b>Definition: <a name="defn_evalPP_alternative" id="defn_evalPP_alternative">Evaluation of Alternative Property Path</a></b></p>
          <p>Let P and Q be property path expressions.</p>
          <blockquote>
            <pre>eval(Path(X, alt(P,Q), Y)) = Union(eval(Path(X, P, Y)), eval(Path(X, Q, Y)))</pre>
          </blockquote>
        </div>
        <p>Informally, this is the same as:</p>
        <pre>SELECT * { { X P Y } UNION { X Q Y } }</pre>
        <div class="defn">
          <p><b>Definition: <a id="defn_nodeSet" name="defn_nodeSet">Node set of a graph</a></b></p>
          <p>The node set of a graph G, nodes(G), is:</p>
          <p>nodes(G) = { n | n is an RDF term that is used as a subject or object of a triple of G}</p>
        </div>
        <div class="defn">
          <p><b>Definition: <a id="defn_evalPP_ZeroOrOnePath">Evaluation of ZeroOrOnePath</a></b></p>
          <pre>eval(Path(X:term, ZeroOrOnePath(P), Y:var)) = { (Y, yn) | yn = X or {(Y, yn)} in eval(Path(X,P,Y)) }</pre>
          <pre>eval(Path(X:var, ZeroOrOnePath(P), Y:term)) = { (X, xn) | xn = Y or {(X, xn)} in eval(Path(X,P,Y)) }</pre>
          <pre>eval(Path(X:term, ZeroOrOnePath(P), Y:term)) = 
    { {} } if X = Y or eval(Path(X,P,Y)) is not empty
    { } othewise</pre>
          <pre>eval(Path(X:var, ZeroOrOnePath(P), Y:var)) = 
    { (X, xn) (Y, yn) | either (yn in nodes(G) and xn = yn) or {(X,xn), (Y,yn)} in eval(Path(X,P,Y)) }</pre>
        </div>
        <p>We define an auxillary function, ALP, used in the definitions of ZeroOrMorePath and OneOrMorePath. Note that the algorithm given here serves to specify the feature. An implementation is
        free to implement evaluation by any method that produces the same results for the query overall. The ZeroOrMorePath and OneOrMorePath forms return matches based on distinct nodes connected by
        the path.</p>
        <p>The matching algorithm is based on following all paths, and detecting when a graph node (subject or object), has been already visited on the path.</p>
        <p>Informally, this algorithm attempts to extend the multiset of results by one application of <tt>path</tt> at each step, noting which nodes it has visited for this particular path. If a
        node has been visited for the path under consideration, it is not a candidate for another step.</p>
        <div class="defn">
          <p><b>Definition: <a name="defn_evalALP_1" id="defn_evalALP_1">Function ALP</a></b></p>
          <pre>Let eval(x:term, path) be the evaluation of 'path', starting at RDF term x, 
                       and returning a multiset of RDF terms reached 
                       by repeated matches of path.

ALP(x:term, path) = 
    Let V = empty multiset
    ALP(x:term, path, V)
    return is V

# V is the set of nodes visited

ALP(x:term, path, V:set of RDF terms) =
    if ( x in V ) return 
    add x to V
    X = eval(x,path) 
    For n:term in X
        ALP(n, path, V)
        End
</pre>
        </div>
        <div class="defn">
          <p><b>Definition: Evaluation of <a name="defn_evalZeroOrMorePath" id="defn_evalZeroOrMorePath">ZeroOrMorePath</a></b></p>
          <pre>eval(Path(X:term, ZeroOrMorePath(path), vy:var)) =
    { { (vy, n) } | n in ALP(X, path) }

eval(Path(vx:var, ZeroOrMorePath(path), vy:var)) =
    { { (vx, t), (vy, n) } |  t in nodes(G), (vy, n) in eval(Path(t, ZeroOrMorePath(path), vy)) }

eval(Path(vx:var, ZeroOrMorePath(path), y:term)) = 
    eval(Path(y:term, ZeroOrMorePath(inv(path)), vx:var))

eval(Path(x:term, ZeroOrMorePath(path), y:term)) = 
    { { } } if { (vy:var,y) } in eval(Path(x, ZeroOrMorePath(path) vy)
    { } otherwise
        </pre>
        </div>
        <div class="defn">
          <p><b>Definition: Evaluation of <a name="defn_evalOneOrMorePath" id="defn_evalOneOrMorePath">OneOrMorePath</a></b></p>
          <p>eval(Path(X, OneOrMorePath(path), Y))</p>
          <pre># For OneOrMorePath, we take one step of the path then start
# recording nodes for results.

eval(Path(x:term, OneOrMorePath(path), vy:var)) =
    Let X = eval(x, path)
    Let V = the empty multiset
    For n in X
        ALP(n, path, V)
        End
    result is V

eval(Path(vx:var, OneOrMorePath(path), vy:var)) =
   { { (vx, t), (vy, n) } |  t in nodes(G), (vy, n) in eval(Path(t, OneOrMorePath(path), vy)) }

eval(Path(vx:var, OneOrMorePath(path), y:term)) =
   eval(Path(y:term, OneOrMorePath(inv(path)), vx))

eval(Path(x:term, OneOrMorePath(path), y:term)) =
    { { } } if { (vy:var, y) } in eval(Path(x, OneOrMorePath(path), vy))
    { } otherwise
        </pre>
        </div>
        <div class="defn">
          <p><b>Definition: <a id="eval_negatedPropertySet" name="eval_negatedPropertySet">Evaluation of NegatedPropertySet</a></b></p>
          <pre class="code">Write μ' as the extension of a solution mapping:
μ'(μ,x) = μ(x)   if x is a variable
μ'(μ,t) = t   if t is a RDF term
        </pre>
          <pre class="code">Let x and y be variables or RDF terms, and S a set of IRIs:

eval(Path(x, NPS(S), y)) = { μ | ∃ triple(μ'(μ,x), p, μ'(μ,y)) in G, such that the IRI of p ∉ S }
        </pre>
        </div>
      </div>
      <div class="div2">
        <h3><a name="sparqlAlgebra" id="sparqlAlgebra"></a>18.5 SPARQL Algebra</h3>
        <p>For each remaining symbol in a SPARQL abstract query, we define an operator for evaluation. The SPARQL algebra operators of the same name are used to evaluate SPARQL abstract query nodes
        as described in the section "<a href="#sparqlAlgebraEval">Evaluation Semantics</a>". Evaluation of basic graph patterns and property path patterns has been described above.</p>
        <div class="defn">
          <p><b>Definition: <a id="defn_algFilter" name="defn_algFilter">Filter</a></b></p>
          <p>Let Ω be a multiset of solution mappings and expr be an expression. We define:</p>
          <p>Filter(expr, Ω, D(G)) = { μ | μ in Ω and expr(μ) is an expression that has an effective boolean value of true }</p>
          <p>card[Filter(expr, Ω, D(G))](μ) = card[Ω](μ)</p>
          <blockquote>
            Note that evaluating an <code>exists(pattern)</code> expression uses the dataset and active graph, D(G). See the <a href="#defn_evalFilter">evaluation of filter</a>.
          </blockquote>
        </div>
        <div class="defn">
          <p><b>Definition: <a id="defn_algJoin" name="defn_algJoin">Join</a></b></p>
          <p>Let Ω<sub>1</sub> and Ω<sub>2</sub> be multisets of solution mappings. We define:</p>
          <p>Join(Ω<sub>1</sub>, Ω<sub>2</sub>) = { merge(μ<sub>1</sub>, μ<sub>2</sub>) | μ<sub>1</sub> in Ω<sub>1</sub>and μ<sub>2</sub> in Ω<sub>2</sub>, and μ<sub>1</sub> and μ<sub>2</sub> are
          compatible }</p>
          <p>card[Join(Ω<sub>1</sub>, Ω<sub>2</sub>)](μ) =<br>
          &nbsp;&nbsp;&nbsp; for each merge(μ<sub>1</sub>, μ<sub>2</sub>), μ<sub>1</sub> in Ω<sub>1</sub>and μ<sub>2</sub> in Ω<sub>2</sub> such that μ = merge(μ<sub>1</sub>, μ<sub>2</sub>),<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sum over (μ<sub>1</sub>, μ<sub>2</sub>), card[Ω<sub>1</sub>](μ<sub>1</sub>)*card[Ω<sub>2</sub>](μ<sub>2</sub>)</p>
        </div>
        <p>It is possible that a solution mapping μ in a Join can arise in different solution mappings, μ<sub>1</sub>and μ<sub>2</sub> in the multisets being joined. The cardinality of&nbsp; μ is the
        sum of the cardinalities from all possibilities.</p>
        <div class="defn">
          <p><b>Definition: <a id="defn_algDiff" name="defn_algDiff">Diff</a></b></p>
          <p>Let Ω<sub>1</sub> and Ω<sub>2</sub> be multisets of solution mappings and expr be an expression. We define:</p>
          <p>Diff(Ω<sub>1</sub>, Ω<sub>2</sub>, expr) = { μ | μ in Ω<sub>1</sub> such that ∀ μ′ in Ω<sub>2</sub>, either μ and μ′ are not compatible or μ and μ' are compatible and expr(merge(μ, μ'))
          has an effective boolean value of false }</p>
          <p>card[Diff(Ω<sub>1</sub>, Ω<sub>2</sub>, expr)](μ) = card[Ω<sub>1</sub>](μ)</p>
        </div>
        <p>Diff is used internally for the definition of LeftJoin.</p>
        <div class="defn">
          <p><b>Definition: <a id="defn_algLeftJoin" name="defn_algLeftJoin">LeftJoin</a></b></p>
          <p>Let Ω<sub>1</sub> and Ω<sub>2</sub> be multisets of solution mappings and expr be an expression. We define:</p>
          <p>LeftJoin(Ω<sub>1</sub>, Ω<sub>2</sub>, expr) = Filter(expr, Join(Ω<sub>1</sub>, Ω<sub>2</sub>)) ∪ Diff(Ω<sub>1</sub>, Ω<sub>2</sub>, expr)</p>
          <p>card[LeftJoin(Ω<sub>1</sub>, Ω<sub>2</sub>, expr)](μ) = card[Filter(expr, Join(Ω<sub>1</sub>, Ω<sub>2</sub>))](μ) + card[Diff(Ω<sub>1</sub>, Ω<sub>2</sub>, expr)](μ)</p>
        </div>
        <p>Written in full that is:</p>
        <p>LeftJoin(Ω<sub>1</sub>, Ω<sub>2</sub>, expr) =<br>
        &nbsp;&nbsp;&nbsp; { merge(μ<sub>1,</sub> μ<sub>2</sub>) | μ<sub>1</sub> in Ω<sub>1</sub> and μ<sub>2</sub> in Ω<sub>2</sub>, μ<sub>1</sub> and μ<sub>2</sub> are compatible and
        expr(merge(μ<sub>1</sub>, μ<sub>2</sub>)) is true }<br>
        ∪<br>
        &nbsp;&nbsp;&nbsp; { μ<sub>1</sub> | μ<sub>1</sub> in Ω<sub>1</sub>, ∀ μ<sub>2</sub> in Ω<sub>2</sub>, μ<sub>1</sub> and μ<sub>2</sub> are not compatible, or Ω<sub>2</sub> is empty }<br>
        ∪<br>
        &nbsp;&nbsp;&nbsp; { μ<sub>1</sub> | μ<sub>1</sub> in Ω<sub>1</sub>, ∃ μ<sub>2</sub> in Ω<sub>2</sub>, μ<sub>1</sub> and μ<sub>2</sub> are compatible and expr(merge(μ<sub>1</sub>,
        μ<sub>2</sub>)) is false. }</p>
        <p>As these are distinct, the cardinality of LeftJoin is cardinality of these individual components of the definition.</p>
        <div class="defn">
          <p><b>Definition: <a id="defn_algUnion" name="defn_algUnion">Union</a></b></p>
          <p>Let Ω<sub>1</sub> and Ω<sub>2</sub> be multisets of solution mappings. We define:</p>
          <p>Union(Ω<sub>1</sub>, Ω<sub>2</sub>) = { μ | μ in Ω<sub>1</sub> or μ in Ω<sub>2</sub> }</p>
          <p>card[Union(Ω<sub>1</sub>, Ω<sub>2</sub>)](μ) = card[Ω<sub>1</sub>](μ) + card[Ω<sub>2</sub>](μ)</p>
        </div>
        <div class="defn">
          <p><b>Definition: <a id="defn_algMinus" name="defn_algMinus">Minus</a></b></p>
          <p>Let Ω<sub>1</sub> and Ω<sub>2</sub> be multisets of solution mappings. We define:</p>
          <p>Minus(Ω<sub>1</sub>, Ω<sub>2</sub>) = { μ | μ in Ω<sub>1</sub> . ∀ μ' in Ω<sub>2</sub>, either μ and μ' are not compatible or dom(μ) and dom(μ') are disjoint }</p>
          <p>card[Minus(Ω<sub>1</sub>, Ω<sub>2</sub>)](μ) = card[Ω<sub>1</sub>](μ)</p>
        </div>
        <p>The additional restriction on dom(μ) and dom(μ') is added because otherwise if there is a solution mapping in Ω<sub>2</sub> that has no variables in common with the solution mappings of
        Ω<sub>1</sub>, then Minus(Ω<sub>1</sub>, Ω<sub>2</sub>) would be empty, regardless of the rest of Ω<sub>2</sub>. The empty solution mapping is compatible with every other solution mapping so
        <code>P MINUS {}</code> would otherwise be empty for any pattern <code>P</code>.</p>
        <div class="defn">
          <b>Definition: <a name="defn_extend" id="defn_extend">Extend</a></b>
          <p>Let μ be a solution mapping, Ω a multiset of solution mappings, <i>var</i> a variable and <i>expr</i> be an <a href="#expressions">expression</a>, then we define:</p>
          <p>Extend(μ, var, expr) = μ ∪ { (var,value) | var not in dom(μ) and value = expr(μ) }</p>
          <p>Extend(μ, var, expr) = μ if var not in dom(μ) and expr(μ) is an error</p>
          <p>Extend is undefined when var in dom(μ).</p>
          <p>Extend(Ω, var, expr) = { Extend(μ, var, expr) | μ in Ω }</p>
        </div>
        <p>Write [ x | C ] for a sequence of elements where C is a condition on x.</p>
        <p>Write card[L](x) to be the cardinality of x in L.</p>
        <div class="defn">
          <b>Definition: <a id="defn_algToList" name="defn_algToList">ToList</a></b>
          <p>Let Ω be a multiset of solution mappings. We define:</p>
          <p>ToList(Ω) = a sequence of mappings μ in Ω in any order, with card[Ω](μ) occurrences of μ</p>
          <p>card[ToList(Ω)](μ) = card[Ω](μ)</p>
        </div>
        <div class="defn">
          <b>Definition: <a id="defn_algOrdered" name="defn_algOrdered">OrderBy</a></b>
          <p>Let Ψ be a sequence of solution mappings. We define:</p>
          <p><a id="defn_algOrderBy" name="defn_algOrderBy">OrderBy</a>(Ψ, condition) = [ μ | μ in Ψ and the sequence satisfies the ordering condition]</p>
          <p>card[OrderBy(Ψ, condition)](μ) = card[Ψ](μ)</p>
        </div>
        <div class="defn">
          <b>Definition: <a id="defn_algProjection" name="defn_algProjection">Project</a></b>
          <p>Let Ψ be a sequence of solution mappings and PV a set of variables.</p>
          <p>For mapping μ, write Proj(μ, PV) to be the restriction of μ to variables in PV.</p>
          <p>Project(Ψ, PV) = [ Proj(Ψ[μ], PV) | μ in Ψ ]</p>
          <p>card[Project(Ψ, PV)](μ) = card[Ψ](μ)</p>
          <p>The order of Project(Ψ, PV) must preserve any ordering given by OrderBy.</p>
        </div>
        <div class="defn">
          <b>Definition: <a id="defn_algDistinct" name="defn_algDistinct">Distinct</a></b>
          <p>Let Ψ be a sequence of solution mappings. We define:</p>
          <p>Distinct(Ψ) = [ μ | μ in Ψ ]</p>
          <p>card[Distinct(Ψ)](μ) = 1</p>
          <p>The order of Distinct(Ψ) must preserve any ordering given by OrderBy.</p>
        </div>
        <div class="defn">
          <b>Definition: <a id="defn_algReduced" name="defn_algReduced">Reduced</a></b>
          <p>Let Ψ be a sequence of solution mappings. We define:</p>
          <p>Reduced(Ψ) = [ μ | μ in Ψ ]</p>
          <p>card[Reduced(Ψ)](μ) is between 1 and card[Ψ](μ)</p>
          <p>The order of Reduced(Ψ) must preserve any ordering given by OrderBy.</p>
        </div>
        <p>The Reduced solution sequence modifier does not guarantee a defined cardinality.</p>
        <div class="defn">
          <b>Definition: <a id="defn_algSlice" name="defn_algSlice">Slice</a></b>
          <p>Let Ψ be a sequence of solution mappings. We define:</p>
          <p><a name="defn_algOrderBy2" id="defn_algOrderBy2">Slice</a>(Ψ, start, length)[i] = Ψ[start+i] for i = 0 to (length-1)</p>
        </div>
        <div class="defn">
          <b>Definition: <a id="defn_algToMultiSet" name="defn_algToMultiSet">ToMultiSet</a></b>
          <p>Let Ψ be a solution sequence. We define:</p>
          <p>ToMultiSet(Ψ) = { μ | μ in Ψ }</p>
          <p>card[ToMultiSet(Ψ)](μ) = card[Ψ](μ)</p>
        </div>
        <p>ListEval is a function which is used to evaluate a list of expressions against a solution and return a list of the resulting values.</p>
        <div class="defn">
          <p><b><a name="defn_algToMultiset" id="defn_algToMultiset">Definition: ToMultiset</a></b></p>
          <p>ToMultiset turns a sequence into a multiset with the same elements and cardinality as the sequence. The order of the sequence has no effect on the resulting multiset, and duplicates are
          preserved.</p>
        </div>
        <div class="defn">
          <p><b>Definition: <a name="defn_exists" id="defn_exists">Exists</a></b></p>
          <p>exists(pattern) is a function that returns true if the pattern <a href="#defn_evalExists">evaluates</a> to a non-empty solution sequence, given the current solution mapping and active
          graph at the time of evaluation; otherwise it returns false.</p>
        </div>
        <div class="div3">
          <h4><a name="aggregateAlgebra" id="aggregateAlgebra"></a>18.5.1 Aggregate Algebra</h4>
          <p>Group is a function which groups a solution sequence into multiple solutions, based on some attribute of the solutions.</p>
          <div class="defn">
            <p><b><a name="defn_algGroup" id="defn_algGroup">Definition: Group</a></b></p>
            <p>Group evaluates a list of expressions against a solution sequence, producing a set of partial functions from keys to solution sequences.</p>
            <p>Group(exprlist, Ω) = { ListEval(exprlist, μ) → { μ' | μ' in Ω, ListEval(exprlist, μ) = ListEval(exprlist, μ') } | μ in Ω }</p>
          </div>
          <div class="defn">
            <p><b>Definition: ListEval</b></p>
            <p>ListEval((expr<sub>1</sub>, ..., expr<sub>n</sub>), μ) returns a list (e<sub>1</sub>, ..., e<sub>n</sub>), where e<sub>i</sub> = expr<sub>i</sub>(μ) or error.</p>
            <p>ListEval retains errors resulting from the evaluation of the list elements.</p>
          </div>
          <p>Note that, although the result of a ListEval can be an error, and errors may be used to group, solutions containing error values are removed at projection time.</p>
          <p>ListEval((unbound), μ) = (error), as the evaluation of an unbound expression is an error.</p>
          <p>Aggregation, a function which calculates a scalar value as an output of the aggregate expression. It is used in the SELECT clause, the HAVING evaluation process, and in ORDER BY (where
          required). Aggregation calculates aggregated values over groups of solutions, using set functions.</p>
          <div class="defn">
            <p><b><a name="defn_algAggregation" id="defn_algAggregation">Definition: Aggregation</a></b></p>
            <p>Let <i>exprlist</i> be a list of expressions or *, <i>func</i> a set function, <i>scalarvals</i> a set of partial functions (possibly empty) passed from the aggregate in the query, and
            let { key<sub>1</sub>→Ω<sub>1</sub>, ..., key<sub>m</sub>→Ω<sub>m</sub> } be a multiset of partial functions from keys to solution sequences as produced by the grouping step.</p>
            <p>Aggregation applies the set function func to the given multiset and produces a single value for each key and partition of solutions for that key.</p>
            <p>Aggregation(exprlist, func, scalarvals, { key<sub>1</sub>→Ω<sub>1</sub>, ..., key<sub>m</sub>→Ω<sub>m</sub> } )<br>
            &nbsp;&nbsp;&nbsp;= { (key, F(Ω)) | key → Ω in { key<sub>1</sub>→Ω<sub>1</sub>, ..., key<sub>m</sub>→Ω<sub>m</sub> } }</p>
            <p>where<br>
            &nbsp;&nbsp;M(Ω) = { ListEval(exprlist, μ) | μ in Ω }<br>
            &nbsp;&nbsp;F(Ω) = func(M(Ω), scalarvals), for non-DISTINCT<br>
            &nbsp;&nbsp;F(Ω) = func(Distinct(M(Ω)), scalarvals), for DISTINCT</p>
            <p><b>Special Case:</b> when <code>COUNT</code> is used with the expression <code>*</code> the value of F will be the cardinality of the group solution sequence, <code>card[Ω]</code>, or
            <code>card[Distinct(Ω)]</code> if the <code>DISTINCT</code> keyword is present.</p>
          </div>
          <p><i>scalarvals</i> are used to pass values to the underlying set function, bypassing the mechanics of the grouping. For example, the aggregate expression <code>GROUP_CONCAT(?x ;
          separator="|")</code> has a scalarvals argument of { "separator" → "|" }.</p>
          <p>All aggregates may have the <code>DISTINCT</code> keyword as the first token in their argument list. If this keyword is present then first argument to func is Distinct(M).</p>
          <p>Example</p>
          <p>Given a solution multiset (Ω) with the following values:</p>
          <table>
            <tbody>
              <tr>
                <td>solution</td>
                <td>?x</td>
                <td>?y</td>
                <td>?z</td>
              </tr>
              <tr>
                <td>μ<sub>1</sub></td>
                <td>1</td>
                <td>2</td>
                <td>3</td>
              </tr>
              <tr>
                <td>μ<sub>2</sub></td>
                <td>1</td>
                <td>3</td>
                <td>4</td>
              </tr>
              <tr>
                <td>μ<sub>3</sub></td>
                <td>2</td>
                <td>5</td>
                <td>6</td>
              </tr>
            </tbody>
          </table>
          <p>And the query expression SELECT (ex:agg(?y, ?z) AS ?agg) WHERE { ?x ?y ?z } GROUP BY ?x.</p>
          <p>We produce G = Group((?x), Ω) = { ( (1), { μ<sub>1</sub>, μ<sub>2</sub> } ), ( (2), { μ<sub>3</sub> } ) }</p>
          <p>And so Aggregation((?y, ?z), ex:agg, {}, G) =<br>
          { ((1), eg:agg({(2, 3), (3, 4)}, {})), ((2), eg:agg({(5, 6)}, {})) }.</p>
          <div class="defn">
            <p><b>Definition: AggregateJoin</b></p>
            <p>Let S<sub>1</sub>, ..., S<sub>n</sub> be a list of sets, where each set S<sub>i</sub> contains key to (aggregated) value maps as produced by Aggregate.</p>
            <p>Let K = { key | key in dom(S<sub>j</sub>) for some 1 &lt;= j &lt;= n } be the set of keys, then<br>
            AggregateJoin(S<sub>1</sub>, ..., S<sub>n</sub>) = { agg<sub>1</sub>→val<sub>1</sub>, ..., agg<sub>n</sub>→val<sub>n</sub> | key in K and key→val<sub>i</sub> in S<sub>i</sub> for each 1
            &lt;= i &lt;= n }</p>
          </div>
          <p>Flatten is a function which is used to collapse multisets of lists into a multiset, so for example { (1, 2), (3, 4) } becomes { 1, 2, 3, 4 }.</p>
          <div class="defn">
            <p><b>Definition: Flatten</b></p>
            <p>The Flatten(M) function takes a multiset of lists, M {(L<sub>1</sub>, L<sub>2</sub>, ...), ...}, and returns the multiset { x | L in M and x in L }.</p>
          </div>
          <div class="div4">
            <h5><a name="setFunctions" id="setFunctions"></a>18.5.1.1 Set Functions</h5>
            <p>The set functions which underlie SPARQL aggregates all have a common signature: SetFunc(M), or SetFunc(M, scalarvals) where M is a multiset of lists, and scalarvals is one or more
            scalar values that are passed to the set function indirectly via the ( ... ; key=value ) syntax for aggregates in the SPARQL grammar. The only use of this that is supported by the
            built-in aggregates in SPARQL Query 1.1 is <code>GROUP_CONCAT</code>, as in <code>GROUP_CONCAT(?x ; separator=", ")</code>.</p>
            <p>Note that the name "Set Function" is somewhat historical — the arguments to set functions are in fact multisets. The name is retained due to the commonality with SQL Set Functions,
            which also operate over multisets.</p>
            <p>The set functions defined in this document are Count, Sum, Min, Max, Avg, GroupConcat, and Sample — corresponding to the aggregates <code>COUNT</code>, <code>SUM</code>,
            <code>MIN</code>, <code>MAX</code>, <code>AVG</code>, <code>GROUP_CONCAT</code>, and <code>SAMPLE</code>. Definitions may be found in the following sections. Systems may choose to expand
            this set using local extensions, using the same notation as for functions and casts. Note that, unless the ; separator is used this requires the parser to know whether some IRI refers to
            a function, cast, or aggregate before it can determine if there are any errors in a query where aggregates are used.</p>
          </div>
          <div class="div4">
            <h5><a name="defn_aggCount" id="defn_aggCount"></a>18.5.1.2 Count</h5>
            <p>Count is a SPARQL set function which counts the number of times a given expression has a bound, and non-error value within the aggregate group.</p>
            <div class="defn">
              <p><b>Definition: Count</b></p>xsd:integer Count(multiset M)
              <p>N = Flatten(M)</p>
              <p>remove error elements from N</p>
              <p>Count(M) = card[N]</p>
            </div>
          </div>
          <div class="div4">
            <h5><a name="defn_aggSum" id="defn_aggSum"></a>18.5.1.3 Sum</h5>
            <p>Sum is a SPARQL set function that will return the numeric value obtained by summing the values within the aggregate group. Type promotion happens as per the op:numeric-add function,
            applied transitively, (see definition below) so the value of SUM(?x), in an aggregate group where ?x has values 1 (integer), 2.0e0 (float), and 3.0 (decimal) will be 6.0 (float).</p>
            <div class="defn">
              <p><b>Definition: Sum</b></p>numeric Sum(multiset M)
              <p>The Sum set function is used by the <code>SUM</code> aggregate in the syntax.</p>
              <p>Sum(M) = Sum(ToList(Flatten(M))).</p>
              <p>Sum(S) = op:numeric-add(S<sub>1</sub>, Sum(S<sub>2..n</sub>)) when card[S] &gt; 1<br>
              Sum(S) = op:numeric-add(S<sub>1</sub>, 0) when card[S] = 1<br>
              Sum(S) = "0"^^xsd:integer when card[S] = 0</p>
              <p>In this way, Sum({1, 2, 3}) = op:numeric-add(1, op:numeric-add(2, op:numeric-add(3, 0))).</p>
            </div>
          </div>
          <div class="div4">
            <h5><a name="defn_aggAvg" id="defn_aggAvg"></a>18.5.1.4 Avg</h5>
            <p><a name="defn_algAvg" id="defn_algAvg"></a>The Avg set function calculates the average value for an expression over a group. It is defined in terms of Sum and Count.</p>
            <div class="defn">
              <p><b>Definition: Avg</b></p>numeric Avg(multiset M)
              <p>Avg(M) = "0"^^xsd:integer, where Count(M) = 0</p>
              <p>Avg(M) = Sum(M) / Count(M), where Count(M) &gt; 0</p>
            </div>
            <p>For example, Avg({1, 2, 3}) = Sum({1, 2, 3})/Count({1, 2, 3}) = 6/3 = 2.</p>
          </div>
          <div class="div4">
            <h5><a name="defn_aggMin" id="defn_aggMin"></a>18.5.1.5 Min</h5>
            <p>Min is a SPARQL set functions that returns the minimum value from a group respectively.</p>
            <p>It makes use of the SPARQL ORDER BY ordering definition, to allow ordering over arbitrarily typed expressions.</p>
            <div class="defn">
              <p><b>Definition: Min</b></p>term Min(multiset M)
              <p>Min(M) = Min(ToList(Flatten(M)))</p>
              <p>Min({}) = error.</p>
              <p>The flattened multiset of values passed as an argument is converted to a sequence S, this sequence is ordered as per the <code>ORDER BY ASC</code> clause.</p>
              <p>Min(S) = S<sub>0</sub></p>
            </div>
          </div>
          <div class="div4">
            <h5><a name="defn_aggMax" id="defn_aggMax"></a>18.5.1.6 Max</h5>
            <p>Max is a SPARQL set function that return the maximum value from a group respectively.</p>
            <p>It makes use of the SPARQL ORDER BY ordering definition, to allow ordering over arbitrarily typed expressions.</p>
            <div class="defn">
              <p><b>Definition: Max</b></p>term Max(multiset M)
              <p>Max(M) = Max(ToList(Flatten(M)))</p>
              <p>Max({}) = error.</p>
              <p>The multiset of values passed as an argument is converted to a sequence S, this sequence is ordered as per the <code>ORDER BY DESC</code> clause.</p>
              <p>Max(S) = S<sub>0</sub></p>
            </div>
          </div>
          <div class="div4">
            <h5><a name="defn_aggGroupConcat" id="defn_aggGroupConcat"></a>18.5.1.7 GroupConcat</h5>
            <p>GroupConcat is a set function which performs a string concatenation across the values of an expression with a group. The order of the strings is not specified. The separator character
            used in the concatenation may be given with the scalar argument SEPARATOR.</p>
            <div class="defn">
              <p><b>Definition: GroupConcat</b></p>literal GroupConcat(multiset M)
              <p>If the "separator" scalar argument is absent from GROUP_CONCAT then it is taken to be the "space" character, unicode codepoint U+0020.</p>
              <p>The multiset of values, M passed as an argument is converted to a sequence S.</p>
              <p>GroupConcat(M, scalarvals) = GroupConcat(Flatten(M), scalarvals("separator"))</p>
              <p>GroupConcat(S, sep) = "", where <span style="font-size: 140%">|</span>S<span style="font-size: 140%">|</span> = 0</p>
              <p>GroupConcat(S, sep) = CONCAT("", S<sub>0</sub>), where <span style="font-size: 140%">|</span>S<span style="font-size: 140%">|</span> = 1</p>
              <p>GroupConcat(S, sep) = CONCAT(S<sub>0</sub>, sep, GroupConcat(S<sub>1..n-1</sub>, sep)), where <span style="font-size: 140%">|</span>S<span style="font-size: 140%">|</span> &gt; 1</p>
            </div>
            <p>For example, GroupConcat({"a", "b", "c"}, {"separator" → "."}) = "a.b.c".</p>
          </div>
          <div class="div4">
            <h5><a name="defn_aggSample" id="defn_aggSample"></a>18.5.1.8 Sample</h5>
            <p>Sample is a set function which returns an arbitrary value from the multiset passed to it.</p>
            <div class="defn">
              <p><b>Definition: Sample</b></p>RDFTerm Sample(multiset M)
              <p>Sample(M) = v, where v in Flatten(M)</p>
              <p>Sample({}) = error</p>
            </div>
            <p>For example, given Sample({"a", "b", "c"}), "a", "b", and "c" are all valid return values. Note that Sample() is not required to be deterministic for a given input, the only
            restriction is that the output value must be present in the input multiset.</p>
          </div>
        </div>
      </div>
      <div class="div2">
        <h3><a name="sparqlAlgebraEval" id="sparqlAlgebraEval"></a>18.6 Evaluation Semantics</h3>
        <p>We define eval(D(G), algebra expression) as the evaluation of an algebra expression with respect to a dataset D having active graph G. The active graph is initially the default graph.</p>
        <pre class="box">D : a dataset
D(G) : D a dataset with active graph G (the one patterns match against)
D[i] : The graph with IRI i in dataset D
P, P1, P2 : graph patterns
L : a solution sequence
F : an expression</pre>
        <div class="defn">
          <b>Definition: <a id="defn_evalBasicGraphPattern" name="defn_evalBasicGraphPattern">Evaluation of a Basic Graph Pattern</a></b>
          <pre class="code">eval(D(G), BGP) = multiset of solution mappings</pre>
          <p>See section <a href="#BasicGraphPattern">Basic Graph Patterns</a></p>
        </div>
        <div class="defn">
          <b>Definition: <a id="defn_evalPropertyPathPattern" name="defn_evalPropertyPathPattern">Evaluation of a Property Path Pattern</a></b>
          <pre class="code">eval(D(G), Path(X, path, Y)) = multiset of solution mappings</pre>
          <p>See section <a href="#defn_PropertyPathExpr">Property Path Expresions</a></p>
        </div>
        <div class="defn">
          <b>Definition: <a id="defn_evalFilter" name="defn_evalFilter">Evaluation of Filter</a></b>
          <pre class="code">eval(D(G), Filter(F, P)) = Filter(F, eval(D(G),P), D(G))</pre>
        </div>
        <p>'substitute' is a filter function in support of the evaluation of <a href="#func-filter-exists"><code>EXISTS</code> and <code>NOT EXISTS</code></a> forms which were translated to
        <code>exists</code>.</p>
        <div class="defn">
          <p><b>Definition: <a name="defn_substitute" id="defn_substitute">Substitute</a></b></p>
          <p>Let μ be a solution mapping.</p>
          <blockquote>
            <p>substitute(<i>pattern</i>, μ) = the pattern formed by replacing every occurrence of a variable v in <i>pattern</i> by μ(v) for each v in dom(μ)</p>
          </blockquote>
        </div>
        <div class="defn">
          <p><b>Definition: <a name="defn_evalExists" id="defn_evalExists">Evaluation of Exists</a></b></p>
          <p>Let μ be the current solution mapping for a filter and P a graph pattern:</p>
          <blockquote>
            The value exists(P), given D(G) is true if and only if eval(D(G), substitute(P, μ)) is a non-empty sequence.
          </blockquote>
        </div>
        <div class="defn">
          <b>Definition: <a id="defn_evalJoin" name="defn_evalJoin">Evaluation of Join</a></b>
          <pre class="code">eval(D(G), Join(P1, P2)) = Join(eval(D(G), P1), eval(D(G), P2))</pre>
        </div>
        <div class="defn">
          <b>Definition: <a id="defn_evalLeftJoin" name="defn_evalLeftJoin">Evaluation of LeftJoin</a></b>
          <pre class="code">eval(D(G), LeftJoin(P1, P2, F)) = LeftJoin(eval(D(G), P1), eval(D(G), P2), F)</pre>
        </div>
        <div class="defn">
          <b>Definition: <a id="defn_evalUnion" name="defn_evalUnion">Evaluation of Union</a></b>
          <pre class="code">eval(D(G), Union(P1,P2)) = Union(eval(D(G), P1), eval(D(G), P2))</pre>
        </div>
        <div class="defn">
          <b>Definition: <a id="defn_evalGraph" name="defn_evalGraph">Evaluation of Graph</a></b>
          <pre class="code">if IRI is a graph name in D
eval(D(G), Graph(IRI,P)) = eval(D(D[IRI]), P)</pre>
          <pre class="code">if IRI is not a graph name in D
eval(D(G), Graph(IRI,P)) = the empty multiset</pre>
          <pre class="code">eval(D(G), Graph(var,P)) =
     Let R be the empty multiset
     foreach IRI i in D
        R := Union(R, Join( eval(D(D[i]), P) , Ω(?var-&gt;i) )
     the result is R
          </pre>
        </div>
        <p>The evaluation of graph uses the SPARQL algebra union operator. The cardinality of a solution mapping is the sum of the cardinalities of that solution mapping in each join operation.</p>
        <div class="defn">
          <p><b><a name="defn_evalGroup" id="defn_evalGroup">Definition: Evaluation of Group</a></b></p>
          <p>eval(D(G), Group(exprlist, P)) = Group(exprlist, eval(D(G), P))</p>
        </div>
        <div class="defn">
          <p><b><a name="defn_evalAggregation" id="defn_evalAggregation">Definition: Evaluation of Aggregation</a></b></p>
          <p>eval(D(G), Aggregation(exprlist, func, scalarvals, P)) = Aggregation(exprlist, func, scalarvals, eval(D(G), P))</p>
        </div>
        <div class="defn">
          <p><b><a name="defn_evalAggregateJoin" id="defn_evalAggregateJoin">Definition: Evaluation of AggregateJoin</a></b></p>
          <p>eval(D(G), AggregateJoin(A<sub>1</sub>, ..., A<sub>n</sub>)) = AggregateJoin(eval(D(G), A<sub>1</sub>), ..., eval(D(G), A<sub>n</sub>))</p>
        </div>
        <p>Note that if eval(D(G), A<sub>i</sub>) is an error, it is ignored.</p>
        <div class="defn">
          <b>Definition: <a id="defn_evalExtend" name="defn_evalExtend">Evaluation of Extend</a></b>
          <pre class="code">eval(D(G), Extend(P, var, expr)) = Extend(eval(D(G), P), var, expr)</pre>
        </div>
        <div class="defn">
          <b>Definition: <a id="defn_evalList" name="defn_evalList">Evaluation of ToList</a></b>
          <pre class="code">eval(D(G), ToList(P)) = ToList(eval(D(G), P))</pre>
        </div>
        <div class="defn">
          <b>Definition: <a id="defn_evalDistinct" name="defn_evalDistinct">Evaluation of Distinct</a></b>
          <pre class="code">eval(D(G), Distinct(L)) = Distinct(eval(D(G), L))
          </pre>
        </div>
        <div class="defn">
          <b>Definition: <a id="defn_evalReduced" name="defn_evalReduced">Evaluation of Reduced</a></b>
          <pre class="code">eval(D(G), Reduced(L)) = Reduced(eval(D(G), L))
          </pre>
        </div>
        <div class="defn">
          <b>Definition: <a id="defn_evalProject" name="defn_evalProject">Evaluation of Project</a></b>
          <pre class="code">eval(D(G), Project(L, vars)) = Project(eval(D(G), L), vars)
          </pre>
        </div>
        <div class="defn">
          <b>Definition: <a id="defn_evalOrderBy" name="defn_evalOrderBy">Evaluation of OrderBy</a></b>
          <pre class="code">eval(D(G), OrderBy(L, condition)) = OrderBy(eval(D(G), L), condition)
          </pre>
        </div>
        <div class="defn">
          <b>Definition: <a id="defn_evalToMultiSet" name="defn_evalToMultiSet">Evaluation of ToMultiSet</a></b>
          <pre class="code">eval(D(G), ToMultiSet(L)) = ToMultiSet(eval(D), M))</pre>
        </div>
        <div class="defn">
          <b>Definition: <a id="defn_evalSlice" name="defn_evalSlice">Evaluation of Slice</a></b>
          <pre class="code">eval(D(G), Slice(L, start, length)) = Slice(eval(D(G), L), start, length)</pre>
        </div>
      </div>
      <div class="div2">
        <h3><a name="sparqlBGPExtend" id="sparqlBGPExtend"></a>18.7 Extending SPARQL Basic Graph Matching</h3>
        <p>The overall SPARQL design can be used for queries which assume a more elaborate form of entailment than simple entailment, by re-writing the matching conditions for basic graph patterns.
        Since it is an open research problem to state such conditions in a single general form which applies to all forms of entailment and optimally eliminates needless or inappropriate redundancy,
        this document only gives necessary conditions which any such solution should satisfy. These will need to be extended to full definitions for each particular case.</p>
        <p>Basic graph patterns stand in the same relation to triple patterns that RDF graphs do to RDF triples, and much of the same terminology can be applied to them. In particular, two basic
        graph patterns are said to be <i>equivalent</i> if there is a bijection M between the terms of the triple patterns that maps blank nodes to blank nodes and maps variables, literals and IRIs
        to themselves, such that a triple ( s, p, o ) is in the first pattern if and only if the triple ( M(s), M(p), M(o) ) is in the second. This definition extends that for RDF graph equivalence
        to basic graph patterns by preserving variable names across equivalent patterns.</p>
        <p>An <i>entailment regime</i> specifies</p>
        <ol>
          <li>a subset of RDF graphs called <i>well-formed</i> for the regime</li>
          <li>an <i>entailment</i> relation between subsets of well-formed graphs and well-formed graphs.</li>
        </ol>
        <p>Detailed definitions for querying various entailment regimes can be found in <a href="http://www.w3.org/TR/sparql11-entailment/">SPARQL 1.1 Entailment Regimes</a>.</p>
        <p>Some entailment regimes can categorize some RDF graphs as inconsistent. For example, the RDF graph:</p>
        <pre class="data">_:x rdf:type xsd:string .
_:x rdf:type xsd:decimal .</pre>
        <p>is D-inconsistent when D contains the XSD datatypes. The effect of a query on an inconsistent graph is not covered by this specification, but must be specified by the particular SPARQL
        extension.</p>
        <p>An entailment regime E must provide conditions on basic graph pattern evaluation such that for any basic graph pattern BGP, any RDF graph G, and any evaluation that satisfies the
        conditions, the resulting multiset of solutions is uniquely determined up to RDF graph equivalence. We denote the multiset of solutions from evaluating BGP over G using E with Eval-E(G,
        BGP).<br>
        An entailment regime must further satisfy the following conditions:</p>
        <ol>
          <li>For any E-consistent active graph AG, the entailment regime E uniquely specifies a <a href="#BGPsparqlBNodes">scoping graph</a> SG that is E-equivalent to AG.</li>
          <li>A set of well-formed graphs for E is specified such that, for any basic graph pattern BGP, scoping graph SG, and solution mapping μ in Eval-E(SG, BGP), the graph μ(BGP) is well-formed
          for E.</li>
          <li>For any basic graph pattern BGP and scoping graph SG, if μ<sub>1</sub>, ..., μ<sub>n</sub> in Eval-E(SG, BGP) and BGP<sub>1</sub>, ..., BGP<sub>n</sub> are basic graph patterns all
          equivalent to BGP but not sharing any blank nodes with each other or with SG, then
            <blockquote>
              <p>SG E-entails (SG union μ<sub>1</sub>(BGP<sub>1</sub>) union ... union μ<sub>n</sub>(BGP<sub>n</sub>))</p>
            </blockquote>
            <p>These conditions do not fully determine the set of possible answers, since RDF allows unlimited amounts of redundancy. In addition, therefore, the following must hold.</p>
          </li>
          <li>Entailment regimes should provide conditions to prevent trivial infinite solution multisets as appropriate to the regime.</li>
        </ol>
        <div class="div3">
          <h4><a name="sparqlBGPExtend-notes" id="sparqlBGPExtend-notes"></a>18.7.1 Notes</h4>
          <p>(a) SG will often be graph equivalent to AG, but restricting this to E-equivalence allows some forms of normalization, for example elimination of semantic redundancies, to be applied to
          the source documents before querying.</p>
          <p>(b) The construction in condition 3 ensures that any blank nodes introduced by the solution mapping are used in a way which is internally consistent with the way that blank nodes occur
          in SG. This ensures that blank node identifiers occur in more than one answer in an answer set only when the blank nodes so identified are indeed identical in SG. If the extension does not
          allow bindings to blank nodes, then this condition can be simplified to the condition:</p>
          <blockquote>
            <p>SG E-entails μ(BGP) for each solution mapping μ.</p>
          </blockquote>
          <p>(c) These conditions do not impose the SPARQL requirement that SG shares no blank nodes with AG or BGP. In particular, it allows SG to actually be AG. This allows query protocols in
          which blank node identifiers retain their meaning between the query and the source document, or across multiple queries. Such protocols are not supported by the current SPARQL protocol
          specification, however.</p>
          <p>(d) Since conditions 1 to 3 are only necessary conditions on answers, condition 4 allows cases where the set of legal answers can be restricted in various ways.</p>
          <p>(e) None of these conditions refer explicitly to instance mappings on blank nodes in BGP. For some entailment regimes, the existential interpretation of blank nodes cannot be fully
          captured by the existence of a single instance mapping. These conditions allow such regimes to give blank nodes in query patterns a 'fully existential' reading.</p>
          <p>It is straightforward to show that SPARQL satisfies these conditions for the case where E is simple entailment, given that the SPARQL condition on SG is that it is graph-equivalent to AG
          but shares no blank nodes with AG or BGP (which satisfies the first condition). The only condition which is nontrivial is (3).</p>
          <p>For every solution mapping μ<sub>i</sub>, there is, by definition of basic graph pattern matching, an RDF instance mapping σ<sub>i</sub> such that P<sub>i</sub>(BGP<sub>i</sub>) is a
          subgraph of SG where P<sub>i</sub> is the pattern instance mapping composed of μ<sub>i</sub> and σ<sub>i</sub>. Since BGP<sub>i</sub> and SG have no blank nodes in common, the ranges of
          σ<sub>i</sub> and μ<sub>i</sub> contain no blank nodes from BGP<sub>i</sub>; therefore, the solution mapping μ<sub>i</sub> and the RDF instance mapping σ<sub>i</sub> of P<sub>i</sub>
          commute, so P<sub>i</sub>(BGP<sub>i</sub>) = σ<sub>i</sub>(μ<sub>i</sub>(BGP<sub>i</sub>)). So</p>
          <p>P<sub>1</sub>(BGP<sub>1</sub>) union ... union P<sub>n</sub>(BGP<sub>n</sub>)<br>
          = σ<sub>1</sub>(μ<sub>1</sub>(BGP<sub>1</sub>)) union ... union σ<sub>n</sub>(μ<sub>n</sub>(BGP<sub>n</sub>))<br>
          = [ σ<sub>1</sub> + ... + σ<sub>n</sub>]( μ<sub>1</sub>(BGP<sub>1</sub>) union ... union μ<sub>n</sub>(BGP<sub>n</sub>) )</p>
          <p>since the domains of the σ<sub>i</sub> RDF instance mappings are all mutually exclusive. Since they are also exclusive from SG,</p>
          <p>SG union [ σ<sub>1</sub> + ... + σ<sub>n</sub>]( μ<sub>1</sub>(BGP<sub>1</sub>) union ... union μ<sub>n</sub>(BGP<sub>n</sub>) )<br>
          = [ σ<sub>1</sub> + ... + σ<sub>n</sub>](SG union μ<sub>1</sub>(BGP<sub>1</sub>) union ... union μ<sub>n</sub>(BGP<sub>n</sub>) )</p>
          <p>i.e.</p>
          <p>SG union μ<sub>1</sub>(BGP<sub>1</sub>) union ... union μ<sub>n</sub>(BGP<sub>n</sub>)</p>
          <p>has an instance which is a subgraph of SG, so is simply entailed by SG by the <a href="http://www.w3.org/TR/rdf-mt/#interplemmaprf">RDF interpolation lemma</a> [<a href=
          "#RDF-MT">RDF-MT</a>].</p>
        </div>
      </div>
    </div>
    <div class="div1">
      <h2><a name="grammar" id="grammar"></a>19 SPARQL Grammar</h2>
      <p>The SPARQL grammar covers both SPARQL Query and <a href="http://www.w3.org/TR/sparql11-update/">SPARQL Update</a>.</p>
      <div class="div2">
        <h3><a name="queryString" id="queryString"></a>19.1 SPARQL Request String</h3>
        <p>A <a name="defn_SPARQLRequestString" id="defn_SPARQLRequestString">SPARQL Request String</a> is a SPARQL Query String or SPARQL Update String and it is a Unicode character string (c.f.
        section 6.1 String concepts of [<a href="#CHARMOD">CHARMOD</a>]) in the language defined by the following grammar.</p>
        <p>A <a name="defn_SPARQLQueryString" id="defn_SPARQLQueryString">SPARQL Query String</a> start at the <a href="#rQueryUnit">QueryUnit</a> production.</p>
        <p>A <a name="defn_SPARQLUpdateString" id="defn_SPARQLUpdateString">SPARQL Update String</a> start at the <a href="#rUpdateUnit">UpdateUnit</a> production.</p>
        <p>For compatibility with future versions of Unicode, the characters in this string may include Unicode codepoints that are unassigned as of the date of this publication (see <a class=
        "inform" href="http://www.unicode.org/reports/tr31/tr31-5.html">Identifier and Pattern Syntax</a> [<a href="#UNIID">UNIID</a>] section 4 Pattern Syntax). For productions with excluded
        character classes (for example <code>[^&lt;&gt;'{}|^`]</code>), the characters are excluded from the range <code>#x0 - #x10FFFF</code>.</p>
      </div>
      <div class="div2">
        <h3><a name="codepointEscape" id="codepointEscape"></a>19.2 Codepoint Escape Sequences</h3>
        <p>A SPARQL Query String is processed for codepoint escape sequences before parsing by the grammar defined in EBNF below. The codepoint escape sequences for a SPARQL query string
        are:</p><a name="table68" id="table68"></a>
        <table summary="Codepoint escapes">
          <colgroup span="1">
            <col width="40%" span="1">
          </colgroup>
          <tbody>
            <tr>
              <th class="major">Escape</th>
              <th class="major">Unicode code point</th>
            </tr>
            <tr>
              <td><span class="token">'\u'</span> <a href="#HEX">HEX</a> <a href="#HEX">HEX</a> <a href="#HEX">HEX</a> <a href="#HEX">HEX</a></td>
              <td>A Unicode code point in the range U+0 to U+FFFF inclusive corresponding to the encoded hexadecimal value.</td>
            </tr>
            <tr>
              <td><span class="token">'\U'</span> <a href="#HEX">HEX</a> <a href="#HEX">HEX</a> <a href="#HEX">HEX</a> <a href="#HEX">HEX</a> <a href="#HEX">HEX</a> <a href="#HEX">HEX</a> <a href=
              "#HEX">HEX</a> <a href="#HEX">HEX</a></td>
              <td>A Unicode code point in the range U+0 to U+10FFFF inclusive corresponding to the encoded hexadecimal value.</td>
            </tr>
          </tbody>
        </table>
        <p>where <a href="#HEX">HEX</a> is a hexadecimal character</p>
        <blockquote>
          <p><code><a name="HEX" id="HEX">HEX</a> ::= [0-9] | [A-F] | [a-f]</code></p>
        </blockquote>
        <p>Examples:</p>
        <pre class="query untested">&lt;ab\u00E9xy&gt;        # Codepoint 00E9 is Latin small e with acute - é
\u03B1:a            # Codepoint x03B1 is Greek small alpha - α
a\u003Ab            # a:b -- codepoint x3A is colon</pre>
        <p>Codepoint escape sequences can appear anywhere in the query string. They are processed before parsing based on the grammar rules and so may be replaced by codepoints with significance in
        the grammar, such as "<code>:</code>" marking a prefixed name.</p>
        <p>These escape sequences are not included in the grammar below. Only escape sequences for characters that would be legal at that point in the grammar may be given. For example, the variable
        "<code>?x\u0020y</code>" is not legal (<code>\u0020</code> is a space and is not permitted in a variable name).</p>
      </div>
      <div class="div2">
        <h3><a name="whitespace" id="whitespace"></a>19.3 White Space</h3>
        <p>White space (production <code><a href="#rWS">WS</a></code>) is used to separate two terminals which would otherwise be (mis-)recognized as one terminal. Rule names below in capitals
        indicate where white space is significant; these form a possible choice of terminals for constructing a SPARQL parser. White space is significant in strings. Otherwise, white space is ignored
        between tokens.</p>
        <p>For example:</p>
        <blockquote>
          <p><code>?a&lt;?b&amp;&amp;?c&gt;?d</code></p>
        </blockquote>
        <p>is the token sequence variable '<code>?a</code>', an IRI '<code>&lt;?b&amp;&amp;?c&gt;</code>', and variable '<code>?d</code>', not a expression involving the operator
        '<code>&amp;&amp;</code>' connecting two expression using '<code>&lt;</code>' (less than) and '<code>&gt;</code>' (greater than).</p>
      </div>
      <div class="div2">
        <h3><a name="grammarComments" id="grammarComments"></a>19.4 Comments</h3>
        <p>Comments in SPARQL queries take the form of '<code>#</code>', outside an IRI or string, and continue to the end of line (marked by characters <code>0x0D</code> or <code>0x0A</code>) or end
        of file if there is no end of line after the comment marker. Comments are treated as white space.</p>
      </div>
      <div class="div2">
        <h3><a name="iriRefs" id="iriRefs"></a>19.5 IRI References</h3>
        <p>Text matched by the <code><a href="#rIRIREF">IRIREF</a></code> production and <code><a href="#rPrefixedName">PrefixedName</a></code> (after prefix expansion) production, after escape
        processing, must conform to the generic syntax of IRI references in section 2.2 of RFC 3987 "ABNF for IRI References and IRIs" [<a href="#rfc3987">RFC3987</a>]. For example, the
        <code><a href="#rIRIREF">IRIREF</a></code> <code>&lt;abc#def&gt;</code> may occur in a SPARQL query string, but the <code><a href="#rIRIREF">IRIREF</a></code> <code>&lt;abc##def&gt;</code>
        must not.</p>
        <p>Base IRIs declared with the <span class="token">BASE</span> keyword must be absolute IRIs. A prefix declared with the <span class="token">PREFIX</span> keyword may not be re-declared in
        the same query. See section 4.1.1, <a href="#QSynIRI">Syntax of IRI Terms</a>, for a description of <span class="token">BASE</span> and <span class="token">PREFIX</span>.</p>
      </div>
      <div class="div2">
        <h3><a name="grammarBNodes" id="grammarBNodes"></a>19.6 Blank Nodes and Blank Node Labels</h3>
        <p>Blank nodes can not be used in:</p>
        <ul>
          <li><code><a href="#rDeleteWhere">DELETE WHERE</a></code></li>
          <li><code><a href="#rDeleteWhere">DELETE DATA</a></code></li>
          <li>a <code><a href="#rDeleteClause">DeleteClause</a></code></li>
        </ul>
        <p>in a <a href="http://www.w3.org/TR/sparql11-update/#terminology">SPARQL Update request</a>.</p>
        <p>Blank node labels are scoped to the <a href="#defn_SPARQLRequestString">SPARQL Request String</a> in which they occur. Different uses of the same blank node label in a request string refer
        to the same blank node. Fresh blank nodes are generated for each request; blank nodes can not be referenced by label across requests.</p>
        <p>The same blank node label can not be used in:</p>
        <ul>
          <li>two basic graph patterns in a SPARQL Query</li>
          <li>two <code><a href="#rModify">WHERE</a></code> clauses within a single SPARQL Update request</li>
          <li>two <code><a href="#rInsertData">INSERT DATA</a></code> operations within a single SPARQL Update request</li>
        </ul>
        <p>Note that the same blank node label can occur in different <a href="#rQuadPattern">QuadPattern</a> clauses in a <a href="http://www.w3.org/TR/sparql11-update/">SPARQL Update</a>
        request.</p>
      </div>
      <div class="div2">
        <h3><a name="grammarEscapes" id="grammarEscapes"></a>19.7 Escape sequences in strings</h3>
        <p>In addition to the <a href="#codepointEscape">codepoint escape sequences</a>, the following escape sequences any <code><a href="#rString">string</a></code> production (e.g. <code><a href=
        "#rSTRING_LITERAL1">STRING_LITERAL1</a></code>, <code><a href="#rSTRING_LITERAL2">STRING_LITERAL2</a></code>, <code><a href="#rSTRING_LITERAL_LONG1">STRING_LITERAL_LONG1</a></code>,
        <code><a href="#rSTRING_LITERAL_LONG2">STRING_LITERAL_LONG2</a></code>):</p>
        <table summary="String escapes">
          <colgroup span="1">
            <col width="40%" span="1">
          </colgroup>
          <tbody>
            <tr>
              <th class="major">Escape</th>
              <th class="major">Unicode code point</th>
            </tr>
            <tr>
              <td><span class="token">'\t'</span></td>
              <td>U+0009 (tab)</td>
            </tr>
            <tr>
              <td><span class="token">'\n'</span></td>
              <td>U+000A (line feed)</td>
            </tr>
            <tr>
              <td><span class="token">'\r'</span></td>
              <td>U+000D (carriage return)</td>
            </tr>
            <tr>
              <td><span class="token">'\b'</span></td>
              <td>U+0008 (backspace)</td>
            </tr>
            <tr>
              <td><span class="token">'\f'</span></td>
              <td>U+000C (form feed)</td>
            </tr>
            <tr>
              <td><span class="token">'\"'</span></td>
              <td>U+0022 (quotation mark, double quote mark)</td>
            </tr>
            <tr>
              <td><span class="token">"\'"</span></td>
              <td>U+0027 (apostrophe-quote, single quote mark)</td>
            </tr>
            <tr>
              <td><span class="token">'\\'</span></td>
              <td>U+005C (backslash)</td>
            </tr>
          </tbody>
        </table>
        <p>Examples:</p>
        <pre class="query untested">"abc\n"
"xy\rz"
'xy\tz'</pre>
      </div>
      <div class="div2">
        <h3><a name="sparqlGrammar" id="sparqlGrammar"></a>19.8 Grammar</h3>
        <p>The EBNF notation used in the grammar is defined in Extensible Markup Language (XML) 1.1 [<a href="#XML11">XML11</a>] section 6 <a class="norm" href=
        "http://www.w3.org/TR/2004/REC-xml11-20040204/#sec-notation">Notation</a>.</p>
        <p>Notes:</p>
        <ol>
          <li>Keywords are matched in a case-insensitive manner with the exception of the keyword '<code>a</code>' which, in line with Turtle and N3, is used in place of the IRI <code>rdf:type</code>
          (in full, <code><a href="http://www.w3.org/1999/02/22-rdf-syntax-ns#type">http://www.w3.org/1999/02/22-rdf-syntax-ns#type</a></code>).</li>
          <li>Escape sequences are case sensitive.</li>
          <li>When tokenizing the input and choosing grammar rules, the longest match is chosen.</li>
          <li>The SPARQL grammar is LL(1) when the rules with uppercased names are used as terminals.</li>
          <li>There are two entry points into the grammar: <code>QueryUnit</code> for SPARQL queries, and <code>UpdateUnit</code> for SPARQL Update requests.</li>
          <li>In signed numbers, no white space is allowed between the sign and the number. The <code><a href="#rAdditiveExpression">AdditiveExpression</a></code> grammar rule allows for this by
          covering the two cases of an expression followed by a signed number. These produce an addition or subtraction of the unsigned number as appropriate.</li>
          <li>The tokens <code>INSERT DATA</code>, DELETE DATA<code>,</code> DELETE WHERE allow any amount of white space between the words. The single space version is used in the grammar for
          clarity.</li>
          <li>The <code><a href="#rQuadData">QuadData</a></code> and <code><a href="#rQuadPattern">QuadPattern</a></code> rules both use rule <code><a href="#rQuads">Quads</a></code>. The rule
          <code><a href="#rQuadData">QuadData</a></code>, used in <a href="#rInsertData"><code>INSERT DATA</code></a> and <a href="#rDeleteData"><code>DELETE DATA</code></a>, must not allow variables
          in the quad patterns.</li>
          <li>Blank node syntax is not allowed in <code><a href="#rDeleteWhere">DELETE WHERE</a></code>, the <code><a href="#rDeleteClause">DeleteClause</a></code> for <code>DELETE</code>, nor in
          <a href="#rDeleteData"><code>DELETE DATA</code></a>.</li>
          <li>Rules for limiting the use of blank node labels are given in <a href="#grammarBNodes">section 19.6</a>.</li>
          <li>The number of variables in the variable list of <code>VALUES</code> block must be the same as the number of each list of associated values in the <code>DataBlock</code>.</li>
          <li>Variables introduced by <code>AS</code> in a <code>SELECT</code> clause must not already be <a href="#variableScope">in-scope</a>.</li>
          <li>The variable assigned in a <code>BIND</code> clause must not be already in-use within the immediately preceding <code><a href="#rTriplesBlock">TriplesBlock</a></code> within a
          <code><a href="#rGroupGraphPattern">GroupGraphPattern</a></code>.</li>
          <li>Aggregate functions can be one of the <a href="#rAggregate">built-in keywords for aggregates</a> or a custom aggregate, which is syntactically a <a href="#rFunctionCall">function
          call</a>. Aggregate functions may only be used in <a href="#rSelectClause">SELECT</a>, <a href="#rHavingClause">HAVING</a> and <a href="#rOrderClause">ORDER BY</a> clauses.</li>
          <li>Only custom aggregate functions use the <tt>DISTINCT</tt> keyword in a <a href="#rFunctionCall">function call</a>.</li>
        </ol>
        <div class="grammarTable">
          <table>
            <tbody>
              <tr valign="baseline">
                <td><code>[1]&nbsp;&nbsp;</code></td>
                <td><code><a id="rQueryUnit" name="rQueryUnit">QueryUnit</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rQuery">Query</a> </code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[2]&nbsp;&nbsp;</code></td>
                <td><code><a id="rQuery" name="rQuery">Query</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rPrologue">Prologue</a><br>
                ( <a href="#rSelectQuery">SelectQuery</a> | <a href="#rConstructQuery">ConstructQuery</a> | <a href="#rDescribeQuery">DescribeQuery</a> | <a href="#rAskQuery">AskQuery</a> )<br>
                <a href="#rValuesClause">ValuesClause</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[3]&nbsp;&nbsp;</code></td>
                <td><code><a id="rUpdateUnit" name="rUpdateUnit">UpdateUnit</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rUpdate">Update</a> </code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[4]&nbsp;&nbsp;</code></td>
                <td><code><a id="rPrologue" name="rPrologue">Prologue</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code>( <a href="#rBaseDecl">BaseDecl</a> | <a href="#rPrefixDecl">PrefixDecl</a> )*</code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[5]&nbsp;&nbsp;</code></td>
                <td><code><a id="rBaseDecl" name="rBaseDecl">BaseDecl</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'BASE'</span> <a href="#rIRIREF">IRIREF</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[6]&nbsp;&nbsp;</code></td>
                <td><code><a id="rPrefixDecl" name="rPrefixDecl">PrefixDecl</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'PREFIX'</span> <a href="#rPNAME_NS">PNAME_NS</a> <a href="#rIRIREF">IRIREF</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[7]&nbsp;&nbsp;</code></td>
                <td><code><a id="rSelectQuery" name="rSelectQuery">SelectQuery</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rSelectClause">SelectClause</a> <a href="#rDatasetClause">DatasetClause</a>* <a href="#rWhereClause">WhereClause</a> <a href=
                "#rSolutionModifier">SolutionModifier</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[8]&nbsp;&nbsp;</code></td>
                <td><code><a id="rSubSelect" name="rSubSelect">SubSelect</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rSelectClause">SelectClause</a> <a href="#rWhereClause">WhereClause</a> <a href="#rSolutionModifier">SolutionModifier</a> <a href=
                "#rValuesClause">ValuesClause</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[9]&nbsp;&nbsp;</code></td>
                <td><code><a id="rSelectClause" name="rSelectClause">SelectClause</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'SELECT'</span> ( <span class="token">'DISTINCT'</span> | <span class="token">'REDUCED'</span> )? ( ( <a href="#rVar">Var</a> | ( <span class=
                "token">'('</span> <a href="#rExpression">Expression</a> <span class="token">'AS'</span> <a href="#rVar">Var</a> <span class="token">')'</span> ) )+ | <span class="token">'*'</span>
                )</code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[10]&nbsp;&nbsp;</code></td>
                <td><code><a id="rConstructQuery" name="rConstructQuery">ConstructQuery</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'CONSTRUCT'</span> ( <a href="#rConstructTemplate">ConstructTemplate</a> <a href="#rDatasetClause">DatasetClause</a>* <a href=
                "#rWhereClause">WhereClause</a> <a href="#rSolutionModifier">SolutionModifier</a> | <a href="#rDatasetClause">DatasetClause</a>* <span class="token">'WHERE'</span> <span class=
                "token">'{'</span> <a href="#rTriplesTemplate">TriplesTemplate</a>? <span class="token">'}'</span> <a href="#rSolutionModifier">SolutionModifier</a> )</code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[11]&nbsp;&nbsp;</code></td>
                <td><code><a id="rDescribeQuery" name="rDescribeQuery">DescribeQuery</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'DESCRIBE'</span> ( <a href="#rVarOrIri">VarOrIri</a>+ | <span class="token">'*'</span> ) <a href="#rDatasetClause">DatasetClause</a>* <a href=
                "#rWhereClause">WhereClause</a>? <a href="#rSolutionModifier">SolutionModifier</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[12]&nbsp;&nbsp;</code></td>
                <td><code><a id="rAskQuery" name="rAskQuery">AskQuery</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'ASK'</span> <a href="#rDatasetClause">DatasetClause</a>* <a href="#rWhereClause">WhereClause</a> <a href=
                "#rSolutionModifier">SolutionModifier</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[13]&nbsp;&nbsp;</code></td>
                <td><code><a id="rDatasetClause" name="rDatasetClause">DatasetClause</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'FROM'</span> ( <a href="#rDefaultGraphClause">DefaultGraphClause</a> | <a href="#rNamedGraphClause">NamedGraphClause</a> )</code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[14]&nbsp;&nbsp;</code></td>
                <td><code><a id="rDefaultGraphClause" name="rDefaultGraphClause">DefaultGraphClause</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rSourceSelector">SourceSelector</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[15]&nbsp;&nbsp;</code></td>
                <td><code><a id="rNamedGraphClause" name="rNamedGraphClause">NamedGraphClause</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'NAMED'</span> <a href="#rSourceSelector">SourceSelector</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[16]&nbsp;&nbsp;</code></td>
                <td><code><a id="rSourceSelector" name="rSourceSelector">SourceSelector</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#riri">iri</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[17]&nbsp;&nbsp;</code></td>
                <td><code><a id="rWhereClause" name="rWhereClause">WhereClause</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'WHERE'</span>? <a href="#rGroupGraphPattern">GroupGraphPattern</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[18]&nbsp;&nbsp;</code></td>
                <td><code><a id="rSolutionModifier" name="rSolutionModifier">SolutionModifier</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rGroupClause">GroupClause</a>? <a href="#rHavingClause">HavingClause</a>? <a href="#rOrderClause">OrderClause</a>? <a href=
                "#rLimitOffsetClauses">LimitOffsetClauses</a>?</code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[19]&nbsp;&nbsp;</code></td>
                <td><code><a id="rGroupClause" name="rGroupClause">GroupClause</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'GROUP'</span> <span class="token">'BY'</span> <a href="#rGroupCondition">GroupCondition</a>+</code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[20]&nbsp;&nbsp;</code></td>
                <td><code><a id="rGroupCondition" name="rGroupCondition">GroupCondition</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rBuiltInCall">BuiltInCall</a> | <a href="#rFunctionCall">FunctionCall</a> | <span class="token">'('</span> <a href="#rExpression">Expression</a> ( <span class=
                "token">'AS'</span> <a href="#rVar">Var</a> )? <span class="token">')'</span> | <a href="#rVar">Var</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[21]&nbsp;&nbsp;</code></td>
                <td><code><a id="rHavingClause" name="rHavingClause">HavingClause</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'HAVING'</span> <a href="#rHavingCondition">HavingCondition</a>+</code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[22]&nbsp;&nbsp;</code></td>
                <td><code><a id="rHavingCondition" name="rHavingCondition">HavingCondition</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rConstraint">Constraint</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[23]&nbsp;&nbsp;</code></td>
                <td><code><a id="rOrderClause" name="rOrderClause">OrderClause</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'ORDER'</span> <span class="token">'BY'</span> <a href="#rOrderCondition">OrderCondition</a>+</code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[24]&nbsp;&nbsp;</code></td>
                <td><code><a id="rOrderCondition" name="rOrderCondition">OrderCondition</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code>( ( <span class="token">'ASC'</span> | <span class="token">'DESC'</span> ) <a href="#rBrackettedExpression">BrackettedExpression</a> )<br>
                | ( <a href="#rConstraint">Constraint</a> | <a href="#rVar">Var</a> )</code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[25]&nbsp;&nbsp;</code></td>
                <td><code><a id="rLimitOffsetClauses" name="rLimitOffsetClauses">LimitOffsetClauses</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rLimitClause">LimitClause</a> <a href="#rOffsetClause">OffsetClause</a>? | <a href="#rOffsetClause">OffsetClause</a> <a href=
                "#rLimitClause">LimitClause</a>?</code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[26]&nbsp;&nbsp;</code></td>
                <td><code><a id="rLimitClause" name="rLimitClause">LimitClause</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'LIMIT'</span> <a href="#rINTEGER">INTEGER</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[27]&nbsp;&nbsp;</code></td>
                <td><code><a id="rOffsetClause" name="rOffsetClause">OffsetClause</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'OFFSET'</span> <a href="#rINTEGER">INTEGER</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[28]&nbsp;&nbsp;</code></td>
                <td><code><a id="rValuesClause" name="rValuesClause">ValuesClause</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code>( <span class="token">'VALUES'</span> <a href="#rDataBlock">DataBlock</a> )?</code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[29]&nbsp;&nbsp;</code></td>
                <td><code><a id="rUpdate" name="rUpdate">Update</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rPrologue">Prologue</a> ( <a href="#rUpdate1">Update1</a> ( <span class="token">';'</span> <a href="#rUpdate">Update</a> )? )?</code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[30]&nbsp;&nbsp;</code></td>
                <td><code><a id="rUpdate1" name="rUpdate1">Update1</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rLoad">Load</a> | <a href="#rClear">Clear</a> | <a href="#rDrop">Drop</a> | <a href="#rAdd">Add</a> | <a href="#rMove">Move</a> | <a href="#rCopy">Copy</a> |
                <a href="#rCreate">Create</a> | <a href="#rInsertData">InsertData</a> | <a href="#rDeleteData">DeleteData</a> | <a href="#rDeleteWhere">DeleteWhere</a> | <a href=
                "#rModify">Modify</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[31]&nbsp;&nbsp;</code></td>
                <td><code><a id="rLoad" name="rLoad">Load</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'LOAD'</span> <span class="token">'SILENT'</span>? <a href="#riri">iri</a> ( <span class="token">'INTO'</span> <a href="#rGraphRef">GraphRef</a>
                )?</code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[32]&nbsp;&nbsp;</code></td>
                <td><code><a id="rClear" name="rClear">Clear</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'CLEAR'</span> <span class="token">'SILENT'</span>? <a href="#rGraphRefAll">GraphRefAll</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[33]&nbsp;&nbsp;</code></td>
                <td><code><a id="rDrop" name="rDrop">Drop</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'DROP'</span> <span class="token">'SILENT'</span>? <a href="#rGraphRefAll">GraphRefAll</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[34]&nbsp;&nbsp;</code></td>
                <td><code><a id="rCreate" name="rCreate">Create</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'CREATE'</span> <span class="token">'SILENT'</span>? <a href="#rGraphRef">GraphRef</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[35]&nbsp;&nbsp;</code></td>
                <td><code><a id="rAdd" name="rAdd">Add</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'ADD'</span> <span class="token">'SILENT'</span>? <a href="#rGraphOrDefault">GraphOrDefault</a> <span class="token">'TO'</span> <a href=
                "#rGraphOrDefault">GraphOrDefault</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[36]&nbsp;&nbsp;</code></td>
                <td><code><a id="rMove" name="rMove">Move</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'MOVE'</span> <span class="token">'SILENT'</span>? <a href="#rGraphOrDefault">GraphOrDefault</a> <span class="token">'TO'</span> <a href=
                "#rGraphOrDefault">GraphOrDefault</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[37]&nbsp;&nbsp;</code></td>
                <td><code><a id="rCopy" name="rCopy">Copy</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'COPY'</span> <span class="token">'SILENT'</span>? <a href="#rGraphOrDefault">GraphOrDefault</a> <span class="token">'TO'</span> <a href=
                "#rGraphOrDefault">GraphOrDefault</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[38]&nbsp;&nbsp;</code></td>
                <td><code><a id="rInsertData" name="rInsertData">InsertData</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'INSERT DATA'</span> <a href="#rQuadData">QuadData</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[39]&nbsp;&nbsp;</code></td>
                <td><code><a id="rDeleteData" name="rDeleteData">DeleteData</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'DELETE DATA'</span> <a href="#rQuadData">QuadData</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[40]&nbsp;&nbsp;</code></td>
                <td><code><a id="rDeleteWhere" name="rDeleteWhere">DeleteWhere</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'DELETE WHERE'</span> <a href="#rQuadPattern">QuadPattern</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[41]&nbsp;&nbsp;</code></td>
                <td><code><a id="rModify" name="rModify">Modify</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code>( <span class="token">'WITH'</span> <a href="#riri">iri</a> )? ( <a href="#rDeleteClause">DeleteClause</a> <a href="#rInsertClause">InsertClause</a>? | <a href=
                "#rInsertClause">InsertClause</a> ) <a href="#rUsingClause">UsingClause</a>* <span class="token">'WHERE'</span> <a href="#rGroupGraphPattern">GroupGraphPattern</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[42]&nbsp;&nbsp;</code></td>
                <td><code><a id="rDeleteClause" name="rDeleteClause">DeleteClause</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'DELETE'</span> <a href="#rQuadPattern">QuadPattern</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[43]&nbsp;&nbsp;</code></td>
                <td><code><a id="rInsertClause" name="rInsertClause">InsertClause</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'INSERT'</span> <a href="#rQuadPattern">QuadPattern</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[44]&nbsp;&nbsp;</code></td>
                <td><code><a id="rUsingClause" name="rUsingClause">UsingClause</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'USING'</span> ( <a href="#riri">iri</a> | <span class="token">'NAMED'</span> <a href="#riri">iri</a> )</code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[45]&nbsp;&nbsp;</code></td>
                <td><code><a id="rGraphOrDefault" name="rGraphOrDefault">GraphOrDefault</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'DEFAULT'</span> | <span class="token">'GRAPH'</span>? <a href="#riri">iri</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[46]&nbsp;&nbsp;</code></td>
                <td><code><a id="rGraphRef" name="rGraphRef">GraphRef</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'GRAPH'</span> <a href="#riri">iri</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[47]&nbsp;&nbsp;</code></td>
                <td><code><a id="rGraphRefAll" name="rGraphRefAll">GraphRefAll</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rGraphRef">GraphRef</a> | <span class="token">'DEFAULT'</span> | <span class="token">'NAMED'</span> | <span class="token">'ALL'</span></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[48]&nbsp;&nbsp;</code></td>
                <td><code><a id="rQuadPattern" name="rQuadPattern">QuadPattern</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'{'</span> <a href="#rQuads">Quads</a> <span class="token">'}'</span></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[49]&nbsp;&nbsp;</code></td>
                <td><code><a id="rQuadData" name="rQuadData">QuadData</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'{'</span> <a href="#rQuads">Quads</a> <span class="token">'}'</span></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[50]&nbsp;&nbsp;</code></td>
                <td><code><a id="rQuads" name="rQuads">Quads</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rTriplesTemplate">TriplesTemplate</a>? ( <a href="#rQuadsNotTriples">QuadsNotTriples</a> <span class="token">'.'</span>? <a href=
                "#rTriplesTemplate">TriplesTemplate</a>? )*</code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[51]&nbsp;&nbsp;</code></td>
                <td><code><a id="rQuadsNotTriples" name="rQuadsNotTriples">QuadsNotTriples</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'GRAPH'</span> <a href="#rVarOrIri">VarOrIri</a> <span class="token">'{'</span> <a href="#rTriplesTemplate">TriplesTemplate</a>? <span class=
                "token">'}'</span></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[52]&nbsp;&nbsp;</code></td>
                <td><code><a id="rTriplesTemplate" name="rTriplesTemplate">TriplesTemplate</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rTriplesSameSubject">TriplesSameSubject</a> ( <span class="token">'.'</span> <a href="#rTriplesTemplate">TriplesTemplate</a>? )?</code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[53]&nbsp;&nbsp;</code></td>
                <td><code><a id="rGroupGraphPattern" name="rGroupGraphPattern">GroupGraphPattern</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'{'</span> ( <a href="#rSubSelect">SubSelect</a> | <a href="#rGroupGraphPatternSub">GroupGraphPatternSub</a> ) <span class="token">'}'</span></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[54]&nbsp;&nbsp;</code></td>
                <td><code><a id="rGroupGraphPatternSub" name="rGroupGraphPatternSub">GroupGraphPatternSub</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rTriplesBlock">TriplesBlock</a>? ( <a href="#rGraphPatternNotTriples">GraphPatternNotTriples</a> <span class="token">'.'</span>? <a href=
                "#rTriplesBlock">TriplesBlock</a>? )*</code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[55]&nbsp;&nbsp;</code></td>
                <td><code><a id="rTriplesBlock" name="rTriplesBlock">TriplesBlock</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rTriplesSameSubjectPath">TriplesSameSubjectPath</a> ( <span class="token">'.'</span> <a href="#rTriplesBlock">TriplesBlock</a>? )?</code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[56]&nbsp;&nbsp;</code></td>
                <td><code><a id="rGraphPatternNotTriples" name="rGraphPatternNotTriples">GraphPatternNotTriples</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rGroupOrUnionGraphPattern">GroupOrUnionGraphPattern</a> | <a href="#rOptionalGraphPattern">OptionalGraphPattern</a> | <a href=
                "#rMinusGraphPattern">MinusGraphPattern</a> | <a href="#rGraphGraphPattern">GraphGraphPattern</a> | <a href="#rServiceGraphPattern">ServiceGraphPattern</a> | <a href=
                "#rFilter">Filter</a> | <a href="#rBind">Bind</a> | <a href="#rInlineData">InlineData</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[57]&nbsp;&nbsp;</code></td>
                <td><code><a id="rOptionalGraphPattern" name="rOptionalGraphPattern">OptionalGraphPattern</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'OPTIONAL'</span> <a href="#rGroupGraphPattern">GroupGraphPattern</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[58]&nbsp;&nbsp;</code></td>
                <td><code><a id="rGraphGraphPattern" name="rGraphGraphPattern">GraphGraphPattern</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'GRAPH'</span> <a href="#rVarOrIri">VarOrIri</a> <a href="#rGroupGraphPattern">GroupGraphPattern</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[59]&nbsp;&nbsp;</code></td>
                <td><code><a id="rServiceGraphPattern" name="rServiceGraphPattern">ServiceGraphPattern</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'SERVICE'</span> <span class="token">'SILENT'</span>? <a href="#rVarOrIri">VarOrIri</a> <a href="#rGroupGraphPattern">GroupGraphPattern</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[60]&nbsp;&nbsp;</code></td>
                <td><code><a id="rBind" name="rBind">Bind</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'BIND'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">'AS'</span> <a href="#rVar">Var</a> <span class=
                "token">')'</span></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[61]&nbsp;&nbsp;</code></td>
                <td><code><a id="rInlineData" name="rInlineData">InlineData</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'VALUES'</span> <a href="#rDataBlock">DataBlock</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[62]&nbsp;&nbsp;</code></td>
                <td><code><a id="rDataBlock" name="rDataBlock">DataBlock</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rInlineDataOneVar">InlineDataOneVar</a> | <a href="#rInlineDataFull">InlineDataFull</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[63]&nbsp;&nbsp;</code></td>
                <td><code><a id="rInlineDataOneVar" name="rInlineDataOneVar">InlineDataOneVar</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rVar">Var</a> <span class="token">'{'</span> <a href="#rDataBlockValue">DataBlockValue</a>* <span class="token">'}'</span></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[64]&nbsp;&nbsp;</code></td>
                <td><code><a id="rInlineDataFull" name="rInlineDataFull">InlineDataFull</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code>( <a href="#rNIL">NIL</a> | <span class="token">'('</span> <a href="#rVar">Var</a>* <span class="token">')'</span> ) <span class="token">'{'</span> ( <span class=
                "token">'('</span> <a href="#rDataBlockValue">DataBlockValue</a>* <span class="token">')'</span> | <a href="#rNIL">NIL</a> )* <span class="token">'}'</span></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[65]&nbsp;&nbsp;</code></td>
                <td><code><a id="rDataBlockValue" name="rDataBlockValue">DataBlockValue</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#riri">iri</a> | <a href="#rRDFLiteral">RDFLiteral</a> | <a href="#rNumericLiteral">NumericLiteral</a> | <a href="#rBooleanLiteral">BooleanLiteral</a> |
                <span class="token">'UNDEF'</span></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[66]&nbsp;&nbsp;</code></td>
                <td><code><a id="rMinusGraphPattern" name="rMinusGraphPattern">MinusGraphPattern</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'MINUS'</span> <a href="#rGroupGraphPattern">GroupGraphPattern</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[67]&nbsp;&nbsp;</code></td>
                <td><code><a id="rGroupOrUnionGraphPattern" name="rGroupOrUnionGraphPattern">GroupOrUnionGraphPattern</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rGroupGraphPattern">GroupGraphPattern</a> ( <span class="token">'UNION'</span> <a href="#rGroupGraphPattern">GroupGraphPattern</a> )*</code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[68]&nbsp;&nbsp;</code></td>
                <td><code><a id="rFilter" name="rFilter">Filter</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'FILTER'</span> <a href="#rConstraint">Constraint</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[69]&nbsp;&nbsp;</code></td>
                <td><code><a id="rConstraint" name="rConstraint">Constraint</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rBrackettedExpression">BrackettedExpression</a> | <a href="#rBuiltInCall">BuiltInCall</a> | <a href="#rFunctionCall">FunctionCall</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[70]&nbsp;&nbsp;</code></td>
                <td><code><a id="rFunctionCall" name="rFunctionCall">FunctionCall</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#riri">iri</a> <a href="#rArgList">ArgList</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[71]&nbsp;&nbsp;</code></td>
                <td><code><a id="rArgList" name="rArgList">ArgList</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rNIL">NIL</a> | <span class="token">'('</span> <span class="token">'DISTINCT'</span>? <a href="#rExpression">Expression</a> ( <span class="token">','</span>
                <a href="#rExpression">Expression</a> )* <span class="token">')'</span></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[72]&nbsp;&nbsp;</code></td>
                <td><code><a id="rExpressionList" name="rExpressionList">ExpressionList</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rNIL">NIL</a> | <span class="token">'('</span> <a href="#rExpression">Expression</a> ( <span class="token">','</span> <a href="#rExpression">Expression</a> )*
                <span class="token">')'</span></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[73]&nbsp;&nbsp;</code></td>
                <td><code><a id="rConstructTemplate" name="rConstructTemplate">ConstructTemplate</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'{'</span> <a href="#rConstructTriples">ConstructTriples</a>? <span class="token">'}'</span></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[74]&nbsp;&nbsp;</code></td>
                <td><code><a id="rConstructTriples" name="rConstructTriples">ConstructTriples</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rTriplesSameSubject">TriplesSameSubject</a> ( <span class="token">'.'</span> <a href="#rConstructTriples">ConstructTriples</a>? )?</code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[75]&nbsp;&nbsp;</code></td>
                <td><code><a id="rTriplesSameSubject" name="rTriplesSameSubject">TriplesSameSubject</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rVarOrTerm">VarOrTerm</a> <a href="#rPropertyListNotEmpty">PropertyListNotEmpty</a> | <a href="#rTriplesNode">TriplesNode</a> <a href=
                "#rPropertyList">PropertyList</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[76]&nbsp;&nbsp;</code></td>
                <td><code><a id="rPropertyList" name="rPropertyList">PropertyList</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rPropertyListNotEmpty">PropertyListNotEmpty</a>?</code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[77]&nbsp;&nbsp;</code></td>
                <td><code><a id="rPropertyListNotEmpty" name="rPropertyListNotEmpty">PropertyListNotEmpty</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rVerb">Verb</a> <a href="#rObjectList">ObjectList</a> ( <span class="token">';'</span> ( <a href="#rVerb">Verb</a> <a href="#rObjectList">ObjectList</a> )?
                )*</code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[78]&nbsp;&nbsp;</code></td>
                <td><code><a id="rVerb" name="rVerb">Verb</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rVarOrIri">VarOrIri</a> | <span class="token">'a'</span></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[79]&nbsp;&nbsp;</code></td>
                <td><code><a id="rObjectList" name="rObjectList">ObjectList</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rObject">Object</a> ( <span class="token">','</span> <a href="#rObject">Object</a> )*</code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[80]&nbsp;&nbsp;</code></td>
                <td><code><a id="rObject" name="rObject">Object</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rGraphNode">GraphNode</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[81]&nbsp;&nbsp;</code></td>
                <td><code><a id="rTriplesSameSubjectPath" name="rTriplesSameSubjectPath">TriplesSameSubjectPath</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rVarOrTerm">VarOrTerm</a> <a href="#rPropertyListPathNotEmpty">PropertyListPathNotEmpty</a> | <a href="#rTriplesNodePath">TriplesNodePath</a> <a href=
                "#rPropertyListPath">PropertyListPath</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[82]&nbsp;&nbsp;</code></td>
                <td><code><a id="rPropertyListPath" name="rPropertyListPath">PropertyListPath</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rPropertyListPathNotEmpty">PropertyListPathNotEmpty</a>?</code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[83]&nbsp;&nbsp;</code></td>
                <td><code><a id="rPropertyListPathNotEmpty" name="rPropertyListPathNotEmpty">PropertyListPathNotEmpty</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code>( <a href="#rVerbPath">VerbPath</a> | <a href="#rVerbSimple">VerbSimple</a> ) <a href="#rObjectListPath">ObjectListPath</a> ( <span class="token">';'</span> ( ( <a href=
                "#rVerbPath">VerbPath</a> | <a href="#rVerbSimple">VerbSimple</a> ) <a href="#rObjectList">ObjectList</a> )? )*</code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[84]&nbsp;&nbsp;</code></td>
                <td><code><a id="rVerbPath" name="rVerbPath">VerbPath</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rPath">Path</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[85]&nbsp;&nbsp;</code></td>
                <td><code><a id="rVerbSimple" name="rVerbSimple">VerbSimple</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rVar">Var</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[86]&nbsp;&nbsp;</code></td>
                <td><code><a id="rObjectListPath" name="rObjectListPath">ObjectListPath</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rObjectPath">ObjectPath</a> ( <span class="token">','</span> <a href="#rObjectPath">ObjectPath</a> )*</code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[87]&nbsp;&nbsp;</code></td>
                <td><code><a id="rObjectPath" name="rObjectPath">ObjectPath</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rGraphNodePath">GraphNodePath</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[88]&nbsp;&nbsp;</code></td>
                <td><code><a id="rPath" name="rPath">Path</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rPathAlternative">PathAlternative</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[89]&nbsp;&nbsp;</code></td>
                <td><code><a id="rPathAlternative" name="rPathAlternative">PathAlternative</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rPathSequence">PathSequence</a> ( <span class="token">'|'</span> <a href="#rPathSequence">PathSequence</a> )*</code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[90]&nbsp;&nbsp;</code></td>
                <td><code><a id="rPathSequence" name="rPathSequence">PathSequence</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rPathEltOrInverse">PathEltOrInverse</a> ( <span class="token">'/'</span> <a href="#rPathEltOrInverse">PathEltOrInverse</a> )*</code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[91]&nbsp;&nbsp;</code></td>
                <td><code><a id="rPathElt" name="rPathElt">PathElt</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rPathPrimary">PathPrimary</a> <a href="#rPathMod">PathMod</a>?</code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[92]&nbsp;&nbsp;</code></td>
                <td><code><a id="rPathEltOrInverse" name="rPathEltOrInverse">PathEltOrInverse</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rPathElt">PathElt</a> | <span class="token">'^'</span> <a href="#rPathElt">PathElt</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[93]&nbsp;&nbsp;</code></td>
                <td><code><a id="rPathMod" name="rPathMod">PathMod</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'?'</span> | <span class="token">'*'</span> | <span class="token">'+'</span></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[94]&nbsp;&nbsp;</code></td>
                <td><code><a id="rPathPrimary" name="rPathPrimary">PathPrimary</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#riri">iri</a> | <span class="token">'a'</span> | <span class="token">'!'</span> <a href="#rPathNegatedPropertySet">PathNegatedPropertySet</a> | <span class=
                "token">'('</span> <a href="#rPath">Path</a> <span class="token">')'</span></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[95]&nbsp;&nbsp;</code></td>
                <td><code><a id="rPathNegatedPropertySet" name="rPathNegatedPropertySet">PathNegatedPropertySet</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rPathOneInPropertySet">PathOneInPropertySet</a> | <span class="token">'('</span> ( <a href="#rPathOneInPropertySet">PathOneInPropertySet</a> ( <span class=
                "token">'|'</span> <a href="#rPathOneInPropertySet">PathOneInPropertySet</a> )* )? <span class="token">')'</span></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[96]&nbsp;&nbsp;</code></td>
                <td><code><a id="rPathOneInPropertySet" name="rPathOneInPropertySet">PathOneInPropertySet</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#riri">iri</a> | <span class="token">'a'</span> | <span class="token">'^'</span> ( <a href="#riri">iri</a> | <span class="token">'a'</span> )</code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[97]&nbsp;&nbsp;</code></td>
                <td><code><a id="rInteger" name="rInteger">Integer</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rINTEGER">INTEGER</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[98]&nbsp;&nbsp;</code></td>
                <td><code><a id="rTriplesNode" name="rTriplesNode">TriplesNode</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rCollection">Collection</a> | <a href="#rBlankNodePropertyList">BlankNodePropertyList</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[99]&nbsp;&nbsp;</code></td>
                <td><code><a id="rBlankNodePropertyList" name="rBlankNodePropertyList">BlankNodePropertyList</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'['</span> <a href="#rPropertyListNotEmpty">PropertyListNotEmpty</a> <span class="token">']'</span></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[100]&nbsp;&nbsp;</code></td>
                <td><code><a id="rTriplesNodePath" name="rTriplesNodePath">TriplesNodePath</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rCollectionPath">CollectionPath</a> | <a href="#rBlankNodePropertyListPath">BlankNodePropertyListPath</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[101]&nbsp;&nbsp;</code></td>
                <td><code><a id="rBlankNodePropertyListPath" name="rBlankNodePropertyListPath">BlankNodePropertyListPath</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'['</span> <a href="#rPropertyListPathNotEmpty">PropertyListPathNotEmpty</a> <span class="token">']'</span></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[102]&nbsp;&nbsp;</code></td>
                <td><code><a id="rCollection" name="rCollection">Collection</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'('</span> <a href="#rGraphNode">GraphNode</a>+ <span class="token">')'</span></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[103]&nbsp;&nbsp;</code></td>
                <td><code><a id="rCollectionPath" name="rCollectionPath">CollectionPath</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'('</span> <a href="#rGraphNodePath">GraphNodePath</a>+ <span class="token">')'</span></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[104]&nbsp;&nbsp;</code></td>
                <td><code><a id="rGraphNode" name="rGraphNode">GraphNode</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rVarOrTerm">VarOrTerm</a> | <a href="#rTriplesNode">TriplesNode</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[105]&nbsp;&nbsp;</code></td>
                <td><code><a id="rGraphNodePath" name="rGraphNodePath">GraphNodePath</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rVarOrTerm">VarOrTerm</a> | <a href="#rTriplesNodePath">TriplesNodePath</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[106]&nbsp;&nbsp;</code></td>
                <td><code><a id="rVarOrTerm" name="rVarOrTerm">VarOrTerm</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rVar">Var</a> | <a href="#rGraphTerm">GraphTerm</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[107]&nbsp;&nbsp;</code></td>
                <td><code><a id="rVarOrIri" name="rVarOrIri">VarOrIri</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rVar">Var</a> | <a href="#riri">iri</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[108]&nbsp;&nbsp;</code></td>
                <td><code><a id="rVar" name="rVar">Var</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rVAR1">VAR1</a> | <a href="#rVAR2">VAR2</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[109]&nbsp;&nbsp;</code></td>
                <td><code><a id="rGraphTerm" name="rGraphTerm">GraphTerm</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#riri">iri</a> | <a href="#rRDFLiteral">RDFLiteral</a> | <a href="#rNumericLiteral">NumericLiteral</a> | <a href="#rBooleanLiteral">BooleanLiteral</a> | <a href=
                "#rBlankNode">BlankNode</a> | <a href="#rNIL">NIL</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[110]&nbsp;&nbsp;</code></td>
                <td><code><a id="rExpression" name="rExpression">Expression</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rConditionalOrExpression">ConditionalOrExpression</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[111]&nbsp;&nbsp;</code></td>
                <td><code><a id="rConditionalOrExpression" name="rConditionalOrExpression">ConditionalOrExpression</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rConditionalAndExpression">ConditionalAndExpression</a> ( <span class="token">'||'</span> <a href="#rConditionalAndExpression">ConditionalAndExpression</a>
                )*</code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[112]&nbsp;&nbsp;</code></td>
                <td><code><a id="rConditionalAndExpression" name="rConditionalAndExpression">ConditionalAndExpression</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rValueLogical">ValueLogical</a> ( <span class="token">'&amp;&amp;'</span> <a href="#rValueLogical">ValueLogical</a> )*</code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[113]&nbsp;&nbsp;</code></td>
                <td><code><a id="rValueLogical" name="rValueLogical">ValueLogical</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rRelationalExpression">RelationalExpression</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[114]&nbsp;&nbsp;</code></td>
                <td><code><a id="rRelationalExpression" name="rRelationalExpression">RelationalExpression</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rNumericExpression">NumericExpression</a> ( <span class="token">'='</span> <a href="#rNumericExpression">NumericExpression</a> | <span class="token">'!='</span>
                <a href="#rNumericExpression">NumericExpression</a> | <span class="token">'&lt;'</span> <a href="#rNumericExpression">NumericExpression</a> | <span class="token">'&gt;'</span>
                <a href="#rNumericExpression">NumericExpression</a> | <span class="token">'&lt;='</span> <a href="#rNumericExpression">NumericExpression</a> | <span class="token">'&gt;='</span>
                <a href="#rNumericExpression">NumericExpression</a> | <span class="token">'IN'</span> <a href="#rExpressionList">ExpressionList</a> | <span class="token">'NOT'</span> <span class=
                "token">'IN'</span> <a href="#rExpressionList">ExpressionList</a> )?</code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[115]&nbsp;&nbsp;</code></td>
                <td><code><a id="rNumericExpression" name="rNumericExpression">NumericExpression</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rAdditiveExpression">AdditiveExpression</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[116]&nbsp;&nbsp;</code></td>
                <td><code><a id="rAdditiveExpression" name="rAdditiveExpression">AdditiveExpression</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rMultiplicativeExpression">MultiplicativeExpression</a> ( <span class="token">'+'</span> <a href="#rMultiplicativeExpression">MultiplicativeExpression</a> |
                <span class="token">'-'</span> <a href="#rMultiplicativeExpression">MultiplicativeExpression</a> | ( <a href="#rNumericLiteralPositive">NumericLiteralPositive</a> | <a href=
                "#rNumericLiteralNegative">NumericLiteralNegative</a> ) ( ( <span class="token">'*'</span> <a href="#rUnaryExpression">UnaryExpression</a> ) | ( <span class="token">'/'</span>
                <a href="#rUnaryExpression">UnaryExpression</a> ) )* )*</code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[117]&nbsp;&nbsp;</code></td>
                <td><code><a id="rMultiplicativeExpression" name="rMultiplicativeExpression">MultiplicativeExpression</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rUnaryExpression">UnaryExpression</a> ( <span class="token">'*'</span> <a href="#rUnaryExpression">UnaryExpression</a> | <span class="token">'/'</span> <a href=
                "#rUnaryExpression">UnaryExpression</a> )*</code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[118]&nbsp;&nbsp;</code></td>
                <td><code><a id="rUnaryExpression" name="rUnaryExpression">UnaryExpression</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code>&nbsp;&nbsp;<span class="token">'!'</span> <a href="#rPrimaryExpression">PrimaryExpression</a><br>
                | <span class="token">'+'</span> <a href="#rPrimaryExpression">PrimaryExpression</a><br>
                | <span class="token">'-'</span> <a href="#rPrimaryExpression">PrimaryExpression</a><br>
                | <a href="#rPrimaryExpression">PrimaryExpression</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[119]&nbsp;&nbsp;</code></td>
                <td><code><a id="rPrimaryExpression" name="rPrimaryExpression">PrimaryExpression</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rBrackettedExpression">BrackettedExpression</a> | <a href="#rBuiltInCall">BuiltInCall</a> | <a href="#ririOrFunction">iriOrFunction</a> | <a href=
                "#rRDFLiteral">RDFLiteral</a> | <a href="#rNumericLiteral">NumericLiteral</a> | <a href="#rBooleanLiteral">BooleanLiteral</a> | <a href="#rVar">Var</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[120]&nbsp;&nbsp;</code></td>
                <td><code><a id="rBrackettedExpression" name="rBrackettedExpression">BrackettedExpression</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[121]&nbsp;&nbsp;</code></td>
                <td><code><a id="rBuiltInCall" name="rBuiltInCall">BuiltInCall</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code>&nbsp;&nbsp;<a href="#rAggregate">Aggregate</a><br>
                | <span class="token">'STR'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                | <span class="token">'LANG'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                | <span class="token">'LANGMATCHES'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a>
                <span class="token">')'</span><br>
                | <span class="token">'DATATYPE'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                | <span class="token">'BOUND'</span> <span class="token">'('</span> <a href="#rVar">Var</a> <span class="token">')'</span><br>
                | <span class="token">'IRI'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                | <span class="token">'URI'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                | <span class="token">'BNODE'</span> ( <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> | <a href="#rNIL">NIL</a> )<br>
                | <span class="token">'RAND'</span> <a href="#rNIL">NIL</a><br>
                | <span class="token">'ABS'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                | <span class="token">'CEIL'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                | <span class="token">'FLOOR'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                | <span class="token">'ROUND'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                | <span class="token">'CONCAT'</span> <a href="#rExpressionList">ExpressionList</a><br>
                | <a href="#rSubstringExpression">SubstringExpression</a><br>
                | <span class="token">'STRLEN'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                | <a href="#rStrReplaceExpression">StrReplaceExpression</a><br>
                | <span class="token">'UCASE'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                | <span class="token">'LCASE'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                | <span class="token">'ENCODE_FOR_URI'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                | <span class="token">'CONTAINS'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a>
                <span class="token">')'</span><br>
                | <span class="token">'STRSTARTS'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a>
                <span class="token">')'</span><br>
                | <span class="token">'STRENDS'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a>
                <span class="token">')'</span><br>
                | <span class="token">'STRBEFORE'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a>
                <span class="token">')'</span><br>
                | <span class="token">'STRAFTER'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a>
                <span class="token">')'</span><br>
                | <span class="token">'YEAR'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                | <span class="token">'MONTH'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                | <span class="token">'DAY'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                | <span class="token">'HOURS'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                | <span class="token">'MINUTES'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                | <span class="token">'SECONDS'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                | <span class="token">'TIMEZONE'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                | <span class="token">'TZ'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                | <span class="token">'NOW'</span> <a href="#rNIL">NIL</a><br>
                | <span class="token">'UUID'</span> <a href="#rNIL">NIL</a><br>
                | <span class="token">'STRUUID'</span> <a href="#rNIL">NIL</a><br>
                | <span class="token">'MD5'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                | <span class="token">'SHA1'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                | <span class="token">'SHA256'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                | <span class="token">'SHA384'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                | <span class="token">'SHA512'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                | <span class="token">'COALESCE'</span> <a href="#rExpressionList">ExpressionList</a><br>
                | <span class="token">'IF'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a>
                <span class="token">','</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                | <span class="token">'STRLANG'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a>
                <span class="token">')'</span><br>
                | <span class="token">'STRDT'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a>
                <span class="token">')'</span><br>
                | <span class="token">'sameTerm'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a>
                <span class="token">')'</span><br>
                | <span class="token">'isIRI'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                | <span class="token">'isURI'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                | <span class="token">'isBLANK'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                | <span class="token">'isLITERAL'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                | <span class="token">'isNUMERIC'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                | <a href="#rRegexExpression">RegexExpression</a><br>
                | <a href="#rExistsFunc">ExistsFunc</a><br>
                | <a href="#rNotExistsFunc">NotExistsFunc</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[122]&nbsp;&nbsp;</code></td>
                <td><code><a id="rRegexExpression" name="rRegexExpression">RegexExpression</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'REGEX'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a>
                ( <span class="token">','</span> <a href="#rExpression">Expression</a> )? <span class="token">')'</span></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[123]&nbsp;&nbsp;</code></td>
                <td><code><a id="rSubstringExpression" name="rSubstringExpression">SubstringExpression</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'SUBSTR'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a>
                ( <span class="token">','</span> <a href="#rExpression">Expression</a> )? <span class="token">')'</span></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[124]&nbsp;&nbsp;</code></td>
                <td><code><a id="rStrReplaceExpression" name="rStrReplaceExpression">StrReplaceExpression</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'REPLACE'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href=
                "#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a> ( <span class="token">','</span> <a href="#rExpression">Expression</a> )?
                <span class="token">')'</span></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[125]&nbsp;&nbsp;</code></td>
                <td><code><a id="rExistsFunc" name="rExistsFunc">ExistsFunc</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'EXISTS'</span> <a href="#rGroupGraphPattern">GroupGraphPattern</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[126]&nbsp;&nbsp;</code></td>
                <td><code><a id="rNotExistsFunc" name="rNotExistsFunc">NotExistsFunc</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'NOT'</span> <span class="token">'EXISTS'</span> <a href="#rGroupGraphPattern">GroupGraphPattern</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[127]&nbsp;&nbsp;</code></td>
                <td><code><a id="rAggregate" name="rAggregate">Aggregate</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code>&nbsp;&nbsp;<span class="token">'COUNT'</span> <span class="token">'('</span> <span class="token">'DISTINCT'</span>? ( <span class="token">'*'</span> | <a href=
                "#rExpression">Expression</a> ) <span class="token">')'</span><br>
                | <span class="token">'SUM'</span> <span class="token">'('</span> <span class="token">'DISTINCT'</span>? <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                | <span class="token">'MIN'</span> <span class="token">'('</span> <span class="token">'DISTINCT'</span>? <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                | <span class="token">'MAX'</span> <span class="token">'('</span> <span class="token">'DISTINCT'</span>? <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                | <span class="token">'AVG'</span> <span class="token">'('</span> <span class="token">'DISTINCT'</span>? <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                | <span class="token">'SAMPLE'</span> <span class="token">'('</span> <span class="token">'DISTINCT'</span>? <a href="#rExpression">Expression</a> <span class="token">')'</span><br>
                | <span class="token">'GROUP_CONCAT'</span> <span class="token">'('</span> <span class="token">'DISTINCT'</span>? <a href="#rExpression">Expression</a> ( <span class=
                "token">';'</span> <span class="token">'SEPARATOR'</span> <span class="token">'='</span> <a href="#rString">String</a> )? <span class="token">')'</span></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[128]&nbsp;&nbsp;</code></td>
                <td><code><a id="ririOrFunction" name="ririOrFunction">iriOrFunction</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#riri">iri</a> <a href="#rArgList">ArgList</a>?</code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[129]&nbsp;&nbsp;</code></td>
                <td><code><a id="rRDFLiteral" name="rRDFLiteral">RDFLiteral</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rString">String</a> ( <a href="#rLANGTAG">LANGTAG</a> | ( <span class="token">'^^'</span> <a href="#riri">iri</a> ) )?</code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[130]&nbsp;&nbsp;</code></td>
                <td><code><a id="rNumericLiteral" name="rNumericLiteral">NumericLiteral</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rNumericLiteralUnsigned">NumericLiteralUnsigned</a> | <a href="#rNumericLiteralPositive">NumericLiteralPositive</a> | <a href=
                "#rNumericLiteralNegative">NumericLiteralNegative</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[131]&nbsp;&nbsp;</code></td>
                <td><code><a id="rNumericLiteralUnsigned" name="rNumericLiteralUnsigned">NumericLiteralUnsigned</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rINTEGER">INTEGER</a> | <a href="#rDECIMAL">DECIMAL</a> | <a href="#rDOUBLE">DOUBLE</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[132]&nbsp;&nbsp;</code></td>
                <td><code><a id="rNumericLiteralPositive" name="rNumericLiteralPositive">NumericLiteralPositive</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rINTEGER_POSITIVE">INTEGER_POSITIVE</a> | <a href="#rDECIMAL_POSITIVE">DECIMAL_POSITIVE</a> | <a href="#rDOUBLE_POSITIVE">DOUBLE_POSITIVE</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[133]&nbsp;&nbsp;</code></td>
                <td><code><a id="rNumericLiteralNegative" name="rNumericLiteralNegative">NumericLiteralNegative</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rINTEGER_NEGATIVE">INTEGER_NEGATIVE</a> | <a href="#rDECIMAL_NEGATIVE">DECIMAL_NEGATIVE</a> | <a href="#rDOUBLE_NEGATIVE">DOUBLE_NEGATIVE</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[134]&nbsp;&nbsp;</code></td>
                <td><code><a id="rBooleanLiteral" name="rBooleanLiteral">BooleanLiteral</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'true'</span> | <span class="token">'false'</span></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[135]&nbsp;&nbsp;</code></td>
                <td><code><a id="rString" name="rString">String</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rSTRING_LITERAL1">STRING_LITERAL1</a> | <a href="#rSTRING_LITERAL2">STRING_LITERAL2</a> | <a href="#rSTRING_LITERAL_LONG1">STRING_LITERAL_LONG1</a> | <a href=
                "#rSTRING_LITERAL_LONG2">STRING_LITERAL_LONG2</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[136]&nbsp;&nbsp;</code></td>
                <td><code><a id="riri" name="riri">iri</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rIRIREF">IRIREF</a> | <a href="#rPrefixedName">PrefixedName</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[137]&nbsp;&nbsp;</code></td>
                <td><code><a id="rPrefixedName" name="rPrefixedName">PrefixedName</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rPNAME_LN">PNAME_LN</a> | <a href="#rPNAME_NS">PNAME_NS</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[138]&nbsp;&nbsp;</code></td>
                <td><code><a id="rBlankNode" name="rBlankNode">BlankNode</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rBLANK_NODE_LABEL">BLANK_NODE_LABEL</a> | <a href="#rANON">ANON</a></code></td>
              </tr>
            </tbody>
          </table>
        </div>
        <p>Productions for terminals:</p>
        <div class="grammarTable">
          <table>
            <tbody>
              <tr valign="baseline">
                <td><code>[139]&nbsp;&nbsp;</code></td>
                <td><code><a id="rIRIREF" name="rIRIREF">IRIREF</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'&lt;' ([^&lt;&gt;"{}|^`\]-[#x00-#x20])* '&gt;'</span></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[140]&nbsp;&nbsp;</code></td>
                <td><code><a id="rPNAME_NS" name="rPNAME_NS">PNAME_NS</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rPN_PREFIX">PN_PREFIX</a>? ':'</code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[141]&nbsp;&nbsp;</code></td>
                <td><code><a id="rPNAME_LN" name="rPNAME_LN">PNAME_LN</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rPNAME_NS">PNAME_NS</a> <a href="#rPN_LOCAL">PN_LOCAL</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[142]&nbsp;&nbsp;</code></td>
                <td><code><a id="rBLANK_NODE_LABEL" name="rBLANK_NODE_LABEL">BLANK_NODE_LABEL</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code>'_:' ( <a href="#rPN_CHARS_U">PN_CHARS_U</a> | [0-9] ) ((<a href="#rPN_CHARS">PN_CHARS</a>|'.')* <a href="#rPN_CHARS">PN_CHARS</a>)?</code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[143]&nbsp;&nbsp;</code></td>
                <td><code><a id="rVAR1" name="rVAR1">VAR1</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code>'?' <a href="#rVARNAME">VARNAME</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[144]&nbsp;&nbsp;</code></td>
                <td><code><a id="rVAR2" name="rVAR2">VAR2</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code>'$' <a href="#rVARNAME">VARNAME</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[145]&nbsp;&nbsp;</code></td>
                <td><code><a id="rLANGTAG" name="rLANGTAG">LANGTAG</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code>'@' [a-zA-Z]+ ('-' [a-zA-Z0-9]+)*</code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[146]&nbsp;&nbsp;</code></td>
                <td><code><a id="rINTEGER" name="rINTEGER">INTEGER</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code>[0-9]+</code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[147]&nbsp;&nbsp;</code></td>
                <td><code><a id="rDECIMAL" name="rDECIMAL">DECIMAL</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code>[0-9]* '.' [0-9]+</code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[148]&nbsp;&nbsp;</code></td>
                <td><code><a id="rDOUBLE" name="rDOUBLE">DOUBLE</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code>[0-9]+ '.' [0-9]* <a href="#rEXPONENT">EXPONENT</a> | '.' ([0-9])+ <a href="#rEXPONENT">EXPONENT</a> | ([0-9])+ <a href="#rEXPONENT">EXPONENT</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[149]&nbsp;&nbsp;</code></td>
                <td><code><a id="rINTEGER_POSITIVE" name="rINTEGER_POSITIVE">INTEGER_POSITIVE</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'+'</span> <a href="#rINTEGER">INTEGER</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[150]&nbsp;&nbsp;</code></td>
                <td><code><a id="rDECIMAL_POSITIVE" name="rDECIMAL_POSITIVE">DECIMAL_POSITIVE</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'+'</span> <a href="#rDECIMAL">DECIMAL</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[151]&nbsp;&nbsp;</code></td>
                <td><code><a id="rDOUBLE_POSITIVE" name="rDOUBLE_POSITIVE">DOUBLE_POSITIVE</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'+'</span> <a href="#rDOUBLE">DOUBLE</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[152]&nbsp;&nbsp;</code></td>
                <td><code><a id="rINTEGER_NEGATIVE" name="rINTEGER_NEGATIVE">INTEGER_NEGATIVE</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'-'</span> <a href="#rINTEGER">INTEGER</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[153]&nbsp;&nbsp;</code></td>
                <td><code><a id="rDECIMAL_NEGATIVE" name="rDECIMAL_NEGATIVE">DECIMAL_NEGATIVE</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'-'</span> <a href="#rDECIMAL">DECIMAL</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[154]&nbsp;&nbsp;</code></td>
                <td><code><a id="rDOUBLE_NEGATIVE" name="rDOUBLE_NEGATIVE">DOUBLE_NEGATIVE</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><span class="token">'-'</span> <a href="#rDOUBLE">DOUBLE</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[155]&nbsp;&nbsp;</code></td>
                <td><code><a id="rEXPONENT" name="rEXPONENT">EXPONENT</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code>[eE] [+-]? [0-9]+</code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[156]&nbsp;&nbsp;</code></td>
                <td><code><a id="rSTRING_LITERAL1" name="rSTRING_LITERAL1">STRING_LITERAL1</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code>"'" ( ([^#x27#x5C#xA#xD]) | <a href="#rECHAR">ECHAR</a> )* "'"</code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[157]&nbsp;&nbsp;</code></td>
                <td><code><a id="rSTRING_LITERAL2" name="rSTRING_LITERAL2">STRING_LITERAL2</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code>'"' ( ([^#x22#x5C#xA#xD]) | <a href="#rECHAR">ECHAR</a> )* '"'</code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[158]&nbsp;&nbsp;</code></td>
                <td><code><a id="rSTRING_LITERAL_LONG1" name="rSTRING_LITERAL_LONG1">STRING_LITERAL_LONG1</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code>"'''" ( ( "'" | "''" )? ( [^'\] | <a href="#rECHAR">ECHAR</a> ) )* "'''"</code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[159]&nbsp;&nbsp;</code></td>
                <td><code><a id="rSTRING_LITERAL_LONG2" name="rSTRING_LITERAL_LONG2">STRING_LITERAL_LONG2</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code>'"""' ( ( '"' | '""' )? ( [^"\] | <a href="#rECHAR">ECHAR</a> ) )* '"""'</code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[160]&nbsp;&nbsp;</code></td>
                <td><code><a id="rECHAR" name="rECHAR">ECHAR</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code>'\' [tbnrf\"']</code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[161]&nbsp;&nbsp;</code></td>
                <td><code><a id="rNIL" name="rNIL">NIL</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code>'(' <a href="#rWS">WS</a>* ')'</code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[162]&nbsp;&nbsp;</code></td>
                <td><code><a id="rWS" name="rWS">WS</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code>#x20 | #x9 | #xD | #xA</code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[163]&nbsp;&nbsp;</code></td>
                <td><code><a id="rANON" name="rANON">ANON</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code>'[' <a href="#rWS">WS</a>* ']'</code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[164]&nbsp;&nbsp;</code></td>
                <td><code><a id="rPN_CHARS_BASE" name="rPN_CHARS_BASE">PN_CHARS_BASE</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code>[A-Z] | [a-z] | [#x00C0-#x00D6] | [#x00D8-#x00F6] | [#x00F8-#x02FF] | [#x0370-#x037D] | [#x037F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] |
                [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]</code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[165]&nbsp;&nbsp;</code></td>
                <td><code><a id="rPN_CHARS_U" name="rPN_CHARS_U">PN_CHARS_U</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rPN_CHARS_BASE">PN_CHARS_BASE</a> | '_'</code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[166]&nbsp;&nbsp;</code></td>
                <td><code><a id="rVARNAME" name="rVARNAME">VARNAME</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code>( <a href="#rPN_CHARS_U">PN_CHARS_U</a> | [0-9] ) ( <a href="#rPN_CHARS_U">PN_CHARS_U</a> | [0-9] | #x00B7 | [#x0300-#x036F] | [#x203F-#x2040] )*</code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[167]&nbsp;&nbsp;</code></td>
                <td><code><a id="rPN_CHARS" name="rPN_CHARS">PN_CHARS</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rPN_CHARS_U">PN_CHARS_U</a> | '-' | [0-9] | #x00B7 | [#x0300-#x036F] | [#x203F-#x2040]</code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[168]&nbsp;&nbsp;</code></td>
                <td><code><a id="rPN_PREFIX" name="rPN_PREFIX">PN_PREFIX</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rPN_CHARS_BASE">PN_CHARS_BASE</a> ((<a href="#rPN_CHARS">PN_CHARS</a>|'.')* <a href="#rPN_CHARS">PN_CHARS</a>)?</code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[169]&nbsp;&nbsp;</code></td>
                <td><code><a id="rPN_LOCAL" name="rPN_LOCAL">PN_LOCAL</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code>(<a href="#rPN_CHARS_U">PN_CHARS_U</a> | ':' | [0-9] | <a href="#rPLX">PLX</a> ) ((<a href="#rPN_CHARS">PN_CHARS</a> | '.' | ':' | <a href="#rPLX">PLX</a>)* (<a href=
                "#rPN_CHARS">PN_CHARS</a> | ':' | <a href="#rPLX">PLX</a>) )?</code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[170]&nbsp;&nbsp;</code></td>
                <td><code><a id="rPLX" name="rPLX">PLX</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code><a href="#rPERCENT">PERCENT</a> | <a href="#rPN_LOCAL_ESC">PN_LOCAL_ESC</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[171]&nbsp;&nbsp;</code></td>
                <td><code><a id="rPERCENT" name="rPERCENT">PERCENT</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code>'%' <a href="#rHEX">HEX</a> <a href="#rHEX">HEX</a></code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[172]&nbsp;&nbsp;</code></td>
                <td><code><a id="rHEX" name="rHEX">HEX</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code>[0-9] | [A-F] | [a-f]</code></td>
              </tr>
              <tr valign="baseline">
                <td><code>[173]&nbsp;&nbsp;</code></td>
                <td><code><a id="rPN_LOCAL_ESC" name="rPN_LOCAL_ESC">PN_LOCAL_ESC</a></code></td>
                <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
                <td><code>'\' ( '_' | '~' | '.' | '-' | '!' | '$' | '&amp;' | "'" | '(' | ')' | '*' | '+' | ',' | ';' | '=' | '/' | '?' | '#' | '@' | '%' )</code></td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>
    <div class="div1">
      <h2><a name="conformance" id="conformance"></a>20 Conformance</h2>
      <p>See Section <a href="#grammar">19 SPARQL Grammar</a> regarding conformance of <a href="#defn_SPARQLQueryString">SPARQL Query strings</a>, and section <a href="#QueryForms">16 Query Forms</a>
      for conformance of query results. See section <a href="#mediaType">22. Internet Media Type</a> for conformance to the application/sparql-query media type.</p>
      <p>This specification is intended for use in conjunction with the SPARQL 1.1 Protocol [<a href="#SPROT">SPROT</a>], the SPARQL Query Results XML Format [<a href="#SPARQL-XML-RESULTS">SPARQL XML
      Results</a>], the SPARQL 1.1 Query Results JSON Format [<a href="#SPARQL-JSON-RESULTS">SPARQL-JSON-Results</a>] and the SPARQL 1.1 Query Results CSV and TSV Formats [<a href=
      "#SPARQL-CSV-TSV-RESULTS">SPARQL CSV and TSV Results</a>]. See those specifications for their conformance criteria.</p>
      <p>Note that the SPARQL protocol describes a means for conveying SPARQL queries to an SPARQL query processing service and returning the query results to the entity that requested them.</p>
    </div>
    <div class="div1">
      <h2><a name="security" id="security"></a>21 Security Considerations (Informative)</h2>
      <p>SPARQL queries using FROM, FROM NAMED, or GRAPH may cause the specified URI to be dereferenced. This may cause additional use of network, disk or CPU resources along with associated
      secondary issues such as denial of service. The security issues of <a class="norm" href="http://www.ietf.org/rfc/rfc3986.txt">Uniform Resource Identifier (URI): Generic Syntax</a> [<a href=
      "#rfc3986">RFC3986</a>] Section 7 should be considered. In addition, the contents of <code>file:</code> URIs can in some cases be accessed, processed and returned as results, providing
      unintended access to local resources.</p>
      <p>SPARQL requests may cause additional requests to be issued from the SPARQL endpoint, such as FROM NAMED. The endpoint is potentially within an organisations firewall or DMZ, and so such
      queries may be a source of indirection attacks.</p>
      <p>The SPARQL language permits extensions, which will have their own security implications.</p>
      <p>Multiple IRIs may have the same appearance. Characters in different scripts may look similar (a Cyrillic "о" may appear similar to a Latin "o"). A character followed by combining characters
      may have the same visual representation as another character (LATIN SMALL LETTER E followed by COMBINING ACUTE ACCENT has the same visual representation as LATIN SMALL LETTER E WITH ACUTE).
      Users of SPARQL must take care to construct queries with IRIs that match the IRIs in the data. Further information about matching of similar characters can be found in <a class="inform" href=
      "http://www.unicode.org/reports/tr36/">Unicode Security Considerations</a> [<a href="#UNISEC">UNISEC</a>] and <a class="norm" href="http://www.ietf.org/rfc/rfc3987.txt">Internationalized
      Resource Identifiers (IRIs)</a> [<a href="#rfc3987">RFC3987</a>] Section 8.</p>
    </div>
    <div class="div1">
      <h2><a name="mediaType" id="mediaType"></a>22 Internet Media Type, File Extension and Macintosh File Type</h2>
      <p>The Internet Media Type / MIME Type for the SPARQL Query Language is "<tt>application/sparql-query</tt>".</p>
      <p>It is recommended that sparql query files have the extension ".rq" (lowercase) on all platforms.</p>
      <p>It is recommended that sparql query files stored on Macintosh HFS file systems be given a file type of "TEXT".</p>
      <div class="mime">
        <dl>
          <dt>Type name:</dt>
          <dd>application</dd>
          <dt>Subtype name:</dt>
          <dd>sparql-query</dd>
          <dt>Required parameters:</dt>
          <dd>None</dd>
          <dt>Optional parameters:</dt>
          <dd>None</dd>
          <dt>Encoding considerations:</dt>
          <dd>The syntax of the SPARQL Query Language is expressed over code points in Unicode [<a href="#UNICODE">UNICODE</a>]. The encoding is always UTF-8 [<a href="#rfc3629">RFC3629</a>].</dd>
          <dd>Unicode code points may also be expressed using an \uXXXX (U+0 to U+FFFF) or \UXXXXXXXX syntax (for U+10000 onwards) where X is a hexadecimal digit [0-9A-F]</dd>
          <dt>Security considerations:</dt>
          <dd>See SPARQL Query appendix C, <a href="#security">Security Considerations</a> as well as <a class="norm" href="http://www.ietf.org/rfc/rfc3629.txt">RFC 3629</a> [<a href=
          "#rfc3629">RFC3629</a>] section 7, Security Considerations.</dd>
          <dt>Interoperability considerations:</dt>
          <dd>There are no known interoperability issues.</dd>
          <dt>Published specification:</dt>
          <dd>This specification.</dd>
          <dt>Applications which use this media type:</dt>
          <dd>No known applications currently use this media type.</dd>
          <dt>Additional information:</dt>
          <dt>Magic number(s):</dt>
          <dd>A SPARQL query may have the string 'PREFIX' (case independent) near the beginning of the document.</dd>
          <dt>File extension(s):</dt>
          <dd>".rq"</dd>
          <dt>Base URI:</dt>
          <dd>The SPARQL 'BASE &lt;IRIref&gt;' term can change the current base URI for relative IRIrefs in the query language that are used sequentially later in the document.</dd>
          <dt>Macintosh file type code(s):</dt>
          <dd>"TEXT"</dd>
          <dt>Person &amp; email address to contact for further information:</dt>
          <dd>public-rdf-dawg-comments@w3.org</dd>
          <dt>Intended usage:</dt>
          <dd>COMMON</dd>
          <dt>Restrictions on usage:</dt>
          <dd>None</dd>
          <dt>Author/Change controller:</dt>
          <dd>The SPARQL 1.1 specification is a work product of the World Wide Web Consortium's SPARQL Working Group. The W3C has change control over these specifications.</dd>
        </dl>
      </div>
    </div>
  </div>
  <div class="back">
    <div class="div1">
      <h2><a name="sec-bibliography" id="sec-bibliography"></a>A References</h2>
      <div class="div2">
        <h3><a name="sec-normative-refs" id="sec-normative-refs"></a>A.1 Normative References</h3>
        <dl class="bib">
          <dt><a name="CHARMOD" id="CHARMOD">[CHARMOD]</a></dt>
          <dd><a href="http://www.w3.org/TR/2005/REC-charmod-20050215/">Character Model for the World Wide Web 1.0: Fundamentals</a>, R. Ishida, F. Yergeau, M. J. Dürst, M. Wolf, T. Texin, Editors,
          W3C Recommendation, 15 February 2005, http://www.w3.org/TR/2005/REC-charmod-20050215/ . <a href="http://www.w3.org/TR/charmod/" title=
          "Latest version of Character Model for the World Wide Web 1.0: Fundamentals">Latest version</a> available at http://www.w3.org/TR/charmod/ .</dd>
          <dt><a name="CONCEPTS" id="CONCEPTS">[CONCEPTS]</a></dt>
          <dd><a href="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/">Resource Description Framework (RDF): Concepts and Abstract Syntax</a>, G. Klyne, J. J. Carroll, Editors, W3C
          Recommendation, 10 February 2004, http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/ . <a href="http://www.w3.org/TR/rdf-concepts/" title=
          "Latest version of Resource Description Framework (RDF): Concepts and Abstract Syntax">Latest version</a> available at http://www.w3.org/TR/rdf-concepts/ .</dd>
          <dt><a name="FUNCOP" id="FUNCOP">[FUNCOP]</a></dt>
          <dd><a href="http://www.w3.org/TR/2007/REC-xpath-functions-20070123/">XQuery 1.0 and XPath 2.0 Functions and Operators</a>, J. Melton, A. Malhotra, N. Walsh, Editors, W3C Recommendation, 23
          January 2007, http://www.w3.org/TR/2007/REC-xpath-functions-20070123/ . <a href="http://www.w3.org/TR/xpath-functions/" title=
          "Latest version of XQuery 1.0 and XPath 2.0 Functions and Operators">Latest version</a> available at http://www.w3.org/TR/xpath-functions/ .</dd>
          <dt><a id="RDF-MT" name="RDF-MT">[RDF-MT]</a></dt>
          <dd><a href="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/">RDF Semantics</a>, P. Hayes, Editor, W3C Recommendation, 10 February 2004, http://www.w3.org/TR/2004/REC-rdf-mt-20040210/ .
          <a title="Latest version of RDF Semantics" href="http://www.w3.org/TR/rdf-mt/">Latest version</a> available at http://www.w3.org/TR/rdf-mt/ .</dd>
          <dt><a name="rfc3629" id="rfc3629">[RFC3629]</a></dt>
          <dd>RFC 3629 <a href="http://www.ietf.org/rfc/rfc3629.txt">UTF-8, a transformation format of ISO 10646</a>, F. Yergeau November 2003</dd>
          <dt><a name="rfc4647" id="rfc4647">[RFC4647]</a></dt>
          <dd>RFC 4647 <a href="http://www.ietf.org/rfc/rfc4647.txt">Matching of Language Tags</a>, A. Phillips, M. Davis September 2006</dd>
          <dt><a name="rfc3986" id="rfc3986">[RFC3986]</a></dt>
          <dd>RFC 3986 <a href="http://www.ietf.org/rfc/rfc3986.txt">Uniform Resource Identifier (URI): Generic Syntax</a>, T. Berners-Lee, R. Fielding, L. Masinter January 2005</dd>
          <dt><a name="rfc3987" id="rfc3987">[RFC3987]</a></dt>
          <dd>RFC 3987 <a href="http://www.ietf.org/rfc/rfc3987.txt">Internationalized Resource Identifiers (IRIs)</a>, M. Dürst , M. Suignard</dd>
          <dt><a name="UNICODE" id="UNICODE">[UNICODE]</a></dt>
          <dd>The Unicode Standard, Version 4. ISBN 0-321-18578-1, as updated from time to time by the publication of new versions. The latest version of Unicode and additional information on
          versions of the standard and of the Unicode Character Database is available at <a href=
          "http://www.unicode.org/unicode/standard/versions/">http://www.unicode.org/unicode/standard/versions/</a>.</dd>
          <dt><a name="XML11" id="XML11">[XML11]</a></dt>
          <dd><a href="http://www.w3.org/TR/2004/REC-xml11-20040204/">Extensible Markup Language (XML) 1.1</a>, J. Cowan, J. Paoli, E. Maler, C. M. Sperberg-McQueen, F. Yergeau, T. Bray, Editors, W3C
          Recommendation, 4 February 2004, http://www.w3.org/TR/2004/REC-xml11-20040204/ . <a href="http://www.w3.org/TR/xml11/" title="Latest version of Extensible Markup Language (XML) 1.1">Latest
          version</a> available at http://www.w3.org/TR/xml11/ .</dd>
          <dt><a name="XPATH20" id="XPATH20">[XPATH20]</a></dt>
          <dd><a href="http://www.w3.org/TR/2007/REC-xpath20-20070123/">XML Path Language (XPath) 2.0</a>, A. Berglund, S. Boag, D. Chamberlin, M. F. Fernández, M. Kay, J. Robie, J. Siméon, Editors,
          W3C Recommendation, 23 January 2007, http://www.w3.org/TR/2007/REC-xpath20-20070123/ . <a href="http://www.w3.org/TR/xpath20/" title="Latest version of XML Path Language (XPath) 2.0">Latest
          version</a> available at http://www.w3.org/TR/xpath20/ .</dd>
          <dt><a name="XQUERY" id="XQUERY">[XQUERY]</a></dt>
          <dd><a href="http://www.w3.org/TR/2007/REC-xquery-20070123/">XQuery 1.0: An XML Query Language</a>, S. Boag, D. Chamberlin, M. F. Fernández, D. Florescu, J. Robie, J. Siméon, Editors, W3C
          Recommendation, 23 January 2007, http://www.w3.org/TR/2007/REC-xquery-20070123/. <a href="http://www.w3.org/TR/xquery/" title="Latest version of XQuery 1.0: An XML Query Language">Latest
          version</a> available at http://www.w3.org/TR/xquery/ .</dd>
          <dt><a name="XSDT" id="XSDT">[XSDT]</a></dt>
          <dd><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/">XML Schema Part 2: Datatypes Second Edition</a>, P. V. Biron, A. Malhotra, Editors, W3C Recommendation, 28 October 2004,
          http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/ . <a href="http://www.w3.org/TR/xmlschema-2/">Latest version</a> available at http://www.w3.org/TR/xmlschema-2/.<br>
          Updated 2012 by <a href="http://www.w3.org/TR/2012/REC-xmlschema11-2-20120405/">W3C XML Schema Definition Language (XSD) 1.1 Part 2: Datatypes</a>. (<a href=
          "http://www.w3.org/TR/xmlschema11-2/">Latest version</a> available at http://www.w3.org/TR/xmlschema11-2/).</dd>
          <dt><a name="BCP47" id="BCP47">[BCP47]</a></dt>
          <dd><a href="http://www.rfc-editor.org/rfc/bcp/bcp47.txt">Best Common Practice 47</a>, P. V. Biron, A. Malhotra, Editors, W3C Recommendation, 28 October 2004,
          http://www.rfc-editor.org/rfc/bcp/bcp47.txt .</dd>
        </dl>
      </div>
      <div class="div2">
        <h3><a name="sec-non-normative-refs" id="sec-non-normative-refs"></a>A.2 Other References</h3>
        <dl class="bib">
          <dt><a name="CBD" id="CBD">[CBD]</a></dt>
          <dd><a href="http://www.w3.org/Submission/CBD/">CBD - Concise Bounded Description</a>, Patrick Stickler, Nokia, W3C Member Submission, 3 June 2005.</dd>
          <dt><a name="DC" id="DC">[DC]</a></dt>
          <dd><a href="http://www.dublincore.org/documents/dcmes-xml/">Expressing Simple Dublin Core in RDF/XML</a> <a href="http://dublincore.org/">Dublin Core Dublin Core Metadata Initiative</a>
          Recommendation 2002-07-31.</dd>
          <dt><a id="multiset" name="multiset">[Multiset]</a></dt>
          <dd><a href="http://en.wikipedia.org/w/index.php?title=Multiset&amp;oldid=163605900">Multiset</a>, Wikipedia, The Free Encyclopedia. Article as given on October 25, 2007 at
          http://en.wikipedia.org/w/index.php?title=Multiset&amp;oldid=163605900. The <a href="http://en.wikipedia.org/wiki/Multiset">latest version</a> of this article is at
          http://en.wikipedia.org/wiki/Multiset.</dd>
          <dt><a name="SPARQL-XML-RESULTS" id="SPARQL-XML-RESULTS">[SPARQL XML Results]</a></dt>
          <dd><cite><a href="http://www.w3.org/TR/2013/REC-rdf-sparql-XMLres-20130321">SPARQL Query Results XML Format (Second Edition)</a></cite>, D. Beckett, J. Broekstra, Editors, W3C
          Recommendation, 21 March 2013, http://www.w3.org/TR/2013/REC-rdf-sparql-XMLres-20130321. <a href="http://www.w3.org/TR/rdf-sparql-XMLres/" title=
          "Latest version of SPARQL Query Results XML Format (Second Edition)">Latest version</a> available at http://www.w3.org/TR/rdf-sparql-XMLres.</dd>
          <dt><a name="SPARQL-JSON-RESULTS" id="SPARQL-JSON-RESULTS">[SPARQL JSON Results]</a></dt>
          <dd><cite><a href="http://www.w3.org/TR/2013/REC-sparql11-results-json-20130321">SPARQL 1.1 Query Results JSON Format</a></cite>, A. Seaborne, Editor, W3C Recommendation, 21 March 2013,
          http://www.w3.org/TR/2013/REC-sparql11-results-json-20130321. <a href="http://www.w3.org/TR/sparql11-results-json/" title="Latest version of SPARQL 1.1 Query Results JSON Format">Latest
          version</a> available at http://www.w3.org/TR/sparql11-results-json.</dd>
          <dt><a name="SPARQL-CSV-TSV-RESULTS" id="SPARQL-CSV-TSV-RESULTS">[SPARQL CSV and TSV Result]</a></dt>
          <dd><cite><a href="http://www.w3.org/TR/2013/REC-sparql11-results-csv-tsv-20130321">SPARQL 1.1 Query Results CSV and TSV Formats</a></cite>, A. Seaborne, Editor, W3C Recommendation, 21
          March 2013, http://www.w3.org/TR/2013/REC-sparql11-results-csv-tsv-20130321. <a href="http://www.w3.org/TR/sparql11-results-csv-tsv/" title=
          "Latest version of SPARQL 1.1 Query Results CSV and TSV Formats">Latest version</a> available at http://www.w3.org/TR/sparql11-results-csv-tsv.</dd>
          <dt><a id="SPROT" name="SPROT">[SPROT]</a></dt>
          <dd><cite><a href="http://www.w3.org/TR/2013/REC-sparql11-protocol-20130321">SPARQL 1.1 Protocol</a></cite>, L. Feigenbaum, G. Williams, K. Clark, E. Torres, Editors, W3C Recommendation, 21
          March 2013, http://www.w3.org/TR/2013/REC-sparql11-protocol-20130321. <a href="http://www.w3.org/TR/sparql11-protocol/" title="Latest version of SPARQL 1.1 Protocol">Latest version</a>
          available at http://www.w3.org/TR/sparql11-protocol.</dd>
          <dt><a name="TURTLE" id="TURTLE">[TURTLE]</a></dt>
          <dd><cite><a href="http://www.w3.org/TR/2013/CR-turtle-20130219/">Turtle: Terse RDF Triple Language</a></cite>, E Prud'hommeaux, G Carothers, Editors, W3C Candidate Recommendation, 19
          February 2013, http://www.w3.org/TR/2013/CR-turtle-20130219/. <a href="http://www.w3.org/TR/turtle/" title="Latest version of Turtle">Latest version</a> available at
          http://www.w3.org/TR/turtle/.</dd>
          <dt><a name="UCNR" id="UCNR">[UCNR]</a></dt>
          <dd><a href="http://www.w3.org/TR/2005/WD-rdf-dawg-uc-20050325/">RDF Data Access Use Cases and Requirements</a>, K. Clark, Editor, W3C Working Draft, 25 March 2005,
          http://www.w3.org/TR/2005/WD-rdf-dawg-uc-20050325/ . <a href="http://www.w3.org/TR/rdf-dawg-uc/" title="Latest version of RDF Data Access Use Cases and Requirements">Latest version</a>
          available at http://www.w3.org/TR/rdf-dawg-uc/ .</dd>
          <dt><a name="UCNR2" id="UCNR2">[UCNR2]</a></dt>
          <dd><a href="http://www.w3.org/TR/2009/WD-sparql-features-20090702/">SPARQL New Features and Rationale</a>, Kjetil Kjernsmo, Alexandre Passant, Editors, W3C Working Draft, 2 July 2009,
          http://www.w3.org/TR/2009/WD-sparql-features-20090702/ . <a href="http://www.w3.org/TR/sparql-features/" title="Latest version of SPARQL New Features and Rationale">Latest version</a>
          available at http://www.w3.org/TR/sparql-features/ .</dd>
          <dt><a name="UNISEC" id="UNISEC">[UNISEC]</a></dt>
          <dd><a href="http://www.unicode.org/reports/tr36/">Unicode Security Considerations</a>, Mark Davis, Michel Suignard</dd>
          <dt><a id="VCARD" name="VCARD">[VCARD]</a></dt>
          <dd><a href="http://www.w3.org/TR/2001/NOTE-vcard-rdf-20010222/">Representing vCard Objects in RDF/XML</a>, Renato Iannella, W3C Note, 22 February 2001,
          http://www.w3.org/TR/2001/NOTE-vcard-rdf-20010222/ . <a href="http://www.w3.org/TR/vcard-rdf">Latest version</a> is available at <tt>http://www.w3.org/TR/vcard-rdf</tt> .</dd>
          <dt><a name="WEBARCH" id="WEBARCH">[WEBARCH]</a></dt>
          <dd><a href="http://www.w3.org/TR/2004/REC-webarch-20041215/">Architecture of the World Wide Web, Volume One</a>, I. Jacobs, N. Walsh, Editors, W3C Recommendation, 15 December 2004,
          http://www.w3.org/TR/2004/REC-webarch-20041215/ . <a href="http://www.w3.org/TR/webarch/">Latest version</a> is available at <tt>http://www.w3.org/TR/webarch/</tt> .</dd>
          <dt><a name="UNIID" id="UNIID">[UNIID]</a></dt>
          <dd><a href="http://www.unicode.org/reports/tr31/tr31-5.html">Identifier and Pattern Syntax 4.1.0</a>, Mark Davis, Unicode Standard Annex #31, 25 March 2005,
          http://www.unicode.org/reports/tr31/tr31-5.html . <a href="http://www.unicode.org/reports/tr31/" title="Latest version of Identifier and Pattern Syntax">Latest version</a> available at
          <a href="http://www.unicode.org/reports/tr31/">http://www.unicode.org/reports/tr31/</a> .</dd>
        </dl>
      </div>
    </div>
    <div>
      <h2 id="changelog">Change Log</h2>
      <h3 id="changes-since-pr">Changes since Proposed Recommendation</h3>
      <ul>
        <li>Fixed error in example of inverse property path</li>
      </ul>
      <h3 id="changes-since-lc">Changes since Last Call</h3>
      <p>The following are the corrections made since last publication:</p>
      <ul>
        <li>Grammar: <tt>DISTINCT</tt> for paths had been left in the grammar - removed.</li>
        <li>Restore translation of <tt>BIND</tt> as per text in previous publications (first and second last call).</li>
      </ul>
      <h3 id="changes-since-10">Since SPARQL 1.0</h3>
      <p>The new features in SPARQL 1.1 Query are:</p>
      <ul>
        <li><a title="Feature:Aggregates" href="#aggregates">Aggregates</a></li>
        <li><a title="Feature:Subqueries" href="#subqueries">Subqueries</a></li>
        <li><a title="Feature:Negation" href="#negation">Negation</a></li>
        <li><a title="Feature:ProjectSelectExpressions" href="#selectExpressions">Expressions in the SELECT clause</a></li>
        <li><a href="#propertypaths">Property Paths</a></li>
        <li><a href="#assignment">Assignment</a></li>
        <li><a href="#constructWhere">A short form for CONSTRUCT</a></li>
        <li><a href="#SparqlOps">An expanded set of functions and operators</a></li>
      </ul>
    </div>
  </div>
  <script type="text/javascript" async src="SPARQL%201.1%20Query%20Language_files/matomo.js"></script>
  <script type="application/javascript" src="SPARQL%201.1%20Query%20Language_files/fixup.js"></script>
</body>
</html>
